namespace std {
    typedef unsigned long size_t;
    typedef long ptrdiff_t;
    typedef decltype(nullptr) nullptr_t;
    extern "C++" inline void __terminate() noexcept __attribute__((always_inline))     {
        void terminate() noexcept;
        terminate();
    }

}
namespace std {
    inline namespace __cxx11 {
    }
}
namespace __gnu_cxx {
    inline namespace __cxx11 {
    }
}
namespace std {
    inline constexpr bool __is_constant_evaluated() noexcept     {
        return __builtin_is_constant_evaluated();
    }
}
namespace std {
    template <typename> class allocator
template<> class allocator<char8_t> : public __allocator_base<char8_t> {
    public:
        typedef char8_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<char8_t>()         {
        }
        constexpr allocator(const std::allocator<char8_t> &__a) noexcept : __allocator_base<char8_t>(__a)         {
        }
        std::allocator<char8_t> &operator=(const std::allocator<char8_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<char8_t>(const allocator<char8_t> &) noexcept;
        constexpr ~allocator<char8_t>() noexcept         {
        }
        constexpr char8_t *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]];
        constexpr void deallocate(char8_t *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char8_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<char8_t> &, const std::allocator<char8_t> &) noexcept;
    }
template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<char16_t>()         {
        }
        constexpr allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a)         {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<char16_t>(const allocator<char16_t> &) noexcept;
        constexpr ~allocator<char16_t>() noexcept         {
        }
        constexpr char16_t *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]];
        constexpr void deallocate(char16_t *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char16_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    }
template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<char32_t>()         {
        }
        constexpr allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a)         {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<char32_t>(const allocator<char32_t> &) noexcept;
        constexpr ~allocator<char32_t>() noexcept         {
        }
        constexpr char32_t *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]];
        constexpr void deallocate(char32_t *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char32_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    };
    template<> class allocator<void>;
    template <typename, typename> struct uses_allocator;
    template <typename> struct allocator_traits
template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static constexpr std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<std::allocator<char>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char>>::size_type max_size(const std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return std::size_t(-1) / sizeof(std::allocator_traits<std::allocator<char>>::value_type);
        }
        static constexpr std::allocator_traits<std::allocator<char>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char>>::allocator_type &__rhs)         {
            return __rhs;
        }
    }
template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<std::allocator<wchar_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::size_type max_size(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return std::size_t(-1) / sizeof(std::allocator_traits<std::allocator<wchar_t>>::value_type);
        }
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__rhs);
    }
template<> struct allocator_traits<std::allocator<char8_t>> {
        using allocator_type = allocator<char8_t>;
        using value_type = char8_t;
        using pointer = char8_t *;
        using const_pointer = const char8_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char8_t>>::pointer allocate(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static constexpr std::allocator_traits<std::allocator<char8_t>>::pointer allocate(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char8_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char8_t>>::size_type max_size(const std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static constexpr std::allocator_traits<std::allocator<char8_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char8_t>>::allocator_type &__rhs);
    }
template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static constexpr std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char16_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char16_t>>::size_type max_size(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static constexpr std::allocator_traits<std::allocator<char16_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__rhs);
    }
template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static constexpr std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char32_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char32_t>>::size_type max_size(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static constexpr std::allocator_traits<std::allocator<char32_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__rhs);
    };
}
namespace std {
    template <class _CharT> struct char_traits;
    template<> struct char_traits<char>;
    template<> struct char_traits<wchar_t>;
    template<> struct char_traits<char8_t>;
    template<> struct char_traits<char16_t>;
    template<> struct char_traits<char32_t>;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string
template<> class basic_string<char, std::char_traits<char>, std::allocator<char>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char>>::rebind<char>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char>, void>;
        public:
            typedef std::char_traits<char> traits_type;
            typedef typename char_traits<char>::char_type value_type;
            typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char, char_traits<char>, allocator<char>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char, char_traits<char>, allocator<char>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type npos = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char, std::char_traits<char>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const _Tp &, const char *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_wrapper __svw, const std::allocator<char> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type {
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char)
            };
            union {
                char _M_local_buf[16];
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char());
            }
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer basic_string<char, char_traits<char>, allocator<char>>::_M_create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type &__capacity, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char *>(const char *__beg, const char *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<char *>(char *__beg, char *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char *>(const char *__beg, const char *__end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<char *>(char *__beg, char *__end, std::forward_iterator_tag)             {
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char, char_traits<char>, allocator<char>> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __req, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_use_local_data() noexcept __attribute__((always_inline))             {
                if (std::is_constant_evaluated())
                    for (char &__c : this->_M_local_buf)
                        __c = char();
                return this->_M_local_data();
            }
        private:
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_check(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s) const             {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            constexpr void _M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, const char *__s) const             {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_limit(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __off) const noexcept             {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const char *__s) const noexcept             {
                return (less<const char *>()(__s, this->_M_data()) || less<const char *>()(this->_M_data() + this->size(), __s));
            }
            static constexpr void _S_copy(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static constexpr void _S_assign(char *__d, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<char *>(char *__p, char *__k1, char *__k2);
            static constexpr void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, char *__k1, char *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(char *__p, const char *__k1, const char *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &);
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_mutate(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len2)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __how_much = this->length() - __pos - __len1;
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __new_capacity = this->length() + __len2 - __len1;
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __r = this->_M_create(__new_capacity, this->capacity());
                if (__pos)
                    this->_S_copy(__r, this->_M_data(), __pos);
                if (__s && __len2)
                    this->_S_copy(__r + __pos, __s, __len2);
                if (__how_much)
                    this->_S_copy(__r + __pos + __len2, this->_M_data() + __pos + __len1, __how_much);
                this->_M_dispose();
                this->_M_data(__r);
                this->_M_capacity(__new_capacity);
            }
            constexpr void _M_erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        public:
            constexpr basic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::valuebasic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::value) : _M_dataplus(this->_M_local_data())             {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr explicit basic_string(const std::allocator<char> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str) : _M_dataplus(this->_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))             {
                this->_M_construct(__str._M_data(), __str._M_data() + __str.length(), std::forward_iterator_tag());
            }
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const std::allocator<char> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a);
            constexpr basic_string(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char>>> constexpr basic_string(const char *__s, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(const char *__s, const std::allocator<char> &__a);
            template <typename = _RequireAllocator<std::allocator<char>>> constexpr basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__n, __c);
            }
;
            constexpr basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            constexpr basic_string(initializer_list<char> __l, const std::allocator<char> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, const std::allocator<char> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str, const std::allocator<char> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
            template<> constexpr basic_string<char *, void>(char *__beg, char *__end, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char> &__a);
            constexpr ~basic_string<char, char_traits<char>, allocator<char>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type size() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            constexpr void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type capacity() const noexcept             {
                return this->_M_is_local() ? std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::reserve(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __res)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __capacity = this->capacity();
                if (__res <= __capacity)
                    return;
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __tmp = this->_M_create(__res, __capacity);
                this->_S_copy(__tmp, this->_M_data(), this->length() + 1);
                this->_M_dispose();
                this->_M_data(__tmp);
                this->_M_capacity(__res);
            }
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept             {
                this->_M_set_length(0);
            }
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos)             {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                ;
                return this->_M_data()[__pos];
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(char __c)             {
                this->push_back(__c);
                return *this;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str)             {
                return this->append(__str._M_data(), __str.size());
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                ;
                this->_M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const char *__s)             {
                ;
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n = traits_type::length(__s);
                this->_M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(initializer_list<char> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr void push_back(char __c)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), 0, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, initializer_list<char> __l);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str)             {
                return this->replace(__pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __str._M_data(), __str.size());
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s)             {
                ;
                return this->replace(__pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __s, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __p, char __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __first, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2)             {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, char *__k1, char *__k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__k1, const char *__k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &_M_replace_aux(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &basic_string<char, char_traits<char>, allocator<char>>::_M_replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len1, const char *__s, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len2)             {
                this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __old_size = this->size();
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __new_size = __old_size + __len2 - __len1;
                if (__new_size <= this->capacity()) {
                    std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __p = this->_M_data() + __pos;
                    const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __how_much = __old_size - __pos - __len1;
                    if (std::is_constant_evaluated()) {
                        auto __newp = _Alloc_traits::allocate(this->_M_get_allocator(), __new_size);
                        _S_copy(__newp, this->_M_data(), __pos);
                        _S_copy(__newp + __pos, __s, __len2);
                        _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
                        _S_copy(this->_M_data(), __newp, __new_size);
                        this->_M_get_allocator().deallocate(__newp, __new_size);
                    } else if (this->_M_disjunct(__s)) {
                        if (__how_much && __len1 != __len2)
                            this->_S_move(__p + __len2, __p + __len1, __how_much);
                        if (__len2)
                            this->_S_copy(__p, __s, __len2);
                    } else {
                        if (__len2 && __len2 <= __len1)
                            this->_S_move(__p, __s, __len2);
                        if (__how_much && __len1 != __len2)
                            this->_S_move(__p + __len2, __p + __len1, __how_much);
                        if (__len2 > __len1) {
                            if (__s + __len2 <= __p + __len1)
                                this->_S_move(__p, __s, __len2);
                            else if (__s >= __p + __len1) {
                                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __poff = (__s - __p) + (__len2 - __len1);
                                this->_S_copy(__p, __p + __poff, __len2);
                            } else {
                                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __nleft = (__p + __len1) - __s;
                                this->_S_move(__p, __s, __nleft);
                                this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                            }
                        }
                    }
                } else
                    this->_M_mutate(__pos, __len1, __s, __len2);
                this->_M_set_length(__new_size);
                return *this;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &basic_string<char, char_traits<char>, allocator<char>>::_M_append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len = __n + this->size();
                if (__len <= this->capacity()) {
                    if (__n)
                        this->_S_copy(this->_M_data() + this->size(), __s, __n);
                } else
                    this->_M_mutate(this->size(), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __s, __n);
                this->_M_set_length(__len);
                return *this;
            }
        public:
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type basic_string<char, char_traits<char>, allocator<char>>::copy(char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos = 0) const             {
                this->_M_check(__pos, "basic_string::copy");
                __n = this->_M_limit(__pos, __n);
                ;
                if (__n)
                    _S_copy(__s, this->_M_data() + __pos, __n);
                return __n;
            }
            constexpr void swap(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__s) noexcept;
            constexpr const char *c_str() const noexcept             {
                return this->_M_data();
            }
            constexpr const char *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char *data() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> substr(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
            constexpr int compare(const char *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char, std::char_traits<char>> __x) const noexcept;
            constexpr bool starts_with(char __x) const noexcept;
            constexpr bool starts_with(const char *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char, std::char_traits<char>> __x) const noexcept;
            constexpr bool ends_with(char __x) const noexcept;
            constexpr bool ends_with(const char *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
template<> class basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t>>::rebind<wchar_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<wchar_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<wchar_t>, void>;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef typename char_traits<wchar_t>::char_type value_type;
            typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type npos = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<wchar_t, std::char_traits<wchar_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>>, __not_<is_convertible<const _Tp &, const wchar_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_wrapper __svw, const std::allocator<wchar_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type {
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(wchar_t)
            };
            union {
                wchar_t _M_local_buf[4];
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], wchar_t());
            }
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_create(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type &__capacity, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::forward_iterator_tag);
            template<> constexpr void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::forward_iterator_tag)             {
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __req, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline))             {
                if (std::is_constant_evaluated())
                    for (wchar_t &__c : this->_M_local_buf)
                        __c = wchar_t();
                return this->_M_local_data();
            }
        private:
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_check(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_limit(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const wchar_t *__s) const noexcept;
            static constexpr void _S_copy(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            static constexpr void _S_assign(wchar_t *__d, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<wchar_t *>(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
            static constexpr void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<wchar_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<wchar_t>>> constexpr basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<std::allocator<wchar_t>>(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template <typename = _RequireAllocator<std::allocator<wchar_t>>> constexpr basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<wchar_t> __l, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, const std::allocator<wchar_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str, const std::allocator<wchar_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<wchar_t *, void>(wchar_t *__beg, wchar_t *__end, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<wchar_t> &__a);
            constexpr ~basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            constexpr void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(initializer_list<wchar_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr void push_back(wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, initializer_list<wchar_t> __l);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __p, wchar_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __first, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace_aux(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len1, const wchar_t *__s, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type copy(wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__s) noexcept;
            constexpr const wchar_t *c_str() const noexcept             {
                return this->_M_data();
            }
            constexpr const wchar_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr wchar_t *data() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> substr(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
            constexpr int compare(const wchar_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
            constexpr bool starts_with(wchar_t __x) const noexcept;
            constexpr bool starts_with(const wchar_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
            constexpr bool ends_with(wchar_t __x) const noexcept;
            constexpr bool ends_with(const wchar_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
template<> class basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char8_t>>::rebind<char8_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char8_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char8_t>, void>;
        public:
            typedef std::char_traits<char8_t> traits_type;
            typedef typename char_traits<char8_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char8_t, std::char_traits<char8_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>>, __not_<is_convertible<const _Tp &, const char8_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_wrapper __svw, const std::allocator<char8_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type {
                std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char8_t)
            };
            union {
                char8_t _M_local_buf[16];
                std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer __p);
            constexpr void _M_length(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __length);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __capacity);
            constexpr void _M_set_length(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_create(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type &, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type);
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::forward_iterator_tag);
            constexpr void _M_construct(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __req, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type &_M_get_allocator() const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline));
        private:
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_check(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_limit(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char8_t *__s) const noexcept;
            static constexpr void _S_copy(char8_t *__d, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            static constexpr void _S_move(char8_t *__d, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            static constexpr void _S_assign(char8_t *__d, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char8_t *__p, _Iterator __k1, _Iterator __k2);
            static constexpr void _S_copy_chars(char8_t *__p, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, char8_t *__k1, char8_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, const char8_t *__k1, const char8_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len1, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char8_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const std::allocator<char8_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::allocator<char8_t> &__a);
            constexpr basic_string(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::allocator<char8_t> &__a = std::allocator<char8_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char8_t>>> constexpr basic_string(const char8_t *__s, const std::allocator<char8_t> &__a);
            template<> constexpr basic_string<std::allocator<char8_t>>(const char8_t *__s, const std::allocator<char8_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char8_t>>> constexpr basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c, const std::allocator<char8_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<char8_t> __l, const std::allocator<char8_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, const std::allocator<char8_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str, const std::allocator<char8_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char8_t> &__a);
            constexpr ~basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type max_size() const noexcept;
            constexpr void resize(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            constexpr void resize(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference operator[](std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference operator[](std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference at(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference at(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(initializer_list<char8_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr void push_back(char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __p, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __p, initializer_list<char8_t> __l);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __p, char8_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __first, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, char8_t *__k1, char8_t *__k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const char8_t *__k1, const char8_t *__k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace_aux(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len1, const char8_t *__s, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_append(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type copy(char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__s) noexcept;
            constexpr const char8_t *c_str() const noexcept;
            constexpr const char8_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char8_t *data() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> substr(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) const;
            constexpr int compare(const char8_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
            constexpr bool starts_with(char8_t __x) const noexcept;
            constexpr bool starts_with(const char8_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
            constexpr bool ends_with(char8_t __x) const noexcept;
            constexpr bool ends_with(const char8_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char16_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char16_t>, void>;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char16_t, std::char_traits<char16_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>, __not_<is_convertible<const _Tp &, const char16_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_wrapper __svw, const std::allocator<char16_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer __p);
            constexpr void _M_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __length);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __capacity);
            constexpr void _M_set_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_create(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type &, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type);
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag);
            constexpr void _M_construct(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __req, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator() const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline));
        private:
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_check(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_limit(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static constexpr void _S_copy(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            static constexpr void _S_move(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            static constexpr void _S_assign(char16_t *__d, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            static constexpr void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const std::allocator<char16_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            constexpr basic_string(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char16_t>>> constexpr basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            template<> constexpr basic_string<std::allocator<char16_t>>(const char16_t *__s, const std::allocator<char16_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char16_t>>> constexpr basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, const std::allocator<char16_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char16_t> &__a);
            constexpr ~basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type max_size() const noexcept;
            constexpr void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            constexpr void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr void push_back(char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, initializer_list<char16_t> __l);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __p, char16_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __first, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_aux(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type copy(char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__s) noexcept;
            constexpr const char16_t *c_str() const noexcept;
            constexpr const char16_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char16_t *data() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> substr(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            constexpr int compare(const char16_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
            constexpr bool starts_with(char16_t __x) const noexcept;
            constexpr bool starts_with(const char16_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
            constexpr bool ends_with(char16_t __x) const noexcept;
            constexpr bool ends_with(const char16_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char32_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char32_t>, void>;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char32_t, std::char_traits<char32_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>, __not_<is_convertible<const _Tp &, const char32_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_wrapper __svw, const std::allocator<char32_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer __p);
            constexpr void _M_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __length);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __capacity);
            constexpr void _M_set_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_create(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type &, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type);
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag);
            constexpr void _M_construct(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __req, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator() const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline));
        private:
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_check(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_limit(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static constexpr void _S_copy(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            static constexpr void _S_move(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            static constexpr void _S_assign(char32_t *__d, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            static constexpr void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const std::allocator<char32_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            constexpr basic_string(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char32_t>>> constexpr basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            template<> constexpr basic_string<std::allocator<char32_t>>(const char32_t *__s, const std::allocator<char32_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char32_t>>> constexpr basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, const std::allocator<char32_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char32_t> &__a);
            constexpr ~basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type max_size() const noexcept;
            constexpr void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            constexpr void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr void push_back(char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, initializer_list<char32_t> __l);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __p, char32_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __first, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_aux(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type copy(char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__s) noexcept;
            constexpr const char32_t *c_str() const noexcept;
            constexpr const char32_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char32_t *data() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> substr(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            constexpr int compare(const char32_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
            constexpr bool starts_with(char32_t __x) const noexcept;
            constexpr bool starts_with(const char32_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
            constexpr bool ends_with(char32_t __x) const noexcept;
            constexpr bool ends_with(const char32_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    typedef basic_string<char8_t> u8string;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
}
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef unsigned long size_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned int wint_t;
typedef struct {
    int __count;
    union {
        unsigned int __wch;
        char __wchb[4];
    } __value;
} __mbstate_t;
typedef __mbstate_t mbstate_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct __locale_struct {
    struct __locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern "C" {
    struct tm;
    extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(truewcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(truewcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(truewcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true) __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(truewcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(truewcscmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(truewcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(truewcscasecmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
    extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(truewcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true);
    extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(truewcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(true);
    extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(truewcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(true);
    extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) noexcept(truewcscoll(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);
    extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(truewcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(truewcscoll_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) noexcept(true);
    extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(truewcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) noexcept(true);
    extern wchar_t *wcsdup(const wchar_t *__s) noexcept(truewcsdup(const wchar_t *__s) noexcept(true) __attribute__((malloc));
    extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) noexcept(truewcschr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) noexcept(truewcsrchr(const wchar_t *__wcs, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) noexcept(truewcschrnul(const wchar_t *__s, wchar_t __wc) noexcept(true) __attribute__((pure));
    extern size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) noexcept(truewcscspn(const wchar_t *__wcs, const wchar_t *__reject) noexcept(true) __attribute__((pure));
    extern size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) noexcept(truewcsspn(const wchar_t *__wcs, const wchar_t *__accept) noexcept(true) __attribute__((pure));
    extern wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) noexcept(truewcspbrk(const wchar_t *__wcs, const wchar_t *__accept) noexcept(true) __attribute__((pure));
    extern wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) noexcept(truewcsstr(const wchar_t *__haystack, const wchar_t *__needle) noexcept(true) __attribute__((pure));
    extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) noexcept(truewcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) noexcept(true);
    extern size_t wcslen(const wchar_t *__s) noexcept(truewcslen(const wchar_t *__s) noexcept(true) __attribute__((pure));
    extern wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) noexcept(truewcswcs(const wchar_t *__haystack, const wchar_t *__needle) noexcept(true) __attribute__((pure));
    extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) noexcept(truewcsnlen(const wchar_t *__s, size_t __maxlen) noexcept(true) __attribute__((pure));
    extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) noexcept(truewmemchr(const wchar_t *__s, wchar_t __c, size_t __n) noexcept(true) __attribute__((pure));
    extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(truewmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true) __attribute__((pure));
    extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(truewmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(truewmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) noexcept(true);
    extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) noexcept(truewmemset(wchar_t *__s, wchar_t __c, size_t __n) noexcept(true);
    extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(truewmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) noexcept(true);
    extern wint_t btowc(int __c) noexcept(truebtowc(int __c) noexcept(true);
    extern int wctob(wint_t __c) noexcept(truewctob(wint_t __c) noexcept(true);
    extern int mbsinit(const mbstate_t *__ps) noexcept(truembsinit(const mbstate_t *__ps) noexcept(true) __attribute__((pure));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) noexcept(truembrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) noexcept(true);
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) noexcept(truewcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t __mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(true__mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(truembrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(truembsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(truewcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) noexcept(truembsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) noexcept(truewcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) noexcept(true);
    extern int wcwidth(wchar_t __c) noexcept(truewcwidth(wchar_t __c) noexcept(true);
    extern int wcswidth(const wchar_t *__s, size_t __n) noexcept(truewcswidth(const wchar_t *__s, size_t __n) noexcept(true);
    extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(truewcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(truewcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(truewcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float32 wcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(truewcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float64 wcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(truewcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float32x wcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(truewcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern _Float64x wcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(truewcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) noexcept(true);
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(truewcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(truewcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(truewcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(truewcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(truewcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(truewcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) noexcept(true);
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(truewcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(truewcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(truewcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(truewcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) noexcept(true);
    extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(truewcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(truewcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(truewcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(truewcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(truewcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(truewcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(truewcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) noexcept(true);
    extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(truewcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) noexcept(true);
    extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(truewcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) noexcept(true);
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(trueopen_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern int fwide(__FILE *__fp, int __mode) noexcept(truefwide(__FILE *__fp, int __mode) noexcept(true);
    extern int fwprintf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wprintf(const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) noexcept(trueswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) noexcept(true);
    extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(truevswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wscanf(const wchar_t *__restrict __format, ...);
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(trueswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(true);
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) asm("__isoc99_fwscanf");
    extern int wscanf(const wchar_t *__restrict __format, ...) asm("__isoc99_wscanf");
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(trueswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept(true) asm("__isoc99_swscanf");
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(truevswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vfwscanf");
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vwscanf");
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(truevswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept(true) asm("__isoc99_vswscanf");
    extern wint_t fgetwc(__FILE *__stream);
    extern wint_t getwc(__FILE *__stream);
    extern wint_t getwchar();
    extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
    extern wint_t getwc_unlocked(__FILE *__stream);
    extern wint_t getwchar_unlocked();
    extern wint_t fgetwc_unlocked(__FILE *__stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) noexcept(truewcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) noexcept(true);
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(truewcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(true);
}
namespace std {
    using ::mbstate_t;
}
extern "C++" {
    namespace std {
        using ::wint_t;
        using ::btowc;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::fwprintf;
        using ::fwscanf;
        using ::getwc;
        using ::getwchar;
        using ::mbrlen;
        using ::mbrtowc;
        using ::mbsinit;
        using ::mbsrtowcs;
        using ::putwc;
        using ::putwchar;
        using ::swprintf;
        using ::swscanf;
        using ::ungetwc;
        using ::vfwprintf;
        using ::vfwscanf;
        using ::vswprintf;
        using ::vswscanf;
        using ::vwprintf;
        using ::vwscanf;
        using ::wcrtomb;
        using ::wcscat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcscpy;
        using ::wcscspn;
        using ::wcsftime;
        using ::wcslen;
        using ::wcsncat;
        using ::wcsncmp;
        using ::wcsncpy;
        using ::wcsrtombs;
        using ::wcsspn;
        using ::wcstod;
        using ::wcstof;
        using ::wcstok;
        using ::wcstol;
        using ::wcstoul;
        using ::wcsxfrm;
        using ::wctob;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wprintf;
        using ::wscanf;
        using ::wcschr;
        using ::wcspbrk;
        using ::wcsrchr;
        using ::wcsstr;
        using ::wmemchr;
        inline wchar_t *wcschr(wchar_t *__p, wchar_t __c)         {
            return wcschr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2)         {
            return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c)         {
            return wcsrchr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2)         {
            return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, std::size_t __n)         {
            return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
        }
    }
}
namespace __gnu_cxx {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
namespace std {
    using std::wcstof;
    using std::vfwscanf;
    using std::vswscanf;
    using std::vwscanf;
    using std::wcstold;
    using std::wcstoll;
    using std::wcstoull;
}
namespace std {
    typedef long streamoff;
    typedef std::ptrdiff_t streamsize;
    template <typename _StateT> class fpos {
    private:
        std::streamoff _M_off;
        _StateT _M_state;
    public:
        fpos<_StateT>() : _M_off(0), _M_state()         {
        }
        fpos<_StateT>(std::streamoff __off) : _M_off(__off), _M_state()         {
        }
        fpos<_StateT>(const fpos<_StateT> &) = default
        fpos<_StateT> &operator=(const fpos<_StateT> &) = default
        ~fpos<_StateT>() = default
        operator streamoff() const         {
            return this->_M_off;
        }
        void state(_StateT __st)         {
            this->_M_state = __st;
        }
        _StateT state() const         {
            return this->_M_state;
        }
        fpos<_StateT> &operator+=(std::streamoff __off)         {
            this->_M_off += __off;
            return *this;
        }
        fpos<_StateT> &operator-=(std::streamoff __off)         {
            this->_M_off -= __off;
            return *this;
        }
        fpos<_StateT> operator+(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos += __off;
            return __pos;
        }
        fpos<_StateT> operator-(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos -= __off;
            return __pos;
        }
        std::streamoff operator-(const fpos<_StateT> &__other) const         {
            return this->_M_off - __other._M_off;
        }
    };
    template <typename _StateT> inline bool operator==(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) == std::streamoff(__rhs);
    }
    template <typename _StateT> inline bool operator!=(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) != std::streamoff(__rhs);
    }
    typedef fpos<mbstate_t> streampos;
    typedef fpos<mbstate_t> wstreampos;
    typedef fpos<mbstate_t> u8streampos;
    typedef fpos<mbstate_t> u16streampos;
    typedef fpos<mbstate_t> u32streampos;
}
namespace std {
    class ios_base;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_filebuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ifstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ofstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_fstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    typedef basic_ios<char> ios;
    typedef basic_streambuf<char> streambuf;
    typedef basic_istream<char> istream;
    typedef basic_ostream<char> ostream;
    typedef basic_iostream<char> iostream;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_istringstream<char> istringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_filebuf<char> filebuf;
    typedef basic_ifstream<char> ifstream;
    typedef basic_ofstream<char> ofstream;
    typedef basic_fstream<char> fstream;
    typedef basic_ios<wchar_t> wios;
    typedef basic_streambuf<wchar_t> wstreambuf;
    typedef basic_istream<wchar_t> wistream;
    typedef basic_ostream<wchar_t> wostream;
    typedef basic_iostream<wchar_t> wiostream;
    typedef basic_stringbuf<wchar_t> wstringbuf;
    typedef basic_istringstream<wchar_t> wistringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;
    typedef basic_stringstream<wchar_t> wstringstream;
    typedef basic_filebuf<wchar_t> wfilebuf;
    typedef basic_ifstream<wchar_t> wifstream;
    typedef basic_ofstream<wchar_t> wofstream;
    typedef basic_fstream<wchar_t> wfstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Allocator = allocator<_CharT>> class basic_syncbuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Allocator = allocator<_CharT>> class basic_osyncstream;
    using syncbuf = basic_syncbuf<char>;
    using osyncstream = basic_osyncstream<char>;
    using wsyncbuf = basic_syncbuf<wchar_t>;
    using wosyncstream = basic_osyncstream<wchar_t>;
}
namespace std {
    template <typename _Tp> class reference_wrapper;
    template <typename _Tp, _Tp __v> struct integral_constant {
        static constexpr _Tp value = __v;
        typedef _Tp value_type;
        typedef integral_constant<_Tp, __v> type;
        constexpr operator value_type() const noexcept         {
            return value;
        }
        constexpr std::integral_constant::value_type operator()() const noexcept         {
            return value;
        }
    };
template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        typedef bool value_type;
        typedef integral_constant<bool, true> type;
        constexpr operator value_type() const noexcept         {
            return value;
        }
        constexpr std::integral_constant<bool, true>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        typedef bool value_type;
        typedef integral_constant<bool, false> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, false>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long, 0> {
        static constexpr unsigned long value;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 0UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 0>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long, 2> {
        static constexpr unsigned long value;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 2UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 2>::value_type operator()() const noexcept;
    };
    using true_type = integral_constant<bool, true>;
    using false_type = integral_constant<bool, false>;
    template <bool __v> using __bool_constant = integral_constant<bool, __v>;
    template <bool __v> using bool_constant = integral_constant<bool, __v>;
    template <bool> struct __conditional {
        template <typename _Tp, typename> using type = _Tp;
    };
template<> struct __conditional<true> {
        template <typename _Tp, typename> using type = _Tp;
    };
    template<> struct __conditional<false> {
        template <typename, typename _Up> using type = _Up;
    };
    template <bool _Cond, typename _If, typename _Else> using __conditional_t = typename __conditional<_Cond>::template type<_If, _Else>;
    template <typename _Type> struct __type_identity {
        using type = _Type;
    };
template<> struct __type_identity<char> {
        using type = char;
    };
template<> struct __type_identity<wchar_t> {
        using type = wchar_t;
    };
template<> struct __type_identity<char8_t> {
        using type = char8_t;
    };
template<> struct __type_identity<char16_t> {
        using type = char16_t;
    };
template<> struct __type_identity<char32_t> {
        using type = char32_t;
    };
template<> struct __type_identity<const char *> {
        using type = const char *;
    };
template<> struct __type_identity<unsigned long> {
        using type = unsigned long;
    };
template<> struct __type_identity<const wchar_t *> {
        using type = const wchar_t *;
    };
template<> struct __type_identity<const char8_t *> {
        using type = const char8_t *;
    };
template<> struct __type_identity<const char16_t *> {
        using type = const char16_t *;
    };
template<> struct __type_identity<const char32_t *> {
        using type = const char32_t *;
    };
template<> struct __type_identity<std::allocator<char>> {
        using type = std::allocator<char>;
    };
    template <typename _Tp> using __type_identity_t = typename __type_identity<_Tp>::type;
    template <typename ...> struct __or_
template<> struct __or_<<std::is_reference<char>, std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public __conditional_t<is_reference<char>::value, std::is_reference<char>, __or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
    }
template<> struct __or_<<std::is_lvalue_reference<char>, std::is_rvalue_reference<char>>> : public __conditional_t<is_lvalue_reference<char>::value, std::is_lvalue_reference<char>, std::is_rvalue_reference<char>> {
    }
template<> struct __or_<<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public __conditional_t<is_function<char>::value, std::is_function<char>, __or_<std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
    }
template<> struct __or_<<std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public __conditional_t<is_void<char>::value, std::is_void<char>, std::__is_array_unknown_bounds<char>> {
    }
template<> struct __or_<<std::is_reference<wchar_t>, std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public __conditional_t<is_reference<wchar_t>::value, std::is_reference<wchar_t>, __or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
    }
template<> struct __or_<<std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>>> : public __conditional_t<is_lvalue_reference<wchar_t>::value, std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>> {
    }
template<> struct __or_<<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public __conditional_t<is_function<wchar_t>::value, std::is_function<wchar_t>, __or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
    }
template<> struct __or_<<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public __conditional_t<is_void<wchar_t>::value, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> {
    }
template<> struct __or_<<std::is_reference<char8_t>, std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> : public __conditional_t<is_reference<char8_t>::value, std::is_reference<char8_t>, __or_<std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> {
    }
template<> struct __or_<<std::is_lvalue_reference<char8_t>, std::is_rvalue_reference<char8_t>>> : public __conditional_t<is_lvalue_reference<char8_t>::value, std::is_lvalue_reference<char8_t>, std::is_rvalue_reference<char8_t>> {
    }
template<> struct __or_<<std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> : public __conditional_t<is_function<char8_t>::value, std::is_function<char8_t>, __or_<std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> {
    }
template<> struct __or_<<std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> : public __conditional_t<is_void<char8_t>::value, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>> {
    }
template<> struct __or_<<std::is_reference<char16_t>, std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public __conditional_t<is_reference<char16_t>::value, std::is_reference<char16_t>, __or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
    }
template<> struct __or_<<std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>>> : public __conditional_t<is_lvalue_reference<char16_t>::value, std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>> {
    }
template<> struct __or_<<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public __conditional_t<is_function<char16_t>::value, std::is_function<char16_t>, __or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
    }
template<> struct __or_<<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public __conditional_t<is_void<char16_t>::value, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> {
    }
template<> struct __or_<<std::is_reference<char32_t>, std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public __conditional_t<is_reference<char32_t>::value, std::is_reference<char32_t>, __or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
    }
template<> struct __or_<<std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>>> : public __conditional_t<is_lvalue_reference<char32_t>::value, std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>> {
    }
template<> struct __or_<<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public __conditional_t<is_function<char32_t>::value, std::is_function<char32_t>, __or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
    }
template<> struct __or_<<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public __conditional_t<is_void<char32_t>::value, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> {
    }
template<> struct __or_<<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>> : public __conditional_t<is_function<const char *>::value, std::is_function<const char *>, __or_<std::is_reference<const char *>, std::is_void<const char *>>> {
    }
template<> struct __or_<<std::is_reference<const char *>, std::is_void<const char *>>> : public __conditional_t<is_reference<const char *>::value, std::is_reference<const char *>, std::is_void<const char *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char *>, std::is_rvalue_reference<const char *>>> : public __conditional_t<is_lvalue_reference<const char *>::value, std::is_lvalue_reference<const char *>, std::is_rvalue_reference<const char *>> {
    }
template<> struct __or_<<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>>> : public __conditional_t<is_void<const char *>::value, std::is_void<const char *>, __or_<std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>>> {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>>> : public __conditional_t<__is_array_unknown_bounds<const char *>::value, std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>> {
    }
template<> struct __or_<<std::is_reference<const char *>, std::is_scalar<const char *>>> : public __conditional_t<is_reference<const char *>::value, std::is_reference<const char *>, std::is_scalar<const char *>> {
    }
template<> struct __or_<<std::is_arithmetic<const char *>, std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> : public __conditional_t<is_arithmetic<const char *>::value, std::is_arithmetic<const char *>, __or_<std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
    }
template<> struct __or_<<std::is_integral<const char *>, std::is_floating_point<const char *>>> : public __conditional_t<is_integral<const char *>::value, std::is_integral<const char *>, std::is_floating_point<const char *>> {
    }
template<> struct __or_<<std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> : public __conditional_t<is_enum<const char *>::value, std::is_enum<const char *>, __or_<std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
    }
template<> struct __or_<<std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> : public __conditional_t<is_pointer<const char *>::value, std::is_pointer<const char *>, __or_<std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
    }
template<> struct __or_<<std::is_reference<const char *>, std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> : public __conditional_t<is_reference<const char *>::value, std::is_reference<const char *>, __or_<std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> {
    }
template<> struct __or_<<std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> : public __conditional_t<is_function<const char *>::value, std::is_function<const char *>, __or_<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> {
    }
template<> struct __or_<<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> : public __conditional_t<is_void<const char *>::value, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>> {
    }
template<> struct __or_<<std::is_void<const char *>, std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_void<const char *>::value, std::is_void<const char *>, __or_<std::is_function<const char *>, std::is_array<const char *>>> {
    }
template<> struct __or_<<std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_function<const char *>::value, std::is_function<const char *>, std::is_array<const char *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char *const &>, std::is_rvalue_reference<const char *const &>>> : public __conditional_t<is_lvalue_reference<const char *const &>::value, std::is_lvalue_reference<const char *const &>, std::is_rvalue_reference<const char *const &>> {
    }
template<> struct __or_<<std::is_void<const char *const &>, std::is_function<const char *const &>, std::is_array<const char *const &>>> : public __conditional_t<is_void<const char *const &>::value, std::is_void<const char *const &>, __or_<std::is_function<const char *const &>, std::is_array<const char *const &>>> {
    }
template<> struct __or_<<std::is_function<const char *const &>, std::is_array<const char *const &>>> : public __conditional_t<is_function<const char *const &>::value, std::is_function<const char *const &>, std::is_array<const char *const &>> {
    }
template<> struct __or_<<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>> : public __conditional_t<is_function<const char>::value, std::is_function<const char>, __or_<std::is_reference<const char>, std::is_void<const char>>> {
    }
template<> struct __or_<<std::is_reference<const char>, std::is_void<const char>>> : public __conditional_t<is_reference<const char>::value, std::is_reference<const char>, std::is_void<const char>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char>, std::is_rvalue_reference<const char>>> : public __conditional_t<is_lvalue_reference<const char>::value, std::is_lvalue_reference<const char>, std::is_rvalue_reference<const char>> {
    }
template<> struct __or_<<std::is_integral<long>, std::is_floating_point<long>>> : public __conditional_t<is_integral<long>::value, std::is_integral<long>, std::is_floating_point<long>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char &>, std::is_rvalue_reference<const char &>>> : public __conditional_t<is_lvalue_reference<const char &>::value, std::is_lvalue_reference<const char &>, std::is_rvalue_reference<const char &>> {
    }
template<> struct __or_<<std::is_void<const char &>, std::is_function<const char &>, std::is_array<const char &>>> : public __conditional_t<is_void<const char &>::value, std::is_void<const char &>, __or_<std::is_function<const char &>, std::is_array<const char &>>> {
    }
template<> struct __or_<<std::is_function<const char &>, std::is_array<const char &>>> : public __conditional_t<is_function<const char &>::value, std::is_function<const char &>, std::is_array<const char &>> {
    }
template<> struct __or_<<std::is_void<char &>, std::is_function<const char &>, std::is_array<const char &>>> : public __conditional_t<is_void<char &>::value, std::is_void<char &>, __or_<std::is_function<const char &>, std::is_array<const char &>>> {
    }
template<> struct __or_<<std::is_void<const char &&>, std::is_function<const char &>, std::is_array<const char &>>> : public __conditional_t<is_void<const char &&>::value, std::is_void<const char &&>, __or_<std::is_function<const char &>, std::is_array<const char &>>> {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>>> : public __conditional_t<is_void<const volatile contiguous_iterator_tag *>::value, std::is_void<const volatile std::contiguous_iterator_tag *>, __or_<std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>>> {
    }
template<> struct __or_<<std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>>> : public __conditional_t<is_function<const volatile input_iterator_tag *>::value, std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>> {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>>> : public __conditional_t<is_void<const volatile contiguous_iterator_tag *>::value, std::is_void<const volatile std::contiguous_iterator_tag *>, __or_<std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>>> {
    }
template<> struct __or_<<std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>>> : public __conditional_t<is_function<const volatile forward_iterator_tag *>::value, std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>> {
    }
template<> struct __or_<<std::is_void<const char *&>, std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_void<const char *&>::value, std::is_void<const char *&>, __or_<std::is_function<const char *>, std::is_array<const char *>>> {
    }
template<> struct __or_<<std::is_void<const char *const &>, std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_void<const char *const &>::value, std::is_void<const char *const &>, __or_<std::is_function<const char *>, std::is_array<const char *>>> {
    }
template<> struct __or_<<std::is_void<const char *const>, std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_void<const char *const>::value, std::is_void<const char *const>, __or_<std::is_function<const char *>, std::is_array<const char *>>> {
    }
template<> struct __or_<<std::is_void<bool>, std::is_function<bool>, std::is_array<bool>>> : public __conditional_t<is_void<bool>::value, std::is_void<bool>, __or_<std::is_function<bool>, std::is_array<bool>>> {
    }
template<> struct __or_<<std::is_function<bool>, std::is_array<bool>>> : public __conditional_t<is_function<bool>::value, std::is_function<bool>, std::is_array<bool>> {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>>> : public __conditional_t<is_void<const volatile contiguous_iterator_tag *>::value, std::is_void<const volatile std::contiguous_iterator_tag *>, __or_<std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>>> {
    }
template<> struct __or_<<std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>>> : public __conditional_t<is_function<const volatile bidirectional_iterator_tag *>::value, std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>> {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>>> : public __conditional_t<is_void<const volatile contiguous_iterator_tag *>::value, std::is_void<const volatile std::contiguous_iterator_tag *>, __or_<std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>>> {
    }
template<> struct __or_<<std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>>> : public __conditional_t<is_function<const volatile random_access_iterator_tag *>::value, std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>> {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>>> : public __conditional_t<is_void<const volatile contiguous_iterator_tag *>::value, std::is_void<const volatile std::contiguous_iterator_tag *>, __or_<std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>>> {
    }
template<> struct __or_<<std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>>> : public __conditional_t<is_function<const volatile contiguous_iterator_tag *>::value, std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>> {
    }
template<> struct __or_<<std::__is_referenceable<const char &, void>, std::is_void<const char &>>> : public __conditional_t<__is_referenceable<const char &, void>::value, std::__is_referenceable<const char &, void>, std::is_void<const char &>> {
    }
template<> struct __or_<<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>>> : public __conditional_t<is_void<unsigned long>::value, std::is_void<unsigned long>, __or_<std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>>> {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>>> : public __conditional_t<__is_array_unknown_bounds<unsigned long>::value, std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>> {
    }
template<> struct __or_<<std::is_reference<unsigned long>, std::is_scalar<unsigned long>>> : public __conditional_t<is_reference<unsigned long>::value, std::is_reference<unsigned long>, std::is_scalar<unsigned long>> {
    }
template<> struct __or_<<std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>>> : public __conditional_t<is_lvalue_reference<unsigned long>::value, std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>> {
    }
template<> struct __or_<<std::is_arithmetic<unsigned long>, std::is_enum<unsigned long>, std::is_pointer<unsigned long>, std::is_member_pointer<unsigned long>, std::is_null_pointer<unsigned long>>> : public __conditional_t<is_arithmetic<unsigned long>::value, std::is_arithmetic<unsigned long>, __or_<std::is_enum<unsigned long>, std::is_pointer<unsigned long>, std::is_member_pointer<unsigned long>, std::is_null_pointer<unsigned long>>> {
    }
template<> struct __or_<<std::is_integral<unsigned long>, std::is_floating_point<unsigned long>>> : public __conditional_t<is_integral<unsigned long>::value, std::is_integral<unsigned long>, std::is_floating_point<unsigned long>> {
    }
template<> struct __or_<<std::is_reference<unsigned long>, std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public __conditional_t<is_reference<unsigned long>::value, std::is_reference<unsigned long>, __or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public __conditional_t<is_function<unsigned long>::value, std::is_function<unsigned long>, __or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
    }
template<> struct __or_<<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public __conditional_t<is_void<unsigned long>::value, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> {
    }
template<> struct __or_<<std::is_void<unsigned long>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public __conditional_t<is_void<unsigned long>::value, std::is_void<unsigned long>, __or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_array<unsigned long>>> : public __conditional_t<is_function<unsigned long>::value, std::is_function<unsigned long>, std::is_array<unsigned long>> {
    }
template<> struct __or_<<std::is_void<unsigned long &>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public __conditional_t<is_void<unsigned long &>::value, std::is_void<unsigned long &>, __or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
    }
template<> struct __or_<<std::is_void<const unsigned long &>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public __conditional_t<is_void<const unsigned long &>::value, std::is_void<const unsigned long &>, __or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
    }
template<> struct __or_<<std::is_void<const unsigned long>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public __conditional_t<is_void<const unsigned long>::value, std::is_void<const unsigned long>, __or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>> : public __conditional_t<is_function<unsigned long>::value, std::is_function<unsigned long>, __or_<std::is_reference<unsigned long>, std::is_void<unsigned long>>> {
    }
template<> struct __or_<<std::is_reference<unsigned long>, std::is_void<unsigned long>>> : public __conditional_t<is_reference<unsigned long>::value, std::is_reference<unsigned long>, std::is_void<unsigned long>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const unsigned long &>, std::is_rvalue_reference<const unsigned long &>>> : public __conditional_t<is_lvalue_reference<const unsigned long &>::value, std::is_lvalue_reference<const unsigned long &>, std::is_rvalue_reference<const unsigned long &>> {
    }
template<> struct __or_<<std::is_void<const unsigned long &>, std::is_function<const unsigned long &>, std::is_array<const unsigned long &>>> : public __conditional_t<is_void<const unsigned long &>::value, std::is_void<const unsigned long &>, __or_<std::is_function<const unsigned long &>, std::is_array<const unsigned long &>>> {
    }
template<> struct __or_<<std::is_function<const unsigned long &>, std::is_array<const unsigned long &>>> : public __conditional_t<is_function<const unsigned long &>::value, std::is_function<const unsigned long &>, std::is_array<const unsigned long &>> {
    }
template<> struct __or_<<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : public __conditional_t<is_function<const wchar_t *>::value, std::is_function<const wchar_t *>, __or_<std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : public __conditional_t<is_reference<const wchar_t *>::value, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const wchar_t *>, std::is_rvalue_reference<const wchar_t *>>> : public __conditional_t<is_lvalue_reference<const wchar_t *>::value, std::is_lvalue_reference<const wchar_t *>, std::is_rvalue_reference<const wchar_t *>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>>> : public __conditional_t<is_void<const wchar_t *>::value, std::is_void<const wchar_t *>, __or_<std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>>> {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>>> : public __conditional_t<__is_array_unknown_bounds<const wchar_t *>::value, std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>> {
    }
template<> struct __or_<<std::is_reference<const wchar_t *>, std::is_scalar<const wchar_t *>>> : public __conditional_t<is_reference<const wchar_t *>::value, std::is_reference<const wchar_t *>, std::is_scalar<const wchar_t *>> {
    }
template<> struct __or_<<std::is_arithmetic<const wchar_t *>, std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> : public __conditional_t<is_arithmetic<const wchar_t *>::value, std::is_arithmetic<const wchar_t *>, __or_<std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_integral<const wchar_t *>, std::is_floating_point<const wchar_t *>>> : public __conditional_t<is_integral<const wchar_t *>::value, std::is_integral<const wchar_t *>, std::is_floating_point<const wchar_t *>> {
    }
template<> struct __or_<<std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> : public __conditional_t<is_enum<const wchar_t *>::value, std::is_enum<const wchar_t *>, __or_<std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> : public __conditional_t<is_pointer<const wchar_t *>::value, std::is_pointer<const wchar_t *>, __or_<std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_reference<const wchar_t *>, std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> : public __conditional_t<is_reference<const wchar_t *>::value, std::is_reference<const wchar_t *>, __or_<std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> : public __conditional_t<is_function<const wchar_t *>::value, std::is_function<const wchar_t *>, __or_<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> : public __conditional_t<is_void<const wchar_t *>::value, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public __conditional_t<is_void<const wchar_t *>::value, std::is_void<const wchar_t *>, __or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public __conditional_t<is_function<const wchar_t *>::value, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const wchar_t *const &>, std::is_rvalue_reference<const wchar_t *const &>>> : public __conditional_t<is_lvalue_reference<const wchar_t *const &>::value, std::is_lvalue_reference<const wchar_t *const &>, std::is_rvalue_reference<const wchar_t *const &>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *const &>, std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>>> : public __conditional_t<is_void<const wchar_t *const &>::value, std::is_void<const wchar_t *const &>, __or_<std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>>> {
    }
template<> struct __or_<<std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>>> : public __conditional_t<is_function<const wchar_t *const &>::value, std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>> {
    }
template<> struct __or_<<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : public __conditional_t<is_function<const wchar_t>::value, std::is_function<const wchar_t>, __or_<std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> {
    }
template<> struct __or_<<std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : public __conditional_t<is_reference<const wchar_t>::value, std::is_reference<const wchar_t>, std::is_void<const wchar_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const wchar_t>, std::is_rvalue_reference<const wchar_t>>> : public __conditional_t<is_lvalue_reference<const wchar_t>::value, std::is_lvalue_reference<const wchar_t>, std::is_rvalue_reference<const wchar_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const wchar_t &>, std::is_rvalue_reference<const wchar_t &>>> : public __conditional_t<is_lvalue_reference<const wchar_t &>::value, std::is_lvalue_reference<const wchar_t &>, std::is_rvalue_reference<const wchar_t &>> {
    }
template<> struct __or_<<std::is_void<const wchar_t &>, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public __conditional_t<is_void<const wchar_t &>::value, std::is_void<const wchar_t &>, __or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
    }
template<> struct __or_<<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public __conditional_t<is_function<const wchar_t &>::value, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> {
    }
template<> struct __or_<<std::is_void<wchar_t &>, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public __conditional_t<is_void<wchar_t &>::value, std::is_void<wchar_t &>, __or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
    }
template<> struct __or_<<std::is_void<const wchar_t &&>, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public __conditional_t<is_void<const wchar_t &&>::value, std::is_void<const wchar_t &&>, __or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *&>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public __conditional_t<is_void<const wchar_t *&>::value, std::is_void<const wchar_t *&>, __or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *const &>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public __conditional_t<is_void<const wchar_t *const &>::value, std::is_void<const wchar_t *const &>, __or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *const>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public __conditional_t<is_void<const wchar_t *const>::value, std::is_void<const wchar_t *const>, __or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
    }
template<> struct __or_<<std::__is_referenceable<const wchar_t &, void>, std::is_void<const wchar_t &>>> : public __conditional_t<__is_referenceable<const wchar_t &, void>::value, std::__is_referenceable<const wchar_t &, void>, std::is_void<const wchar_t &>> {
    }
template<> struct __or_<<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : public __conditional_t<is_function<const char8_t *>::value, std::is_function<const char8_t *>, __or_<std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> {
    }
template<> struct __or_<<std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : public __conditional_t<is_reference<const char8_t *>::value, std::is_reference<const char8_t *>, std::is_void<const char8_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char8_t *>, std::is_rvalue_reference<const char8_t *>>> : public __conditional_t<is_lvalue_reference<const char8_t *>::value, std::is_lvalue_reference<const char8_t *>, std::is_rvalue_reference<const char8_t *>> {
    }
template<> struct __or_<<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>>> : public __conditional_t<is_void<const char8_t *>::value, std::is_void<const char8_t *>, __or_<std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>>> {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>>> : public __conditional_t<__is_array_unknown_bounds<const char8_t *>::value, std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>> {
    }
template<> struct __or_<<std::is_reference<const char8_t *>, std::is_scalar<const char8_t *>>> : public __conditional_t<is_reference<const char8_t *>::value, std::is_reference<const char8_t *>, std::is_scalar<const char8_t *>> {
    }
template<> struct __or_<<std::is_arithmetic<const char8_t *>, std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> : public __conditional_t<is_arithmetic<const char8_t *>::value, std::is_arithmetic<const char8_t *>, __or_<std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
    }
template<> struct __or_<<std::is_integral<const char8_t *>, std::is_floating_point<const char8_t *>>> : public __conditional_t<is_integral<const char8_t *>::value, std::is_integral<const char8_t *>, std::is_floating_point<const char8_t *>> {
    }
template<> struct __or_<<std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> : public __conditional_t<is_enum<const char8_t *>::value, std::is_enum<const char8_t *>, __or_<std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
    }
template<> struct __or_<<std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> : public __conditional_t<is_pointer<const char8_t *>::value, std::is_pointer<const char8_t *>, __or_<std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
    }
template<> struct __or_<<std::is_reference<const char8_t *>, std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> : public __conditional_t<is_reference<const char8_t *>::value, std::is_reference<const char8_t *>, __or_<std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> {
    }
template<> struct __or_<<std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> : public __conditional_t<is_function<const char8_t *>::value, std::is_function<const char8_t *>, __or_<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> {
    }
template<> struct __or_<<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> : public __conditional_t<is_void<const char8_t *>::value, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>> {
    }
template<> struct __or_<<std::is_void<const char8_t *>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public __conditional_t<is_void<const char8_t *>::value, std::is_void<const char8_t *>, __or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
    }
template<> struct __or_<<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public __conditional_t<is_function<const char8_t *>::value, std::is_function<const char8_t *>, std::is_array<const char8_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char8_t *const &>, std::is_rvalue_reference<const char8_t *const &>>> : public __conditional_t<is_lvalue_reference<const char8_t *const &>::value, std::is_lvalue_reference<const char8_t *const &>, std::is_rvalue_reference<const char8_t *const &>> {
    }
template<> struct __or_<<std::is_void<const char8_t *const &>, std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>>> : public __conditional_t<is_void<const char8_t *const &>::value, std::is_void<const char8_t *const &>, __or_<std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>>> {
    }
template<> struct __or_<<std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>>> : public __conditional_t<is_function<const char8_t *const &>::value, std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>> {
    }
template<> struct __or_<<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>> : public __conditional_t<is_function<const char8_t>::value, std::is_function<const char8_t>, __or_<std::is_reference<const char8_t>, std::is_void<const char8_t>>> {
    }
template<> struct __or_<<std::is_reference<const char8_t>, std::is_void<const char8_t>>> : public __conditional_t<is_reference<const char8_t>::value, std::is_reference<const char8_t>, std::is_void<const char8_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char8_t>, std::is_rvalue_reference<const char8_t>>> : public __conditional_t<is_lvalue_reference<const char8_t>::value, std::is_lvalue_reference<const char8_t>, std::is_rvalue_reference<const char8_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char8_t &>, std::is_rvalue_reference<const char8_t &>>> : public __conditional_t<is_lvalue_reference<const char8_t &>::value, std::is_lvalue_reference<const char8_t &>, std::is_rvalue_reference<const char8_t &>> {
    }
template<> struct __or_<<std::is_void<const char8_t &>, std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public __conditional_t<is_void<const char8_t &>::value, std::is_void<const char8_t &>, __or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
    }
template<> struct __or_<<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public __conditional_t<is_function<const char8_t &>::value, std::is_function<const char8_t &>, std::is_array<const char8_t &>> {
    }
template<> struct __or_<<std::is_void<char8_t &>, std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public __conditional_t<is_void<char8_t &>::value, std::is_void<char8_t &>, __or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
    }
template<> struct __or_<<std::is_void<const char8_t &&>, std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public __conditional_t<is_void<const char8_t &&>::value, std::is_void<const char8_t &&>, __or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
    }
template<> struct __or_<<std::is_void<const char8_t *&>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public __conditional_t<is_void<const char8_t *&>::value, std::is_void<const char8_t *&>, __or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
    }
template<> struct __or_<<std::is_void<const char8_t *const &>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public __conditional_t<is_void<const char8_t *const &>::value, std::is_void<const char8_t *const &>, __or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
    }
template<> struct __or_<<std::is_void<const char8_t *const>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public __conditional_t<is_void<const char8_t *const>::value, std::is_void<const char8_t *const>, __or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
    }
template<> struct __or_<<std::__is_referenceable<const char8_t &, void>, std::is_void<const char8_t &>>> : public __conditional_t<__is_referenceable<const char8_t &, void>::value, std::__is_referenceable<const char8_t &, void>, std::is_void<const char8_t &>> {
    }
template<> struct __or_<<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : public __conditional_t<is_function<const char16_t *>::value, std::is_function<const char16_t *>, __or_<std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> {
    }
template<> struct __or_<<std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : public __conditional_t<is_reference<const char16_t *>::value, std::is_reference<const char16_t *>, std::is_void<const char16_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char16_t *>, std::is_rvalue_reference<const char16_t *>>> : public __conditional_t<is_lvalue_reference<const char16_t *>::value, std::is_lvalue_reference<const char16_t *>, std::is_rvalue_reference<const char16_t *>> {
    }
template<> struct __or_<<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>>> : public __conditional_t<is_void<const char16_t *>::value, std::is_void<const char16_t *>, __or_<std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>>> {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>>> : public __conditional_t<__is_array_unknown_bounds<const char16_t *>::value, std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>> {
    }
template<> struct __or_<<std::is_reference<const char16_t *>, std::is_scalar<const char16_t *>>> : public __conditional_t<is_reference<const char16_t *>::value, std::is_reference<const char16_t *>, std::is_scalar<const char16_t *>> {
    }
template<> struct __or_<<std::is_arithmetic<const char16_t *>, std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> : public __conditional_t<is_arithmetic<const char16_t *>::value, std::is_arithmetic<const char16_t *>, __or_<std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
    }
template<> struct __or_<<std::is_integral<const char16_t *>, std::is_floating_point<const char16_t *>>> : public __conditional_t<is_integral<const char16_t *>::value, std::is_integral<const char16_t *>, std::is_floating_point<const char16_t *>> {
    }
template<> struct __or_<<std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> : public __conditional_t<is_enum<const char16_t *>::value, std::is_enum<const char16_t *>, __or_<std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
    }
template<> struct __or_<<std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> : public __conditional_t<is_pointer<const char16_t *>::value, std::is_pointer<const char16_t *>, __or_<std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
    }
template<> struct __or_<<std::is_reference<const char16_t *>, std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> : public __conditional_t<is_reference<const char16_t *>::value, std::is_reference<const char16_t *>, __or_<std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> {
    }
template<> struct __or_<<std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> : public __conditional_t<is_function<const char16_t *>::value, std::is_function<const char16_t *>, __or_<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> {
    }
template<> struct __or_<<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> : public __conditional_t<is_void<const char16_t *>::value, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>> {
    }
template<> struct __or_<<std::is_void<const char16_t *>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public __conditional_t<is_void<const char16_t *>::value, std::is_void<const char16_t *>, __or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
    }
template<> struct __or_<<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public __conditional_t<is_function<const char16_t *>::value, std::is_function<const char16_t *>, std::is_array<const char16_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char16_t *const &>, std::is_rvalue_reference<const char16_t *const &>>> : public __conditional_t<is_lvalue_reference<const char16_t *const &>::value, std::is_lvalue_reference<const char16_t *const &>, std::is_rvalue_reference<const char16_t *const &>> {
    }
template<> struct __or_<<std::is_void<const char16_t *const &>, std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>>> : public __conditional_t<is_void<const char16_t *const &>::value, std::is_void<const char16_t *const &>, __or_<std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>>> {
    }
template<> struct __or_<<std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>>> : public __conditional_t<is_function<const char16_t *const &>::value, std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>> {
    }
template<> struct __or_<<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>> : public __conditional_t<is_function<const char16_t>::value, std::is_function<const char16_t>, __or_<std::is_reference<const char16_t>, std::is_void<const char16_t>>> {
    }
template<> struct __or_<<std::is_reference<const char16_t>, std::is_void<const char16_t>>> : public __conditional_t<is_reference<const char16_t>::value, std::is_reference<const char16_t>, std::is_void<const char16_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char16_t>, std::is_rvalue_reference<const char16_t>>> : public __conditional_t<is_lvalue_reference<const char16_t>::value, std::is_lvalue_reference<const char16_t>, std::is_rvalue_reference<const char16_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char16_t &>, std::is_rvalue_reference<const char16_t &>>> : public __conditional_t<is_lvalue_reference<const char16_t &>::value, std::is_lvalue_reference<const char16_t &>, std::is_rvalue_reference<const char16_t &>> {
    }
template<> struct __or_<<std::is_void<const char16_t &>, std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public __conditional_t<is_void<const char16_t &>::value, std::is_void<const char16_t &>, __or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
    }
template<> struct __or_<<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public __conditional_t<is_function<const char16_t &>::value, std::is_function<const char16_t &>, std::is_array<const char16_t &>> {
    }
template<> struct __or_<<std::is_void<char16_t &>, std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public __conditional_t<is_void<char16_t &>::value, std::is_void<char16_t &>, __or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
    }
template<> struct __or_<<std::is_void<const char16_t &&>, std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public __conditional_t<is_void<const char16_t &&>::value, std::is_void<const char16_t &&>, __or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
    }
template<> struct __or_<<std::is_void<const char16_t *&>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public __conditional_t<is_void<const char16_t *&>::value, std::is_void<const char16_t *&>, __or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
    }
template<> struct __or_<<std::is_void<const char16_t *const &>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public __conditional_t<is_void<const char16_t *const &>::value, std::is_void<const char16_t *const &>, __or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
    }
template<> struct __or_<<std::is_void<const char16_t *const>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public __conditional_t<is_void<const char16_t *const>::value, std::is_void<const char16_t *const>, __or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
    }
template<> struct __or_<<std::__is_referenceable<const char16_t &, void>, std::is_void<const char16_t &>>> : public __conditional_t<__is_referenceable<const char16_t &, void>::value, std::__is_referenceable<const char16_t &, void>, std::is_void<const char16_t &>> {
    }
template<> struct __or_<<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : public __conditional_t<is_function<const char32_t *>::value, std::is_function<const char32_t *>, __or_<std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> {
    }
template<> struct __or_<<std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : public __conditional_t<is_reference<const char32_t *>::value, std::is_reference<const char32_t *>, std::is_void<const char32_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char32_t *>, std::is_rvalue_reference<const char32_t *>>> : public __conditional_t<is_lvalue_reference<const char32_t *>::value, std::is_lvalue_reference<const char32_t *>, std::is_rvalue_reference<const char32_t *>> {
    }
template<> struct __or_<<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>>> : public __conditional_t<is_void<const char32_t *>::value, std::is_void<const char32_t *>, __or_<std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>>> {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>>> : public __conditional_t<__is_array_unknown_bounds<const char32_t *>::value, std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>> {
    }
template<> struct __or_<<std::is_reference<const char32_t *>, std::is_scalar<const char32_t *>>> : public __conditional_t<is_reference<const char32_t *>::value, std::is_reference<const char32_t *>, std::is_scalar<const char32_t *>> {
    }
template<> struct __or_<<std::is_arithmetic<const char32_t *>, std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> : public __conditional_t<is_arithmetic<const char32_t *>::value, std::is_arithmetic<const char32_t *>, __or_<std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
    }
template<> struct __or_<<std::is_integral<const char32_t *>, std::is_floating_point<const char32_t *>>> : public __conditional_t<is_integral<const char32_t *>::value, std::is_integral<const char32_t *>, std::is_floating_point<const char32_t *>> {
    }
template<> struct __or_<<std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> : public __conditional_t<is_enum<const char32_t *>::value, std::is_enum<const char32_t *>, __or_<std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
    }
template<> struct __or_<<std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> : public __conditional_t<is_pointer<const char32_t *>::value, std::is_pointer<const char32_t *>, __or_<std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
    }
template<> struct __or_<<std::is_reference<const char32_t *>, std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> : public __conditional_t<is_reference<const char32_t *>::value, std::is_reference<const char32_t *>, __or_<std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> {
    }
template<> struct __or_<<std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> : public __conditional_t<is_function<const char32_t *>::value, std::is_function<const char32_t *>, __or_<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> {
    }
template<> struct __or_<<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> : public __conditional_t<is_void<const char32_t *>::value, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>> {
    }
template<> struct __or_<<std::is_void<const char32_t *>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public __conditional_t<is_void<const char32_t *>::value, std::is_void<const char32_t *>, __or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
    }
template<> struct __or_<<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public __conditional_t<is_function<const char32_t *>::value, std::is_function<const char32_t *>, std::is_array<const char32_t *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char32_t *const &>, std::is_rvalue_reference<const char32_t *const &>>> : public __conditional_t<is_lvalue_reference<const char32_t *const &>::value, std::is_lvalue_reference<const char32_t *const &>, std::is_rvalue_reference<const char32_t *const &>> {
    }
template<> struct __or_<<std::is_void<const char32_t *const &>, std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>>> : public __conditional_t<is_void<const char32_t *const &>::value, std::is_void<const char32_t *const &>, __or_<std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>>> {
    }
template<> struct __or_<<std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>>> : public __conditional_t<is_function<const char32_t *const &>::value, std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>> {
    }
template<> struct __or_<<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>> : public __conditional_t<is_function<const char32_t>::value, std::is_function<const char32_t>, __or_<std::is_reference<const char32_t>, std::is_void<const char32_t>>> {
    }
template<> struct __or_<<std::is_reference<const char32_t>, std::is_void<const char32_t>>> : public __conditional_t<is_reference<const char32_t>::value, std::is_reference<const char32_t>, std::is_void<const char32_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char32_t>, std::is_rvalue_reference<const char32_t>>> : public __conditional_t<is_lvalue_reference<const char32_t>::value, std::is_lvalue_reference<const char32_t>, std::is_rvalue_reference<const char32_t>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const char32_t &>, std::is_rvalue_reference<const char32_t &>>> : public __conditional_t<is_lvalue_reference<const char32_t &>::value, std::is_lvalue_reference<const char32_t &>, std::is_rvalue_reference<const char32_t &>> {
    }
template<> struct __or_<<std::is_void<const char32_t &>, std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public __conditional_t<is_void<const char32_t &>::value, std::is_void<const char32_t &>, __or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
    }
template<> struct __or_<<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public __conditional_t<is_function<const char32_t &>::value, std::is_function<const char32_t &>, std::is_array<const char32_t &>> {
    }
template<> struct __or_<<std::is_void<char32_t &>, std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public __conditional_t<is_void<char32_t &>::value, std::is_void<char32_t &>, __or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
    }
template<> struct __or_<<std::is_void<const char32_t &&>, std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public __conditional_t<is_void<const char32_t &&>::value, std::is_void<const char32_t &&>, __or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
    }
template<> struct __or_<<std::is_void<const char32_t *&>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public __conditional_t<is_void<const char32_t *&>::value, std::is_void<const char32_t *&>, __or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
    }
template<> struct __or_<<std::is_void<const char32_t *const &>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public __conditional_t<is_void<const char32_t *const &>::value, std::is_void<const char32_t *const &>, __or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
    }
template<> struct __or_<<std::is_void<const char32_t *const>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public __conditional_t<is_void<const char32_t *const>::value, std::is_void<const char32_t *const>, __or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
    }
template<> struct __or_<<std::__is_referenceable<const char32_t &, void>, std::is_void<const char32_t &>>> : public __conditional_t<__is_referenceable<const char32_t &, void>::value, std::__is_referenceable<const char32_t &, void>, std::is_void<const char32_t &>> {
    }
template<> struct __or_<<std::is_integral<unsigned int>, std::is_floating_point<unsigned int>>> : public __conditional_t<is_integral<unsigned int>::value, std::is_integral<unsigned int>, std::is_floating_point<unsigned int>> {
    }
template<> struct __or_<<std::is_void<const unsigned int &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public __conditional_t<is_void<const unsigned int &>::value, std::is_void<const unsigned int &>, __or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public __conditional_t<is_function<basic_string_view<char, char_traits<char>>>::value, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>> {
    }
template<> struct __or_<<std::is_integral<unsigned long long>, std::is_floating_point<unsigned long long>>> : public __conditional_t<is_integral<unsigned long long>::value, std::is_integral<unsigned long long>, std::is_floating_point<unsigned long long>> {
    }
template<> struct __or_<<std::is_void<const char *const &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public __conditional_t<is_void<const char *const &>::value, std::is_void<const char *const &>, __or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
    }
template<> struct __or_<<std::is_void<const char *const *>, std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> : public __conditional_t<is_void<const char *const *>::value, std::is_void<const char *const *>, __or_<std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> : public __conditional_t<is_function<const basic_string<char, char_traits<char>, allocator<char>> *>::value, std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *const &>, std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> : public __conditional_t<is_void<const wchar_t *const &>::value, std::is_void<const wchar_t *const &>, __or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> : public __conditional_t<is_function<basic_string_view<wchar_t, char_traits<wchar_t>>>::value, std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
    }
template<> struct __or_<<std::is_void<const wchar_t *const *>, std::is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>, std::is_array<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>> : public __conditional_t<is_void<const wchar_t *const *>::value, std::is_void<const wchar_t *const *>, __or_<std::is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>, std::is_array<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>> {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>, std::is_array<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>> : public __conditional_t<is_function<const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>::value, std::is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>, std::is_array<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>> {
    }
template<> struct __or_<<std::is_void<const char8_t *const &>, std::is_function<std::basic_string_view<char8_t, std::char_traits<char8_t>>>, std::is_array<std::basic_string_view<char8_t, std::char_traits<char8_t>>>>> : public __conditional_t<is_void<const char8_t *const &>::value, std::is_void<const char8_t *const &>, __or_<std::is_function<std::basic_string_view<char8_t, std::char_traits<char8_t>>>, std::is_array<std::basic_string_view<char8_t, std::char_traits<char8_t>>>>> {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<char8_t, std::char_traits<char8_t>>>, std::is_array<std::basic_string_view<char8_t, std::char_traits<char8_t>>>>> : public __conditional_t<is_function<basic_string_view<char8_t, char_traits<char8_t>>>::value, std::is_function<std::basic_string_view<char8_t, std::char_traits<char8_t>>>, std::is_array<std::basic_string_view<char8_t, std::char_traits<char8_t>>>> {
    }
template<> struct __or_<<std::is_void<const char8_t *const *>, std::is_function<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>, std::is_array<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>>> : public __conditional_t<is_void<const char8_t *const *>::value, std::is_void<const char8_t *const *>, __or_<std::is_function<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>, std::is_array<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>>> {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>, std::is_array<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>>> : public __conditional_t<is_function<const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>::value, std::is_function<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>, std::is_array<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>> {
    }
template<> struct __or_<<std::is_void<const char16_t *const &>, std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>>> : public __conditional_t<is_void<const char16_t *const &>::value, std::is_void<const char16_t *const &>, __or_<std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>>> {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>>> : public __conditional_t<is_function<basic_string_view<char16_t, char_traits<char16_t>>>::value, std::is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>>> {
    }
template<> struct __or_<<std::is_void<const char16_t *const *>, std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> : public __conditional_t<is_void<const char16_t *const *>::value, std::is_void<const char16_t *const *>, __or_<std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> : public __conditional_t<is_function<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>::value, std::is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>, std::is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>> {
    }
template<> struct __or_<<std::is_void<const char32_t *const &>, std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>>> : public __conditional_t<is_void<const char32_t *const &>::value, std::is_void<const char32_t *const &>, __or_<std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>>> {
    }
template<> struct __or_<<std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>>> : public __conditional_t<is_function<basic_string_view<char32_t, char_traits<char32_t>>>::value, std::is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>>> {
    }
template<> struct __or_<<std::is_void<const char32_t *const *>, std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> : public __conditional_t<is_void<const char32_t *const *>::value, std::is_void<const char32_t *const *>, __or_<std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> {
    }
template<> struct __or_<<std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> : public __conditional_t<is_function<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>::value, std::is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>, std::is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>> {
    }
template<> struct __or_<<std::is_lvalue_reference<const std::_V2::error_category *const &>, std::is_rvalue_reference<const std::_V2::error_category *const &>>> : public __conditional_t<is_lvalue_reference<const error_category *const &>::value, std::is_lvalue_reference<const std::_V2::error_category *const &>, std::is_rvalue_reference<const std::_V2::error_category *const &>> {
    }
template<> struct __or_<<std::is_void<const std::_V2::error_category *const &>, std::is_function<const std::_V2::error_category *const &>, std::is_array<const std::_V2::error_category *const &>>> : public __conditional_t<is_void<const error_category *const &>::value, std::is_void<const std::_V2::error_category *const &>, __or_<std::is_function<const std::_V2::error_category *const &>, std::is_array<const std::_V2::error_category *const &>>> {
    }
template<> struct __or_<<std::is_function<const std::_V2::error_category *const &>, std::is_array<const std::_V2::error_category *const &>>> : public __conditional_t<is_function<const error_category *const &>::value, std::is_function<const std::_V2::error_category *const &>, std::is_array<const std::_V2::error_category *const &>> {
    }
template<> struct __or_<<std::is_void<const std::_V2::error_category *>, std::is_function<const volatile void *>, std::is_array<const volatile void *>>> : public __conditional_t<is_void<const error_category *>::value, std::is_void<const std::_V2::error_category *>, __or_<std::is_function<const volatile void *>, std::is_array<const volatile void *>>> {
    }
template<> struct __or_<<std::is_function<const volatile void *>, std::is_array<const volatile void *>>> : public __conditional_t<is_function<const volatile void *>::value, std::is_function<const volatile void *>, std::is_array<const volatile void *>> {
    }
template<> struct __or_<<std::is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public __conditional_t<is_void<const basic_string<char, char_traits<char>, allocator<char>> &>::value, std::is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &>, __or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
    }
template<> struct __or_<<std::is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> : public __conditional_t<is_void<const basic_string<char, char_traits<char>, allocator<char>> *>::value, std::is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, __or_<std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> {
    }
template<> struct __or_<<std::is_function<char>, std::is_reference<char>, std::is_void<char>>> : public __conditional_t<is_function<char>::value, std::is_function<char>, __or_<std::is_reference<char>, std::is_void<char>>> {
    }
template<> struct __or_<<std::is_reference<char>, std::is_void<char>>> : public __conditional_t<is_reference<char>::value, std::is_reference<char>, std::is_void<char>> {
    }
template<> struct __or_<<std::is_void<char *const &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public __conditional_t<is_void<char *const &>::value, std::is_void<char *const &>, __or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
    }
template<> struct __or_<<std::is_void<char *const *>, std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> : public __conditional_t<is_void<char *const *>::value, std::is_void<char *const *>, __or_<std::is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>, std::is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> {
    }
template<> struct __or_<<std::is_void<char *const &>, std::is_function<const char *>, std::is_array<const char *>>> : public __conditional_t<is_void<char *const &>::value, std::is_void<char *const &>, __or_<std::is_function<const char *>, std::is_array<const char *>>> {
    }
template<> struct __or_<<std::is_void<const char &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public __conditional_t<is_void<const char &>::value, std::is_void<const char &>, __or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
    }
template<> struct __or_<<std::is_reference<std::allocator<char>>, std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public __conditional_t<is_reference<allocator<char>>::value, std::is_reference<std::allocator<char>>, __or_<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
    }
template<> struct __or_<<std::is_lvalue_reference<std::allocator<char>>, std::is_rvalue_reference<std::allocator<char>>>> : public __conditional_t<is_lvalue_reference<allocator<char>>::value, std::is_lvalue_reference<std::allocator<char>>, std::is_rvalue_reference<std::allocator<char>>> {
    }
template<> struct __or_<<std::is_function<std::allocator<char>>, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public __conditional_t<is_function<allocator<char>>::value, std::is_function<std::allocator<char>>, __or_<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> {
    }
template<> struct __or_<<std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>>> : public __conditional_t<is_void<allocator<char>>::value, std::is_void<std::allocator<char>>, std::__is_array_unknown_bounds<std::allocator<char>>> {
    }
template<> struct __or_<<std::is_void<const int &>, std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> : public __conditional_t<is_void<const int &>::value, std::is_void<const int &>, __or_<std::is_function<std::basic_string_view<char, std::char_traits<char>>>, std::is_array<std::basic_string_view<char, std::char_traits<char>>>>> {
    }
template<> struct __or_<<std::is_void<std::random_access_iterator_tag>, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public __conditional_t<is_void<random_access_iterator_tag>::value, std::is_void<std::random_access_iterator_tag>, __or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> {
    }
template<> struct __or_<<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public __conditional_t<is_function<input_iterator_tag>::value, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> {
    }
template<> struct __or_<<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>> : public __conditional_t<is_function<wchar_t>::value, std::is_function<wchar_t>, __or_<std::is_reference<wchar_t>, std::is_void<wchar_t>>> {
    }
template<> struct __or_<<std::is_reference<wchar_t>, std::is_void<wchar_t>>> : public __conditional_t<is_reference<wchar_t>::value, std::is_reference<wchar_t>, std::is_void<wchar_t>> {
    }
template<> struct __or_<<std::is_void<wchar_t *const &>, std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> : public __conditional_t<is_void<wchar_t *const &>::value, std::is_void<wchar_t *const &>, __or_<std::is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>>> {
    }
template<> struct __or_<<std::is_void<wchar_t *const *>, std::is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>, std::is_array<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>> : public __conditional_t<is_void<wchar_t *const *>::value, std::is_void<wchar_t *const *>, __or_<std::is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>, std::is_array<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>> {
    }
template<> struct __or_<<std::is_void<wchar_t *const &>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public __conditional_t<is_void<wchar_t *const &>::value, std::is_void<wchar_t *const &>, __or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
    };
    template<> struct __or_<> : public std::false_type {
    };
    template <typename _B1> struct __or_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __or_<_B1, _B2> : public __conditional_t<_B1::value, _B1, _B2> {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __or_<_B1, _B2, _B3, _Bn...> : public __conditional_t<_B1::value, _B1, __or_<_B2, _B3, _Bn...>> {
    };
    template <typename ...> struct __and_
template<> struct __and_<<std::is_array<char>, std::__not_<std::extent<char, 0>>>> : public __conditional_t<is_array<char>::value, std::__not_<std::extent<char, 0>>, std::is_array<char>> {
    }
template<> struct __and_<<std::is_array<wchar_t>, std::__not_<std::extent<wchar_t, 0>>>> : public __conditional_t<is_array<wchar_t>::value, std::__not_<std::extent<wchar_t, 0>>, std::is_array<wchar_t>> {
    }
template<> struct __and_<<std::is_array<char8_t>, std::__not_<std::extent<char8_t, 0>>>> : public __conditional_t<is_array<char8_t>::value, std::__not_<std::extent<char8_t, 0>>, std::is_array<char8_t>> {
    }
template<> struct __and_<<std::is_array<char16_t>, std::__not_<std::extent<char16_t, 0>>>> : public __conditional_t<is_array<char16_t>::value, std::__not_<std::extent<char16_t, 0>>, std::is_array<char16_t>> {
    }
template<> struct __and_<<std::is_array<char32_t>, std::__not_<std::extent<char32_t, 0>>>> : public __conditional_t<is_array<char32_t>::value, std::__not_<std::extent<char32_t, 0>>, std::is_array<char32_t>> {
    }
template<> struct __and_<<std::is_array<const char *>, std::__not_<std::extent<const char *, 0>>>> : public __conditional_t<is_array<const char *>::value, std::__not_<std::extent<const char *, 0>>, std::is_array<const char *>> {
    }
template<> struct __and_<<std::is_convertible<const char &&, const char &>>> : public std::is_convertible<const char &&, const char &> {
    }
template<> struct __and_<<std::is_array<unsigned long>, std::__not_<std::extent<unsigned long, 0>>>> : public __conditional_t<is_array<unsigned long>::value, std::__not_<std::extent<unsigned long, 0>>, std::is_array<unsigned long>> {
    }
template<> struct __and_<<std::is_array<const wchar_t *>, std::__not_<std::extent<const wchar_t *, 0>>>> : public __conditional_t<is_array<const wchar_t *>::value, std::__not_<std::extent<const wchar_t *, 0>>, std::is_array<const wchar_t *>> {
    }
template<> struct __and_<<std::is_convertible<const wchar_t &&, const wchar_t &>>> : public std::is_convertible<const wchar_t &&, const wchar_t &> {
    }
template<> struct __and_<<std::is_array<const char8_t *>, std::__not_<std::extent<const char8_t *, 0>>>> : public __conditional_t<is_array<const char8_t *>::value, std::__not_<std::extent<const char8_t *, 0>>, std::is_array<const char8_t *>> {
    }
template<> struct __and_<<std::is_convertible<const char8_t &&, const char8_t &>>> : public std::is_convertible<const char8_t &&, const char8_t &> {
    }
template<> struct __and_<<std::is_array<const char16_t *>, std::__not_<std::extent<const char16_t *, 0>>>> : public __conditional_t<is_array<const char16_t *>::value, std::__not_<std::extent<const char16_t *, 0>>, std::is_array<const char16_t *>> {
    }
template<> struct __and_<<std::is_convertible<const char16_t &&, const char16_t &>>> : public std::is_convertible<const char16_t &&, const char16_t &> {
    }
template<> struct __and_<<std::is_array<const char32_t *>, std::__not_<std::extent<const char32_t *, 0>>>> : public __conditional_t<is_array<const char32_t *>::value, std::__not_<std::extent<const char32_t *, 0>>, std::is_array<const char32_t *>> {
    }
template<> struct __and_<<std::is_convertible<const char32_t &&, const char32_t &>>> : public std::is_convertible<const char32_t &&, const char32_t &> {
    }
template<> struct __and_<<std::is_arithmetic<unsigned int>, std::__not_<std::is_signed<unsigned int>>>> : public __conditional_t<is_arithmetic<unsigned int>::value, std::__not_<std::is_signed<unsigned int>>, std::is_arithmetic<unsigned int>> {
    }
template<> struct __and_<<std::is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const unsigned int *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>> : public __conditional_t<is_convertible<const unsigned int &, basic_string_view<char, char_traits<char>>>::value, __and_<std::__not_<std::is_convertible<const unsigned int *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const unsigned int &, const char *>>>, std::is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>> {
    }
template<> struct __and_<<std::is_arithmetic<unsigned long>, std::__not_<std::is_signed<unsigned long>>>> : public __conditional_t<is_arithmetic<unsigned long>::value, std::__not_<std::is_signed<unsigned long>>, std::is_arithmetic<unsigned long>> {
    }
template<> struct __and_<<std::is_arithmetic<unsigned long long>, std::__not_<std::is_signed<unsigned long long>>>> : public __conditional_t<is_arithmetic<unsigned long long>::value, std::__not_<std::is_signed<unsigned long long>>, std::is_arithmetic<unsigned long long>> {
    }
template<> struct __and_<<std::is_convertible<const char *const &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>> : public __conditional_t<is_convertible<const char *const &, basic_string_view<char, char_traits<char>>>::value, __and_<std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>, std::is_convertible<const char *const &, std::basic_string_view<char, std::char_traits<char>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const char *const &, const char *>>>> : public __conditional_t<__not_<is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>::value, std::__not_<std::is_convertible<const char *const &, const char *>>, std::__not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> {
    }
template<> struct __and_<<std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>> : public __conditional_t<is_convertible<const wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::value, __and_<std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>, std::is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>>> : public __conditional_t<__not_<is_convertible<const wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>>::value, std::__not_<std::is_convertible<const wchar_t *const &, const wchar_t *>>, std::__not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>> {
    }
template<> struct __and_<<std::is_convertible<const char8_t *const &, std::basic_string_view<char8_t, std::char_traits<char8_t>>>, std::__not_<std::is_convertible<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>>, std::__not_<std::is_convertible<const char8_t *const &, const char8_t *>>>> : public __conditional_t<is_convertible<const char8_t *const &, basic_string_view<char8_t, char_traits<char8_t>>>::value, __and_<std::__not_<std::is_convertible<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>>, std::__not_<std::is_convertible<const char8_t *const &, const char8_t *>>>, std::is_convertible<const char8_t *const &, std::basic_string_view<char8_t, std::char_traits<char8_t>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>>, std::__not_<std::is_convertible<const char8_t *const &, const char8_t *>>>> : public __conditional_t<__not_<is_convertible<const char8_t *const *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>>::value, std::__not_<std::is_convertible<const char8_t *const &, const char8_t *>>, std::__not_<std::is_convertible<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>>> {
    }
template<> struct __and_<<std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>, std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>> : public __conditional_t<is_convertible<const char16_t *const &, basic_string_view<char16_t, char_traits<char16_t>>>::value, __and_<std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>, std::is_convertible<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>>> : public __conditional_t<__not_<is_convertible<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>::value, std::__not_<std::is_convertible<const char16_t *const &, const char16_t *>>, std::__not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>>> {
    }
template<> struct __and_<<std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>, std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>> : public __conditional_t<is_convertible<const char32_t *const &, basic_string_view<char32_t, char_traits<char32_t>>>::value, __and_<std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>, std::is_convertible<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>>> : public __conditional_t<__not_<is_convertible<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>::value, std::__not_<std::is_convertible<const char32_t *const &, const char32_t *>>, std::__not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>>> {
    }
template<> struct __and_<<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, const char *>>>> : public __conditional_t<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> &, basic_string_view<char, char_traits<char>>>::value, __and_<std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, const char *>>>, std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::basic_string_view<char, std::char_traits<char>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, const char *>>>> : public __conditional_t<__not_<is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>>::value, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, const char *>>, std::__not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> {
    }
template<> struct __and_<<std::is_convertible<char *const &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>> : public __conditional_t<is_convertible<char *const &, basic_string_view<char, char_traits<char>>>::value, __and_<std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>, std::is_convertible<char *const &, std::basic_string_view<char, std::char_traits<char>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<char *const &, const char *>>>> : public __conditional_t<__not_<is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>>::value, std::__not_<std::is_convertible<char *const &, const char *>>, std::__not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>> {
    }
template<> struct __and_<<std::is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const char *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const char &, const char *>>>> : public __conditional_t<is_convertible<const char &, basic_string_view<char, char_traits<char>>>::value, __and_<std::__not_<std::is_convertible<const char *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const char &, const char *>>>, std::is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>>> {
    }
template<> struct __and_<<std::is_array<std::allocator<char>>, std::__not_<std::extent<std::allocator<char>, 0>>>> : public __conditional_t<is_array<allocator<char>>::value, std::__not_<std::extent<std::allocator<char>, 0>>, std::is_array<std::allocator<char>>> {
    }
template<> struct __and_<<std::is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>>, std::__not_<std::is_convertible<const int *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const int &, const char *>>>> : public __conditional_t<is_convertible<const int &, basic_string_view<char, char_traits<char>>>::value, __and_<std::__not_<std::is_convertible<const int *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>>, std::__not_<std::is_convertible<const int &, const char *>>>, std::is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>>> {
    }
template<> struct __and_<<std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>, std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>> : public __conditional_t<is_convertible<wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::value, __and_<std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>, std::is_convertible<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>> {
    }
template<> struct __and_<<std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>>> : public __conditional_t<__not_<is_convertible<wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>>::value, std::__not_<std::is_convertible<wchar_t *const &, const wchar_t *>>, std::__not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>>> {
    };
    template<> struct __and_<> : public std::true_type {
    };
    template <typename _B1> struct __and_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __and_<_B1, _B2> : public __conditional_t<_B1::value, _B2, _B1> {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __and_<_B1, _B2, _B3, _Bn...> : public __conditional_t<_B1::value, __and_<_B2, _B3, _Bn...>, _B1> {
    };
    template <typename _Pp> struct __not_ : public __bool_constant<!bool(_Pp::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>> : public __bool_constant<!bool(__or_<is_function<const char *>, is_reference<const char *>, is_void<const char *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>> : public __bool_constant<!bool(__or_<is_function<const char>, is_reference<const char>, is_void<const char>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>> : public __bool_constant<!bool(__or_<is_function<unsigned long>, is_reference<unsigned long>, is_void<unsigned long>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : public __bool_constant<!bool(__or_<is_function<const wchar_t *>, is_reference<const wchar_t *>, is_void<const wchar_t *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : public __bool_constant<!bool(__or_<is_function<const wchar_t>, is_reference<const wchar_t>, is_void<const wchar_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : public __bool_constant<!bool(__or_<is_function<const char8_t *>, is_reference<const char8_t *>, is_void<const char8_t *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>> : public __bool_constant<!bool(__or_<is_function<const char8_t>, is_reference<const char8_t>, is_void<const char8_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : public __bool_constant<!bool(__or_<is_function<const char16_t *>, is_reference<const char16_t *>, is_void<const char16_t *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>> : public __bool_constant<!bool(__or_<is_function<const char16_t>, is_reference<const char16_t>, is_void<const char16_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : public __bool_constant<!bool(__or_<is_function<const char32_t *>, is_reference<const char32_t *>, is_void<const char32_t *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>> : public __bool_constant<!bool(__or_<is_function<const char32_t>, is_reference<const char32_t>, is_void<const char32_t>>::value)> {
    };
template<> struct __not_<std::is_signed<unsigned int>> : public __bool_constant<!bool(is_signed<unsigned int>::value)> {
    };
template<> struct __not_<std::is_signed<unsigned long>> : public __bool_constant<!bool(is_signed<unsigned long>::value)> {
    };
template<> struct __not_<std::is_signed<unsigned long long>> : public __bool_constant<!bool(is_signed<unsigned long long>::value)> {
    };
template<> struct __not_<std::is_convertible<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>> : public __bool_constant<!bool(is_convertible<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char *const &, const char *>> : public __bool_constant<!bool(is_convertible<const char *const &, const char *>::value)> {
    };
template<> struct __not_<std::is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>> : public __bool_constant<!bool(is_convertible<const wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const wchar_t *const &, const wchar_t *>> : public __bool_constant<!bool(is_convertible<const wchar_t *const &, const wchar_t *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>> : public __bool_constant<!bool(is_convertible<const char8_t *const *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char8_t *const &, const char8_t *>> : public __bool_constant<!bool(is_convertible<const char8_t *const &, const char8_t *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>> : public __bool_constant<!bool(is_convertible<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char16_t *const &, const char16_t *>> : public __bool_constant<!bool(is_convertible<const char16_t *const &, const char16_t *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>> : public __bool_constant<!bool(is_convertible<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<const char32_t *const &, const char32_t *>> : public __bool_constant<!bool(is_convertible<const char32_t *const &, const char32_t *>::value)> {
    };
template<> struct __not_<std::is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>> : public __bool_constant<!bool(is_convertible<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<char>, std::is_reference<char>, std::is_void<char>>> : public __bool_constant<!bool(__or_<is_function<char>, is_reference<char>, is_void<char>>::value)> {
    };
template<> struct __not_<std::is_convertible<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>> : public __bool_constant<!bool(is_convertible<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<char *const &, const char *>> : public __bool_constant<!bool(is_convertible<char *const &, const char *>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>> : public __bool_constant<!bool(__or_<is_function<wchar_t>, is_reference<wchar_t>, is_void<wchar_t>>::value)> {
    };
template<> struct __not_<std::is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>> : public __bool_constant<!bool(is_convertible<wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>::value)> {
    };
template<> struct __not_<std::is_convertible<wchar_t *const &, const wchar_t *>> : public __bool_constant<!bool(is_convertible<wchar_t *const &, const wchar_t *>::value)> {
    };
    template <typename ..._Bn> constexpr bool __or_v = __or_<_Bn...>::value;
    template <typename ..._Bn> constexpr bool __and_v = __and_<_Bn...>::value;
    template <typename ..._Bn> struct conjunction : __and_<_Bn...> {
    };
    template <typename ..._Bn> struct disjunction : __or_<_Bn...> {
    };
    template <typename _Pp> struct negation : __not_<_Pp> {
    };
    template <typename ..._Bn> constexpr bool conjunction_v = conjunction<_Bn...>::value;
    template <typename ..._Bn> constexpr bool disjunction_v = disjunction<_Bn...>::value;
    template <typename _Pp> constexpr bool negation_v = negation<_Pp>::value;
    template <typename> struct is_reference
template<> struct is_reference<char> : public __or_<is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    }
template<> struct is_reference<wchar_t> : public __or_<is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    }
template<> struct is_reference<char8_t> : public __or_<is_lvalue_reference<char8_t>, is_rvalue_reference<char8_t>>::type {
    }
template<> struct is_reference<char16_t> : public __or_<is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    }
template<> struct is_reference<char32_t> : public __or_<is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    }
template<> struct is_reference<const char *> : public __or_<is_lvalue_reference<const char *>, is_rvalue_reference<const char *>>::type {
    }
template<> struct is_reference<const char *const &> : public __or_<is_lvalue_reference<const char *const &>, is_rvalue_reference<const char *const &>>::type {
    }
template<> struct is_reference<const char> : public __or_<is_lvalue_reference<const char>, is_rvalue_reference<const char>>::type {
    }
template<> struct is_reference<const char &> : public __or_<is_lvalue_reference<const char &>, is_rvalue_reference<const char &>>::type {
    }
template<> struct is_reference<unsigned long> : public __or_<is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    }
template<> struct is_reference<const unsigned long &> : public __or_<is_lvalue_reference<const unsigned long &>, is_rvalue_reference<const unsigned long &>>::type {
    }
template<> struct is_reference<const wchar_t *> : public __or_<is_lvalue_reference<const wchar_t *>, is_rvalue_reference<const wchar_t *>>::type {
    }
template<> struct is_reference<const wchar_t *const &> : public __or_<is_lvalue_reference<const wchar_t *const &>, is_rvalue_reference<const wchar_t *const &>>::type {
    }
template<> struct is_reference<const wchar_t> : public __or_<is_lvalue_reference<const wchar_t>, is_rvalue_reference<const wchar_t>>::type {
    }
template<> struct is_reference<const wchar_t &> : public __or_<is_lvalue_reference<const wchar_t &>, is_rvalue_reference<const wchar_t &>>::type {
    }
template<> struct is_reference<const char8_t *> : public __or_<is_lvalue_reference<const char8_t *>, is_rvalue_reference<const char8_t *>>::type {
    }
template<> struct is_reference<const char8_t *const &> : public __or_<is_lvalue_reference<const char8_t *const &>, is_rvalue_reference<const char8_t *const &>>::type {
    }
template<> struct is_reference<const char8_t> : public __or_<is_lvalue_reference<const char8_t>, is_rvalue_reference<const char8_t>>::type {
    }
template<> struct is_reference<const char8_t &> : public __or_<is_lvalue_reference<const char8_t &>, is_rvalue_reference<const char8_t &>>::type {
    }
template<> struct is_reference<const char16_t *> : public __or_<is_lvalue_reference<const char16_t *>, is_rvalue_reference<const char16_t *>>::type {
    }
template<> struct is_reference<const char16_t *const &> : public __or_<is_lvalue_reference<const char16_t *const &>, is_rvalue_reference<const char16_t *const &>>::type {
    }
template<> struct is_reference<const char16_t> : public __or_<is_lvalue_reference<const char16_t>, is_rvalue_reference<const char16_t>>::type {
    }
template<> struct is_reference<const char16_t &> : public __or_<is_lvalue_reference<const char16_t &>, is_rvalue_reference<const char16_t &>>::type {
    }
template<> struct is_reference<const char32_t *> : public __or_<is_lvalue_reference<const char32_t *>, is_rvalue_reference<const char32_t *>>::type {
    }
template<> struct is_reference<const char32_t *const &> : public __or_<is_lvalue_reference<const char32_t *const &>, is_rvalue_reference<const char32_t *const &>>::type {
    }
template<> struct is_reference<const char32_t> : public __or_<is_lvalue_reference<const char32_t>, is_rvalue_reference<const char32_t>>::type {
    }
template<> struct is_reference<const char32_t &> : public __or_<is_lvalue_reference<const char32_t &>, is_rvalue_reference<const char32_t &>>::type {
    }
template<> struct is_reference<const std::_V2::error_category *const &> : public __or_<is_lvalue_reference<const error_category *const &>, is_rvalue_reference<const error_category *const &>>::type {
    }
template<> struct is_reference<std::allocator<char>> : public __or_<is_lvalue_reference<allocator<char>>, is_rvalue_reference<allocator<char>>>::type {
    };
    template <typename> struct is_function
template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    }
template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    }
template<> struct is_function<char8_t> : public __bool_constant<!is_const<const char8_t>::value> {
    }
template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    }
template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    }
template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    }
template<> struct is_function<const char *const &> : public std::false_type {
    }
template<> struct is_function<const char> : public __bool_constant<!is_const<const const char>::value> {
    }
template<> struct is_function<const char &> : public std::false_type {
    }
template<> struct is_function<const volatile std::input_iterator_tag *> : public __bool_constant<!is_const<const volatile input_iterator_tag *const>::value> {
    }
template<> struct is_function<const volatile std::forward_iterator_tag *> : public __bool_constant<!is_const<const volatile forward_iterator_tag *const>::value> {
    }
template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    }
template<> struct is_function<const volatile std::bidirectional_iterator_tag *> : public __bool_constant<!is_const<const volatile bidirectional_iterator_tag *const>::value> {
    }
template<> struct is_function<const volatile std::random_access_iterator_tag *> : public __bool_constant<!is_const<const volatile random_access_iterator_tag *const>::value> {
    }
template<> struct is_function<const volatile std::contiguous_iterator_tag *> : public __bool_constant<!is_const<const volatile contiguous_iterator_tag *const>::value> {
    }
template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    }
template<> struct is_function<const unsigned long &> : public std::false_type {
    }
template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    }
template<> struct is_function<const wchar_t *const &> : public std::false_type {
    }
template<> struct is_function<const wchar_t> : public __bool_constant<!is_const<const const wchar_t>::value> {
    }
template<> struct is_function<const wchar_t &> : public std::false_type {
    }
template<> struct is_function<const char8_t *> : public __bool_constant<!is_const<const char8_t *const>::value> {
    }
template<> struct is_function<const char8_t *const &> : public std::false_type {
    }
template<> struct is_function<const char8_t> : public __bool_constant<!is_const<const const char8_t>::value> {
    }
template<> struct is_function<const char8_t &> : public std::false_type {
    }
template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    }
template<> struct is_function<const char16_t *const &> : public std::false_type {
    }
template<> struct is_function<const char16_t> : public __bool_constant<!is_const<const const char16_t>::value> {
    }
template<> struct is_function<const char16_t &> : public std::false_type {
    }
template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    }
template<> struct is_function<const char32_t *const &> : public std::false_type {
    }
template<> struct is_function<const char32_t> : public __bool_constant<!is_const<const const char32_t>::value> {
    }
template<> struct is_function<const char32_t &> : public std::false_type {
    }
template<> struct is_function<std::basic_string_view<char, std::char_traits<char>>> : public __bool_constant<!is_const<const basic_string_view<char, char_traits<char>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public __bool_constant<!is_const<const basic_string<char, char_traits<char>, allocator<char>> *const>::value> {
    }
template<> struct is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __bool_constant<!is_const<const basic_string_view<wchar_t, char_traits<wchar_t>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *> : public __bool_constant<!is_const<const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *const>::value> {
    }
template<> struct is_function<std::basic_string_view<char8_t, std::char_traits<char8_t>>> : public __bool_constant<!is_const<const basic_string_view<char8_t, char_traits<char8_t>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *> : public __bool_constant<!is_const<const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *const>::value> {
    }
template<> struct is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public __bool_constant<!is_const<const basic_string_view<char16_t, char_traits<char16_t>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public __bool_constant<!is_const<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *const>::value> {
    }
template<> struct is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public __bool_constant<!is_const<const basic_string_view<char32_t, char_traits<char32_t>>>::value> {
    }
template<> struct is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public __bool_constant<!is_const<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *const>::value> {
    }
template<> struct is_function<const std::_V2::error_category *const &> : public std::false_type {
    }
template<> struct is_function<const volatile void *> : public __bool_constant<!is_const<const volatile void *const>::value> {
    }
template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    }
template<> struct is_function<std::input_iterator_tag> : public __bool_constant<!is_const<const input_iterator_tag>::value> {
    };
    template <typename> struct is_void
template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    }
template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    }
template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    }
template<> struct is_void<char8_t> : public __is_void_helper<__remove_cv_t<char8_t>>::type {
    }
template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    }
template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    }
template<> struct is_void<const char *> : public __is_void_helper<__remove_cv_t<const char *>>::type {
    }
template<> struct is_void<const char *const &> : public __is_void_helper<__remove_cv_t<const char *const &>>::type {
    }
template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    }
template<> struct is_void<const char &> : public __is_void_helper<__remove_cv_t<const char &>>::type {
    }
template<> struct is_void<char &> : public __is_void_helper<__remove_cv_t<char &>>::type {
    }
template<> struct is_void<const char &&> : public __is_void_helper<__remove_cv_t<const char &&>>::type {
    }
template<> struct is_void<const volatile std::contiguous_iterator_tag *> : public __is_void_helper<__remove_cv_t<const volatile contiguous_iterator_tag *>>::type {
    }
template<> struct is_void<const char *&> : public __is_void_helper<__remove_cv_t<const char *&>>::type {
    }
template<> struct is_void<const char *const> : public __is_void_helper<__remove_cv_t<const char *const>>::type {
    }
template<> struct is_void<bool> : public __is_void_helper<__remove_cv_t<bool>>::type {
    }
template<> struct is_void<unsigned long> : public __is_void_helper<__remove_cv_t<unsigned long>>::type {
    }
template<> struct is_void<unsigned long &> : public __is_void_helper<__remove_cv_t<unsigned long &>>::type {
    }
template<> struct is_void<const unsigned long &> : public __is_void_helper<__remove_cv_t<const unsigned long &>>::type {
    }
template<> struct is_void<const unsigned long> : public __is_void_helper<__remove_cv_t<const unsigned long>>::type {
    }
template<> struct is_void<const wchar_t *> : public __is_void_helper<__remove_cv_t<const wchar_t *>>::type {
    }
template<> struct is_void<const wchar_t *const &> : public __is_void_helper<__remove_cv_t<const wchar_t *const &>>::type {
    }
template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    }
template<> struct is_void<const wchar_t &> : public __is_void_helper<__remove_cv_t<const wchar_t &>>::type {
    }
template<> struct is_void<wchar_t &> : public __is_void_helper<__remove_cv_t<wchar_t &>>::type {
    }
template<> struct is_void<const wchar_t &&> : public __is_void_helper<__remove_cv_t<const wchar_t &&>>::type {
    }
template<> struct is_void<const wchar_t *&> : public __is_void_helper<__remove_cv_t<const wchar_t *&>>::type {
    }
template<> struct is_void<const wchar_t *const> : public __is_void_helper<__remove_cv_t<const wchar_t *const>>::type {
    }
template<> struct is_void<const char8_t *> : public __is_void_helper<__remove_cv_t<const char8_t *>>::type {
    }
template<> struct is_void<const char8_t *const &> : public __is_void_helper<__remove_cv_t<const char8_t *const &>>::type {
    }
template<> struct is_void<const char8_t> : public __is_void_helper<__remove_cv_t<const char8_t>>::type {
    }
template<> struct is_void<const char8_t &> : public __is_void_helper<__remove_cv_t<const char8_t &>>::type {
    }
template<> struct is_void<char8_t &> : public __is_void_helper<__remove_cv_t<char8_t &>>::type {
    }
template<> struct is_void<const char8_t &&> : public __is_void_helper<__remove_cv_t<const char8_t &&>>::type {
    }
template<> struct is_void<const char8_t *&> : public __is_void_helper<__remove_cv_t<const char8_t *&>>::type {
    }
template<> struct is_void<const char8_t *const> : public __is_void_helper<__remove_cv_t<const char8_t *const>>::type {
    }
template<> struct is_void<const char16_t *> : public __is_void_helper<__remove_cv_t<const char16_t *>>::type {
    }
template<> struct is_void<const char16_t *const &> : public __is_void_helper<__remove_cv_t<const char16_t *const &>>::type {
    }
template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    }
template<> struct is_void<const char16_t &> : public __is_void_helper<__remove_cv_t<const char16_t &>>::type {
    }
template<> struct is_void<char16_t &> : public __is_void_helper<__remove_cv_t<char16_t &>>::type {
    }
template<> struct is_void<const char16_t &&> : public __is_void_helper<__remove_cv_t<const char16_t &&>>::type {
    }
template<> struct is_void<const char16_t *&> : public __is_void_helper<__remove_cv_t<const char16_t *&>>::type {
    }
template<> struct is_void<const char16_t *const> : public __is_void_helper<__remove_cv_t<const char16_t *const>>::type {
    }
template<> struct is_void<const char32_t *> : public __is_void_helper<__remove_cv_t<const char32_t *>>::type {
    }
template<> struct is_void<const char32_t *const &> : public __is_void_helper<__remove_cv_t<const char32_t *const &>>::type {
    }
template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    }
template<> struct is_void<const char32_t &> : public __is_void_helper<__remove_cv_t<const char32_t &>>::type {
    }
template<> struct is_void<char32_t &> : public __is_void_helper<__remove_cv_t<char32_t &>>::type {
    }
template<> struct is_void<const char32_t &&> : public __is_void_helper<__remove_cv_t<const char32_t &&>>::type {
    }
template<> struct is_void<const char32_t *&> : public __is_void_helper<__remove_cv_t<const char32_t *&>>::type {
    }
template<> struct is_void<const char32_t *const> : public __is_void_helper<__remove_cv_t<const char32_t *const>>::type {
    }
template<> struct is_void<const unsigned int &> : public __is_void_helper<__remove_cv_t<const unsigned int &>>::type {
    }
template<> struct is_void<const char *const *> : public __is_void_helper<__remove_cv_t<const char *const *>>::type {
    }
template<> struct is_void<const wchar_t *const *> : public __is_void_helper<__remove_cv_t<const wchar_t *const *>>::type {
    }
template<> struct is_void<const char8_t *const *> : public __is_void_helper<__remove_cv_t<const char8_t *const *>>::type {
    }
template<> struct is_void<const char16_t *const *> : public __is_void_helper<__remove_cv_t<const char16_t *const *>>::type {
    }
template<> struct is_void<const char32_t *const *> : public __is_void_helper<__remove_cv_t<const char32_t *const *>>::type {
    }
template<> struct is_void<const std::_V2::error_category *const &> : public __is_void_helper<__remove_cv_t<const error_category *const &>>::type {
    }
template<> struct is_void<const std::_V2::error_category *> : public __is_void_helper<__remove_cv_t<const error_category *>>::type {
    }
template<> struct is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> : public __is_void_helper<__remove_cv_t<const basic_string<char, char_traits<char>, allocator<char>> &>>::type {
    }
template<> struct is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public __is_void_helper<__remove_cv_t<const basic_string<char, char_traits<char>, allocator<char>> *>>::type {
    }
template<> struct is_void<char *const &> : public __is_void_helper<__remove_cv_t<char *const &>>::type {
    }
template<> struct is_void<char *const *> : public __is_void_helper<__remove_cv_t<char *const *>>::type {
    }
template<> struct is_void<std::allocator<char>> : public __is_void_helper<__remove_cv_t<allocator<char>>>::type {
    }
template<> struct is_void<const int &> : public __is_void_helper<__remove_cv_t<const int &>>::type {
    }
template<> struct is_void<std::random_access_iterator_tag> : public __is_void_helper<__remove_cv_t<random_access_iterator_tag>>::type {
    }
template<> struct is_void<wchar_t *const &> : public __is_void_helper<__remove_cv_t<wchar_t *const &>>::type {
    }
template<> struct is_void<wchar_t *const *> : public __is_void_helper<__remove_cv_t<wchar_t *const *>>::type {
    };
    template <typename> struct remove_cv
template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    }
template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    }
template<> struct remove_cv<char8_t> {
        using type = char8_t;
    }
template<> struct remove_cv<unsigned char> {
        using type = unsigned char;
    }
template<> struct remove_cv<char16_t> {
        using type = char16_t;
    }
template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    }
template<> struct remove_cv<char32_t> {
        using type = char32_t;
    }
template<> struct remove_cv<void> {
        using type = void;
    }
template<> struct remove_cv<double> {
        using type = double;
    }
template<> struct remove_cv<std::ranges::__detail::__max_size_type> {
        using type = std::ranges::__detail::__max_size_type;
    }
template<> struct remove_cv<int> {
        using type = int;
    }
template<> struct remove_cv<unsigned __int128> {
        using type = unsigned __int128;
    }
template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    }
template<> struct remove_cv<std::ranges::__detail::__max_diff_type> {
        using type = std::ranges::__detail::__max_diff_type;
    }
template<> struct remove_cv<char> {
        using type = char;
    }
template<> struct remove_cv<const char *> {
        using type = const char *;
    }
template<> struct remove_cv<const char *const &> {
        using type = const char *const &;
    }
template<> struct remove_cv<const char> {
        using type = char;
    }
template<> struct remove_cv<long> {
        using type = long;
    }
template<> struct remove_cv<const char &> {
        using type = const char &;
    }
template<> struct remove_cv<char &> {
        using type = char &;
    }
template<> struct remove_cv<const char &&> {
        using type = const char &&;
    }
template<> struct remove_cv<const volatile std::contiguous_iterator_tag *> {
        using type = const volatile std::contiguous_iterator_tag *;
    }
template<> struct remove_cv<const char *&> {
        using type = const char *&;
    }
template<> struct remove_cv<const char *const> {
        using type = const char *;
    }
template<> struct remove_cv<bool> {
        using type = bool;
    }
template<> struct remove_cv<unsigned long &> {
        using type = unsigned long &;
    }
template<> struct remove_cv<const unsigned long &> {
        using type = const unsigned long &;
    }
template<> struct remove_cv<const unsigned long> {
        using type = unsigned long;
    }
template<> struct remove_cv<const wchar_t *> {
        using type = const wchar_t *;
    }
template<> struct remove_cv<const wchar_t *const &> {
        using type = const wchar_t *const &;
    }
template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    }
template<> struct remove_cv<const wchar_t &> {
        using type = const wchar_t &;
    }
template<> struct remove_cv<wchar_t &> {
        using type = wchar_t &;
    }
template<> struct remove_cv<const wchar_t &&> {
        using type = const wchar_t &&;
    }
template<> struct remove_cv<const wchar_t *&> {
        using type = const wchar_t *&;
    }
template<> struct remove_cv<const wchar_t *const> {
        using type = const wchar_t *;
    }
template<> struct remove_cv<const char8_t *> {
        using type = const char8_t *;
    }
template<> struct remove_cv<const char8_t *const &> {
        using type = const char8_t *const &;
    }
template<> struct remove_cv<const char8_t> {
        using type = char8_t;
    }
template<> struct remove_cv<const char8_t &> {
        using type = const char8_t &;
    }
template<> struct remove_cv<char8_t &> {
        using type = char8_t &;
    }
template<> struct remove_cv<const char8_t &&> {
        using type = const char8_t &&;
    }
template<> struct remove_cv<const char8_t *&> {
        using type = const char8_t *&;
    }
template<> struct remove_cv<const char8_t *const> {
        using type = const char8_t *;
    }
template<> struct remove_cv<const char16_t *> {
        using type = const char16_t *;
    }
template<> struct remove_cv<const char16_t *const &> {
        using type = const char16_t *const &;
    }
template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    }
template<> struct remove_cv<const char16_t &> {
        using type = const char16_t &;
    }
template<> struct remove_cv<char16_t &> {
        using type = char16_t &;
    }
template<> struct remove_cv<const char16_t &&> {
        using type = const char16_t &&;
    }
template<> struct remove_cv<const char16_t *&> {
        using type = const char16_t *&;
    }
template<> struct remove_cv<const char16_t *const> {
        using type = const char16_t *;
    }
template<> struct remove_cv<const char32_t *> {
        using type = const char32_t *;
    }
template<> struct remove_cv<const char32_t *const &> {
        using type = const char32_t *const &;
    }
template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    }
template<> struct remove_cv<const char32_t &> {
        using type = const char32_t &;
    }
template<> struct remove_cv<char32_t &> {
        using type = char32_t &;
    }
template<> struct remove_cv<const char32_t &&> {
        using type = const char32_t &&;
    }
template<> struct remove_cv<const char32_t *&> {
        using type = const char32_t *&;
    }
template<> struct remove_cv<const char32_t *const> {
        using type = const char32_t *;
    }
template<> struct remove_cv<const unsigned int &> {
        using type = const unsigned int &;
    }
template<> struct remove_cv<unsigned long long> {
        using type = unsigned long long;
    }
template<> struct remove_cv<const char *const *> {
        using type = const char *const *;
    }
template<> struct remove_cv<const wchar_t *const *> {
        using type = const wchar_t *const *;
    }
template<> struct remove_cv<const char8_t *const *> {
        using type = const char8_t *const *;
    }
template<> struct remove_cv<const char16_t *const *> {
        using type = const char16_t *const *;
    }
template<> struct remove_cv<const char32_t *const *> {
        using type = const char32_t *const *;
    }
template<> struct remove_cv<const std::_V2::error_category *const &> {
        using type = const std::_V2::error_category *const &;
    }
template<> struct remove_cv<const std::_V2::error_category *> {
        using type = const std::_V2::error_category *;
    }
template<> struct remove_cv<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> {
        using type = const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &;
    }
template<> struct remove_cv<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> {
        using type = const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *;
    }
template<> struct remove_cv<char *const &> {
        using type = char *const &;
    }
template<> struct remove_cv<char *const *> {
        using type = char *const *;
    }
template<> struct remove_cv<std::allocator<char>> {
        using type = std::allocator<char>;
    }
template<> struct remove_cv<const int &> {
        using type = const int &;
    }
template<> struct remove_cv<std::random_access_iterator_tag> {
        using type = std::random_access_iterator_tag;
    }
template<> struct remove_cv<wchar_t *const &> {
        using type = wchar_t *const &;
    }
template<> struct remove_cv<wchar_t *const *> {
        using type = wchar_t *const *;
    };
    template <typename> struct is_const
template<> struct is_const<wchar_t> : public std::false_type {
    }
template<> struct is_const<char8_t> : public std::false_type {
    }
template<> struct is_const<char16_t> : public std::false_type {
    }
template<> struct is_const<char32_t> : public std::false_type {
    }
template<> struct is_const<unsigned int> : public std::false_type {
    }
template<> struct is_const<unsigned char> : public std::false_type {
    }
template<> struct is_const<unsigned short> : public std::false_type {
    }
template<> struct is_const<const char> : public std::true_type {
    }
template<> struct is_const<const wchar_t> : public std::true_type {
    }
template<> struct is_const<const char8_t> : public std::true_type {
    }
template<> struct is_const<const char16_t> : public std::true_type {
    }
template<> struct is_const<const char32_t> : public std::true_type {
    }
template<> struct is_const<const char *const> : public std::true_type {
    }
template<> struct is_const<char> : public std::false_type {
    }
template<> struct is_const<const volatile std::input_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const volatile std::forward_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const bool> : public std::true_type {
    }
template<> struct is_const<const volatile std::bidirectional_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const volatile std::random_access_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const volatile std::contiguous_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const unsigned long> : public std::true_type {
    }
template<> struct is_const<const wchar_t *const> : public std::true_type {
    }
template<> struct is_const<const char8_t *const> : public std::true_type {
    }
template<> struct is_const<const char16_t *const> : public std::true_type {
    }
template<> struct is_const<const char32_t *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<char, std::char_traits<char>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<char8_t, std::char_traits<char8_t>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *const> : public std::true_type {
    }
template<> struct is_const<const std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public std::true_type {
    }
template<> struct is_const<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *const> : public std::true_type {
    }
template<> struct is_const<const std::_V2::error_category *const> : public std::true_type {
    }
template<> struct is_const<const volatile void *const> : public std::true_type {
    }
template<> struct is_const<const std::allocator<char>> : public std::true_type {
    }
template<> struct is_const<const std::input_iterator_tag> : public std::true_type {
    };
    template <typename> struct __is_array_unknown_bounds
template<> struct __is_array_unknown_bounds<char> : public __and_<is_array<char>, __not_<extent<char>>> {
    }
template<> struct __is_array_unknown_bounds<wchar_t> : public __and_<is_array<wchar_t>, __not_<extent<wchar_t>>> {
    }
template<> struct __is_array_unknown_bounds<char8_t> : public __and_<is_array<char8_t>, __not_<extent<char8_t>>> {
    }
template<> struct __is_array_unknown_bounds<char16_t> : public __and_<is_array<char16_t>, __not_<extent<char16_t>>> {
    }
template<> struct __is_array_unknown_bounds<char32_t> : public __and_<is_array<char32_t>, __not_<extent<char32_t>>> {
    }
template<> struct __is_array_unknown_bounds<const char *> : public __and_<is_array<const char *>, __not_<extent<const char *>>> {
    }
template<> struct __is_array_unknown_bounds<unsigned long> : public __and_<is_array<unsigned long>, __not_<extent<unsigned long>>> {
    }
template<> struct __is_array_unknown_bounds<const wchar_t *> : public __and_<is_array<const wchar_t *>, __not_<extent<const wchar_t *>>> {
    }
template<> struct __is_array_unknown_bounds<const char8_t *> : public __and_<is_array<const char8_t *>, __not_<extent<const char8_t *>>> {
    }
template<> struct __is_array_unknown_bounds<const char16_t *> : public __and_<is_array<const char16_t *>, __not_<extent<const char16_t *>>> {
    }
template<> struct __is_array_unknown_bounds<const char32_t *> : public __and_<is_array<const char32_t *>, __not_<extent<const char32_t *>>> {
    }
template<> struct __is_array_unknown_bounds<std::allocator<char>> : public __and_<is_array<std::allocator<char>>, __not_<extent<std::allocator<char>>>> {
    };
    template <typename _Tp, std::size_t = sizeof(_Tp)> constexpr std::true_type __is_complete_or_unbounded(__type_identity<_Tp>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char, 1>(__type_identity<char>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<wchar_t, 4>(__type_identity<wchar_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char8_t, 1>(__type_identity<char8_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char16_t, 2>(__type_identity<char16_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char32_t, 4>(__type_identity<char32_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char *, 8>(__type_identity<const char *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<unsigned long, 8>(__type_identity<unsigned long>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const wchar_t *, 8>(__type_identity<const wchar_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char8_t *, 8>(__type_identity<const char8_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char16_t *, 8>(__type_identity<const char16_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char32_t *, 8>(__type_identity<const char32_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<std::allocator<char>, 1>(__type_identity<std::allocator<char>>)     {
        return {};
    }
    template <typename _TypeIdentity, typename _NestedType = typename _TypeIdentity::type> constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>, __is_array_unknown_bounds<_NestedType>>::type __is_complete_or_unbounded(_TypeIdentity)     {
        return {};
    }
    template<> constexpr typename __or_<is_reference<char>, is_function<char>, is_void<char>, __is_array_unknown_bounds<char>>::type __is_complete_or_unbounded<std::__type_identity<char>, char>(std::__type_identity<char>)    template<> constexpr typename __or_<is_reference<wchar_t>, is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>::type __is_complete_or_unbounded<std::__type_identity<wchar_t>, wchar_t>(std::__type_identity<wchar_t>)    template<> constexpr typename __or_<is_reference<char8_t>, is_function<char8_t>, is_void<char8_t>, __is_array_unknown_bounds<char8_t>>::type __is_complete_or_unbounded<std::__type_identity<char8_t>, char8_t>(std::__type_identity<char8_t>)    template<> constexpr typename __or_<is_reference<char16_t>, is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>::type __is_complete_or_unbounded<std::__type_identity<char16_t>, char16_t>(std::__type_identity<char16_t>)    template<> constexpr typename __or_<is_reference<char32_t>, is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>::type __is_complete_or_unbounded<std::__type_identity<char32_t>, char32_t>(std::__type_identity<char32_t>)    template<> constexpr typename __or_<is_reference<const char *>, is_function<const char *>, is_void<const char *>, __is_array_unknown_bounds<const char *>>::type __is_complete_or_unbounded<std::__type_identity<const char *>, const char *>(std::__type_identity<const char *>)    template<> constexpr typename __or_<is_reference<unsigned long>, is_function<unsigned long>, is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>::type __is_complete_or_unbounded<std::__type_identity<unsigned long>, unsigned long>(std::__type_identity<unsigned long>)    template<> constexpr typename __or_<is_reference<const wchar_t *>, is_function<const wchar_t *>, is_void<const wchar_t *>, __is_array_unknown_bounds<const wchar_t *>>::type __is_complete_or_unbounded<std::__type_identity<const wchar_t *>, const wchar_t *>(std::__type_identity<const wchar_t *>)    template<> constexpr typename __or_<is_reference<const char8_t *>, is_function<const char8_t *>, is_void<const char8_t *>, __is_array_unknown_bounds<const char8_t *>>::type __is_complete_or_unbounded<std::__type_identity<const char8_t *>, const char8_t *>(std::__type_identity<const char8_t *>)    template<> constexpr typename __or_<is_reference<const char16_t *>, is_function<const char16_t *>, is_void<const char16_t *>, __is_array_unknown_bounds<const char16_t *>>::type __is_complete_or_unbounded<std::__type_identity<const char16_t *>, const char16_t *>(std::__type_identity<const char16_t *>)    template<> constexpr typename __or_<is_reference<const char32_t *>, is_function<const char32_t *>, is_void<const char32_t *>, __is_array_unknown_bounds<const char32_t *>>::type __is_complete_or_unbounded<std::__type_identity<const char32_t *>, const char32_t *>(std::__type_identity<const char32_t *>)    template<> constexpr typename __or_<is_reference<allocator<char>>, is_function<allocator<char>>, is_void<allocator<char>>, __is_array_unknown_bounds<allocator<char>>>::type __is_complete_or_unbounded<std::__type_identity<std::allocator<char>>, std::allocator<char>>(std::__type_identity<std::allocator<char>>)    template <typename _Tp> struct __success_type {
        typedef _Tp type;
    };
    struct __failure_type {
    };
    template <typename _Tp> using __remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename> struct __is_void_helper : public std::false_type {
    };
template<> struct __is_void_helper<char> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t> : public std::false_type {
    };
template<> struct __is_void_helper<char8_t> : public std::false_type {
    };
template<> struct __is_void_helper<char16_t> : public std::false_type {
    };
template<> struct __is_void_helper<char32_t> : public std::false_type {
    };
template<> struct __is_void_helper<const char *> : public std::false_type {
    };
template<> struct __is_void_helper<const char *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char &> : public std::false_type {
    };
template<> struct __is_void_helper<char &> : public std::false_type {
    };
template<> struct __is_void_helper<const char &&> : public std::false_type {
    };
template<> struct __is_void_helper<const volatile std::contiguous_iterator_tag *> : public std::false_type {
    };
template<> struct __is_void_helper<const char *&> : public std::false_type {
    };
template<> struct __is_void_helper<bool> : public std::false_type {
    };
template<> struct __is_void_helper<unsigned long> : public std::false_type {
    };
template<> struct __is_void_helper<unsigned long &> : public std::false_type {
    };
template<> struct __is_void_helper<const unsigned long &> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t &> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *&> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t *> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t &> : public std::false_type {
    };
template<> struct __is_void_helper<char8_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t *&> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t &> : public std::false_type {
    };
template<> struct __is_void_helper<char16_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *&> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t &> : public std::false_type {
    };
template<> struct __is_void_helper<char32_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *&> : public std::false_type {
    };
template<> struct __is_void_helper<const unsigned int &> : public std::false_type {
    };
template<> struct __is_void_helper<const char *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *const *> : public std::false_type {
    };
template<> struct __is_void_helper<const std::_V2::error_category *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const std::_V2::error_category *> : public std::false_type {
    };
template<> struct __is_void_helper<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> : public std::false_type {
    };
template<> struct __is_void_helper<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public std::false_type {
    };
template<> struct __is_void_helper<char *const &> : public std::false_type {
    };
template<> struct __is_void_helper<char *const *> : public std::false_type {
    };
template<> struct __is_void_helper<std::allocator<char>> : public std::false_type {
    };
template<> struct __is_void_helper<const int &> : public std::false_type {
    };
template<> struct __is_void_helper<std::random_access_iterator_tag> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t *const *> : public std::false_type {
    };
    template<> struct __is_void_helper<void> : public std::true_type {
    };
    template <typename _Tp> struct is_void : public __is_void_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    };
template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    };
template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    };
template<> struct is_void<char8_t> : public __is_void_helper<__remove_cv_t<char8_t>>::type {
    };
template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    };
template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    };
template<> struct is_void<const char *> : public __is_void_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_void<const char *const &> : public __is_void_helper<__remove_cv_t<const char *const &>>::type {
    };
template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    };
template<> struct is_void<const char &> : public __is_void_helper<__remove_cv_t<const char &>>::type {
    };
template<> struct is_void<char &> : public __is_void_helper<__remove_cv_t<char &>>::type {
    };
template<> struct is_void<const char &&> : public __is_void_helper<__remove_cv_t<const char &&>>::type {
    };
template<> struct is_void<const volatile std::contiguous_iterator_tag *> : public __is_void_helper<__remove_cv_t<const volatile contiguous_iterator_tag *>>::type {
    };
template<> struct is_void<const char *&> : public __is_void_helper<__remove_cv_t<const char *&>>::type {
    };
template<> struct is_void<const char *const> : public __is_void_helper<__remove_cv_t<const char *const>>::type {
    };
template<> struct is_void<bool> : public __is_void_helper<__remove_cv_t<bool>>::type {
    };
template<> struct is_void<unsigned long> : public __is_void_helper<__remove_cv_t<unsigned long>>::type {
    };
template<> struct is_void<unsigned long &> : public __is_void_helper<__remove_cv_t<unsigned long &>>::type {
    };
template<> struct is_void<const unsigned long &> : public __is_void_helper<__remove_cv_t<const unsigned long &>>::type {
    };
template<> struct is_void<const unsigned long> : public __is_void_helper<__remove_cv_t<const unsigned long>>::type {
    };
template<> struct is_void<const wchar_t *> : public __is_void_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_void<const wchar_t *const &> : public __is_void_helper<__remove_cv_t<const wchar_t *const &>>::type {
    };
template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    };
template<> struct is_void<const wchar_t &> : public __is_void_helper<__remove_cv_t<const wchar_t &>>::type {
    };
template<> struct is_void<wchar_t &> : public __is_void_helper<__remove_cv_t<wchar_t &>>::type {
    };
template<> struct is_void<const wchar_t &&> : public __is_void_helper<__remove_cv_t<const wchar_t &&>>::type {
    };
template<> struct is_void<const wchar_t *&> : public __is_void_helper<__remove_cv_t<const wchar_t *&>>::type {
    };
template<> struct is_void<const wchar_t *const> : public __is_void_helper<__remove_cv_t<const wchar_t *const>>::type {
    };
template<> struct is_void<const char8_t *> : public __is_void_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_void<const char8_t *const &> : public __is_void_helper<__remove_cv_t<const char8_t *const &>>::type {
    };
template<> struct is_void<const char8_t> : public __is_void_helper<__remove_cv_t<const char8_t>>::type {
    };
template<> struct is_void<const char8_t &> : public __is_void_helper<__remove_cv_t<const char8_t &>>::type {
    };
template<> struct is_void<char8_t &> : public __is_void_helper<__remove_cv_t<char8_t &>>::type {
    };
template<> struct is_void<const char8_t &&> : public __is_void_helper<__remove_cv_t<const char8_t &&>>::type {
    };
template<> struct is_void<const char8_t *&> : public __is_void_helper<__remove_cv_t<const char8_t *&>>::type {
    };
template<> struct is_void<const char8_t *const> : public __is_void_helper<__remove_cv_t<const char8_t *const>>::type {
    };
template<> struct is_void<const char16_t *> : public __is_void_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_void<const char16_t *const &> : public __is_void_helper<__remove_cv_t<const char16_t *const &>>::type {
    };
template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    };
template<> struct is_void<const char16_t &> : public __is_void_helper<__remove_cv_t<const char16_t &>>::type {
    };
template<> struct is_void<char16_t &> : public __is_void_helper<__remove_cv_t<char16_t &>>::type {
    };
template<> struct is_void<const char16_t &&> : public __is_void_helper<__remove_cv_t<const char16_t &&>>::type {
    };
template<> struct is_void<const char16_t *&> : public __is_void_helper<__remove_cv_t<const char16_t *&>>::type {
    };
template<> struct is_void<const char16_t *const> : public __is_void_helper<__remove_cv_t<const char16_t *const>>::type {
    };
template<> struct is_void<const char32_t *> : public __is_void_helper<__remove_cv_t<const char32_t *>>::type {
    };
template<> struct is_void<const char32_t *const &> : public __is_void_helper<__remove_cv_t<const char32_t *const &>>::type {
    };
template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    };
template<> struct is_void<const char32_t &> : public __is_void_helper<__remove_cv_t<const char32_t &>>::type {
    };
template<> struct is_void<char32_t &> : public __is_void_helper<__remove_cv_t<char32_t &>>::type {
    };
template<> struct is_void<const char32_t &&> : public __is_void_helper<__remove_cv_t<const char32_t &&>>::type {
    };
template<> struct is_void<const char32_t *&> : public __is_void_helper<__remove_cv_t<const char32_t *&>>::type {
    };
template<> struct is_void<const char32_t *const> : public __is_void_helper<__remove_cv_t<const char32_t *const>>::type {
    };
template<> struct is_void<const unsigned int &> : public __is_void_helper<__remove_cv_t<const unsigned int &>>::type {
    };
template<> struct is_void<const char *const *> : public __is_void_helper<__remove_cv_t<const char *const *>>::type {
    };
template<> struct is_void<const wchar_t *const *> : public __is_void_helper<__remove_cv_t<const wchar_t *const *>>::type {
    };
template<> struct is_void<const char8_t *const *> : public __is_void_helper<__remove_cv_t<const char8_t *const *>>::type {
    };
template<> struct is_void<const char16_t *const *> : public __is_void_helper<__remove_cv_t<const char16_t *const *>>::type {
    };
template<> struct is_void<const char32_t *const *> : public __is_void_helper<__remove_cv_t<const char32_t *const *>>::type {
    };
template<> struct is_void<const std::_V2::error_category *const &> : public __is_void_helper<__remove_cv_t<const error_category *const &>>::type {
    };
template<> struct is_void<const std::_V2::error_category *> : public __is_void_helper<__remove_cv_t<const error_category *>>::type {
    };
template<> struct is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> : public __is_void_helper<__remove_cv_t<const basic_string<char, char_traits<char>, allocator<char>> &>>::type {
    };
template<> struct is_void<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public __is_void_helper<__remove_cv_t<const basic_string<char, char_traits<char>, allocator<char>> *>>::type {
    };
template<> struct is_void<char *const &> : public __is_void_helper<__remove_cv_t<char *const &>>::type {
    };
template<> struct is_void<char *const *> : public __is_void_helper<__remove_cv_t<char *const *>>::type {
    };
template<> struct is_void<std::allocator<char>> : public __is_void_helper<__remove_cv_t<allocator<char>>>::type {
    };
template<> struct is_void<const int &> : public __is_void_helper<__remove_cv_t<const int &>>::type {
    };
template<> struct is_void<std::random_access_iterator_tag> : public __is_void_helper<__remove_cv_t<random_access_iterator_tag>>::type {
    };
template<> struct is_void<wchar_t *const &> : public __is_void_helper<__remove_cv_t<wchar_t *const &>>::type {
    };
template<> struct is_void<wchar_t *const *> : public __is_void_helper<__remove_cv_t<wchar_t *const *>>::type {
    };
    template <typename> struct __is_integral_helper : public std::false_type {
    };
template<> struct __is_integral_helper<std::ranges::__detail::__max_size_type> : public std::false_type {
    };
template<> struct __is_integral_helper<unsigned __int128> : public std::false_type {
    };
template<> struct __is_integral_helper<std::ranges::__detail::__max_diff_type> : public std::false_type {
    };
template<> struct __is_integral_helper<const char *> : public std::false_type {
    };
template<> struct __is_integral_helper<const wchar_t *> : public std::false_type {
    };
template<> struct __is_integral_helper<const char8_t *> : public std::false_type {
    };
template<> struct __is_integral_helper<const char16_t *> : public std::false_type {
    };
template<> struct __is_integral_helper<const char32_t *> : public std::false_type {
    };
    template<> struct __is_integral_helper<bool> : public std::true_type {
    };
    template<> struct __is_integral_helper<char> : public std::true_type {
    };
    template<> struct __is_integral_helper<signed char> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned char> : public std::true_type {
    };
    template<> struct __is_integral_helper<wchar_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char8_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char16_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char32_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<short> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned short> : public std::true_type {
    };
    template<> struct __is_integral_helper<int> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned int> : public std::true_type {
    };
    template<> struct __is_integral_helper<long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long> : public std::true_type {
    };
    template<> struct __is_integral_helper<long long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long long> : public std::true_type {
    };
    template <typename _Tp> struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_integral<wchar_t> : public __is_integral_helper<__remove_cv_t<wchar_t>>::type {
    };
template<> struct is_integral<unsigned int> : public __is_integral_helper<__remove_cv_t<unsigned int>>::type {
    };
template<> struct is_integral<char8_t> : public __is_integral_helper<__remove_cv_t<char8_t>>::type {
    };
template<> struct is_integral<unsigned char> : public __is_integral_helper<__remove_cv_t<unsigned char>>::type {
    };
template<> struct is_integral<char16_t> : public __is_integral_helper<__remove_cv_t<char16_t>>::type {
    };
template<> struct is_integral<unsigned short> : public __is_integral_helper<__remove_cv_t<unsigned short>>::type {
    };
template<> struct is_integral<char32_t> : public __is_integral_helper<__remove_cv_t<char32_t>>::type {
    };
template<> struct is_integral<std::ranges::__detail::__max_size_type> : public __is_integral_helper<__remove_cv_t<__max_size_type>>::type {
    };
template<> struct is_integral<int> : public __is_integral_helper<__remove_cv_t<int>>::type {
    };
template<> struct is_integral<unsigned __int128> : public __is_integral_helper<__remove_cv_t<unsigned __int128>>::type {
    };
template<> struct is_integral<unsigned long> : public __is_integral_helper<__remove_cv_t<unsigned long>>::type {
    };
template<> struct is_integral<std::ranges::__detail::__max_diff_type> : public __is_integral_helper<__remove_cv_t<__max_diff_type>>::type {
    };
template<> struct is_integral<const char *> : public __is_integral_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_integral<long> : public __is_integral_helper<__remove_cv_t<long>>::type {
    };
template<> struct is_integral<const wchar_t *> : public __is_integral_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_integral<const char8_t *> : public __is_integral_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_integral<const char16_t *> : public __is_integral_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_integral<const char32_t *> : public __is_integral_helper<__remove_cv_t<const char32_t *>>::type {
    };
template<> struct is_integral<unsigned long long> : public __is_integral_helper<__remove_cv_t<unsigned long long>>::type {
    };
    template <typename> struct __is_floating_point_helper : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const wchar_t *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char8_t *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char16_t *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char32_t *> : public std::false_type {
    };
    template<> struct __is_floating_point_helper<float> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<double> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<long double> : public std::true_type {
    };
    template <typename _Tp> struct is_floating_point : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_floating_point<double> : public __is_floating_point_helper<__remove_cv_t<double>>::type {
    };
template<> struct is_floating_point<const char *> : public __is_floating_point_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_floating_point<const wchar_t *> : public __is_floating_point_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_floating_point<const char8_t *> : public __is_floating_point_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_floating_point<const char16_t *> : public __is_floating_point_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_floating_point<const char32_t *> : public __is_floating_point_helper<__remove_cv_t<const char32_t *>>::type {
    };
    template <typename> struct is_array : public std::false_type {
    };
template<> struct is_array<char> : public std::false_type {
    };
template<> struct is_array<wchar_t> : public std::false_type {
    };
template<> struct is_array<char8_t> : public std::false_type {
    };
template<> struct is_array<char16_t> : public std::false_type {
    };
template<> struct is_array<char32_t> : public std::false_type {
    };
template<> struct is_array<const char *> : public std::false_type {
    };
template<> struct is_array<const char *const &> : public std::false_type {
    };
template<> struct is_array<const char &> : public std::false_type {
    };
template<> struct is_array<const volatile std::input_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<const volatile std::forward_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<bool> : public std::false_type {
    };
template<> struct is_array<const volatile std::bidirectional_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<const volatile std::random_access_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<const volatile std::contiguous_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<unsigned long> : public std::false_type {
    };
template<> struct is_array<const unsigned long &> : public std::false_type {
    };
template<> struct is_array<const wchar_t *> : public std::false_type {
    };
template<> struct is_array<const wchar_t *const &> : public std::false_type {
    };
template<> struct is_array<const wchar_t &> : public std::false_type {
    };
template<> struct is_array<const char8_t *> : public std::false_type {
    };
template<> struct is_array<const char8_t *const &> : public std::false_type {
    };
template<> struct is_array<const char8_t &> : public std::false_type {
    };
template<> struct is_array<const char16_t *> : public std::false_type {
    };
template<> struct is_array<const char16_t *const &> : public std::false_type {
    };
template<> struct is_array<const char16_t &> : public std::false_type {
    };
template<> struct is_array<const char32_t *> : public std::false_type {
    };
template<> struct is_array<const char32_t *const &> : public std::false_type {
    };
template<> struct is_array<const char32_t &> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<char, std::char_traits<char>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<char8_t, std::char_traits<char8_t>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public std::false_type {
    };
template<> struct is_array<std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public std::false_type {
    };
template<> struct is_array<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public std::false_type {
    };
template<> struct is_array<const std::_V2::error_category *const &> : public std::false_type {
    };
template<> struct is_array<const volatile void *> : public std::false_type {
    };
template<> struct is_array<std::allocator<char>> : public std::false_type {
    };
template<> struct is_array<std::input_iterator_tag> : public std::false_type {
    };
    template <typename _Tp, std::size_t _Size> struct is_array<_Tp [_Size]> : public std::true_type {
    };
    template <typename _Tp> struct is_array<_Tp []> : public std::true_type {
    };
    template <typename> struct __is_pointer_helper : public std::false_type {
    };
template<> struct __is_pointer_helper<const char *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const wchar_t *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const char8_t *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const char16_t *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const char32_t *> : public std::true_type {
    };
    template <typename _Tp> struct __is_pointer_helper<_Tp *> : public std::true_type {
    };
    template <typename _Tp> struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_pointer<const char *> : public __is_pointer_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_pointer<const wchar_t *> : public __is_pointer_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_pointer<const char8_t *> : public __is_pointer_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_pointer<const char16_t *> : public __is_pointer_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_pointer<const char32_t *> : public __is_pointer_helper<__remove_cv_t<const char32_t *>>::type {
    };
    template <typename> struct is_lvalue_reference : public std::false_type {
    };
template<> struct is_lvalue_reference<char> : public std::false_type {
    };
template<> struct is_lvalue_reference<wchar_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char8_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char16_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char32_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char *const &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char &> : public std::true_type {
    };
template<> struct is_lvalue_reference<unsigned long> : public std::false_type {
    };
template<> struct is_lvalue_reference<unsigned long &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const unsigned long &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const wchar_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const wchar_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const wchar_t *const &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const wchar_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const wchar_t &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char8_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char8_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char8_t *const &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char8_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char8_t &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char16_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char16_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char16_t *const &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char16_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char16_t &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char32_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char32_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char32_t *const &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char32_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char32_t &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const std::_V2::error_category *const &> : public std::true_type {
    };
template<> struct is_lvalue_reference<std::allocator<char>> : public std::false_type {
    };
    template <typename _Tp> struct is_lvalue_reference<_Tp &> : public std::true_type {
    };
    template <typename> struct is_rvalue_reference : public std::false_type {
    };
template<> struct is_rvalue_reference<char> : public std::false_type {
    };
template<> struct is_rvalue_reference<wchar_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char8_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char16_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char32_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char> : public std::false_type {
    };
template<> struct is_rvalue_reference<unsigned long> : public std::false_type {
    };
template<> struct is_rvalue_reference<const wchar_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const wchar_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char8_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char8_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char16_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char16_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char32_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char32_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<std::allocator<char>> : public std::false_type {
    };
    template <typename _Tp> struct is_rvalue_reference<_Tp &&> : public std::true_type {
    };
    template <typename> struct __is_member_object_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public __not_<is_function<_Tp>>::type {
    };
    template <typename _Tp> struct is_member_object_pointer : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct __is_member_function_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type {
    };
    template <typename _Tp> struct is_member_function_pointer : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {
    };
template<> struct is_enum<wchar_t> : public integral_constant<bool, __is_enum(wchar_t)> {
    };
template<> struct is_enum<unsigned int> : public integral_constant<bool, __is_enum(unsigned int)> {
    };
template<> struct is_enum<char8_t> : public integral_constant<bool, __is_enum(char8_t)> {
    };
template<> struct is_enum<unsigned char> : public integral_constant<bool, __is_enum(unsigned char)> {
    };
template<> struct is_enum<char16_t> : public integral_constant<bool, __is_enum(char16_t)> {
    };
template<> struct is_enum<unsigned short> : public integral_constant<bool, __is_enum(unsigned short)> {
    };
template<> struct is_enum<char32_t> : public integral_constant<bool, __is_enum(char32_t)> {
    };
template<> struct is_enum<const char *> : public integral_constant<bool, __is_enum(const char *)> {
    };
template<> struct is_enum<const char *const> : public integral_constant<bool, __is_enum(const char *const)> {
    };
template<> struct is_enum<unsigned long> : public integral_constant<bool, __is_enum(unsigned long)> {
    };
template<> struct is_enum<const wchar_t *> : public integral_constant<bool, __is_enum(const wchar_t *)> {
    };
template<> struct is_enum<const wchar_t *const> : public integral_constant<bool, __is_enum(const wchar_t *const)> {
    };
template<> struct is_enum<const char8_t *> : public integral_constant<bool, __is_enum(const char8_t *)> {
    };
template<> struct is_enum<const char8_t *const> : public integral_constant<bool, __is_enum(const char8_t *const)> {
    };
template<> struct is_enum<const char16_t *> : public integral_constant<bool, __is_enum(const char16_t *)> {
    };
template<> struct is_enum<const char16_t *const> : public integral_constant<bool, __is_enum(const char16_t *const)> {
    };
template<> struct is_enum<const char32_t *> : public integral_constant<bool, __is_enum(const char32_t *)> {
    };
template<> struct is_enum<const char32_t *const> : public integral_constant<bool, __is_enum(const char32_t *const)> {
    };
    template <typename _Tp> struct is_union : public integral_constant<bool, __is_union(_Tp)> {
    };
template<> struct is_union<const char *> : public integral_constant<bool, __is_union(const char *)> {
    };
template<> struct is_union<const char *const> : public integral_constant<bool, __is_union(const char *const)> {
    };
template<> struct is_union<unsigned long> : public integral_constant<bool, __is_union(unsigned long)> {
    };
template<> struct is_union<const wchar_t *> : public integral_constant<bool, __is_union(const wchar_t *)> {
    };
template<> struct is_union<const wchar_t *const> : public integral_constant<bool, __is_union(const wchar_t *const)> {
    };
template<> struct is_union<const char8_t *> : public integral_constant<bool, __is_union(const char8_t *)> {
    };
template<> struct is_union<const char8_t *const> : public integral_constant<bool, __is_union(const char8_t *const)> {
    };
template<> struct is_union<const char16_t *> : public integral_constant<bool, __is_union(const char16_t *)> {
    };
template<> struct is_union<const char16_t *const> : public integral_constant<bool, __is_union(const char16_t *const)> {
    };
template<> struct is_union<const char32_t *> : public integral_constant<bool, __is_union(const char32_t *)> {
    };
template<> struct is_union<const char32_t *const> : public integral_constant<bool, __is_union(const char32_t *const)> {
    };
    template <typename _Tp> struct is_class : public integral_constant<bool, __is_class(_Tp)> {
    };
template<> struct is_class<const char *> : public integral_constant<bool, __is_class(const char *)> {
    };
template<> struct is_class<const char *const> : public integral_constant<bool, __is_class(const char *const)> {
    };
template<> struct is_class<unsigned long> : public integral_constant<bool, __is_class(unsigned long)> {
    };
template<> struct is_class<const wchar_t *> : public integral_constant<bool, __is_class(const wchar_t *)> {
    };
template<> struct is_class<const wchar_t *const> : public integral_constant<bool, __is_class(const wchar_t *const)> {
    };
template<> struct is_class<const char8_t *> : public integral_constant<bool, __is_class(const char8_t *)> {
    };
template<> struct is_class<const char8_t *const> : public integral_constant<bool, __is_class(const char8_t *const)> {
    };
template<> struct is_class<const char16_t *> : public integral_constant<bool, __is_class(const char16_t *)> {
    };
template<> struct is_class<const char16_t *const> : public integral_constant<bool, __is_class(const char16_t *const)> {
    };
template<> struct is_class<const char32_t *> : public integral_constant<bool, __is_class(const char32_t *)> {
    };
template<> struct is_class<const char32_t *const> : public integral_constant<bool, __is_class(const char32_t *const)> {
    };
template<> struct is_class<std::basic_ostream<char> &> : public integral_constant<bool, __is_class(std::basic_ostream<char> &)> {
    };
    template <typename _Tp> struct is_function : public __bool_constant<!is_const<const _Tp>::value> {
    };
template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    };
template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    };
template<> struct is_function<char8_t> : public __bool_constant<!is_const<const char8_t>::value> {
    };
template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    };
template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    };
template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    };
template<> struct is_function<const char *const &> : public std::false_type {
    };
template<> struct is_function<const char> : public __bool_constant<!is_const<const const char>::value> {
    };
template<> struct is_function<const char &> : public std::false_type {
    };
template<> struct is_function<const volatile std::input_iterator_tag *> : public __bool_constant<!is_const<const volatile input_iterator_tag *const>::value> {
    };
template<> struct is_function<const volatile std::forward_iterator_tag *> : public __bool_constant<!is_const<const volatile forward_iterator_tag *const>::value> {
    };
template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    };
template<> struct is_function<const volatile std::bidirectional_iterator_tag *> : public __bool_constant<!is_const<const volatile bidirectional_iterator_tag *const>::value> {
    };
template<> struct is_function<const volatile std::random_access_iterator_tag *> : public __bool_constant<!is_const<const volatile random_access_iterator_tag *const>::value> {
    };
template<> struct is_function<const volatile std::contiguous_iterator_tag *> : public __bool_constant<!is_const<const volatile contiguous_iterator_tag *const>::value> {
    };
template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    };
template<> struct is_function<const unsigned long &> : public std::false_type {
    };
template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    };
template<> struct is_function<const wchar_t *const &> : public std::false_type {
    };
template<> struct is_function<const wchar_t> : public __bool_constant<!is_const<const const wchar_t>::value> {
    };
template<> struct is_function<const wchar_t &> : public std::false_type {
    };
template<> struct is_function<const char8_t *> : public __bool_constant<!is_const<const char8_t *const>::value> {
    };
template<> struct is_function<const char8_t *const &> : public std::false_type {
    };
template<> struct is_function<const char8_t> : public __bool_constant<!is_const<const const char8_t>::value> {
    };
template<> struct is_function<const char8_t &> : public std::false_type {
    };
template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    };
template<> struct is_function<const char16_t *const &> : public std::false_type {
    };
template<> struct is_function<const char16_t> : public __bool_constant<!is_const<const const char16_t>::value> {
    };
template<> struct is_function<const char16_t &> : public std::false_type {
    };
template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    };
template<> struct is_function<const char32_t *const &> : public std::false_type {
    };
template<> struct is_function<const char32_t> : public __bool_constant<!is_const<const const char32_t>::value> {
    };
template<> struct is_function<const char32_t &> : public std::false_type {
    };
template<> struct is_function<std::basic_string_view<char, std::char_traits<char>>> : public __bool_constant<!is_const<const basic_string_view<char, char_traits<char>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public __bool_constant<!is_const<const basic_string<char, char_traits<char>, allocator<char>> *const>::value> {
    };
template<> struct is_function<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __bool_constant<!is_const<const basic_string_view<wchar_t, char_traits<wchar_t>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *> : public __bool_constant<!is_const<const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *const>::value> {
    };
template<> struct is_function<std::basic_string_view<char8_t, std::char_traits<char8_t>>> : public __bool_constant<!is_const<const basic_string_view<char8_t, char_traits<char8_t>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *> : public __bool_constant<!is_const<const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *const>::value> {
    };
template<> struct is_function<std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public __bool_constant<!is_const<const basic_string_view<char16_t, char_traits<char16_t>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public __bool_constant<!is_const<const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *const>::value> {
    };
template<> struct is_function<std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public __bool_constant<!is_const<const basic_string_view<char32_t, char_traits<char32_t>>>::value> {
    };
template<> struct is_function<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public __bool_constant<!is_const<const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *const>::value> {
    };
template<> struct is_function<const std::_V2::error_category *const &> : public std::false_type {
    };
template<> struct is_function<const volatile void *> : public __bool_constant<!is_const<const volatile void *const>::value> {
    };
template<> struct is_function<std::allocator<char>> : public __bool_constant<!is_const<const allocator<char>>::value> {
    };
template<> struct is_function<std::input_iterator_tag> : public __bool_constant<!is_const<const input_iterator_tag>::value> {
    };
    template <typename _Tp> struct is_function<_Tp &> : public std::false_type {
    };
    template <typename _Tp> struct is_function<_Tp &&> : public std::false_type {
    };
    template <typename> struct __is_null_pointer_helper : public std::false_type {
    };
    template<> struct __is_null_pointer_helper<std::nullptr_t> : public std::true_type {
    };
    template <typename _Tp> struct is_null_pointer : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct __attribute__((deprecated("use 'std::is_null_pointer' instead"))) __is_nullptr_t : public is_null_pointer<_Tp> {
    };
    template <typename _Tp> struct is_reference : public __or_<is_lvalue_reference<_Tp>, is_rvalue_reference<_Tp>>::type {
    };
template<> struct is_reference<char> : public __or_<is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    };
template<> struct is_reference<wchar_t> : public __or_<is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    };
template<> struct is_reference<char8_t> : public __or_<is_lvalue_reference<char8_t>, is_rvalue_reference<char8_t>>::type {
    };
template<> struct is_reference<char16_t> : public __or_<is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    };
template<> struct is_reference<char32_t> : public __or_<is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    };
template<> struct is_reference<const char *> : public __or_<is_lvalue_reference<const char *>, is_rvalue_reference<const char *>>::type {
    };
template<> struct is_reference<const char *const &> : public __or_<is_lvalue_reference<const char *const &>, is_rvalue_reference<const char *const &>>::type {
    };
template<> struct is_reference<const char> : public __or_<is_lvalue_reference<const char>, is_rvalue_reference<const char>>::type {
    };
template<> struct is_reference<const char &> : public __or_<is_lvalue_reference<const char &>, is_rvalue_reference<const char &>>::type {
    };
template<> struct is_reference<unsigned long> : public __or_<is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    };
template<> struct is_reference<const unsigned long &> : public __or_<is_lvalue_reference<const unsigned long &>, is_rvalue_reference<const unsigned long &>>::type {
    };
template<> struct is_reference<const wchar_t *> : public __or_<is_lvalue_reference<const wchar_t *>, is_rvalue_reference<const wchar_t *>>::type {
    };
template<> struct is_reference<const wchar_t *const &> : public __or_<is_lvalue_reference<const wchar_t *const &>, is_rvalue_reference<const wchar_t *const &>>::type {
    };
template<> struct is_reference<const wchar_t> : public __or_<is_lvalue_reference<const wchar_t>, is_rvalue_reference<const wchar_t>>::type {
    };
template<> struct is_reference<const wchar_t &> : public __or_<is_lvalue_reference<const wchar_t &>, is_rvalue_reference<const wchar_t &>>::type {
    };
template<> struct is_reference<const char8_t *> : public __or_<is_lvalue_reference<const char8_t *>, is_rvalue_reference<const char8_t *>>::type {
    };
template<> struct is_reference<const char8_t *const &> : public __or_<is_lvalue_reference<const char8_t *const &>, is_rvalue_reference<const char8_t *const &>>::type {
    };
template<> struct is_reference<const char8_t> : public __or_<is_lvalue_reference<const char8_t>, is_rvalue_reference<const char8_t>>::type {
    };
template<> struct is_reference<const char8_t &> : public __or_<is_lvalue_reference<const char8_t &>, is_rvalue_reference<const char8_t &>>::type {
    };
template<> struct is_reference<const char16_t *> : public __or_<is_lvalue_reference<const char16_t *>, is_rvalue_reference<const char16_t *>>::type {
    };
template<> struct is_reference<const char16_t *const &> : public __or_<is_lvalue_reference<const char16_t *const &>, is_rvalue_reference<const char16_t *const &>>::type {
    };
template<> struct is_reference<const char16_t> : public __or_<is_lvalue_reference<const char16_t>, is_rvalue_reference<const char16_t>>::type {
    };
template<> struct is_reference<const char16_t &> : public __or_<is_lvalue_reference<const char16_t &>, is_rvalue_reference<const char16_t &>>::type {
    };
template<> struct is_reference<const char32_t *> : public __or_<is_lvalue_reference<const char32_t *>, is_rvalue_reference<const char32_t *>>::type {
    };
template<> struct is_reference<const char32_t *const &> : public __or_<is_lvalue_reference<const char32_t *const &>, is_rvalue_reference<const char32_t *const &>>::type {
    };
template<> struct is_reference<const char32_t> : public __or_<is_lvalue_reference<const char32_t>, is_rvalue_reference<const char32_t>>::type {
    };
template<> struct is_reference<const char32_t &> : public __or_<is_lvalue_reference<const char32_t &>, is_rvalue_reference<const char32_t &>>::type {
    };
template<> struct is_reference<const std::_V2::error_category *const &> : public __or_<is_lvalue_reference<const error_category *const &>, is_rvalue_reference<const error_category *const &>>::type {
    };
template<> struct is_reference<std::allocator<char>> : public __or_<is_lvalue_reference<allocator<char>>, is_rvalue_reference<allocator<char>>>::type {
    };
    template <typename _Tp> struct is_arithmetic : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {
    };
template<> struct is_arithmetic<const char *> : public __or_<is_integral<const char *>, is_floating_point<const char *>>::type {
    };
template<> struct is_arithmetic<long> : public __or_<is_integral<long>, is_floating_point<long>>::type {
    };
template<> struct is_arithmetic<unsigned long> : public __or_<is_integral<unsigned long>, is_floating_point<unsigned long>>::type {
    };
template<> struct is_arithmetic<const wchar_t *> : public __or_<is_integral<const wchar_t *>, is_floating_point<const wchar_t *>>::type {
    };
template<> struct is_arithmetic<const char8_t *> : public __or_<is_integral<const char8_t *>, is_floating_point<const char8_t *>>::type {
    };
template<> struct is_arithmetic<const char16_t *> : public __or_<is_integral<const char16_t *>, is_floating_point<const char16_t *>>::type {
    };
template<> struct is_arithmetic<const char32_t *> : public __or_<is_integral<const char32_t *>, is_floating_point<const char32_t *>>::type {
    };
template<> struct is_arithmetic<unsigned int> : public __or_<is_integral<unsigned int>, is_floating_point<unsigned int>>::type {
    };
template<> struct is_arithmetic<unsigned long long> : public __or_<is_integral<unsigned long long>, is_floating_point<unsigned long long>>::type {
    };
    template <typename _Tp> struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template <typename _Tp> struct is_object : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {
    };
template<> struct is_object<const char *> : public __not_<__or_<is_function<const char *>, is_reference<const char *>, is_void<const char *>>>::type {
    };
template<> struct is_object<const char> : public __not_<__or_<is_function<const char>, is_reference<const char>, is_void<const char>>>::type {
    };
template<> struct is_object<unsigned long> : public __not_<__or_<is_function<unsigned long>, is_reference<unsigned long>, is_void<unsigned long>>>::type {
    };
template<> struct is_object<const wchar_t *> : public __not_<__or_<is_function<const wchar_t *>, is_reference<const wchar_t *>, is_void<const wchar_t *>>>::type {
    };
template<> struct is_object<const wchar_t> : public __not_<__or_<is_function<const wchar_t>, is_reference<const wchar_t>, is_void<const wchar_t>>>::type {
    };
template<> struct is_object<const char8_t *> : public __not_<__or_<is_function<const char8_t *>, is_reference<const char8_t *>, is_void<const char8_t *>>>::type {
    };
template<> struct is_object<const char8_t> : public __not_<__or_<is_function<const char8_t>, is_reference<const char8_t>, is_void<const char8_t>>>::type {
    };
template<> struct is_object<const char16_t *> : public __not_<__or_<is_function<const char16_t *>, is_reference<const char16_t *>, is_void<const char16_t *>>>::type {
    };
template<> struct is_object<const char16_t> : public __not_<__or_<is_function<const char16_t>, is_reference<const char16_t>, is_void<const char16_t>>>::type {
    };
template<> struct is_object<const char32_t *> : public __not_<__or_<is_function<const char32_t *>, is_reference<const char32_t *>, is_void<const char32_t *>>>::type {
    };
template<> struct is_object<const char32_t> : public __not_<__or_<is_function<const char32_t>, is_reference<const char32_t>, is_void<const char32_t>>>::type {
    };
template<> struct is_object<char> : public __not_<__or_<is_function<char>, is_reference<char>, is_void<char>>>::type {
    };
template<> struct is_object<wchar_t> : public __not_<__or_<is_function<wchar_t>, is_reference<wchar_t>, is_void<wchar_t>>>::type {
    };
    template <typename> struct is_member_pointer;
    template <typename _Tp> struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>, is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {
    };
template<> struct is_scalar<const char *> : public __or_<is_arithmetic<const char *>, is_enum<const char *>, is_pointer<const char *>, is_member_pointer<const char *>, is_null_pointer<const char *>>::type {
    };
template<> struct is_scalar<unsigned long> : public __or_<is_arithmetic<unsigned long>, is_enum<unsigned long>, is_pointer<unsigned long>, is_member_pointer<unsigned long>, is_null_pointer<unsigned long>>::type {
    };
template<> struct is_scalar<const wchar_t *> : public __or_<is_arithmetic<const wchar_t *>, is_enum<const wchar_t *>, is_pointer<const wchar_t *>, is_member_pointer<const wchar_t *>, is_null_pointer<const wchar_t *>>::type {
    };
template<> struct is_scalar<const char8_t *> : public __or_<is_arithmetic<const char8_t *>, is_enum<const char8_t *>, is_pointer<const char8_t *>, is_member_pointer<const char8_t *>, is_null_pointer<const char8_t *>>::type {
    };
template<> struct is_scalar<const char16_t *> : public __or_<is_arithmetic<const char16_t *>, is_enum<const char16_t *>, is_pointer<const char16_t *>, is_member_pointer<const char16_t *>, is_null_pointer<const char16_t *>>::type {
    };
template<> struct is_scalar<const char32_t *> : public __or_<is_arithmetic<const char32_t *>, is_enum<const char32_t *>, is_pointer<const char32_t *>, is_member_pointer<const char32_t *>, is_null_pointer<const char32_t *>>::type {
    };
    template <typename _Tp> struct is_compound : public __not_<is_fundamental<_Tp>>::type {
    };
    template <typename _Tp> struct __is_member_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public std::true_type {
    };
    template <typename _Tp> struct is_member_pointer : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename, typename> struct is_same
template<> struct is_same<list_start, list_start> : public integral_constant<bool, __is_same(list_start, list_start)> {
    }
template<> struct is_same<list_start, list_end> : public integral_constant<bool, __is_same(list_start, list_end)> {
    }
template<> struct is_same<plus, list_end> : public integral_constant<bool, __is_same(plus, list_end)> {
    }
template<> struct is_same<whitespace, list_end> : public integral_constant<bool, __is_same(whitespace, list_end)> {
    }
template<> struct is_same<integer<3>, list_end> : public integral_constant<bool, __is_same(integer<3>, list_end)> {
    }
template<> struct is_same<integer<2>, list_end> : public integral_constant<bool, __is_same(integer<2>, list_end)> {
    }
template<> struct is_same<list_end, list_end> : public integral_constant<bool, __is_same(list_end, list_end)> {
    }
template<> struct is_same<plus, list_start> : public integral_constant<bool, __is_same(plus, list_start)> {
    }
template<> struct is_same<plus, whitespace> : public integral_constant<bool, __is_same(plus, whitespace)> {
    }
template<> struct is_same<whitespace, list_start> : public integral_constant<bool, __is_same(whitespace, list_start)> {
    }
template<> struct is_same<whitespace, whitespace> : public integral_constant<bool, __is_same(whitespace, whitespace)> {
    }
template<> struct is_same<integer<3>, list_start> : public integral_constant<bool, __is_same(integer<3>, list_start)> {
    }
template<> struct is_same<integer<2>, list_start> : public integral_constant<bool, __is_same(integer<2>, list_start)> {
    }
template<> struct is_same<list_end, list_start> : public integral_constant<bool, __is_same(list_end, list_start)> {
    }
template<> struct is_same<plus, plus> : public integral_constant<bool, __is_same(plus, plus)> {
    }
template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    }
template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    }
template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    }
template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    }
template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    }
template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    }
template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    }
template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Tp, typename ..._Types> using __is_one_of = __or_<is_same<_Tp, _Types>...>;
    template <typename _Tp> using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>, signed char, short, int, long, long long>;
    template <typename _Tp> using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
    template <typename _Tp> using __is_standard_integer = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;
    template <typename ...> using __void_t = void;
    template <typename _Tp, typename = void> struct __is_referenceable : public std::false_type {
    };
template<> struct __is_referenceable<const char *, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char &, void> : public std::true_type {
    };
template<> struct __is_referenceable<unsigned long, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t &, void> : public std::true_type {
    };
    template <typename _Tp> struct __is_referenceable<_Tp, __void_t<_Tp &>> : public std::true_type {
    };
    template <typename> struct is_const : public std::false_type {
    };
template<> struct is_const<wchar_t> : public std::false_type {
    };
template<> struct is_const<char8_t> : public std::false_type {
    };
template<> struct is_const<char16_t> : public std::false_type {
    };
template<> struct is_const<char32_t> : public std::false_type {
    };
template<> struct is_const<unsigned int> : public std::false_type {
    };
template<> struct is_const<unsigned char> : public std::false_type {
    };
template<> struct is_const<unsigned short> : public std::false_type {
    };
template<> struct is_const<const char> : public std::true_type {
    };
template<> struct is_const<const wchar_t> : public std::true_type {
    };
template<> struct is_const<const char8_t> : public std::true_type {
    };
template<> struct is_const<const char16_t> : public std::true_type {
    };
template<> struct is_const<const char32_t> : public std::true_type {
    };
template<> struct is_const<const char *const> : public std::true_type {
    };
template<> struct is_const<char> : public std::false_type {
    };
template<> struct is_const<const volatile std::input_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const volatile std::forward_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const bool> : public std::true_type {
    };
template<> struct is_const<const volatile std::bidirectional_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const volatile std::random_access_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const volatile std::contiguous_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const unsigned long> : public std::true_type {
    };
template<> struct is_const<const wchar_t *const> : public std::true_type {
    };
template<> struct is_const<const char8_t *const> : public std::true_type {
    };
template<> struct is_const<const char16_t *const> : public std::true_type {
    };
template<> struct is_const<const char32_t *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<char, std::char_traits<char>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<char8_t, std::char_traits<char8_t>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *const> : public std::true_type {
    };
template<> struct is_const<const std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public std::true_type {
    };
template<> struct is_const<const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *const> : public std::true_type {
    };
template<> struct is_const<const std::_V2::error_category *const> : public std::true_type {
    };
template<> struct is_const<const volatile void *const> : public std::true_type {
    };
template<> struct is_const<const std::allocator<char>> : public std::true_type {
    };
template<> struct is_const<const std::input_iterator_tag> : public std::true_type {
    };
    template <typename _Tp> struct is_const<const _Tp> : public std::true_type {
    };
    template <typename> struct is_volatile : public std::false_type {
    };
template<> struct is_volatile<wchar_t> : public std::false_type {
    };
template<> struct is_volatile<char8_t> : public std::false_type {
    };
template<> struct is_volatile<char16_t> : public std::false_type {
    };
template<> struct is_volatile<char32_t> : public std::false_type {
    };
template<> struct is_volatile<unsigned int> : public std::false_type {
    };
template<> struct is_volatile<unsigned char> : public std::false_type {
    };
template<> struct is_volatile<unsigned short> : public std::false_type {
    };
template<> struct is_volatile<const char *const> : public std::false_type {
    };
template<> struct is_volatile<const char> : public std::false_type {
    };
template<> struct is_volatile<char> : public std::false_type {
    };
template<> struct is_volatile<const unsigned long> : public std::false_type {
    };
template<> struct is_volatile<const wchar_t *const> : public std::false_type {
    };
template<> struct is_volatile<const wchar_t> : public std::false_type {
    };
template<> struct is_volatile<const char8_t *const> : public std::false_type {
    };
template<> struct is_volatile<const char8_t> : public std::false_type {
    };
template<> struct is_volatile<const char16_t *const> : public std::false_type {
    };
template<> struct is_volatile<const char16_t> : public std::false_type {
    };
template<> struct is_volatile<const char32_t *const> : public std::false_type {
    };
template<> struct is_volatile<const char32_t> : public std::false_type {
    };
template<> struct is_volatile<const std::_V2::error_category *const> : public std::false_type {
    };
    template <typename _Tp> struct is_volatile<volatile _Tp> : public std::true_type {
    };
    template <typename _Tp> struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char> : public integral_constant<bool, __is_trivial(char)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<wchar_t> : public integral_constant<bool, __is_trivial(wchar_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char8_t> : public integral_constant<bool, __is_trivial(char8_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char8_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char16_t> : public integral_constant<bool, __is_trivial(char16_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char32_t> : public integral_constant<bool, __is_trivial(char32_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char> : public integral_constant<bool, __is_standard_layout(char)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<wchar_t> : public integral_constant<bool, __is_standard_layout(wchar_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char8_t> : public integral_constant<bool, __is_standard_layout(char8_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char8_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char16_t> : public integral_constant<bool, __is_standard_layout(char16_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char32_t> : public integral_constant<bool, __is_standard_layout(char32_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct [[deprecated("use is_standard_layout && is_trivial instead")]] is_pod : public integral_constant<bool, __is_pod(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct [[deprecated("")]] is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {
    };
    template <typename _Tp> struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
    };
    template <typename _Tp> struct is_final : public integral_constant<bool, __is_final(_Tp)> {
    };
    template <typename _Tp> struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {
    };
    template <typename _Tp, bool = is_arithmetic<_Tp>::value> struct __is_signed_helper : public std::false_type {
    };
template<> struct __is_signed_helper<long, true> : public integral_constant<bool, long(-1) < long(0)> {
    };
template<> struct __is_signed_helper<unsigned int, true> : public integral_constant<bool, unsigned int(-1) < unsigned int(0)> {
    };
template<> struct __is_signed_helper<unsigned long, true> : public integral_constant<bool, unsigned long(-1) < unsigned long(0)> {
    };
template<> struct __is_signed_helper<unsigned long long, true> : public integral_constant<bool, unsigned long long(-1) < unsigned long long(0)> {
    };
    template <typename _Tp> struct __is_signed_helper<_Tp, true> : public integral_constant<bool, _Tp(-1) < _Tp(0)> {
    };
    template <typename _Tp> struct is_signed : public __is_signed_helper<_Tp>::type {
    };
template<> struct is_signed<long> : public __is_signed_helper<long>::type {
    };
template<> struct is_signed<unsigned int> : public __is_signed_helper<unsigned int>::type {
    };
template<> struct is_signed<unsigned long> : public __is_signed_helper<unsigned long>::type {
    };
template<> struct is_signed<unsigned long long> : public __is_signed_helper<unsigned long long>::type {
    };
    template <typename _Tp> struct is_unsigned : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>> {
    };
template<> struct is_unsigned<unsigned int> : public __and_<is_arithmetic<unsigned int>, __not_<is_signed<unsigned int>>> {
    };
template<> struct is_unsigned<unsigned long> : public __and_<is_arithmetic<unsigned long>, __not_<is_signed<unsigned long>>> {
    };
template<> struct is_unsigned<unsigned long long> : public __and_<is_arithmetic<unsigned long long>, __not_<is_signed<unsigned long long>>> {
    };
    template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);
    template<> const std::ranges::__cust_swap::_Swap &__declval<const std::ranges::__cust_swap::_Swap &, const std::ranges::__cust_swap::_Swap &>(int);
    template<> const char &__declval<const char &, const char &>(int);
    template<> char &__declval<char &, char &>(int);
    template<> const wchar_t &__declval<const wchar_t &, const wchar_t &>(int);
    template<> wchar_t &__declval<wchar_t &, wchar_t &>(int);
    template<> const char8_t &__declval<const char8_t &, const char8_t &>(int);
    template<> char8_t &__declval<char8_t &, char8_t &>(int);
    template<> const char16_t &__declval<const char16_t &, const char16_t &>(int);
    template<> const char32_t &__declval<const char32_t &, const char32_t &>(int);
    template<> const char *&&__declval<const char *, const char *&&>(int);
    template<> const char *const &(&__declval<const char *const &(&)(), const char *const &(&)()>(int))();
    template<> const char *const &__declval<const char *const &, const char *const &>(int);
    template<> const char *&__declval<const char *&, const char *&>(int);
    template<> const char &(&__declval<const char &(&)(), const char &(&)()>(int))();
    template<> const char &&__declval<const char &&, const char &&>(int);
    template<> const volatile std::contiguous_iterator_tag *&&__declval<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *&&>(int);
    template<> const char *const &&__declval<const char *const, const char *const &&>(int);
    template<> bool &&__declval<bool, bool &&>(int);
    template<> unsigned long &&__declval<unsigned long, unsigned long &&>(int);
    template<> unsigned long &__declval<unsigned long &, unsigned long &>(int);
    template<> const unsigned long &__declval<const unsigned long &, const unsigned long &>(int);
    template<> const unsigned long &&__declval<const unsigned long, const unsigned long &&>(int);
    template<> const unsigned long &(&__declval<const unsigned long &(&)(), const unsigned long &(&)()>(int))();
    template<> const wchar_t *&&__declval<const wchar_t *, const wchar_t *&&>(int);
    template<> const wchar_t *const &(&__declval<const wchar_t *const &(&)(), const wchar_t *const &(&)()>(int))();
    template<> const wchar_t *const &__declval<const wchar_t *const &, const wchar_t *const &>(int);
    template<> const wchar_t *&__declval<const wchar_t *&, const wchar_t *&>(int);
    template<> const wchar_t &(&__declval<const wchar_t &(&)(), const wchar_t &(&)()>(int))();
    template<> const wchar_t &&__declval<const wchar_t &&, const wchar_t &&>(int);
    template<> const wchar_t *const &&__declval<const wchar_t *const, const wchar_t *const &&>(int);
    template<> const char8_t *&&__declval<const char8_t *, const char8_t *&&>(int);
    template<> const char8_t *const &(&__declval<const char8_t *const &(&)(), const char8_t *const &(&)()>(int))();
    template<> const char8_t *const &__declval<const char8_t *const &, const char8_t *const &>(int);
    template<> const char8_t *&__declval<const char8_t *&, const char8_t *&>(int);
    template<> const char8_t &(&__declval<const char8_t &(&)(), const char8_t &(&)()>(int))();
    template<> const char8_t &&__declval<const char8_t &&, const char8_t &&>(int);
    template<> const char8_t *const &&__declval<const char8_t *const, const char8_t *const &&>(int);
    template<> const char16_t *&&__declval<const char16_t *, const char16_t *&&>(int);
    template<> const char16_t *const &(&__declval<const char16_t *const &(&)(), const char16_t *const &(&)()>(int))();
    template<> const char16_t *const &__declval<const char16_t *const &, const char16_t *const &>(int);
    template<> const char16_t *&__declval<const char16_t *&, const char16_t *&>(int);
    template<> const char16_t &(&__declval<const char16_t &(&)(), const char16_t &(&)()>(int))();
    template<> char16_t &__declval<char16_t &, char16_t &>(int);
    template<> const char16_t &&__declval<const char16_t &&, const char16_t &&>(int);
    template<> const char16_t *const &&__declval<const char16_t *const, const char16_t *const &&>(int);
    template<> const char32_t *&&__declval<const char32_t *, const char32_t *&&>(int);
    template<> const char32_t *const &(&__declval<const char32_t *const &(&)(), const char32_t *const &(&)()>(int))();
    template<> const char32_t *const &__declval<const char32_t *const &, const char32_t *const &>(int);
    template<> const char32_t *&__declval<const char32_t *&, const char32_t *&>(int);
    template<> const char32_t &(&__declval<const char32_t &(&)(), const char32_t &(&)()>(int))();
    template<> char32_t &__declval<char32_t &, char32_t &>(int);
    template<> const char32_t &&__declval<const char32_t &&, const char32_t &&>(int);
    template<> const char32_t *const &&__declval<const char32_t *const, const char32_t *const &&>(int);
    template<> std::allocator<char> &__declval<std::allocator<char> &, std::allocator<char> &>(int);
    template<> const unsigned int &__declval<const unsigned int &, const unsigned int &>(int);
    template<> std::allocator<wchar_t> &__declval<std::allocator<wchar_t> &, std::allocator<wchar_t> &>(int);
    template<> std::allocator<char8_t> &__declval<std::allocator<char8_t> &, std::allocator<char8_t> &>(int);
    template<> std::allocator<char16_t> &__declval<std::allocator<char16_t> &, std::allocator<char16_t> &>(int);
    template<> std::allocator<char32_t> &__declval<std::allocator<char32_t> &, std::allocator<char32_t> &>(int);
    template<> const char *const *&&__declval<const char *const *, const char *const *&&>(int);
    template<> const wchar_t *const *&&__declval<const wchar_t *const *, const wchar_t *const *&&>(int);
    template<> const char8_t *const *&&__declval<const char8_t *const *, const char8_t *const *&&>(int);
    template<> const char16_t *const *&&__declval<const char16_t *const *, const char16_t *const *&&>(int);
    template<> const char32_t *const *&&__declval<const char32_t *const *, const char32_t *const *&&>(int);
    template<> const std::_V2::error_category *const &(&__declval<const std::_V2::error_category *const &(&)(), const std::_V2::error_category *const &(&)()>(int))();
    template<> const std::_V2::error_category *const &__declval<const std::_V2::error_category *const &, const std::_V2::error_category *const &>(int);
    template<> const std::_V2::error_category *&&__declval<const std::_V2::error_category *, const std::_V2::error_category *&&>(int);
    template<> const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &>(int);
    template<> const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *&&__declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *&&>(int);
    template<> char *const &__declval<char *const &, char *const &>(int);
    template<> char *const *&&__declval<char *const *, char *const *&&>(int);
    template<> const int &__declval<const int &, const int &>(int);
    template<> std::random_access_iterator_tag &&__declval<std::random_access_iterator_tag, std::random_access_iterator_tag &&>(int);
    template<> wchar_t *const &__declval<wchar_t *const &, wchar_t *const &>(int);
    template<> wchar_t *const *&&__declval<wchar_t *const *, wchar_t *const *&&>(int);
    template <typename _Tp> _Tp __declval(long);
    template<> const std::ranges::__cust_swap::_Swap &__declval<const std::ranges::__cust_swap::_Swap &>(long);
    template<> const char &__declval<const char &>(long);
    template<> char &__declval<char &>(long);
    template<> const wchar_t &__declval<const wchar_t &>(long);
    template<> wchar_t &__declval<wchar_t &>(long);
    template<> const char8_t &__declval<const char8_t &>(long);
    template<> char8_t &__declval<char8_t &>(long);
    template<> const char16_t &__declval<const char16_t &>(long);
    template<> const char32_t &__declval<const char32_t &>(long);
    template<> const char *__declval<const char *>(long);
    template<> const char *const &(&__declval<const char *const &(&)()>(long))();
    template<> const char *const &__declval<const char *const &>(long);
    template<> const char *&__declval<const char *&>(long);
    template<> const char &(&__declval<const char &(&)()>(long))();
    template<> const char &&__declval<const char &&>(long);
    template<> const volatile std::contiguous_iterator_tag *__declval<const volatile std::contiguous_iterator_tag *>(long);
    template<> const char *const __declval<const char *const>(long);
    template<> bool __declval<bool>(long);
    template<> unsigned long __declval<unsigned long>(long);
    template<> unsigned long &__declval<unsigned long &>(long);
    template<> const unsigned long &__declval<const unsigned long &>(long);
    template<> const unsigned long __declval<const unsigned long>(long);
    template<> const unsigned long &(&__declval<const unsigned long &(&)()>(long))();
    template<> const wchar_t *__declval<const wchar_t *>(long);
    template<> const wchar_t *const &(&__declval<const wchar_t *const &(&)()>(long))();
    template<> const wchar_t *const &__declval<const wchar_t *const &>(long);
    template<> const wchar_t *&__declval<const wchar_t *&>(long);
    template<> const wchar_t &(&__declval<const wchar_t &(&)()>(long))();
    template<> const wchar_t &&__declval<const wchar_t &&>(long);
    template<> const wchar_t *const __declval<const wchar_t *const>(long);
    template<> const char8_t *__declval<const char8_t *>(long);
    template<> const char8_t *const &(&__declval<const char8_t *const &(&)()>(long))();
    template<> const char8_t *const &__declval<const char8_t *const &>(long);
    template<> const char8_t *&__declval<const char8_t *&>(long);
    template<> const char8_t &(&__declval<const char8_t &(&)()>(long))();
    template<> const char8_t &&__declval<const char8_t &&>(long);
    template<> const char8_t *const __declval<const char8_t *const>(long);
    template<> const char16_t *__declval<const char16_t *>(long);
    template<> const char16_t *const &(&__declval<const char16_t *const &(&)()>(long))();
    template<> const char16_t *const &__declval<const char16_t *const &>(long);
    template<> const char16_t *&__declval<const char16_t *&>(long);
    template<> const char16_t &(&__declval<const char16_t &(&)()>(long))();
    template<> char16_t &__declval<char16_t &>(long);
    template<> const char16_t &&__declval<const char16_t &&>(long);
    template<> const char16_t *const __declval<const char16_t *const>(long);
    template<> const char32_t *__declval<const char32_t *>(long);
    template<> const char32_t *const &(&__declval<const char32_t *const &(&)()>(long))();
    template<> const char32_t *const &__declval<const char32_t *const &>(long);
    template<> const char32_t *&__declval<const char32_t *&>(long);
    template<> const char32_t &(&__declval<const char32_t &(&)()>(long))();
    template<> char32_t &__declval<char32_t &>(long);
    template<> const char32_t &&__declval<const char32_t &&>(long);
    template<> const char32_t *const __declval<const char32_t *const>(long);
    template<> std::allocator<char> &__declval<std::allocator<char> &>(long);
    template<> const unsigned int &__declval<const unsigned int &>(long);
    template<> std::allocator<wchar_t> &__declval<std::allocator<wchar_t> &>(long);
    template<> std::allocator<char8_t> &__declval<std::allocator<char8_t> &>(long);
    template<> std::allocator<char16_t> &__declval<std::allocator<char16_t> &>(long);
    template<> std::allocator<char32_t> &__declval<std::allocator<char32_t> &>(long);
    template<> const char *const *__declval<const char *const *>(long);
    template<> const wchar_t *const *__declval<const wchar_t *const *>(long);
    template<> const char8_t *const *__declval<const char8_t *const *>(long);
    template<> const char16_t *const *__declval<const char16_t *const *>(long);
    template<> const char32_t *const *__declval<const char32_t *const *>(long);
    template<> const std::_V2::error_category *const &(&__declval<const std::_V2::error_category *const &(&)()>(long))();
    template<> const std::_V2::error_category *const &__declval<const std::_V2::error_category *const &>(long);
    template<> const std::_V2::error_category *__declval<const std::_V2::error_category *>(long);
    template<> const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &>(long);
    template<> const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *__declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(long);
    template<> char *const &__declval<char *const &>(long);
    template<> char *const *__declval<char *const *>(long);
    template<> const int &__declval<const int &>(long);
    template<> std::random_access_iterator_tag __declval<std::random_access_iterator_tag>(long);
    template<> wchar_t *const &__declval<wchar_t *const &>(long);
    template<> wchar_t *const *__declval<wchar_t *const *>(long);
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0));
    template <typename, unsigned int = 0> struct extent;
    template <typename> struct remove_all_extents;
    template <typename _Tp> struct __is_array_known_bounds : public integral_constant<bool, (extent<_Tp>::value > 0)> {
    };
    template <typename _Tp> struct __is_array_unknown_bounds : public __and_<is_array<_Tp>, __not_<extent<_Tp>>> {
    };
template<> struct __is_array_unknown_bounds<char> : public __and_<is_array<char>, __not_<extent<char>>> {
    };
template<> struct __is_array_unknown_bounds<wchar_t> : public __and_<is_array<wchar_t>, __not_<extent<wchar_t>>> {
    };
template<> struct __is_array_unknown_bounds<char8_t> : public __and_<is_array<char8_t>, __not_<extent<char8_t>>> {
    };
template<> struct __is_array_unknown_bounds<char16_t> : public __and_<is_array<char16_t>, __not_<extent<char16_t>>> {
    };
template<> struct __is_array_unknown_bounds<char32_t> : public __and_<is_array<char32_t>, __not_<extent<char32_t>>> {
    };
template<> struct __is_array_unknown_bounds<const char *> : public __and_<is_array<const char *>, __not_<extent<const char *>>> {
    };
template<> struct __is_array_unknown_bounds<unsigned long> : public __and_<is_array<unsigned long>, __not_<extent<unsigned long>>> {
    };
template<> struct __is_array_unknown_bounds<const wchar_t *> : public __and_<is_array<const wchar_t *>, __not_<extent<const wchar_t *>>> {
    };
template<> struct __is_array_unknown_bounds<const char8_t *> : public __and_<is_array<const char8_t *>, __not_<extent<const char8_t *>>> {
    };
template<> struct __is_array_unknown_bounds<const char16_t *> : public __and_<is_array<const char16_t *>, __not_<extent<const char16_t *>>> {
    };
template<> struct __is_array_unknown_bounds<const char32_t *> : public __and_<is_array<const char32_t *>, __not_<extent<const char32_t *>>> {
    };
template<> struct __is_array_unknown_bounds<std::allocator<char>> : public __and_<is_array<std::allocator<char>>, __not_<extent<std::allocator<char>>>> {
    };
    struct __do_is_destructible_impl {
        template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())> static std::true_type __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_destructible_impl : public std::__do_is_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_destructible_safe;
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, false> : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_destructible : public __is_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_nt_destructible_impl {
        template <typename _Tp> static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_nt_destructible_impl : public std::__do_is_nt_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_nt_destructible_safe
template<> struct __is_nt_destructible_safe<const char *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<unsigned long, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const wchar_t *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const char8_t *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const char16_t *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const char32_t *, false, true> : public std::true_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, false> : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char *> : public __is_nt_destructible_safe<const char *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<unsigned long> : public __is_nt_destructible_safe<unsigned long>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const wchar_t *> : public __is_nt_destructible_safe<const wchar_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char8_t *> : public __is_nt_destructible_safe<const char8_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char16_t *> : public __is_nt_destructible_safe<const char16_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char32_t *> : public __is_nt_destructible_safe<const char32_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct __is_constructible_impl : public __bool_constant<__is_constructible(_Tp, _Args...)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *>> : public __bool_constant<__is_constructible(const char *, const char *)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *&>> : public __bool_constant<__is_constructible(const char *, const char *&)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *const &>> : public __bool_constant<__is_constructible(const char *, const char *const &)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *const>> : public __bool_constant<__is_constructible(const char *, const char *const)> {
    };
template<> struct __is_constructible_impl<const char *, <>> : public __bool_constant<__is_constructible(const char *)> {
    };
template<> struct __is_constructible_impl<unsigned long, <unsigned long>> : public __bool_constant<__is_constructible(unsigned long, unsigned long)> {
    };
template<> struct __is_constructible_impl<unsigned long, <unsigned long &>> : public __bool_constant<__is_constructible(unsigned long, unsigned long &)> {
    };
template<> struct __is_constructible_impl<unsigned long, <const unsigned long &>> : public __bool_constant<__is_constructible(unsigned long, const unsigned long &)> {
    };
template<> struct __is_constructible_impl<unsigned long, <const unsigned long>> : public __bool_constant<__is_constructible(unsigned long, const unsigned long)> {
    };
template<> struct __is_constructible_impl<unsigned long, <>> : public __bool_constant<__is_constructible(unsigned long)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *&>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *&)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *const &>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *const &)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *const>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *const)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <>> : public __bool_constant<__is_constructible(const wchar_t *)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *&>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *&)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *const &>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *const &)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *const>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *const)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <>> : public __bool_constant<__is_constructible(const char8_t *)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *&>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *&)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *const &>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *const &)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *const>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *const)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <>> : public __bool_constant<__is_constructible(const char16_t *)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *&>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *&)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *const &>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *const &)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *const>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *const)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <>> : public __bool_constant<__is_constructible(const char32_t *)> {
    };
    template <typename _Tp, typename ..._Args> struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *>> : public __is_constructible_impl<const char *, const char *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *&>> : public __is_constructible_impl<const char *, const char *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *const &>> : public __is_constructible_impl<const char *, const char *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *const>> : public __is_constructible_impl<const char *, const char *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <>> : public __is_constructible_impl<const char *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <unsigned long>> : public __is_constructible_impl<unsigned long, unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <unsigned long &>> : public __is_constructible_impl<unsigned long, unsigned long &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <const unsigned long &>> : public __is_constructible_impl<unsigned long, const unsigned long &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <const unsigned long>> : public __is_constructible_impl<unsigned long, const unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <>> : public __is_constructible_impl<unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *>> : public __is_constructible_impl<const wchar_t *, const wchar_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *&>> : public __is_constructible_impl<const wchar_t *, const wchar_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *const &>> : public __is_constructible_impl<const wchar_t *, const wchar_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *const>> : public __is_constructible_impl<const wchar_t *, const wchar_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <>> : public __is_constructible_impl<const wchar_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *>> : public __is_constructible_impl<const char8_t *, const char8_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *&>> : public __is_constructible_impl<const char8_t *, const char8_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *const &>> : public __is_constructible_impl<const char8_t *, const char8_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *const>> : public __is_constructible_impl<const char8_t *, const char8_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <>> : public __is_constructible_impl<const char8_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *>> : public __is_constructible_impl<const char16_t *, const char16_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *&>> : public __is_constructible_impl<const char16_t *, const char16_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *const &>> : public __is_constructible_impl<const char16_t *, const char16_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *const>> : public __is_constructible_impl<const char16_t *, const char16_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <>> : public __is_constructible_impl<const char16_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *>> : public __is_constructible_impl<const char32_t *, const char32_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *&>> : public __is_constructible_impl<const char32_t *, const char32_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *const &>> : public __is_constructible_impl<const char32_t *, const char32_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *const>> : public __is_constructible_impl<const char32_t *, const char32_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <>> : public __is_constructible_impl<const char32_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_default_constructible : public __is_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_constructible_impl;
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_copy_constructible : public __is_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_constructible_impl;
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_move_constructible : public __is_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> using __is_nothrow_constructible_impl = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;
    template <typename _Tp, typename ..._Args> struct is_nothrow_constructible : public __is_nothrow_constructible_impl<_Tp, _Args...>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_default_constructible : public __bool_constant<__is_nothrow_constructible(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_default_constructible<std::allocator<char>> : public __bool_constant<__is_nothrow_constructible(std::allocator<char>)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<std::allocator<char>>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_copy_constructible_impl;
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_constructible : public __is_nothrow_copy_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_move_constructible_impl
template<> struct __is_nothrow_move_constructible_impl<const char *, true> : public __is_nothrow_constructible_impl<const char *, const char *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<unsigned long, true> : public __is_nothrow_constructible_impl<unsigned long, unsigned long &&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const wchar_t *, true> : public __is_nothrow_constructible_impl<const wchar_t *, const wchar_t *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const char8_t *, true> : public __is_nothrow_constructible_impl<const char8_t *, const char8_t *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const char16_t *, true> : public __is_nothrow_constructible_impl<const char16_t *, const char16_t *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const char32_t *, true> : public __is_nothrow_constructible_impl<const char32_t *, const char32_t *&&> {
    };
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_constructible : public __is_nothrow_move_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char *> : public __is_nothrow_move_constructible_impl<const char *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<unsigned long> : public __is_nothrow_move_constructible_impl<unsigned long>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const wchar_t *> : public __is_nothrow_move_constructible_impl<const wchar_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char8_t *> : public __is_nothrow_move_constructible_impl<const char8_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char16_t *> : public __is_nothrow_move_constructible_impl<const char16_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char32_t *> : public __is_nothrow_move_constructible_impl<const char32_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_assignable : public __bool_constant<__is_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_assignable_impl;
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_copy_assignable : public __is_copy_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_assignable_impl;
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_move_assignable : public __is_move_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> using __is_nothrow_assignable_impl = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;
    template <typename _Tp, typename _Up> struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_copy_assignable_impl;
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_move_assignable_impl
template<> struct __is_nt_move_assignable_impl<const char *, true> : public __is_nothrow_assignable_impl<const char *&, const char *&&> {
    }
template<> struct __is_nt_move_assignable_impl<unsigned long, true> : public __is_nothrow_assignable_impl<unsigned long &, unsigned long &&> {
    }
template<> struct __is_nt_move_assignable_impl<const wchar_t *, true> : public __is_nothrow_assignable_impl<const wchar_t *&, const wchar_t *&&> {
    }
template<> struct __is_nt_move_assignable_impl<const char8_t *, true> : public __is_nothrow_assignable_impl<const char8_t *&, const char8_t *&&> {
    }
template<> struct __is_nt_move_assignable_impl<const char16_t *, true> : public __is_nothrow_assignable_impl<const char16_t *&, const char16_t *&&> {
    }
template<> struct __is_nt_move_assignable_impl<const char32_t *, true> : public __is_nothrow_assignable_impl<const char32_t *&, const char32_t *&&> {
    };
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char *> : public __is_nt_move_assignable_impl<const char *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<unsigned long> : public __is_nt_move_assignable_impl<unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const wchar_t *> : public __is_nt_move_assignable_impl<const wchar_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char8_t *> : public __is_nt_move_assignable_impl<const char8_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char16_t *> : public __is_nt_move_assignable_impl<const char16_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char32_t *> : public __is_nt_move_assignable_impl<const char32_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct is_trivially_constructible : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_default_constructible : public __bool_constant<__is_trivially_constructible(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_implicitly_default_constructible_impl {
        template <typename _Tp> static void __helper(const _Tp &);
        template <typename _Tp> static std::true_type __test(const _Tp &, decltype(__helper<const _Tp &>({})) * = 0);
        static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_impl : public std::__do_is_implicitly_default_constructible_impl {
        typedef decltype(__test(declval<_Tp>())) type;
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_implicitly_default_constructible : public __and_<__is_constructible_impl<_Tp>, __is_implicitly_default_constructible_safe<_Tp>> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_constructible_impl;
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, true> : public __and_<__is_copy_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp &)>> {
    };
    template <typename _Tp> struct is_trivially_copy_constructible : public __is_trivially_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_constructible_impl;
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, true> : public __and_<__is_move_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, _Tp &&)>> {
    };
    template <typename _Tp> struct is_trivially_move_constructible : public __is_trivially_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_trivially_assignable : public __bool_constant<__is_trivially_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_assignable_impl;
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_trivially_copy_assignable : public __is_trivially_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_assignable_impl;
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_trivially_move_assignable : public __is_trivially_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_destructible : public __and_<__is_destructible_safe<_Tp>, __bool_constant<__has_trivial_destructor(_Tp)>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename> struct rank : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, std::size_t _Size> struct rank<_Tp [_Size]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename _Tp> struct rank<_Tp []> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename, unsigned int _Uint = 0> struct extent : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, unsigned int _Uint, std::size_t _Size> struct extent<_Tp [_Size], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, unsigned int _Uint> struct extent<_Tp [], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, typename _Up> struct is_same : public integral_constant<bool, __is_same(_Tp, _Up)> {
    };
template<> struct is_same<list_start, list_start> : public integral_constant<bool, __is_same(list_start, list_start)> {
    };
template<> struct is_same<list_start, list_end> : public integral_constant<bool, __is_same(list_start, list_end)> {
    };
template<> struct is_same<plus, list_end> : public integral_constant<bool, __is_same(plus, list_end)> {
    };
template<> struct is_same<whitespace, list_end> : public integral_constant<bool, __is_same(whitespace, list_end)> {
    };
template<> struct is_same<integer<3>, list_end> : public integral_constant<bool, __is_same(integer<3>, list_end)> {
    };
template<> struct is_same<integer<2>, list_end> : public integral_constant<bool, __is_same(integer<2>, list_end)> {
    };
template<> struct is_same<list_end, list_end> : public integral_constant<bool, __is_same(list_end, list_end)> {
    };
template<> struct is_same<plus, list_start> : public integral_constant<bool, __is_same(plus, list_start)> {
    };
template<> struct is_same<plus, whitespace> : public integral_constant<bool, __is_same(plus, whitespace)> {
    };
template<> struct is_same<whitespace, list_start> : public integral_constant<bool, __is_same(whitespace, list_start)> {
    };
template<> struct is_same<whitespace, whitespace> : public integral_constant<bool, __is_same(whitespace, whitespace)> {
    };
template<> struct is_same<integer<3>, list_start> : public integral_constant<bool, __is_same(integer<3>, list_start)> {
    };
template<> struct is_same<integer<2>, list_start> : public integral_constant<bool, __is_same(integer<2>, list_start)> {
    };
template<> struct is_same<list_end, list_start> : public integral_constant<bool, __is_same(list_end, list_start)> {
    };
template<> struct is_same<plus, plus> : public integral_constant<bool, __is_same(plus, plus)> {
    };
template<> struct is_same<int, int> : public integral_constant<bool, __is_same(int, int)> {
    };
template<> struct is_same<long, int> : public integral_constant<bool, __is_same(long, int)> {
    };
template<> struct is_same<unsigned long, int> : public integral_constant<bool, __is_same(unsigned long, int)> {
    };
template<> struct is_same<long long, int> : public integral_constant<bool, __is_same(long long, int)> {
    };
template<> struct is_same<unsigned long long, int> : public integral_constant<bool, __is_same(unsigned long long, int)> {
    };
template<> struct is_same<float, int> : public integral_constant<bool, __is_same(float, int)> {
    };
template<> struct is_same<double, int> : public integral_constant<bool, __is_same(double, int)> {
    };
template<> struct is_same<long double, int> : public integral_constant<bool, __is_same(long double, int)> {
    };
    template <typename _Base, typename _Derived> struct is_base_of : public integral_constant<bool, __is_base_of(_Base, _Derived)> {
    };
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_convertible_helper {
        typedef typename is_void<_To>::type type;
    };
template<> class __is_convertible_helper<const char *, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *, const char *>(...);
    public:
        typedef decltype(__test<const char *, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const char *const &, const char *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *const &>(const char *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const &, const char *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const &, const char *const &>(...);
    public:
        typedef decltype(__test<const char *const &, const char *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char &, const char &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char &>(const char &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char &, const char &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char &, const char &>(...);
    public:
        typedef decltype(__test<const char &, const char &>(0)) type;
    };
template<> class __is_convertible_helper<char &, const char &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char &>(const char &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char &, const char &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char &, const char &>(...);
    public:
        typedef decltype(__test<char &, const char &>(0)) type;
    };
template<> class __is_convertible_helper<const char &&, const char &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char &>(const char &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char &&, const char &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char &&, const char &>(...);
    public:
        typedef decltype(__test<const char &&, const char &>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::input_iterator_tag *>(const volatile std::input_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::forward_iterator_tag *>(const volatile std::forward_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const char *&, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *&, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *&, const char *>(...);
    public:
        typedef decltype(__test<const char *&, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const char *const &, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const &, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const &, const char *>(...);
    public:
        typedef decltype(__test<const char *const &, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const char *const, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const, const char *>(...);
    public:
        typedef decltype(__test<const char *const, const char *>(0)) type;
    };
template<> class __is_convertible_helper<bool, bool, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<bool>(bool) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<bool, bool, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<bool, bool>(...);
    public:
        typedef decltype(__test<bool, bool>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::bidirectional_iterator_tag *>(const volatile std::bidirectional_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::random_access_iterator_tag *>(const volatile std::random_access_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::contiguous_iterator_tag *>(const volatile std::contiguous_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<unsigned long, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<unsigned long, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<unsigned long, unsigned long>(...);
    public:
        typedef decltype(__test<unsigned long, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<unsigned long &, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<unsigned long &, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<unsigned long &, unsigned long>(...);
    public:
        typedef decltype(__test<unsigned long &, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned long &, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const unsigned long &, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned long &, unsigned long>(...);
    public:
        typedef decltype(__test<const unsigned long &, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned long, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const unsigned long, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned long, unsigned long>(...);
    public:
        typedef decltype(__test<const unsigned long, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned long &, const unsigned long &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const unsigned long &>(const unsigned long &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const unsigned long &, const unsigned long &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned long &, const unsigned long &>(...);
    public:
        typedef decltype(__test<const unsigned long &, const unsigned long &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const &, const wchar_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *const &>(const wchar_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const &, const wchar_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const &, const wchar_t *const &>(...);
    public:
        typedef decltype(__test<const wchar_t *const &, const wchar_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t &, const wchar_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t &>(const wchar_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t &, const wchar_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t &, const wchar_t &>(...);
    public:
        typedef decltype(__test<const wchar_t &, const wchar_t &>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t &, const wchar_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t &>(const wchar_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<wchar_t &, const wchar_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t &, const wchar_t &>(...);
    public:
        typedef decltype(__test<wchar_t &, const wchar_t &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t &&, const wchar_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t &>(const wchar_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t &&, const wchar_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t &&, const wchar_t &>(...);
    public:
        typedef decltype(__test<const wchar_t &&, const wchar_t &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *&, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *&, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *&, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *&, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const &, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const &, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const &, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *const &, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *const, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const &, const char8_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *const &>(const char8_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *const &, const char8_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const &, const char8_t *const &>(...);
    public:
        typedef decltype(__test<const char8_t *const &, const char8_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t &, const char8_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t &>(const char8_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t &, const char8_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t &, const char8_t &>(...);
    public:
        typedef decltype(__test<const char8_t &, const char8_t &>(0)) type;
    };
template<> class __is_convertible_helper<char8_t &, const char8_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t &>(const char8_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char8_t &, const char8_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char8_t &, const char8_t &>(...);
    public:
        typedef decltype(__test<char8_t &, const char8_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t &&, const char8_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t &>(const char8_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t &&, const char8_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t &&, const char8_t &>(...);
    public:
        typedef decltype(__test<const char8_t &&, const char8_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *&, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *&, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *&, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *&, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const &, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *const &, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const &, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *const &, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *const, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *const, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const &, const char16_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *const &>(const char16_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const &, const char16_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const &, const char16_t *const &>(...);
    public:
        typedef decltype(__test<const char16_t *const &, const char16_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t &, const char16_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t &>(const char16_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t &, const char16_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t &, const char16_t &>(...);
    public:
        typedef decltype(__test<const char16_t &, const char16_t &>(0)) type;
    };
template<> class __is_convertible_helper<char16_t &, const char16_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t &>(const char16_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char16_t &, const char16_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char16_t &, const char16_t &>(...);
    public:
        typedef decltype(__test<char16_t &, const char16_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t &&, const char16_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t &>(const char16_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t &&, const char16_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t &&, const char16_t &>(...);
    public:
        typedef decltype(__test<const char16_t &&, const char16_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *&, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *&, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *&, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *&, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const &, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const &, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const &, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *const &, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *const, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const &, const char32_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *const &>(const char32_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const &, const char32_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const &, const char32_t *const &>(...);
    public:
        typedef decltype(__test<const char32_t *const &, const char32_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t &, const char32_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t &>(const char32_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t &, const char32_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t &, const char32_t &>(...);
    public:
        typedef decltype(__test<const char32_t &, const char32_t &>(0)) type;
    };
template<> class __is_convertible_helper<char32_t &, const char32_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t &>(const char32_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char32_t &, const char32_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char32_t &, const char32_t &>(...);
    public:
        typedef decltype(__test<char32_t &, const char32_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t &&, const char32_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t &>(const char32_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t &&, const char32_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t &&, const char32_t &>(...);
    public:
        typedef decltype(__test<const char32_t &&, const char32_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *&, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *&, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *&, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *&, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const &, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const &, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const &, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *const &, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *const, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const char *const &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char, std::char_traits<char>>>(std::basic_string_view<char, std::char_traits<char>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const &, std::basic_string_view<char, std::char_traits<char>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const char *const &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(...);
    public:
        typedef decltype(__test<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(std::basic_string_view<wchar_t, std::char_traits<wchar_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(...);
    public:
        typedef decltype(__test<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>(...);
    public:
        typedef decltype(__test<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const &, std::basic_string_view<char8_t, std::char_traits<char8_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char8_t, std::char_traits<char8_t>>>(std::basic_string_view<char8_t, std::char_traits<char8_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *const &, std::basic_string_view<char8_t, std::char_traits<char8_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const &, std::basic_string_view<char8_t, std::char_traits<char8_t>>>(...);
    public:
        typedef decltype(__test<const char8_t *const &, std::basic_string_view<char8_t, std::char_traits<char8_t>>>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>(...);
    public:
        typedef decltype(__test<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char16_t, std::char_traits<char16_t>>>(std::basic_string_view<char16_t, std::char_traits<char16_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>(...);
    public:
        typedef decltype(__test<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>(...);
    public:
        typedef decltype(__test<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char32_t, std::char_traits<char32_t>>>(std::basic_string_view<char32_t, std::char_traits<char32_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>(...);
    public:
        typedef decltype(__test<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>(...);
    public:
        typedef decltype(__test<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *>(0)) type;
    };
template<> class __is_convertible_helper<const std::_V2::error_category *const &, const std::_V2::error_category *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const std::_V2::error_category *const &>(const std::_V2::error_category *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const std::_V2::error_category *const &, const std::_V2::error_category *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const std::_V2::error_category *const &, const std::_V2::error_category *const &>(...);
    public:
        typedef decltype(__test<const std::_V2::error_category *const &, const std::_V2::error_category *const &>(0)) type;
    };
template<> class __is_convertible_helper<const std::_V2::error_category *, const volatile void *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile void *>(const volatile void *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const std::_V2::error_category *, const volatile void *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const std::_V2::error_category *, const volatile void *>(...);
    public:
        typedef decltype(__test<const std::_V2::error_category *, const volatile void *>(0)) type;
    };
template<> class __is_convertible_helper<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char, std::char_traits<char>>>(std::basic_string_view<char, std::char_traits<char>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::basic_string_view<char, std::char_traits<char>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(...);
    public:
        typedef decltype(__test<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(0)) type;
    };
template<> class __is_convertible_helper<char *const &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<char, std::char_traits<char>>>(std::basic_string_view<char, std::char_traits<char>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char *const &, std::basic_string_view<char, std::char_traits<char>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *const &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<char *const &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(...);
    public:
        typedef decltype(__test<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(0)) type;
    };
template<> class __is_convertible_helper<char *const &, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char *const &, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char *const &, const char *>(...);
    public:
        typedef decltype(__test<char *const &, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const char &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const char &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<const int &, std::basic_string_view<char, std::char_traits<char>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const int &, std::basic_string_view<char, std::char_traits<char>>>(...);
    public:
        typedef decltype(__test<const int &, std::basic_string_view<char, std::char_traits<char>>>(0)) type;
    };
template<> class __is_convertible_helper<std::random_access_iterator_tag, std::input_iterator_tag, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::input_iterator_tag>(std::input_iterator_tag) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<std::random_access_iterator_tag, std::input_iterator_tag, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<std::random_access_iterator_tag, std::input_iterator_tag>(...);
    public:
        typedef decltype(__test<std::random_access_iterator_tag, std::input_iterator_tag>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(std::basic_string_view<wchar_t, std::char_traits<wchar_t>>) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(...);
    public:
        typedef decltype(__test<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>(...);
    public:
        typedef decltype(__test<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t *const &, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<wchar_t *const &, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t *const &, const wchar_t *>(...);
    public:
        typedef decltype(__test<wchar_t *const &, const wchar_t *>(0)) type;
    };
    template <typename _From, typename _To> class __is_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        typedef decltype(__test<_From, _To>(0)) type;
    };
    template <typename _From, typename _To> struct is_convertible : public __is_convertible_helper<_From, _To>::type {
    };
template<> struct is_convertible<const char *, const char *> : public __is_convertible_helper<const char *, const char *>::type {
    };
template<> struct is_convertible<const char *const &, const char *const &> : public __is_convertible_helper<const char *const &, const char *const &>::type {
    };
template<> struct is_convertible<const char &, const char &> : public __is_convertible_helper<const char &, const char &>::type {
    };
template<> struct is_convertible<char &, const char &> : public __is_convertible_helper<char &, const char &>::type {
    };
template<> struct is_convertible<const char &&, const char &> : public __is_convertible_helper<const char &&, const char &>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile input_iterator_tag *>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile forward_iterator_tag *>::type {
    };
template<> struct is_convertible<const char *&, const char *> : public __is_convertible_helper<const char *&, const char *>::type {
    };
template<> struct is_convertible<const char *const &, const char *> : public __is_convertible_helper<const char *const &, const char *>::type {
    };
template<> struct is_convertible<const char *const, const char *> : public __is_convertible_helper<const char *const, const char *>::type {
    };
template<> struct is_convertible<bool, bool> : public __is_convertible_helper<bool, bool>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile bidirectional_iterator_tag *>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile random_access_iterator_tag *>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile contiguous_iterator_tag *>::type {
    };
template<> struct is_convertible<unsigned long, unsigned long> : public __is_convertible_helper<unsigned long, unsigned long>::type {
    };
template<> struct is_convertible<unsigned long &, unsigned long> : public __is_convertible_helper<unsigned long &, unsigned long>::type {
    };
template<> struct is_convertible<const unsigned long &, unsigned long> : public __is_convertible_helper<const unsigned long &, unsigned long>::type {
    };
template<> struct is_convertible<const unsigned long, unsigned long> : public __is_convertible_helper<const unsigned long, unsigned long>::type {
    };
template<> struct is_convertible<const unsigned long &, const unsigned long &> : public __is_convertible_helper<const unsigned long &, const unsigned long &>::type {
    };
template<> struct is_convertible<const wchar_t *, const wchar_t *> : public __is_convertible_helper<const wchar_t *, const wchar_t *>::type {
    };
template<> struct is_convertible<const wchar_t *const &, const wchar_t *const &> : public __is_convertible_helper<const wchar_t *const &, const wchar_t *const &>::type {
    };
template<> struct is_convertible<const wchar_t &, const wchar_t &> : public __is_convertible_helper<const wchar_t &, const wchar_t &>::type {
    };
template<> struct is_convertible<wchar_t &, const wchar_t &> : public __is_convertible_helper<wchar_t &, const wchar_t &>::type {
    };
template<> struct is_convertible<const wchar_t &&, const wchar_t &> : public __is_convertible_helper<const wchar_t &&, const wchar_t &>::type {
    };
template<> struct is_convertible<const wchar_t *&, const wchar_t *> : public __is_convertible_helper<const wchar_t *&, const wchar_t *>::type {
    };
template<> struct is_convertible<const wchar_t *const &, const wchar_t *> : public __is_convertible_helper<const wchar_t *const &, const wchar_t *>::type {
    };
template<> struct is_convertible<const wchar_t *const, const wchar_t *> : public __is_convertible_helper<const wchar_t *const, const wchar_t *>::type {
    };
template<> struct is_convertible<const char8_t *, const char8_t *> : public __is_convertible_helper<const char8_t *, const char8_t *>::type {
    };
template<> struct is_convertible<const char8_t *const &, const char8_t *const &> : public __is_convertible_helper<const char8_t *const &, const char8_t *const &>::type {
    };
template<> struct is_convertible<const char8_t &, const char8_t &> : public __is_convertible_helper<const char8_t &, const char8_t &>::type {
    };
template<> struct is_convertible<char8_t &, const char8_t &> : public __is_convertible_helper<char8_t &, const char8_t &>::type {
    };
template<> struct is_convertible<const char8_t &&, const char8_t &> : public __is_convertible_helper<const char8_t &&, const char8_t &>::type {
    };
template<> struct is_convertible<const char8_t *&, const char8_t *> : public __is_convertible_helper<const char8_t *&, const char8_t *>::type {
    };
template<> struct is_convertible<const char8_t *const &, const char8_t *> : public __is_convertible_helper<const char8_t *const &, const char8_t *>::type {
    };
template<> struct is_convertible<const char8_t *const, const char8_t *> : public __is_convertible_helper<const char8_t *const, const char8_t *>::type {
    };
template<> struct is_convertible<const char16_t *, const char16_t *> : public __is_convertible_helper<const char16_t *, const char16_t *>::type {
    };
template<> struct is_convertible<const char16_t *const &, const char16_t *const &> : public __is_convertible_helper<const char16_t *const &, const char16_t *const &>::type {
    };
template<> struct is_convertible<const char16_t &, const char16_t &> : public __is_convertible_helper<const char16_t &, const char16_t &>::type {
    };
template<> struct is_convertible<char16_t &, const char16_t &> : public __is_convertible_helper<char16_t &, const char16_t &>::type {
    };
template<> struct is_convertible<const char16_t &&, const char16_t &> : public __is_convertible_helper<const char16_t &&, const char16_t &>::type {
    };
template<> struct is_convertible<const char16_t *&, const char16_t *> : public __is_convertible_helper<const char16_t *&, const char16_t *>::type {
    };
template<> struct is_convertible<const char16_t *const &, const char16_t *> : public __is_convertible_helper<const char16_t *const &, const char16_t *>::type {
    };
template<> struct is_convertible<const char16_t *const, const char16_t *> : public __is_convertible_helper<const char16_t *const, const char16_t *>::type {
    };
template<> struct is_convertible<const char32_t *, const char32_t *> : public __is_convertible_helper<const char32_t *, const char32_t *>::type {
    };
template<> struct is_convertible<const char32_t *const &, const char32_t *const &> : public __is_convertible_helper<const char32_t *const &, const char32_t *const &>::type {
    };
template<> struct is_convertible<const char32_t &, const char32_t &> : public __is_convertible_helper<const char32_t &, const char32_t &>::type {
    };
template<> struct is_convertible<char32_t &, const char32_t &> : public __is_convertible_helper<char32_t &, const char32_t &>::type {
    };
template<> struct is_convertible<const char32_t &&, const char32_t &> : public __is_convertible_helper<const char32_t &&, const char32_t &>::type {
    };
template<> struct is_convertible<const char32_t *&, const char32_t *> : public __is_convertible_helper<const char32_t *&, const char32_t *>::type {
    };
template<> struct is_convertible<const char32_t *const &, const char32_t *> : public __is_convertible_helper<const char32_t *const &, const char32_t *>::type {
    };
template<> struct is_convertible<const char32_t *const, const char32_t *> : public __is_convertible_helper<const char32_t *const, const char32_t *>::type {
    };
template<> struct is_convertible<const unsigned int &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const unsigned int &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const char *const &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const char *const &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public __is_convertible_helper<const char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>::type {
    };
template<> struct is_convertible<const wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __is_convertible_helper<const wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::type {
    };
template<> struct is_convertible<const wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *> : public __is_convertible_helper<const wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>::type {
    };
template<> struct is_convertible<const char8_t *const &, std::basic_string_view<char8_t, std::char_traits<char8_t>>> : public __is_convertible_helper<const char8_t *const &, basic_string_view<char8_t, char_traits<char8_t>>>::type {
    };
template<> struct is_convertible<const char8_t *const *, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> *> : public __is_convertible_helper<const char8_t *const *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>::type {
    };
template<> struct is_convertible<const char16_t *const &, std::basic_string_view<char16_t, std::char_traits<char16_t>>> : public __is_convertible_helper<const char16_t *const &, basic_string_view<char16_t, char_traits<char16_t>>>::type {
    };
template<> struct is_convertible<const char16_t *const *, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> *> : public __is_convertible_helper<const char16_t *const *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>::type {
    };
template<> struct is_convertible<const char32_t *const &, std::basic_string_view<char32_t, std::char_traits<char32_t>>> : public __is_convertible_helper<const char32_t *const &, basic_string_view<char32_t, char_traits<char32_t>>>::type {
    };
template<> struct is_convertible<const char32_t *const *, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> *> : public __is_convertible_helper<const char32_t *const *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>::type {
    };
template<> struct is_convertible<const std::_V2::error_category *const &, const std::_V2::error_category *const &> : public __is_convertible_helper<const error_category *const &, const error_category *const &>::type {
    };
template<> struct is_convertible<const std::_V2::error_category *, const volatile void *> : public __is_convertible_helper<const error_category *, const volatile void *>::type {
    };
template<> struct is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const basic_string<char, char_traits<char>, allocator<char>> &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public __is_convertible_helper<const basic_string<char, char_traits<char>, allocator<char>> *, const basic_string<char, char_traits<char>, allocator<char>> *>::type {
    };
template<> struct is_convertible<char *const &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<char *const &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<char *const *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> : public __is_convertible_helper<char *const *, const basic_string<char, char_traits<char>, allocator<char>> *>::type {
    };
template<> struct is_convertible<char *const &, const char *> : public __is_convertible_helper<char *const &, const char *>::type {
    };
template<> struct is_convertible<const char &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const char &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<const int &, std::basic_string_view<char, std::char_traits<char>>> : public __is_convertible_helper<const int &, basic_string_view<char, char_traits<char>>>::type {
    };
template<> struct is_convertible<std::random_access_iterator_tag, std::input_iterator_tag> : public __is_convertible_helper<random_access_iterator_tag, input_iterator_tag>::type {
    };
template<> struct is_convertible<wchar_t *const &, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> : public __is_convertible_helper<wchar_t *const &, basic_string_view<wchar_t, char_traits<wchar_t>>>::type {
    };
template<> struct is_convertible<wchar_t *const *, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> *> : public __is_convertible_helper<wchar_t *const *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>::type {
    };
template<> struct is_convertible<wchar_t *const &, const wchar_t *> : public __is_convertible_helper<wchar_t *const &, const wchar_t *>::type {
    };
    template <typename _ToElementType, typename _FromElementType> using __is_array_convertible = is_convertible<_FromElementType (*)[], _ToElementType (*)[]>;
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_nt_convertible_helper : is_void<_To> {
    };
    template <typename _From, typename _To> class __is_nt_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1> static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))> __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        using type = decltype(__test<_From, _To>(0));
    };
    template <typename _From, typename _To> struct __is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {
    };
    template <typename _From, typename _To> struct is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {
    };
    template <typename _From, typename _To> constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_From, _To>::value;
    template <typename _Tp> struct remove_const {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_const<const _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile<volatile _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_cv {
        using type = _Tp;
    };
template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    };
template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    };
template<> struct remove_cv<char8_t> {
        using type = char8_t;
    };
template<> struct remove_cv<unsigned char> {
        using type = unsigned char;
    };
template<> struct remove_cv<char16_t> {
        using type = char16_t;
    };
template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    };
template<> struct remove_cv<char32_t> {
        using type = char32_t;
    };
template<> struct remove_cv<void> {
        using type = void;
    };
template<> struct remove_cv<double> {
        using type = double;
    };
template<> struct remove_cv<std::ranges::__detail::__max_size_type> {
        using type = std::ranges::__detail::__max_size_type;
    };
template<> struct remove_cv<int> {
        using type = int;
    };
template<> struct remove_cv<unsigned __int128> {
        using type = unsigned __int128;
    };
template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    };
template<> struct remove_cv<std::ranges::__detail::__max_diff_type> {
        using type = std::ranges::__detail::__max_diff_type;
    };
template<> struct remove_cv<char> {
        using type = char;
    };
template<> struct remove_cv<const char *> {
        using type = const char *;
    };
template<> struct remove_cv<const char *const &> {
        using type = const char *const &;
    };
template<> struct remove_cv<const char> {
        using type = char;
    };
template<> struct remove_cv<long> {
        using type = long;
    };
template<> struct remove_cv<const char &> {
        using type = const char &;
    };
template<> struct remove_cv<char &> {
        using type = char &;
    };
template<> struct remove_cv<const char &&> {
        using type = const char &&;
    };
template<> struct remove_cv<const volatile std::contiguous_iterator_tag *> {
        using type = const volatile std::contiguous_iterator_tag *;
    };
template<> struct remove_cv<const char *&> {
        using type = const char *&;
    };
template<> struct remove_cv<const char *const> {
        using type = const char *;
    };
template<> struct remove_cv<bool> {
        using type = bool;
    };
template<> struct remove_cv<unsigned long &> {
        using type = unsigned long &;
    };
template<> struct remove_cv<const unsigned long &> {
        using type = const unsigned long &;
    };
template<> struct remove_cv<const unsigned long> {
        using type = unsigned long;
    };
template<> struct remove_cv<const wchar_t *> {
        using type = const wchar_t *;
    };
template<> struct remove_cv<const wchar_t *const &> {
        using type = const wchar_t *const &;
    };
template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    };
template<> struct remove_cv<const wchar_t &> {
        using type = const wchar_t &;
    };
template<> struct remove_cv<wchar_t &> {
        using type = wchar_t &;
    };
template<> struct remove_cv<const wchar_t &&> {
        using type = const wchar_t &&;
    };
template<> struct remove_cv<const wchar_t *&> {
        using type = const wchar_t *&;
    };
template<> struct remove_cv<const wchar_t *const> {
        using type = const wchar_t *;
    };
template<> struct remove_cv<const char8_t *> {
        using type = const char8_t *;
    };
template<> struct remove_cv<const char8_t *const &> {
        using type = const char8_t *const &;
    };
template<> struct remove_cv<const char8_t> {
        using type = char8_t;
    };
template<> struct remove_cv<const char8_t &> {
        using type = const char8_t &;
    };
template<> struct remove_cv<char8_t &> {
        using type = char8_t &;
    };
template<> struct remove_cv<const char8_t &&> {
        using type = const char8_t &&;
    };
template<> struct remove_cv<const char8_t *&> {
        using type = const char8_t *&;
    };
template<> struct remove_cv<const char8_t *const> {
        using type = const char8_t *;
    };
template<> struct remove_cv<const char16_t *> {
        using type = const char16_t *;
    };
template<> struct remove_cv<const char16_t *const &> {
        using type = const char16_t *const &;
    };
template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    };
template<> struct remove_cv<const char16_t &> {
        using type = const char16_t &;
    };
template<> struct remove_cv<char16_t &> {
        using type = char16_t &;
    };
template<> struct remove_cv<const char16_t &&> {
        using type = const char16_t &&;
    };
template<> struct remove_cv<const char16_t *&> {
        using type = const char16_t *&;
    };
template<> struct remove_cv<const char16_t *const> {
        using type = const char16_t *;
    };
template<> struct remove_cv<const char32_t *> {
        using type = const char32_t *;
    };
template<> struct remove_cv<const char32_t *const &> {
        using type = const char32_t *const &;
    };
template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    };
template<> struct remove_cv<const char32_t &> {
        using type = const char32_t &;
    };
template<> struct remove_cv<char32_t &> {
        using type = char32_t &;
    };
template<> struct remove_cv<const char32_t &&> {
        using type = const char32_t &&;
    };
template<> struct remove_cv<const char32_t *&> {
        using type = const char32_t *&;
    };
template<> struct remove_cv<const char32_t *const> {
        using type = const char32_t *;
    };
template<> struct remove_cv<const unsigned int &> {
        using type = const unsigned int &;
    };
template<> struct remove_cv<unsigned long long> {
        using type = unsigned long long;
    };
template<> struct remove_cv<const char *const *> {
        using type = const char *const *;
    };
template<> struct remove_cv<const wchar_t *const *> {
        using type = const wchar_t *const *;
    };
template<> struct remove_cv<const char8_t *const *> {
        using type = const char8_t *const *;
    };
template<> struct remove_cv<const char16_t *const *> {
        using type = const char16_t *const *;
    };
template<> struct remove_cv<const char32_t *const *> {
        using type = const char32_t *const *;
    };
template<> struct remove_cv<const std::_V2::error_category *const &> {
        using type = const std::_V2::error_category *const &;
    };
template<> struct remove_cv<const std::_V2::error_category *> {
        using type = const std::_V2::error_category *;
    };
template<> struct remove_cv<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> {
        using type = const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &;
    };
template<> struct remove_cv<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *> {
        using type = const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *;
    };
template<> struct remove_cv<char *const &> {
        using type = char *const &;
    };
template<> struct remove_cv<char *const *> {
        using type = char *const *;
    };
template<> struct remove_cv<std::allocator<char>> {
        using type = std::allocator<char>;
    };
template<> struct remove_cv<const int &> {
        using type = const int &;
    };
template<> struct remove_cv<std::random_access_iterator_tag> {
        using type = std::random_access_iterator_tag;
    };
template<> struct remove_cv<wchar_t *const &> {
        using type = wchar_t *const &;
    };
template<> struct remove_cv<wchar_t *const *> {
        using type = wchar_t *const *;
    };
    template <typename _Tp> struct remove_cv<const _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<const volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct add_const {
        typedef const _Tp type;
    };
    template <typename _Tp> struct add_volatile {
        typedef volatile _Tp type;
    };
    template <typename _Tp> struct add_cv {
        typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
    };
    template <typename _Tp> using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;
    template <typename _Tp> struct remove_reference {
        typedef _Tp type;
    };
template<> struct remove_reference<const char &> {
        typedef const char type;
    };
template<> struct remove_reference<char &> {
        typedef char type;
    };
template<> struct remove_reference<const wchar_t &> {
        typedef const wchar_t type;
    };
template<> struct remove_reference<wchar_t &> {
        typedef wchar_t type;
    };
template<> struct remove_reference<const char8_t &> {
        typedef const char8_t type;
    };
template<> struct remove_reference<char8_t &> {
        typedef char8_t type;
    };
template<> struct remove_reference<const char16_t &> {
        typedef const char16_t type;
    };
template<> struct remove_reference<const char32_t &> {
        typedef const char32_t type;
    };
template<> struct remove_reference<const char *&> {
        typedef const char *type;
    };
template<> struct remove_reference<const char *> {
        typedef const char *type;
    };
template<> struct remove_reference<const char *const &> {
        typedef const char *const type;
    };
template<> struct remove_reference<const char *const> {
        typedef const char *const type;
    };
template<> struct remove_reference<unsigned long &> {
        typedef unsigned long type;
    };
template<> struct remove_reference<unsigned long> {
        typedef unsigned long type;
    };
template<> struct remove_reference<const unsigned long &> {
        typedef const unsigned long type;
    };
template<> struct remove_reference<const unsigned long> {
        typedef const unsigned long type;
    };
template<> struct remove_reference<const wchar_t *&> {
        typedef const wchar_t *type;
    };
template<> struct remove_reference<const wchar_t *> {
        typedef const wchar_t *type;
    };
template<> struct remove_reference<const wchar_t *const &> {
        typedef const wchar_t *const type;
    };
template<> struct remove_reference<const wchar_t *const> {
        typedef const wchar_t *const type;
    };
template<> struct remove_reference<const char8_t *&> {
        typedef const char8_t *type;
    };
template<> struct remove_reference<const char8_t *> {
        typedef const char8_t *type;
    };
template<> struct remove_reference<const char8_t *const &> {
        typedef const char8_t *const type;
    };
template<> struct remove_reference<const char8_t *const> {
        typedef const char8_t *const type;
    };
template<> struct remove_reference<const char16_t *&> {
        typedef const char16_t *type;
    };
template<> struct remove_reference<const char16_t *> {
        typedef const char16_t *type;
    };
template<> struct remove_reference<const char16_t *const &> {
        typedef const char16_t *const type;
    };
template<> struct remove_reference<const char16_t *const> {
        typedef const char16_t *const type;
    };
template<> struct remove_reference<const char32_t *&> {
        typedef const char32_t *type;
    };
template<> struct remove_reference<const char32_t *> {
        typedef const char32_t *type;
    };
template<> struct remove_reference<const char32_t *const &> {
        typedef const char32_t *const type;
    };
template<> struct remove_reference<const char32_t *const> {
        typedef const char32_t *const type;
    };
template<> struct remove_reference<std::allocator<char> &> {
        typedef std::allocator<char> type;
    };
template<> struct remove_reference<const std::_V2::error_category *> {
        typedef const std::_V2::error_category *type;
    };
template<> struct remove_reference<const std::_V2::error_category *const &> {
        typedef const std::_V2::error_category *const type;
    };
template<> struct remove_reference<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> {
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> type;
    };
    template <typename _Tp> struct remove_reference<_Tp &> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_reference<_Tp &&> {
        typedef _Tp type;
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_lvalue_reference_helper<_Tp, true> {
        typedef _Tp &type;
    };
    template <typename _Tp> struct add_lvalue_reference : public __add_lvalue_reference_helper<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_rvalue_reference_helper<_Tp, true> {
        typedef _Tp &&type;
    };
    template <typename _Tp> struct add_rvalue_reference : public __add_rvalue_reference_helper<_Tp> {
    };
    template <typename _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
    template <typename _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
    template <typename _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
    template <typename _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector
template<> struct __cv_selector<unsigned int, false, false> {
        typedef unsigned int __type;
    }
template<> struct __cv_selector<unsigned char, false, false> {
        typedef unsigned char __type;
    }
template<> struct __cv_selector<unsigned short, false, false> {
        typedef unsigned short __type;
    }
template<> struct __cv_selector<int, false, false> {
        typedef int __type;
    }
template<> struct __cv_selector<signed char, false, false> {
        typedef signed char __type;
    }
template<> struct __cv_selector<short, false, false> {
        typedef short __type;
    }
template<> struct __cv_selector<const char *const, true, false> {
        typedef const char *const const __type;
    }
template<> struct __cv_selector<char, true, false> {
        typedef const char __type;
    }
template<> struct __cv_selector<const char, false, false> {
        typedef const char __type;
    }
template<> struct __cv_selector<const char, true, false> {
        typedef const const char __type;
    }
template<> struct __cv_selector<const unsigned long, true, false> {
        typedef const const unsigned long __type;
    }
template<> struct __cv_selector<const wchar_t *const, true, false> {
        typedef const wchar_t *const const __type;
    }
template<> struct __cv_selector<wchar_t, true, false> {
        typedef const wchar_t __type;
    }
template<> struct __cv_selector<const wchar_t, false, false> {
        typedef const wchar_t __type;
    }
template<> struct __cv_selector<const wchar_t, true, false> {
        typedef const const wchar_t __type;
    }
template<> struct __cv_selector<const char8_t *const, true, false> {
        typedef const char8_t *const const __type;
    }
template<> struct __cv_selector<char8_t, true, false> {
        typedef const char8_t __type;
    }
template<> struct __cv_selector<const char8_t, false, false> {
        typedef const char8_t __type;
    }
template<> struct __cv_selector<const char8_t, true, false> {
        typedef const const char8_t __type;
    }
template<> struct __cv_selector<const char16_t *const, true, false> {
        typedef const char16_t *const const __type;
    }
template<> struct __cv_selector<char16_t, true, false> {
        typedef const char16_t __type;
    }
template<> struct __cv_selector<const char16_t, false, false> {
        typedef const char16_t __type;
    }
template<> struct __cv_selector<const char16_t, true, false> {
        typedef const const char16_t __type;
    }
template<> struct __cv_selector<const char32_t *const, true, false> {
        typedef const char32_t *const const __type;
    }
template<> struct __cv_selector<char32_t, true, false> {
        typedef const char32_t __type;
    }
template<> struct __cv_selector<const char32_t, false, false> {
        typedef const char32_t __type;
    }
template<> struct __cv_selector<const char32_t, true, false> {
        typedef const const char32_t __type;
    }
template<> struct __cv_selector<const std::_V2::error_category *const, true, false> {
        typedef const std::_V2::error_category *const const __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, false> {
        typedef _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, true> {
        typedef volatile _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, false> {
        typedef const _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, true> {
        typedef const volatile _Unqualified __type;
    };
    template <typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value> class __match_cv_qualifiers {
        typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<wchar_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char8_t, unsigned char, false, false> {
        typedef __cv_selector<unsigned char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char16_t, unsigned short, false, false> {
        typedef __cv_selector<unsigned short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char32_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned int, int, false, false> {
        typedef __cv_selector<int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned char, signed char, false, false> {
        typedef __cv_selector<signed char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned short, short, false, false> {
        typedef __cv_selector<short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char *const, const char *const, true, false> {
        typedef __cv_selector<const char *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char, char, true, false> {
        typedef __cv_selector<char, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char, const char, false, false> {
        typedef __cv_selector<const char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char, const char, true, false> {
        typedef __cv_selector<const char, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const unsigned long, const unsigned long, true, false> {
        typedef __cv_selector<const unsigned long, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const wchar_t *const, const wchar_t *const, true, false> {
        typedef __cv_selector<const wchar_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const wchar_t, wchar_t, true, false> {
        typedef __cv_selector<wchar_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<wchar_t, const wchar_t, false, false> {
        typedef __cv_selector<const wchar_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const wchar_t, const wchar_t, true, false> {
        typedef __cv_selector<const wchar_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char8_t *const, const char8_t *const, true, false> {
        typedef __cv_selector<const char8_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char8_t, char8_t, true, false> {
        typedef __cv_selector<char8_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char8_t, const char8_t, false, false> {
        typedef __cv_selector<const char8_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char8_t, const char8_t, true, false> {
        typedef __cv_selector<const char8_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char16_t *const, const char16_t *const, true, false> {
        typedef __cv_selector<const char16_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char16_t, char16_t, true, false> {
        typedef __cv_selector<char16_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char16_t, const char16_t, false, false> {
        typedef __cv_selector<const char16_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char16_t, const char16_t, true, false> {
        typedef __cv_selector<const char16_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char32_t *const, const char32_t *const, true, false> {
        typedef __cv_selector<const char32_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char32_t, char32_t, true, false> {
        typedef __cv_selector<char32_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char32_t, const char32_t, false, false> {
        typedef __cv_selector<const char32_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char32_t, const char32_t, true, false> {
        typedef __cv_selector<const char32_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const std::_V2::error_category *const, const std::_V2::error_category *const, true, false> {
        typedef __cv_selector<const std::_V2::error_category *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template <typename _Tp> struct __make_unsigned {
        typedef _Tp __type;
    };
    template<> struct __make_unsigned<char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<signed char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<short> {
        typedef unsigned short __type;
    };
    template<> struct __make_unsigned<int> {
        typedef unsigned int __type;
    };
    template<> struct __make_unsigned<long> {
        typedef unsigned long __type;
    };
    template<> struct __make_unsigned<long long> {
        typedef unsigned long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_unsigned_selector
template<> class __make_unsigned_selector<wchar_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(wchar_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char8_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char8_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char8_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char16_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char32_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<wchar_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<wchar_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char8_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char8_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char8_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char16_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char32_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    class __make_unsigned_selector_base {
    protected:
        template <typename ...> struct _List {
        };
template<> struct _List<<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned short, unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned char);
        };
template<> struct _List<<unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned short);
        };
template<> struct _List<<unsigned int, unsigned long, unsigned long long>> : _List<unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned int);
        };
template<> struct _List<<unsigned long, unsigned long long>> : _List<unsigned long long> {
            static constexpr std::size_t __size;
        };
template<> struct _List<<unsigned long long>> : _List<> {
            static constexpr std::size_t __size;
        };
template<> struct _List<<>> {
        };
        template <typename _Tp, typename ..._Up> struct _List<_Tp, _Up...> : _List<_Up...> {
            static constexpr std::size_t __size = sizeof(_Tp);
        };
        template <std::size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)> struct __select
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned int;
        }
template<> struct __select<1, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned char;
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned short;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, true> {
            using __type = _Uint;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, false> : __select<_Sz, _List<_UInts...>> {
        };
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    template<> struct __make_unsigned<wchar_t> {
        using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char8_t> {
        using __type = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char16_t> {
        using __type = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char32_t> {
        using __type = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_unsigned {
        typedef typename __make_unsigned_selector<_Tp>::__type type;
    };
    template<> struct make_unsigned<bool>;
    template <typename _Tp> struct __make_signed {
        typedef _Tp __type;
    };
    template<> struct __make_signed<char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned short> {
        typedef short __type;
    };
    template<> struct __make_signed<unsigned int> {
        typedef int __type;
    };
    template<> struct __make_signed<unsigned long> {
        typedef long __type;
    };
    template<> struct __make_signed<unsigned long long> {
        typedef long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_signed_selector
template<> class __make_signed_selector<wchar_t, false, true> {
        typedef typename __make_unsigned_selector<wchar_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned int, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned int>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned int, __signed_type>::__type;
    }
template<> class __make_signed_selector<char8_t, false, true> {
        typedef typename __make_unsigned_selector<char8_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned char, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned char>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned char, __signed_type>::__type;
    }
template<> class __make_signed_selector<char16_t, false, true> {
        typedef typename __make_unsigned_selector<char16_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned short, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned short>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned short, __signed_type>::__type;
    }
template<> class __make_signed_selector<char32_t, false, true> {
        typedef typename __make_unsigned_selector<char32_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
        typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template<> struct __make_signed<wchar_t> {
        using __type = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_signed<char8_t> {
        using __type = typename __make_signed_selector<char8_t, false, true>::__type;
    };
    template<> struct __make_signed<char16_t> {
        using __type = typename __make_signed_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_signed<char32_t> {
        using __type = typename __make_signed_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_signed {
        typedef typename __make_signed_selector<_Tp>::__type type;
    };
    template<> struct make_signed<bool>;
    template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;
    template <typename _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
    template <typename _Tp> struct remove_extent {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp [_Size]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_extent<_Tp []> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_all_extents {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_all_extents<_Tp [_Size]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> struct remove_all_extents<_Tp []> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
    template <typename _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
    template <typename _Tp, typename> struct __remove_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp, typename _Up> struct __remove_pointer_helper<_Tp, _Up *> {
        typedef _Up type;
    };
    template <typename _Tp> struct remove_pointer : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {
    };
    template <typename _Tp, bool = __or_<__is_referenceable<_Tp>, is_void<_Tp>>::value> struct __add_pointer_helper {
        typedef _Tp type;
    };
template<> struct __add_pointer_helper<const char &, true> {
        typedef typename remove_reference<const char &>::type *type;
    };
template<> struct __add_pointer_helper<const wchar_t &, true> {
        typedef typename remove_reference<const wchar_t &>::type *type;
    };
template<> struct __add_pointer_helper<const char8_t &, true> {
        typedef typename remove_reference<const char8_t &>::type *type;
    };
template<> struct __add_pointer_helper<const char16_t &, true> {
        typedef typename remove_reference<const char16_t &>::type *type;
    };
template<> struct __add_pointer_helper<const char32_t &, true> {
        typedef typename remove_reference<const char32_t &>::type *type;
    };
    template <typename _Tp> struct __add_pointer_helper<_Tp, true> {
        typedef typename remove_reference<_Tp>::type *type;
    };
    template <typename _Tp> struct add_pointer : public __add_pointer_helper<_Tp> {
    };
template<> struct add_pointer<const char &> : public __add_pointer_helper<const char &> {
    };
template<> struct add_pointer<const wchar_t &> : public __add_pointer_helper<const wchar_t &> {
    };
template<> struct add_pointer<const char8_t &> : public __add_pointer_helper<const char8_t &> {
    };
template<> struct add_pointer<const char16_t &> : public __add_pointer_helper<const char16_t &> {
    };
template<> struct add_pointer<const char32_t &> : public __add_pointer_helper<const char32_t &> {
    };
    template <typename _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
    template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
    template <std::size_t _Len> struct __aligned_storage_msa {
        union __type {
            unsigned char __data[_Len];
            struct __attribute__((aligned)) {
            } __align;
        };
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> struct aligned_storage {
        union type {
            unsigned char __data[_Len];
            struct __attribute__((aligned((_Align)))) {
            } __align;
        };
    };
    template <typename ..._Types> struct __strictest_alignment {
        static const std::size_t _S_alignment = 0;
        static const std::size_t _S_size = 0;
    };
    template <typename _Tp, typename ..._Types> struct __strictest_alignment<_Tp, _Types...> {
        static const std::size_t _S_alignment = alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
        static const std::size_t _S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
    template <std::size_t _Len, typename ..._Types> struct aligned_union {
    private:
        static_assert(sizeof...(_Types) != 0, "At least one type is required");
        using __strictest = __strictest_alignment<_Types...>;
        static const std::size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;
    public:
        static const std::size_t alignment_value = __strictest::_S_alignment;
        typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };
    const std::size_t alignment_value;
    template <typename _Up, bool _IsArray = is_array<_Up>::value, bool _IsFunction = is_function<_Up>::value> struct __decay_selector;
    template <typename _Up> struct __decay_selector<_Up, false, false> {
        typedef __remove_cv_t<_Up> __type;
    };
    template <typename _Up> struct __decay_selector<_Up, true, false> {
        typedef typename remove_extent<_Up>::type *__type;
    };
    template <typename _Up> struct __decay_selector<_Up, false, true> {
        typedef typename add_pointer<_Up>::type __type;
    };
    template <typename _Tp> class decay {
        typedef typename remove_reference<_Tp>::type __remove_type;
    public:
        typedef typename __decay_selector<__remove_type>::__type type;
    };
    template <typename _Tp> struct __strip_reference_wrapper {
        typedef _Tp __type;
    };
    template <typename _Tp> struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
        typedef _Tp &__type;
    };
    template <typename _Tp> using __decay_t = typename decay<_Tp>::type;
    template <typename _Tp> using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;
    template <bool, typename _Tp = void> struct enable_if {
    };
template<> struct enable_if<true, double> {
        typedef double type;
    };
template<> struct enable_if<true, const char *const &> {
        typedef const char *const &type;
    };
template<> struct enable_if<true, const char &> {
        typedef const char &type;
    };
template<> struct enable_if<true, void> {
        typedef void type;
    };
template<> struct enable_if<true, const unsigned long &> {
        typedef const unsigned long &type;
    };
template<> struct enable_if<true, const wchar_t *const &> {
        typedef const wchar_t *const &type;
    };
template<> struct enable_if<true, const wchar_t &> {
        typedef const wchar_t &type;
    };
template<> struct enable_if<true, const char8_t *const &> {
        typedef const char8_t *const &type;
    };
template<> struct enable_if<true, const char8_t &> {
        typedef const char8_t &type;
    };
template<> struct enable_if<true, const char16_t *const &> {
        typedef const char16_t *const &type;
    };
template<> struct enable_if<true, const char16_t &> {
        typedef const char16_t &type;
    };
template<> struct enable_if<true, const char32_t *const &> {
        typedef const char32_t *const &type;
    };
template<> struct enable_if<true, const char32_t &> {
        typedef const char32_t &type;
    };
template<> struct enable_if<true, std::allocator<char>> {
        typedef std::allocator<char> type;
    };
template<> struct enable_if<false, void> {
    };
template<> struct enable_if<true, std::allocator<wchar_t>> {
        typedef std::allocator<wchar_t> type;
    };
template<> struct enable_if<true, std::allocator<char8_t>> {
        typedef std::allocator<char8_t> type;
    };
template<> struct enable_if<true, std::allocator<char16_t>> {
        typedef std::allocator<char16_t> type;
    };
template<> struct enable_if<true, std::allocator<char32_t>> {
        typedef std::allocator<char32_t> type;
    };
template<> struct enable_if<true, const std::_V2::error_category *const &> {
        typedef const std::_V2::error_category *const &type;
    };
template<> struct enable_if<false, std::error_code &> {
    };
template<> struct enable_if<false, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> {
    };
    template <typename _Tp> struct enable_if<true, _Tp> {
        typedef _Tp type;
    };
    template <bool _Cond, typename _Tp = void> using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <typename ..._Cond> using _Require = __enable_if_t<__and_<_Cond...>::value>;
    template <typename _Tp> using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> struct conditional {
        typedef _Iftrue type;
    };
    template <typename _Iftrue, typename _Iffalse> struct conditional<false, _Iftrue, _Iffalse> {
        typedef _Iffalse type;
    };
    template <typename ..._Tp> struct common_type;
    struct __do_common_type_impl {
        template <typename _Tp, typename _Up> using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());
        template <typename _Tp, typename _Up> static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);
        template <typename _Tp, typename _Up> static __success_type<__remove_cvref_t<__cond_t<const _Tp &, const _Up &>>> _S_test_2(int);
        template <typename, typename> static std::__failure_type _S_test_2(...);
        template <typename _Tp, typename _Up> static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
    };
    template<> struct common_type<> {
    };
    template <typename _Tp0> struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {
    };
    template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>> struct __common_type_impl {
        using type = common_type<_Dp1, _Dp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2> : private std::__do_common_type_impl {
        using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };
    template <typename _Tp1, typename _Tp2> struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {
    };
    template <typename ...> struct __common_type_pack {
    };
    template <typename, typename, typename = void> struct __common_type_fold;
    template <typename _Tp1, typename _Tp2, typename ..._Rp> struct common_type<_Tp1, _Tp2, _Rp...> : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>> {
    };
    template <typename _CTp, typename ..._Rp> struct __common_type_fold<_CTp, __common_type_pack<_Rp...>, __void_t<typename _CTp::type>> : public common_type<typename _CTp::type, _Rp...> {
    };
    template <typename _CTp, typename _Rp> struct __common_type_fold<_CTp, _Rp, void> {
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl {
        using type = __underlying_type(_Tp);
    };
    template <typename _Tp> struct __underlying_type_impl<_Tp, false> {
    };
    template <typename _Tp> struct underlying_type : public __underlying_type_impl<_Tp> {
    };
    template <typename _Tp> struct __declval_protector {
        static const bool __stop = false;
    };
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0))     {
        static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
        return __declval<_Tp>(0);
    }
    template<> auto declval<const std::ranges::__cust_swap::_Swap &>() noexcept -> decltype(__declval<const std::ranges::__cust_swap::_Swap &>(0))    template<> auto declval<const char &>() noexcept -> decltype(__declval<const char &>(0))    template<> auto declval<char &>() noexcept -> decltype(__declval<char &>(0))    template<> auto declval<const wchar_t &>() noexcept -> decltype(__declval<const wchar_t &>(0))    template<> auto declval<wchar_t &>() noexcept -> decltype(__declval<wchar_t &>(0))    template<> auto declval<const char8_t &>() noexcept -> decltype(__declval<const char8_t &>(0))    template<> auto declval<char8_t &>() noexcept -> decltype(__declval<char8_t &>(0))    template<> auto declval<const char16_t &>() noexcept -> decltype(__declval<const char16_t &>(0))    template<> auto declval<const char32_t &>() noexcept -> decltype(__declval<const char32_t &>(0))    template<> auto declval<const char *>() noexcept -> decltype(__declval<const char *>(0))    template<> auto declval<const char *const &(&)()>() noexcept -> decltype(__declval<const char *const &(&)()>(0))    template<> auto declval<const char *const &>() noexcept -> decltype(__declval<const char *const &>(0))    template<> auto declval<const char *&>() noexcept -> decltype(__declval<const char *&>(0))    template<> auto declval<const char &(&)()>() noexcept -> decltype(__declval<const char &(&)()>(0))    template<> auto declval<const char &&>() noexcept -> decltype(__declval<const char &&>(0))    template<> auto declval<const volatile std::contiguous_iterator_tag *>() noexcept -> decltype(__declval<const volatile std::contiguous_iterator_tag *>(0))    template<> auto declval<const char *const>() noexcept -> decltype(__declval<const char *const>(0))    template<> auto declval<bool>() noexcept -> decltype(__declval<bool>(0))    template<> auto declval<unsigned long>() noexcept -> decltype(__declval<unsigned long>(0))    template<> auto declval<unsigned long &>() noexcept -> decltype(__declval<unsigned long &>(0))    template<> auto declval<const unsigned long &>() noexcept -> decltype(__declval<const unsigned long &>(0))    template<> auto declval<const unsigned long>() noexcept -> decltype(__declval<const unsigned long>(0))    template<> auto declval<const unsigned long &(&)()>() noexcept -> decltype(__declval<const unsigned long &(&)()>(0))    template<> auto declval<const wchar_t *>() noexcept -> decltype(__declval<const wchar_t *>(0))    template<> auto declval<const wchar_t *const &(&)()>() noexcept -> decltype(__declval<const wchar_t *const &(&)()>(0))    template<> auto declval<const wchar_t *const &>() noexcept -> decltype(__declval<const wchar_t *const &>(0))    template<> auto declval<const wchar_t *&>() noexcept -> decltype(__declval<const wchar_t *&>(0))    template<> auto declval<const wchar_t &(&)()>() noexcept -> decltype(__declval<const wchar_t &(&)()>(0))    template<> auto declval<const wchar_t &&>() noexcept -> decltype(__declval<const wchar_t &&>(0))    template<> auto declval<const wchar_t *const>() noexcept -> decltype(__declval<const wchar_t *const>(0))    template<> auto declval<const char8_t *>() noexcept -> decltype(__declval<const char8_t *>(0))    template<> auto declval<const char8_t *const &(&)()>() noexcept -> decltype(__declval<const char8_t *const &(&)()>(0))    template<> auto declval<const char8_t *const &>() noexcept -> decltype(__declval<const char8_t *const &>(0))    template<> auto declval<const char8_t *&>() noexcept -> decltype(__declval<const char8_t *&>(0))    template<> auto declval<const char8_t &(&)()>() noexcept -> decltype(__declval<const char8_t &(&)()>(0))    template<> auto declval<const char8_t &&>() noexcept -> decltype(__declval<const char8_t &&>(0))    template<> auto declval<const char8_t *const>() noexcept -> decltype(__declval<const char8_t *const>(0))    template<> auto declval<const char16_t *>() noexcept -> decltype(__declval<const char16_t *>(0))    template<> auto declval<const char16_t *const &(&)()>() noexcept -> decltype(__declval<const char16_t *const &(&)()>(0))    template<> auto declval<const char16_t *const &>() noexcept -> decltype(__declval<const char16_t *const &>(0))    template<> auto declval<const char16_t *&>() noexcept -> decltype(__declval<const char16_t *&>(0))    template<> auto declval<const char16_t &(&)()>() noexcept -> decltype(__declval<const char16_t &(&)()>(0))    template<> auto declval<char16_t &>() noexcept -> decltype(__declval<char16_t &>(0))    template<> auto declval<const char16_t &&>() noexcept -> decltype(__declval<const char16_t &&>(0))    template<> auto declval<const char16_t *const>() noexcept -> decltype(__declval<const char16_t *const>(0))    template<> auto declval<const char32_t *>() noexcept -> decltype(__declval<const char32_t *>(0))    template<> auto declval<const char32_t *const &(&)()>() noexcept -> decltype(__declval<const char32_t *const &(&)()>(0))    template<> auto declval<const char32_t *const &>() noexcept -> decltype(__declval<const char32_t *const &>(0))    template<> auto declval<const char32_t *&>() noexcept -> decltype(__declval<const char32_t *&>(0))    template<> auto declval<const char32_t &(&)()>() noexcept -> decltype(__declval<const char32_t &(&)()>(0))    template<> auto declval<char32_t &>() noexcept -> decltype(__declval<char32_t &>(0))    template<> auto declval<const char32_t &&>() noexcept -> decltype(__declval<const char32_t &&>(0))    template<> auto declval<const char32_t *const>() noexcept -> decltype(__declval<const char32_t *const>(0))    template<> auto declval<std::allocator<char> &>() noexcept -> decltype(__declval<std::allocator<char> &>(0))    template<> auto declval<const unsigned int &>() noexcept -> decltype(__declval<const unsigned int &>(0))    template<> auto declval<std::allocator<wchar_t> &>() noexcept -> decltype(__declval<std::allocator<wchar_t> &>(0))    template<> auto declval<std::allocator<char8_t> &>() noexcept -> decltype(__declval<std::allocator<char8_t> &>(0))    template<> auto declval<std::allocator<char16_t> &>() noexcept -> decltype(__declval<std::allocator<char16_t> &>(0))    template<> auto declval<std::allocator<char32_t> &>() noexcept -> decltype(__declval<std::allocator<char32_t> &>(0))    template<> auto declval<const char *const *>() noexcept -> decltype(__declval<const char *const *>(0))    template<> auto declval<const wchar_t *const *>() noexcept -> decltype(__declval<const wchar_t *const *>(0))    template<> auto declval<const char8_t *const *>() noexcept -> decltype(__declval<const char8_t *const *>(0))    template<> auto declval<const char16_t *const *>() noexcept -> decltype(__declval<const char16_t *const *>(0))    template<> auto declval<const char32_t *const *>() noexcept -> decltype(__declval<const char32_t *const *>(0))    template<> auto declval<const std::_V2::error_category *const &(&)()>() noexcept -> decltype(__declval<const std::_V2::error_category *const &(&)()>(0))    template<> auto declval<const std::_V2::error_category *const &>() noexcept -> decltype(__declval<const std::_V2::error_category *const &>(0))    template<> auto declval<const std::_V2::error_category *>() noexcept -> decltype(__declval<const std::_V2::error_category *>(0))    template<> auto declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &>() noexcept -> decltype(__declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &>(0))    template<> auto declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>() noexcept -> decltype(__declval<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> *>(0))    template<> auto declval<char *const &>() noexcept -> decltype(__declval<char *const &>(0))    template<> auto declval<char *const *>() noexcept -> decltype(__declval<char *const *>(0))    template<> auto declval<const int &>() noexcept -> decltype(__declval<const int &>(0))    template<> auto declval<std::random_access_iterator_tag>() noexcept -> decltype(__declval<std::random_access_iterator_tag>(0))    template<> auto declval<wchar_t *const &>() noexcept -> decltype(__declval<wchar_t *const &>(0))    template<> auto declval<wchar_t *const *>() noexcept -> decltype(__declval<wchar_t *const *>(0))    template <typename _Signature> struct result_of;
    struct __invoke_memfun_ref {
    };
    struct __invoke_memfun_deref {
    };
    struct __invoke_memobj_ref {
    };
    struct __invoke_memobj_deref {
    };
    struct __invoke_other {
    };
    template <typename _Tp, typename _Tag> struct __result_of_success : __success_type<_Tp> {
        using __invoke_type = _Tag;
    };
    struct __result_of_memfun_ref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype((std::declval<_Tp1>() .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_ref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_ref : private std::__result_of_memfun_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memfun_deref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype(((*std::declval<_Tp1>()) .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_deref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_deref : private std::__result_of_memfun_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memobj_ref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype(std::declval<_Tp1>() .* std::declval<_Fp>()), std::__invoke_memobj_ref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_ref : private std::__result_of_memobj_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    struct __result_of_memobj_deref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype((*std::declval<_Tp1>()) .* std::declval<_Fp>()), std::__invoke_memobj_deref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_deref : private std::__result_of_memobj_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj;
    template <typename _Res, typename _Class, typename _Arg> struct __result_of_memobj<_Res _Class::*, _Arg> {
        typedef __remove_cvref_t<_Arg> _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename __conditional_t<__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value, __result_of_memobj_ref<_MemPtr, _Arg>, __result_of_memobj_deref<_MemPtr, _Arg>>::type type;
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun;
    template <typename _Res, typename _Class, typename _Arg, typename ..._Args> struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
        typedef typename remove_reference<_Arg>::type _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename __conditional_t<is_base_of<_Class, _Argval>::value, __result_of_memfun_ref<_MemPtr, _Arg, _Args...>, __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type type;
    };
    template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>> struct __inv_unwrap {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
        using type = _Up &;
    };
    template <bool, bool, typename _Functor, typename ..._ArgTypes> struct __result_of_impl {
        typedef std::__failure_type type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_impl<true, false, _MemPtr, _Arg> : public __result_of_memobj<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type> {
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...> : public __result_of_memfun<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type, _Args...> {
    };
    struct __result_of_other_impl {
        template <typename _Fn, typename ..._Args> static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)), std::__invoke_other> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _Functor, typename ..._ArgTypes> struct __result_of_impl<false, false, _Functor, _ArgTypes...> : private std::__result_of_other_impl {
        typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };
    template <typename _Functor, typename ..._ArgTypes> struct __invoke_result : public __result_of_impl<is_member_object_pointer<typename remove_reference<_Functor>::type>::value, is_member_function_pointer<typename remove_reference<_Functor>::type>::value, _Functor, _ArgTypes...>::type {
    };
    template <typename _Functor, typename ..._ArgTypes> struct __attribute__((deprecated("use 'std::invoke_result' instead"))) result_of<_Functor (_ArgTypes...)> : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <std::size_t _Len, typename ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <typename _Tp> using decay_t = typename decay<_Tp>::type;
    template <bool _Cond, typename _Tp = void> using enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
    template <typename ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
    template <typename _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
    template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;
    template <typename ...> using void_t = void;
    template <typename _Default, typename _AlwaysVoid, template <typename ...> class _Op, typename ..._Args> struct __detector {
        using value_t = std::false_type;
        using type = _Default;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {
        using value_t = std::true_type;
        using type = _Op<_Args...>;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or = __detector<_Default, void, _Op, _Args...>;
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
    template <typename _Tp> struct __is_swappable;
    template <typename _Tp> struct __is_nothrow_swappable;
    template <typename> struct __is_tuple_like_impl : std::false_type {
    };
    template <typename _Tp> struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {
    };
    template <typename _Tp> inline constexpr _Require<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>> swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::valueswap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value);
    template <typename _Tp, std::size_t _Nm> inline constexpr __enable_if_t<__is_swappable<_Tp>::value> swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);
    namespace __swappable_details {
        using std::swap;
        struct __do_is_swappable_impl {
            template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_impl {
            template <typename _Tp> static __bool_constant<noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> __test(int);
            template <typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp> struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_swappable : public __is_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct is_swappable : public __is_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool is_swappable_v = is_swappable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
    namespace __swappable_with_details {
        using std::swap;
        struct __do_is_swappable_with_impl {
            template <typename _Tp, typename _Up, typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())), typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))> static std::true_type __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_with_impl {
            template <typename _Tp, typename _Up> static __bool_constant<noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) && noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))> __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp, typename _Up> struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>({})), "second template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "first template argument must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>({})), "second template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
    template <typename _Result, typename _Ret, bool = is_void<_Ret>::value, typename = void> struct __is_invocable_impl : std::false_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, true, __void_t<typename _Result::type>> : std::true_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, false, __void_t<typename _Result::type>> {
    private:
        static typename _Result::type _S_get();
        template <typename _Tp> static void _S_conv(_Tp);
        template <typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))> static std::true_type _S_test(int);
        template <typename _Tp> static std::false_type _S_test(...);
    public:
        using type = decltype(_S_test<_Ret>(1));
    };
    template <typename _Fn, typename ..._ArgTypes> struct __is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
    };
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept((std::declval<_Up>() .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_deref)     {
        return noexcept(((*std::declval<_Tp>()) .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept(std::declval<_Up>() .* std::declval<_Fn>());
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_deref)     {
        return noexcept((*std::declval<_Tp>()) .* std::declval<_Fn>());
    }
    template <typename _Fn, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_other)     {
        return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }
    template <typename _Result, typename _Fn, typename ..._Args> struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type({}))> {
    };
    template <typename _Fn, typename ..._Args> using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
    template <typename _Fn, typename ..._Args> struct __is_nothrow_invocable : __and_<__is_invocable<_Fn, _Args...>, __call_is_nothrow_<_Fn, _Args...>>::type {
    };
    struct __nonesuchbase {
    };
    struct __nonesuch : private std::__nonesuchbase {
        ~__nonesuch() = delete
        __nonesuch(const std::__nonesuch &) = delete
        void operator=(const std::__nonesuch &) = delete
    };
    template <typename _Functor, typename ..._ArgTypes> struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>({})), "_Functor must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>({})) && ...), "each argument type must be a complete class or an unbounded array");
    };
    template <typename _Fn, typename ..._Args> using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
    template <typename _Fn, typename ..._ArgTypes> struct is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>({})) && ...), "each argument type must be a complete class or an unbounded array");
    };
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_invocable_r : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>({})) && ...), "each argument type must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>({})), "_Ret must be a complete class or an unbounded array");
    };
    template <typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>({})) && ...), "each argument type must be a complete class or an unbounded array");
    };
    template <typename _Result, typename _Ret, typename = void> struct __is_nt_invocable_impl : std::false_type {
    };
    template <typename _Result, typename _Ret> struct __is_nt_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>> : __or_<is_void<_Ret>, __is_nothrow_convertible<typename _Result::type, _Ret>> {
    };
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable_r : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
        static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>({})) && ...), "each argument type must be a complete class or an unbounded array");
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>({})), "_Ret must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool is_void_v = is_void<_Tp>::value;
    template <typename _Tp> constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_integral_v = is_integral<_Tp>::value;
    template <typename _Tp> constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
    template <typename _Tp> constexpr bool is_array_v = is_array<_Tp>::value;
    template <typename _Tp> constexpr bool is_pointer_v = is_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_enum_v = is_enum<_Tp>::value;
    template <typename _Tp> constexpr bool is_union_v = is_union<_Tp>::value;
    template <typename _Tp> constexpr bool is_class_v = is_class<_Tp>::value;
    template <typename _Tp> constexpr bool is_function_v = is_function<_Tp>::value;
    template <typename _Tp> constexpr bool is_reference_v = is_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
    template <typename _Tp> constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
    template <typename _Tp> constexpr bool is_object_v = is_object<_Tp>::value;
    template <typename _Tp> constexpr bool is_scalar_v = is_scalar<_Tp>::value;
    template <typename _Tp> constexpr bool is_compound_v = is_compound<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_const_v = is_const<_Tp>::value;
    template <typename _Tp> constexpr bool is_volatile_v = is_volatile<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivial_v = is_trivial<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Tp>::value;
    template <typename _Tp> constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
    template <typename _Tp> constexpr bool is_pod_v = is_pod<_Tp>::value [[deprecated("use is_standard_layout_v && is_trivial_v instead")]];
    template <typename _Tp> constexpr bool is_literal_type_v = is_literal_type<_Tp>::value [[deprecated("")]];
    template <typename _Tp> constexpr bool is_empty_v = is_empty<_Tp>::value;
    template <typename _Tp> constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
    template <typename _Tp> constexpr bool is_abstract_v = is_abstract<_Tp>::value;
    template <typename _Tp> constexpr bool is_final_v = is_final<_Tp>::value;
    template <typename _Tp> constexpr bool is_signed_v = is_signed<_Tp>::value;
    template <typename _Tp> constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_constructible_v = is_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_default_constructible_v = is_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_destructible_v = is_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;
    template <typename _Tp> constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Tp>::value;
    template <typename _Tp> constexpr std::size_t alignment_of_v = alignment_of<_Tp>::value;
    template <typename _Tp> constexpr std::size_t rank_v = rank<_Tp>::value;
    template <typename _Tp, unsigned int _Idx = 0> constexpr std::size_t extent_v = extent<_Tp, _Idx>::value;
    template <typename _Tp, typename _Up> constexpr bool is_same_v = __is_same(_Tp, _Up);
    template <typename _Base, typename _Derived> constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
    template <typename _From, typename _To> constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
    template <typename _Fn, typename ..._Args> constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
    template <typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Tp> struct has_unique_object_representations : bool_constant<__has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Tp>::value;
    template <typename _Tp> struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {
    };
    template <typename _Tp> constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
    template <typename _Tp> struct remove_cvref : remove_cv<_Tp> {
    };
template<> struct remove_cvref<const char *> : remove_cv<const char *> {
    };
template<> struct remove_cvref<const char &> : remove_cv<const char> {
    };
template<> struct remove_cvref<const wchar_t *> : remove_cv<const wchar_t *> {
    };
template<> struct remove_cvref<const wchar_t &> : remove_cv<const wchar_t> {
    };
template<> struct remove_cvref<const char8_t *> : remove_cv<const char8_t *> {
    };
template<> struct remove_cvref<const char8_t &> : remove_cv<const char8_t> {
    };
template<> struct remove_cvref<const char16_t *> : remove_cv<const char16_t *> {
    };
template<> struct remove_cvref<const char16_t &> : remove_cv<const char16_t> {
    };
template<> struct remove_cvref<const char32_t *> : remove_cv<const char32_t *> {
    };
template<> struct remove_cvref<const char32_t &> : remove_cv<const char32_t> {
    };
    template <typename _Tp> struct remove_cvref<_Tp &> : remove_cv<_Tp> {
    };
    template <typename _Tp> struct remove_cvref<_Tp &&> : remove_cv<_Tp> {
    };
    template <typename _Tp> using remove_cvref_t = typename remove_cvref<_Tp>::type;
    template <typename _Tp> struct type_identity {
        using type = _Tp;
    };
    template <typename _Tp> using type_identity_t = typename type_identity<_Tp>::type;
    template <typename _Tp> struct unwrap_reference {
        using type = _Tp;
    };
    template <typename _Tp> struct unwrap_reference<reference_wrapper<_Tp>> {
        using type = _Tp &;
    };
    template <typename _Tp> using unwrap_reference_t = typename unwrap_reference<_Tp>::type;
    template <typename _Tp> struct unwrap_ref_decay {
        using type = unwrap_reference_t<decay_t<_Tp>>;
    };
    template <typename _Tp> using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
    template <typename _Tp> struct is_bounded_array : public __is_array_known_bounds<_Tp> {
    };
    template <typename _Tp> struct is_unbounded_array : public __is_array_unknown_bounds<_Tp> {
    };
    template <typename _Tp> constexpr bool is_bounded_array_v = is_bounded_array<_Tp>::value;
    template <typename _Tp> constexpr bool is_unbounded_array_v = is_unbounded_array<_Tp>::value;
    inline constexpr bool is_constant_evaluated() noexcept     {
        return __builtin_is_constant_evaluated();
    }
    template <typename _From, typename _To> using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;
    template <typename _Xp, typename _Yp> using __cond_res = decltype(false ? declval<_Xp (&)()>()() : declval<_Yp (&)()>()());
    template <typename _Ap, typename _Bp, typename = void> struct __common_ref_impl {
    };
template<> struct __common_ref_impl<const char *const &, const char *const &, void> : enable_if<is_reference_v<__condres_cvref<const char *const, const char *const>>, __condres_cvref<const char *const, const char *const>> {
    };
template<> struct __common_ref_impl<const char &, char &, void> : enable_if<is_reference_v<__condres_cvref<const char, char>>, __condres_cvref<const char, char>> {
    };
template<> struct __common_ref_impl<char &, const char &, void> : enable_if<is_reference_v<__condres_cvref<char, const char>>, __condres_cvref<char, const char>> {
    };
template<> struct __common_ref_impl<const char &, const char &&, void> : __common_ref_impl<const char &&, const char &> {
    };
template<> struct __common_ref_impl<const char &&, const char &, void> {
        using type = __common_ref_D<const char, const char>;
    };
template<> struct __common_ref_impl<const char &, const char &, void> : enable_if<is_reference_v<__condres_cvref<const char, const char>>, __condres_cvref<const char, const char>> {
    };
template<> struct __common_ref_impl<const unsigned long &, const unsigned long &, void> : enable_if<is_reference_v<__condres_cvref<const unsigned long, const unsigned long>>, __condres_cvref<const unsigned long, const unsigned long>> {
    };
template<> struct __common_ref_impl<const wchar_t *const &, const wchar_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const wchar_t *const, const wchar_t *const>>, __condres_cvref<const wchar_t *const, const wchar_t *const>> {
    };
template<> struct __common_ref_impl<const wchar_t &, wchar_t &, void> : enable_if<is_reference_v<__condres_cvref<const wchar_t, wchar_t>>, __condres_cvref<const wchar_t, wchar_t>> {
    };
template<> struct __common_ref_impl<wchar_t &, const wchar_t &, void> : enable_if<is_reference_v<__condres_cvref<wchar_t, const wchar_t>>, __condres_cvref<wchar_t, const wchar_t>> {
    };
template<> struct __common_ref_impl<const wchar_t &, const wchar_t &&, void> : __common_ref_impl<const wchar_t &&, const wchar_t &> {
    };
template<> struct __common_ref_impl<const wchar_t &&, const wchar_t &, void> {
        using type = __common_ref_D<const wchar_t, const wchar_t>;
    };
template<> struct __common_ref_impl<const wchar_t &, const wchar_t &, void> : enable_if<is_reference_v<__condres_cvref<const wchar_t, const wchar_t>>, __condres_cvref<const wchar_t, const wchar_t>> {
    };
template<> struct __common_ref_impl<const char8_t *const &, const char8_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const char8_t *const, const char8_t *const>>, __condres_cvref<const char8_t *const, const char8_t *const>> {
    };
template<> struct __common_ref_impl<const char8_t &, char8_t &, void> : enable_if<is_reference_v<__condres_cvref<const char8_t, char8_t>>, __condres_cvref<const char8_t, char8_t>> {
    };
template<> struct __common_ref_impl<char8_t &, const char8_t &, void> : enable_if<is_reference_v<__condres_cvref<char8_t, const char8_t>>, __condres_cvref<char8_t, const char8_t>> {
    };
template<> struct __common_ref_impl<const char8_t &, const char8_t &&, void> : __common_ref_impl<const char8_t &&, const char8_t &> {
    };
template<> struct __common_ref_impl<const char8_t &&, const char8_t &, void> {
        using type = __common_ref_D<const char8_t, const char8_t>;
    };
template<> struct __common_ref_impl<const char8_t &, const char8_t &, void> : enable_if<is_reference_v<__condres_cvref<const char8_t, const char8_t>>, __condres_cvref<const char8_t, const char8_t>> {
    };
template<> struct __common_ref_impl<const char16_t *const &, const char16_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const char16_t *const, const char16_t *const>>, __condres_cvref<const char16_t *const, const char16_t *const>> {
    };
template<> struct __common_ref_impl<const char16_t &, char16_t &, void> : enable_if<is_reference_v<__condres_cvref<const char16_t, char16_t>>, __condres_cvref<const char16_t, char16_t>> {
    };
template<> struct __common_ref_impl<char16_t &, const char16_t &, void> : enable_if<is_reference_v<__condres_cvref<char16_t, const char16_t>>, __condres_cvref<char16_t, const char16_t>> {
    };
template<> struct __common_ref_impl<const char16_t &, const char16_t &&, void> : __common_ref_impl<const char16_t &&, const char16_t &> {
    };
template<> struct __common_ref_impl<const char16_t &&, const char16_t &, void> {
        using type = __common_ref_D<const char16_t, const char16_t>;
    };
template<> struct __common_ref_impl<const char16_t &, const char16_t &, void> : enable_if<is_reference_v<__condres_cvref<const char16_t, const char16_t>>, __condres_cvref<const char16_t, const char16_t>> {
    };
template<> struct __common_ref_impl<const char32_t *const &, const char32_t *const &, void> : enable_if<is_reference_v<__condres_cvref<const char32_t *const, const char32_t *const>>, __condres_cvref<const char32_t *const, const char32_t *const>> {
    };
template<> struct __common_ref_impl<const char32_t &, char32_t &, void> : enable_if<is_reference_v<__condres_cvref<const char32_t, char32_t>>, __condres_cvref<const char32_t, char32_t>> {
    };
template<> struct __common_ref_impl<char32_t &, const char32_t &, void> : enable_if<is_reference_v<__condres_cvref<char32_t, const char32_t>>, __condres_cvref<char32_t, const char32_t>> {
    };
template<> struct __common_ref_impl<const char32_t &, const char32_t &&, void> : __common_ref_impl<const char32_t &&, const char32_t &> {
    };
template<> struct __common_ref_impl<const char32_t &&, const char32_t &, void> {
        using type = __common_ref_D<const char32_t, const char32_t>;
    };
template<> struct __common_ref_impl<const char32_t &, const char32_t &, void> : enable_if<is_reference_v<__condres_cvref<const char32_t, const char32_t>>, __condres_cvref<const char32_t, const char32_t>> {
    };
template<> struct __common_ref_impl<const std::_V2::error_category *const &, const std::_V2::error_category *const &, void> : enable_if<is_reference_v<__condres_cvref<const std::_V2::error_category *const, const std::_V2::error_category *const>>, __condres_cvref<const std::_V2::error_category *const, const std::_V2::error_category *const>> {
    };
    template <typename _Ap, typename _Bp> using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;
    template <typename _Xp, typename _Yp> using __condres_cvref = __cond_res<__copy_cv<_Xp, _Yp> &, __copy_cv<_Yp, _Xp> &>;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &, _Yp &, __void_t<__condres_cvref<_Xp, _Yp>>> : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>, __condres_cvref<_Xp, _Yp>> {
    };
    template <typename _Xp, typename _Yp> using __common_ref_C = remove_reference_t<__common_ref<_Xp &, _Yp &>> &&;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &&, _Yp &&, _Require<is_convertible<_Xp &&, __common_ref_C<_Xp, _Yp>>, is_convertible<_Yp &&, __common_ref_C<_Xp, _Yp>>>> {
        using type = __common_ref_C<_Xp, _Yp>;
    };
    template <typename _Xp, typename _Yp> using __common_ref_D = __common_ref<const _Xp &, _Yp &>;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &&, _Yp &, _Require<is_convertible<_Xp &&, __common_ref_D<_Xp, _Yp>>>> {
        using type = __common_ref_D<_Xp, _Yp>;
    };
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &, _Yp &&> : __common_ref_impl<_Yp &&, _Xp &> {
    };
    template <typename _Tp, typename _Up, template <typename> class _TQual, template <typename> class _UQual> struct basic_common_reference {
    };
    template <typename _Tp> struct __xref {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up>;
    };
    template <typename _Tp> struct __xref<_Tp &> {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up> &;
    };
    template <typename _Tp> struct __xref<_Tp &&> {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up> &&;
    };
    template <typename _Tp1, typename _Tp2> using __basic_common_ref = typename basic_common_reference<remove_cvref_t<_Tp1>, remove_cvref_t<_Tp2>, __xref<_Tp1>::template __type, __xref<_Tp2>::template __type>::type;
    template <typename ..._Tp> struct common_reference
template<> struct common_reference<<const char *const &, const char *const &>> : __common_reference_impl<const char *const &, const char *const &> {
    }
template<> struct common_reference<<const char &, char &>> : __common_reference_impl<const char &, char &> {
    }
template<> struct common_reference<<char &, const char &>> : __common_reference_impl<char &, const char &> {
    }
template<> struct common_reference<<const char &, const char &&>> : __common_reference_impl<const char &, const char &&> {
    }
template<> struct common_reference<<const char &&, const char &>> : __common_reference_impl<const char &&, const char &> {
    }
template<> struct common_reference<<const unsigned long &, const unsigned long &>> : __common_reference_impl<const unsigned long &, const unsigned long &> {
    }
template<> struct common_reference<<const wchar_t *const &, const wchar_t *const &>> : __common_reference_impl<const wchar_t *const &, const wchar_t *const &> {
    }
template<> struct common_reference<<const wchar_t &, wchar_t &>> : __common_reference_impl<const wchar_t &, wchar_t &> {
    }
template<> struct common_reference<<wchar_t &, const wchar_t &>> : __common_reference_impl<wchar_t &, const wchar_t &> {
    }
template<> struct common_reference<<const wchar_t &, const wchar_t &&>> : __common_reference_impl<const wchar_t &, const wchar_t &&> {
    }
template<> struct common_reference<<const wchar_t &&, const wchar_t &>> : __common_reference_impl<const wchar_t &&, const wchar_t &> {
    }
template<> struct common_reference<<const char8_t *const &, const char8_t *const &>> : __common_reference_impl<const char8_t *const &, const char8_t *const &> {
    }
template<> struct common_reference<<const char8_t &, char8_t &>> : __common_reference_impl<const char8_t &, char8_t &> {
    }
template<> struct common_reference<<char8_t &, const char8_t &>> : __common_reference_impl<char8_t &, const char8_t &> {
    }
template<> struct common_reference<<const char8_t &, const char8_t &&>> : __common_reference_impl<const char8_t &, const char8_t &&> {
    }
template<> struct common_reference<<const char8_t &&, const char8_t &>> : __common_reference_impl<const char8_t &&, const char8_t &> {
    }
template<> struct common_reference<<const char16_t *const &, const char16_t *const &>> : __common_reference_impl<const char16_t *const &, const char16_t *const &> {
    }
template<> struct common_reference<<const char16_t &, char16_t &>> : __common_reference_impl<const char16_t &, char16_t &> {
    }
template<> struct common_reference<<char16_t &, const char16_t &>> : __common_reference_impl<char16_t &, const char16_t &> {
    }
template<> struct common_reference<<const char16_t &, const char16_t &&>> : __common_reference_impl<const char16_t &, const char16_t &&> {
    }
template<> struct common_reference<<const char16_t &&, const char16_t &>> : __common_reference_impl<const char16_t &&, const char16_t &> {
    }
template<> struct common_reference<<const char32_t *const &, const char32_t *const &>> : __common_reference_impl<const char32_t *const &, const char32_t *const &> {
    }
template<> struct common_reference<<const char32_t &, char32_t &>> : __common_reference_impl<const char32_t &, char32_t &> {
    }
template<> struct common_reference<<char32_t &, const char32_t &>> : __common_reference_impl<char32_t &, const char32_t &> {
    }
template<> struct common_reference<<const char32_t &, const char32_t &&>> : __common_reference_impl<const char32_t &, const char32_t &&> {
    }
template<> struct common_reference<<const char32_t &&, const char32_t &>> : __common_reference_impl<const char32_t &&, const char32_t &> {
    }
template<> struct common_reference<<const std::_V2::error_category *const &, const std::_V2::error_category *const &>> : __common_reference_impl<const std::_V2::error_category *const &, const std::_V2::error_category *const &> {
    };
    template <typename ..._Tp> using common_reference_t = typename common_reference<_Tp...>::type;
    template<> struct common_reference<> {
    };
    template <typename _Tp0> struct common_reference<_Tp0> {
        using type = _Tp0;
    };
    template <typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void> struct __common_reference_impl : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1> {
    };
template<> struct __common_reference_impl<const char *const &, const char *const &, 1, void> {
        using type = __common_ref<const char *const &, const char *const &>;
    };
template<> struct __common_reference_impl<const char &, char &, 1, void> {
        using type = __common_ref<const char &, char &>;
    };
template<> struct __common_reference_impl<char &, const char &, 1, void> {
        using type = __common_ref<char &, const char &>;
    };
template<> struct __common_reference_impl<const char &, const char &&, 1, void> {
        using type = __common_ref<const char &, const char &&>;
    };
template<> struct __common_reference_impl<const char &&, const char &, 1, void> {
        using type = __common_ref<const char &&, const char &>;
    };
template<> struct __common_reference_impl<const unsigned long &, const unsigned long &, 1, void> {
        using type = __common_ref<const unsigned long &, const unsigned long &>;
    };
template<> struct __common_reference_impl<const wchar_t *const &, const wchar_t *const &, 1, void> {
        using type = __common_ref<const wchar_t *const &, const wchar_t *const &>;
    };
template<> struct __common_reference_impl<const wchar_t &, wchar_t &, 1, void> {
        using type = __common_ref<const wchar_t &, wchar_t &>;
    };
template<> struct __common_reference_impl<wchar_t &, const wchar_t &, 1, void> {
        using type = __common_ref<wchar_t &, const wchar_t &>;
    };
template<> struct __common_reference_impl<const wchar_t &, const wchar_t &&, 1, void> {
        using type = __common_ref<const wchar_t &, const wchar_t &&>;
    };
template<> struct __common_reference_impl<const wchar_t &&, const wchar_t &, 1, void> {
        using type = __common_ref<const wchar_t &&, const wchar_t &>;
    };
template<> struct __common_reference_impl<const char8_t *const &, const char8_t *const &, 1, void> {
        using type = __common_ref<const char8_t *const &, const char8_t *const &>;
    };
template<> struct __common_reference_impl<const char8_t &, char8_t &, 1, void> {
        using type = __common_ref<const char8_t &, char8_t &>;
    };
template<> struct __common_reference_impl<char8_t &, const char8_t &, 1, void> {
        using type = __common_ref<char8_t &, const char8_t &>;
    };
template<> struct __common_reference_impl<const char8_t &, const char8_t &&, 1, void> {
        using type = __common_ref<const char8_t &, const char8_t &&>;
    };
template<> struct __common_reference_impl<const char8_t &&, const char8_t &, 1, void> {
        using type = __common_ref<const char8_t &&, const char8_t &>;
    };
template<> struct __common_reference_impl<const char16_t *const &, const char16_t *const &, 1, void> {
        using type = __common_ref<const char16_t *const &, const char16_t *const &>;
    };
template<> struct __common_reference_impl<const char16_t &, char16_t &, 1, void> {
        using type = __common_ref<const char16_t &, char16_t &>;
    };
template<> struct __common_reference_impl<char16_t &, const char16_t &, 1, void> {
        using type = __common_ref<char16_t &, const char16_t &>;
    };
template<> struct __common_reference_impl<const char16_t &, const char16_t &&, 1, void> {
        using type = __common_ref<const char16_t &, const char16_t &&>;
    };
template<> struct __common_reference_impl<const char16_t &&, const char16_t &, 1, void> {
        using type = __common_ref<const char16_t &&, const char16_t &>;
    };
template<> struct __common_reference_impl<const char32_t *const &, const char32_t *const &, 1, void> {
        using type = __common_ref<const char32_t *const &, const char32_t *const &>;
    };
template<> struct __common_reference_impl<const char32_t &, char32_t &, 1, void> {
        using type = __common_ref<const char32_t &, char32_t &>;
    };
template<> struct __common_reference_impl<char32_t &, const char32_t &, 1, void> {
        using type = __common_ref<char32_t &, const char32_t &>;
    };
template<> struct __common_reference_impl<const char32_t &, const char32_t &&, 1, void> {
        using type = __common_ref<const char32_t &, const char32_t &&>;
    };
template<> struct __common_reference_impl<const char32_t &&, const char32_t &, 1, void> {
        using type = __common_ref<const char32_t &&, const char32_t &>;
    };
template<> struct __common_reference_impl<const std::_V2::error_category *const &, const std::_V2::error_category *const &, 1, void> {
        using type = __common_ref<const std::_V2::error_category *const &, const std::_V2::error_category *const &>;
    };
    template <typename _Tp1, typename _Tp2> struct common_reference<_Tp1, _Tp2> : __common_reference_impl<_Tp1, _Tp2> {
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &, _Tp2 &, 1, void_t<__common_ref<_Tp1 &, _Tp2 &>>> {
        using type = __common_ref<_Tp1 &, _Tp2 &>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &&, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &&>>> {
        using type = __common_ref<_Tp1 &&, _Tp2 &&>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &, _Tp2 &&>>> {
        using type = __common_ref<_Tp1 &, _Tp2 &&>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &&, _Tp2 &, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &>>> {
        using type = __common_ref<_Tp1 &&, _Tp2 &>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 2, void_t<__basic_common_ref<_Tp1, _Tp2>>> {
        using type = __basic_common_ref<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 3, void_t<__cond_res<_Tp1, _Tp2>>> {
        using type = __cond_res<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 4, void_t<common_type_t<_Tp1, _Tp2>>> {
        using type = common_type_t<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 5, void> {
    };
    template <typename _Tp1, typename _Tp2, typename ..._Rest> struct common_reference<_Tp1, _Tp2, _Rest...> : __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>> {
    };
    template <typename _Tp1, typename _Tp2, typename ..._Rest> struct __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>, void_t<common_reference_t<_Tp1, _Tp2>>> : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...> {
    };
    constexpr bool is_floating_point_v = is_floating_point<double>::value;
    constexpr bool is_integral_v = is_integral<__max_size_type>::value;
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_size_type, __int128);
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_size_type, unsigned __int128);
    constexpr bool is_integral_v = is_integral<int>::value;
    constexpr bool is_integral_v = is_integral<unsigned __int128>::value;
    constexpr bool is_same_v = __is_same(unsigned __int128, __int128);
    constexpr bool is_same_v = __is_same(unsigned __int128, unsigned __int128);
    constexpr bool is_integral_v = is_integral<unsigned long>::value;
    constexpr bool is_integral_v = is_integral<__max_diff_type>::value;
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_diff_type, __int128);
    constexpr bool is_same_v = __is_same(std::ranges::__detail::__max_diff_type, unsigned __int128);
    constexpr bool is_array_v = is_array<char>::value;
    constexpr bool is_trivial_v = is_trivial<char>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char>::value;
    constexpr bool is_same_v = __is_same(char, char);
    constexpr bool is_array_v = is_array<wchar_t>::value;
    constexpr bool is_trivial_v = is_trivial<wchar_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<wchar_t>::value;
    constexpr bool is_same_v = __is_same(wchar_t, wchar_t);
    constexpr bool is_array_v = is_array<char8_t>::value;
    constexpr bool is_trivial_v = is_trivial<char8_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char8_t>::value;
    constexpr bool is_same_v = __is_same(char8_t, char8_t);
    constexpr bool is_array_v = is_array<char16_t>::value;
    constexpr bool is_trivial_v = is_trivial<char16_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char16_t>::value;
    constexpr bool is_same_v = __is_same(char16_t, char16_t);
    constexpr bool is_array_v = is_array<char32_t>::value;
    constexpr bool is_trivial_v = is_trivial<char32_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char32_t>::value;
    constexpr bool is_same_v = __is_same(char32_t, char32_t);
    constexpr bool is_object_v = is_object<const char *>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *>::value;
    constexpr bool is_convertible_v = is_convertible<const char *, const char *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char *&>::value;
    constexpr bool is_reference_v = is_reference<const char *const &>::value;
    constexpr bool is_same_v = __is_same(const char *const &, const char *const &);
    constexpr bool is_convertible_v = is_convertible<const char *const &, const char *const &>::value;
    constexpr bool is_same_v = __is_same(const char *&, const char *&);
    constexpr bool is_class_v = is_class<const char *>::value;
    constexpr bool is_union_v = is_union<const char *>::value;
    constexpr bool is_enum_v = is_enum<const char *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char *>::value;
    constexpr bool is_object_v = is_object<const char>::value;
    constexpr bool is_integral_v = is_integral<long>::value;
    constexpr bool is_signed_v = is_signed<long>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char &>::value;
    constexpr bool is_same_v = __is_same(const char &, const char &);
    constexpr bool is_class_v = is_class<const char *const>::value;
    constexpr bool is_union_v = is_union<const char *const>::value;
    constexpr bool is_enum_v = is_enum<const char *const>::value;
    constexpr bool is_same_v = __is_same(const char &&, const char &&);
    constexpr bool is_reference_v = is_reference<const char &>::value;
    constexpr bool is_convertible_v = is_convertible<const char &, const char &>::value;
    constexpr bool is_convertible_v = is_convertible<char &, const char &>::value;
    constexpr bool is_convertible_v = is_convertible<const char &&, const char &>::value;
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile input_iterator_tag *>::value;
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile forward_iterator_tag *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char *&, const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char *const &, const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char *const, const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *>::value;
    constexpr bool is_convertible_v = is_convertible<bool, bool>::value;
    constexpr bool is_same_v = __is_same(const char *, const char *);
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile bidirectional_iterator_tag *>::value;
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile random_access_iterator_tag *>::value;
    constexpr bool is_same_v = __is_same(long, long);
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile contiguous_iterator_tag *>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, unsigned long>::value;
    constexpr bool is_convertible_v = is_convertible<unsigned long, unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, unsigned long &>::value;
    constexpr bool is_convertible_v = is_convertible<unsigned long &, unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, const unsigned long &>::value;
    constexpr bool is_convertible_v = is_convertible<const unsigned long &, unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, const unsigned long>::value;
    constexpr bool is_convertible_v = is_convertible<const unsigned long, unsigned long>::value;
    constexpr bool is_object_v = is_object<unsigned long>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<unsigned long &>::value;
    constexpr bool is_reference_v = is_reference<const unsigned long &>::value;
    constexpr bool is_same_v = __is_same(const unsigned long &, const unsigned long &);
    constexpr bool is_convertible_v = is_convertible<const unsigned long &, const unsigned long &>::value;
    constexpr bool is_same_v = __is_same(unsigned long &, unsigned long &);
    constexpr bool is_class_v = is_class<unsigned long>::value;
    constexpr bool is_union_v = is_union<unsigned long>::value;
    constexpr bool is_enum_v = is_enum<unsigned long>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<unsigned long>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long>::value;
    constexpr bool is_object_v = is_object<const wchar_t *>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *, const wchar_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const wchar_t *&>::value;
    constexpr bool is_reference_v = is_reference<const wchar_t *const &>::value;
    constexpr bool is_same_v = __is_same(const wchar_t *const &, const wchar_t *const &);
    constexpr bool is_convertible_v = is_convertible<const wchar_t *const &, const wchar_t *const &>::value;
    constexpr bool is_same_v = __is_same(const wchar_t *&, const wchar_t *&);
    constexpr bool is_class_v = is_class<const wchar_t *>::value;
    constexpr bool is_union_v = is_union<const wchar_t *>::value;
    constexpr bool is_enum_v = is_enum<const wchar_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const wchar_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const wchar_t *>::value;
    constexpr bool is_object_v = is_object<const wchar_t>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const wchar_t &>::value;
    constexpr bool is_same_v = __is_same(const wchar_t &, const wchar_t &);
    constexpr bool is_class_v = is_class<const wchar_t *const>::value;
    constexpr bool is_union_v = is_union<const wchar_t *const>::value;
    constexpr bool is_enum_v = is_enum<const wchar_t *const>::value;
    constexpr bool is_same_v = __is_same(const wchar_t &&, const wchar_t &&);
    constexpr bool is_reference_v = is_reference<const wchar_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t &, const wchar_t &>::value;
    constexpr bool is_convertible_v = is_convertible<wchar_t &, const wchar_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t &&, const wchar_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *&, const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *const &, const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *const, const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *>::value;
    constexpr bool is_same_v = __is_same(const wchar_t *, const wchar_t *);
    constexpr bool is_object_v = is_object<const char8_t *>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *, const char8_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char8_t *&>::value;
    constexpr bool is_reference_v = is_reference<const char8_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char8_t *const &, const char8_t *const &);
    constexpr bool is_convertible_v = is_convertible<const char8_t *const &, const char8_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char8_t *&, const char8_t *&);
    constexpr bool is_class_v = is_class<const char8_t *>::value;
    constexpr bool is_union_v = is_union<const char8_t *>::value;
    constexpr bool is_enum_v = is_enum<const char8_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char8_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char8_t *>::value;
    constexpr bool is_object_v = is_object<const char8_t>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char8_t &>::value;
    constexpr bool is_same_v = __is_same(const char8_t &, const char8_t &);
    constexpr bool is_class_v = is_class<const char8_t *const>::value;
    constexpr bool is_union_v = is_union<const char8_t *const>::value;
    constexpr bool is_enum_v = is_enum<const char8_t *const>::value;
    constexpr bool is_same_v = __is_same(const char8_t &&, const char8_t &&);
    constexpr bool is_reference_v = is_reference<const char8_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t &, const char8_t &>::value;
    constexpr bool is_convertible_v = is_convertible<char8_t &, const char8_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t &&, const char8_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *&, const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *const &, const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *const, const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *>::value;
    constexpr bool is_same_v = __is_same(const char8_t *, const char8_t *);
    constexpr bool is_object_v = is_object<const char16_t *>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *, const char16_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char16_t *&>::value;
    constexpr bool is_reference_v = is_reference<const char16_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char16_t *const &, const char16_t *const &);
    constexpr bool is_convertible_v = is_convertible<const char16_t *const &, const char16_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char16_t *&, const char16_t *&);
    constexpr bool is_class_v = is_class<const char16_t *>::value;
    constexpr bool is_union_v = is_union<const char16_t *>::value;
    constexpr bool is_enum_v = is_enum<const char16_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char16_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char16_t *>::value;
    constexpr bool is_object_v = is_object<const char16_t>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char16_t &>::value;
    constexpr bool is_same_v = __is_same(const char16_t &, const char16_t &);
    constexpr bool is_class_v = is_class<const char16_t *const>::value;
    constexpr bool is_union_v = is_union<const char16_t *const>::value;
    constexpr bool is_enum_v = is_enum<const char16_t *const>::value;
    constexpr bool is_same_v = __is_same(const char16_t &&, const char16_t &&);
    constexpr bool is_reference_v = is_reference<const char16_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t &, const char16_t &>::value;
    constexpr bool is_convertible_v = is_convertible<char16_t &, const char16_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t &&, const char16_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *&, const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *const &, const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *const, const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *>::value;
    constexpr bool is_same_v = __is_same(const char16_t *, const char16_t *);
    constexpr bool is_object_v = is_object<const char32_t *>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *, const char32_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char32_t *&>::value;
    constexpr bool is_reference_v = is_reference<const char32_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char32_t *const &, const char32_t *const &);
    constexpr bool is_convertible_v = is_convertible<const char32_t *const &, const char32_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char32_t *&, const char32_t *&);
    constexpr bool is_class_v = is_class<const char32_t *>::value;
    constexpr bool is_union_v = is_union<const char32_t *>::value;
    constexpr bool is_enum_v = is_enum<const char32_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char32_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char32_t *>::value;
    constexpr bool is_object_v = is_object<const char32_t>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char32_t &>::value;
    constexpr bool is_same_v = __is_same(const char32_t &, const char32_t &);
    constexpr bool is_class_v = is_class<const char32_t *const>::value;
    constexpr bool is_union_v = is_union<const char32_t *const>::value;
    constexpr bool is_enum_v = is_enum<const char32_t *const>::value;
    constexpr bool is_same_v = __is_same(const char32_t &&, const char32_t &&);
    constexpr bool is_reference_v = is_reference<const char32_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t &, const char32_t &>::value;
    constexpr bool is_convertible_v = is_convertible<char32_t &, const char32_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t &&, const char32_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *&, const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *const &, const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *const, const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *>::value;
    constexpr bool is_same_v = __is_same(const char32_t *, const char32_t *);
    constexpr bool is_same_v = __is_same(std::partial_ordering, std::partial_ordering);
    constexpr bool is_reference_v = is_reference<const error_category *const &>::value;
    constexpr bool is_same_v = __is_same(const std::_V2::error_category *const &, const std::_V2::error_category *const &);
    constexpr bool is_convertible_v = is_convertible<const error_category *const &, const error_category *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const error_category *, const volatile void *>::value;
    constexpr bool is_object_v = is_object<char>::value;
    constexpr bool is_class_v = is_class<basic_ostream<char> &>::value;
    constexpr bool is_object_v = is_object<wchar_t>::value;
}
namespace std {
    namespace __detail {
        template <typename _Tp, typename _Up> concept __same_as = std::is_same_v<_Tp, _Up>;;
    }
    template <typename _Tp, typename _Up> concept same_as = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;;
    template <typename _Derived, typename _Base> concept derived_from = __is_base_of(_Base, _Derived) && is_convertible_v<const volatile _Derived *, const volatile _Base *>;;
    template <typename _From, typename _To> concept convertible_to = is_convertible_v<_From, _To> && requires { static_cast<_To>(std::declval<_From>()); };;
    template <typename _Tp, typename _Up> concept common_reference_with = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> && convertible_to<_Tp, common_reference_t<_Tp, _Up>> && convertible_to<_Up, common_reference_t<_Tp, _Up>>;;
    template <typename _Tp, typename _Up> concept common_with = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>> && requires { static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>()); static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>()); } && common_reference_with<add_lvalue_reference_t<const _Tp>, add_lvalue_reference_t<const _Up>> && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>, common_reference_t<add_lvalue_reference_t<const _Tp>, add_lvalue_reference_t<const _Up>>>;;
    template <typename _Tp> concept integral = is_integral_v<_Tp>;;
    template <typename _Tp> concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;;
    template <typename _Tp> concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;;
    template <typename _Tp> concept floating_point = is_floating_point_v<_Tp>;;
    namespace __detail {
        template <typename _Tp> using __cref = const remove_reference_t<_Tp> &;
        template <typename _Tp> concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;;
    }
    template <typename _Lhs, typename _Rhs> concept assignable_from = is_lvalue_reference_v<_Lhs> && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>> && requires (_Lhs __lhs, _Rhs &&__rhs) { { __lhs = static_cast<_Rhs &&>(__rhs) } -> same_as<_Lhs>; };;
    template <typename _Tp> concept destructible = is_nothrow_destructible_v<_Tp>;;
    template <typename _Tp, typename ..._Args> concept constructible_from = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;;
    template <typename _Tp> concept default_initializable = constructible_from<_Tp> && requires { _Tp({}); (void)::new _Tp; };;
    template <typename _Tp> concept move_constructible = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;;
    template <typename _Tp> concept copy_constructible = move_constructible<_Tp> && constructible_from<_Tp, _Tp &> && convertible_to<_Tp &, _Tp> && constructible_from<_Tp, const _Tp &> && convertible_to<const _Tp &, _Tp> && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;;
    namespace ranges {
        namespace __cust_swap {
            template <typename _Tp> void swap(_Tp &, _Tp &) = delete
            template <typename _Tp, typename _Up> concept __adl_swap = (__detail::__class_or_enum<remove_reference_t<_Tp>> || __detail::__class_or_enum<remove_reference_t<_Up>>) && requires (_Tp &&__t, _Up &&__u) { swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); };;
            struct _Swap {
            private:
                template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()                 {
                    if (__adl_swap<_Tp, _Up>)
                        return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<_Tp>> && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
                }
                template<> static constexpr bool _S_noexcept<const char *&, const char *&>()                 {
                    if (__adl_swap<const char *&, const char *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char *&>>;
                }
                template<> static constexpr bool _S_noexcept<unsigned long &, unsigned long &>()                 {
                    if (__adl_swap<unsigned long &, unsigned long &>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<unsigned long &>> && is_nothrow_move_assignable_v<remove_reference_t<unsigned long &>>;
                }
                template<> static constexpr bool _S_noexcept<const wchar_t *&, const wchar_t *&>()                 {
                    if (__adl_swap<const wchar_t *&, const wchar_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const wchar_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const wchar_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char8_t *&, const char8_t *&>()                 {
                    if (__adl_swap<const char8_t *&, const char8_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char8_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char8_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char16_t *&, const char16_t *&>()                 {
                    if (__adl_swap<const char16_t *&, const char16_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char16_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char16_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char32_t *&, const char32_t *&>()                 {
                    if (__adl_swap<const char32_t *&, const char32_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char32_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char32_t *&>>;
                }
            public:
                template <typename _Tp, typename _Up> constexpr void operator()(_Tp &&__t, _Up &&__u) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__t, _Up &&__u) const noexcept(_S_noexcept<_Tp, _Up>())                 {
                    if (__adl_swap<_Tp, _Up>)
                        swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
                    else {
                        auto __tmp = static_cast<remove_reference_t<_Tp> &&>(__t);
                        __t = static_cast<remove_reference_t<_Tp> &&>(__u);
                        __u = static_cast<remove_reference_t<_Tp> &&>(__tmp);
                    }
                }
                template<> constexpr void operator()<const char *&, const char *&>(const char *&__t, const char *&__u) const noexcept(_S_noexcept<const char *&, const char *&>()operator()<const char *&, const char *&>(const char *&__t, const char *&__u) const noexcept(_S_noexcept<const char *&, const char *&>())                template<> constexpr void operator()<unsigned long &, unsigned long &>(unsigned long &__t, unsigned long &__u) const noexcept(_S_noexcept<unsigned long &, unsigned long &>()operator()<unsigned long &, unsigned long &>(unsigned long &__t, unsigned long &__u) const noexcept(_S_noexcept<unsigned long &, unsigned long &>())                template<> constexpr void operator()<const wchar_t *&, const wchar_t *&>(const wchar_t *&__t, const wchar_t *&__u) const noexcept(_S_noexcept<const wchar_t *&, const wchar_t *&>()operator()<const wchar_t *&, const wchar_t *&>(const wchar_t *&__t, const wchar_t *&__u) const noexcept(_S_noexcept<const wchar_t *&, const wchar_t *&>())                template<> constexpr void operator()<const char8_t *&, const char8_t *&>(const char8_t *&__t, const char8_t *&__u) const noexcept(_S_noexcept<const char8_t *&, const char8_t *&>()operator()<const char8_t *&, const char8_t *&>(const char8_t *&__t, const char8_t *&__u) const noexcept(_S_noexcept<const char8_t *&, const char8_t *&>())                template<> constexpr void operator()<const char16_t *&, const char16_t *&>(const char16_t *&__t, const char16_t *&__u) const noexcept(_S_noexcept<const char16_t *&, const char16_t *&>()operator()<const char16_t *&, const char16_t *&>(const char16_t *&__t, const char16_t *&__u) const noexcept(_S_noexcept<const char16_t *&, const char16_t *&>())                template<> constexpr void operator()<const char32_t *&, const char32_t *&>(const char32_t *&__t, const char32_t *&__u) const noexcept(_S_noexcept<const char32_t *&, const char32_t *&>()operator()<const char32_t *&, const char32_t *&>(const char32_t *&__t, const char32_t *&__u) const noexcept(_S_noexcept<const char32_t *&, const char32_t *&>())                template <typename _Tp, typename _Up, std::size_t _Num> constexpr void operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const noexcept(noexcept(std::declval<const std::ranges::__cust_swap::_Swap &>()(*__e1, *__e2))operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const noexcept(noexcept(std::declval<const std::ranges::__cust_swap::_Swap &>()(*__e1, *__e2)))                 {
                    for (std::size_t __n = 0; __n < _Num; ++__n)
                        (*this)(__e1[__n], __e2[__n]);
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_swap::_Swap swap{};
        }
    }
    template <typename _Tp> concept swappable = requires (_Tp &__a, _Tp &__b) { ranges::swap(__a, __b); };;
    template <typename _Tp, typename _Up> concept swappable_with = common_reference_with<_Tp, _Up> && requires (_Tp &&__t, _Up &&__u) { ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Tp &&>(__t)); ranges::swap(static_cast<_Up &&>(__u), static_cast<_Up &&>(__u)); ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); ranges::swap(static_cast<_Up &&>(__u), static_cast<_Tp &&>(__t)); };;
    template <typename _Tp> concept movable = is_object_v<_Tp> && move_constructible<_Tp> && assignable_from<_Tp &, _Tp> && swappable<_Tp>;;
    template <typename _Tp> concept copyable = copy_constructible<_Tp> && movable<_Tp> && assignable_from<_Tp &, _Tp &> && assignable_from<_Tp &, const _Tp &> && assignable_from<_Tp &, const _Tp>;;
    template <typename _Tp> concept semiregular = copyable<_Tp> && default_initializable<_Tp>;;
    namespace __detail {
        template <typename _Tp> concept __boolean_testable_impl = convertible_to<_Tp, bool>;;
        template <typename _Tp> concept __boolean_testable = __boolean_testable_impl<_Tp> && requires (_Tp &&__t) { { !static_cast<_Tp &&>(__t) } -> __boolean_testable_impl; };;
    }
    namespace __detail {
        template <typename _Tp, typename _Up> concept __weakly_eq_cmp_with = requires (__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) { { __t == __u } -> __boolean_testable; { __t != __u } -> __boolean_testable; { __u == __t } -> __boolean_testable; { __u != __t } -> __boolean_testable; };;
    }
    template <typename _Tp> concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;;
    template <typename _Tp, typename _Up> concept equality_comparable_with = equality_comparable<_Tp> && equality_comparable<_Up> && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>> && equality_comparable<common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> && __detail::__weakly_eq_cmp_with<_Tp, _Up>;;
    namespace __detail {
        template <typename _Tp, typename _Up> concept __partially_ordered_with = requires (const remove_reference_t<_Tp> &__t, const remove_reference_t<_Up> &__u) { { __t < __u } -> __boolean_testable; { __t > __u } -> __boolean_testable; { __t <= __u } -> __boolean_testable; { __t >= __u } -> __boolean_testable; { __u < __t } -> __boolean_testable; { __u > __t } -> __boolean_testable; { __u <= __t } -> __boolean_testable; { __u >= __t } -> __boolean_testable; };;
    }
    template <typename _Tp> concept totally_ordered = equality_comparable<_Tp> && __detail::__partially_ordered_with<_Tp, _Tp>;;
    template <typename _Tp, typename _Up> concept totally_ordered_with = totally_ordered<_Tp> && totally_ordered<_Up> && equality_comparable_with<_Tp, _Up> && totally_ordered<common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> && __detail::__partially_ordered_with<_Tp, _Up>;;
    template <typename _Tp> concept regular = semiregular<_Tp> && equality_comparable<_Tp>;;
    template <typename _Fn, typename ..._Args> concept invocable = is_invocable_v<_Fn, _Args...>;;
    template <typename _Fn, typename ..._Args> concept regular_invocable = invocable<_Fn, _Args...>;;
    template <typename _Fn, typename ..._Args> concept predicate = regular_invocable<_Fn, _Args...> && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;;
    template <typename _Rel, typename _Tp, typename _Up> concept relation = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up> && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;;
    template <typename _Rel, typename _Tp, typename _Up> concept equivalence_relation = relation<_Rel, _Tp, _Up>;;
    template <typename _Rel, typename _Tp, typename _Up> concept strict_weak_order = relation<_Rel, _Tp, _Up>;;
}
namespace std {
    namespace __cmp_cat {
        using type = signed char;
        enum class _Ord : std::__cmp_cat::type {
            equivalent = 0,
            less = -1,
            greater = 1
        };
        enum class _Ncmp : std::__cmp_cat::type {
            _Unordered = 2
        };
        struct __unspec {
            constexpr __unspec(std::__cmp_cat::__unspec *) noexcept             {
            }
        };
    }
    class partial_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit partial_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
        constexpr explicit partial_ordering(__cmp_cat::_Ncmp __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
        friend  class weak_ordering;
        friend  class strong_ordering;
    public:
        static const std::partial_ordering less;
        static const std::partial_ordering equivalent;
        static const std::partial_ordering greater;
        static const std::partial_ordering unordered;
        friend constexpr bool operator==(std::partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value == 0;
        }
;
        friend bool operator==(std::partial_ordering, std::partial_ordering) noexcept [[nodiscard("")]] = default;
        friend constexpr bool operator<(std::partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value == -1;
        }
;
        friend constexpr bool operator>(std::partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value == 1;
        }
;
        friend constexpr bool operator<=(std::partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(std::partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, std::partial_ordering __v) noexcept [[nodiscard("")]]         {
            return __v._M_value == 1;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, std::partial_ordering __v) noexcept [[nodiscard("")]]         {
            return __v._M_value == -1;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, std::partial_ordering __v) noexcept [[nodiscard("")]]         {
            return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, std::partial_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 >= __v._M_value;
        }
;
        friend constexpr std::partial_ordering operator<=>(std::partial_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v;
        }
;
        friend constexpr std::partial_ordering operator<=>(__cmp_cat::__unspec, std::partial_ordering __v) noexcept [[nodiscard("")]]         {
            if (__v._M_value & 1)
                return std::partial_ordering(__cmp_cat::_Ord(-__v._M_value));
            else
                return __v;
        }
;
    };
    constexpr std::partial_ordering less(__cmp_cat::_Ord::less);
    constexpr std::partial_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr std::partial_ordering greater(__cmp_cat::_Ord::greater);
    constexpr std::partial_ordering unordered(__cmp_cat::_Ncmp::_Unordered);
    class weak_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
        friend  class strong_ordering;
    public:
        static const std::weak_ordering less;
        static const std::weak_ordering equivalent;
        static const std::weak_ordering greater;
        constexpr operator partial_ordering() const noexcept [[nodiscard("")]]         {
            return std::partial_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        friend constexpr bool operator==(std::weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value == 0;
        }
;
        friend bool operator==(std::weak_ordering, std::weak_ordering) noexcept [[nodiscard("")]] = default;
        friend constexpr bool operator<(std::weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value < 0;
        }
;
        friend constexpr bool operator>(std::weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value > 0;
        }
;
        friend constexpr bool operator<=(std::weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(std::weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value >= 0;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, std::weak_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 < __v._M_value;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, std::weak_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 > __v._M_value;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, std::weak_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 <= __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, std::weak_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 >= __v._M_value;
        }
;
        friend constexpr std::weak_ordering operator<=>(std::weak_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v;
        }
;
        friend constexpr std::weak_ordering operator<=>(__cmp_cat::__unspec, std::weak_ordering __v) noexcept [[nodiscard("")]]         {
            return std::weak_ordering(__cmp_cat::_Ord(-__v._M_value));
        }
;
    };
    constexpr std::weak_ordering less(__cmp_cat::_Ord::less);
    constexpr std::weak_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr std::weak_ordering greater(__cmp_cat::_Ord::greater);
    class strong_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit strong_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
    public:
        static const std::strong_ordering less;
        static const std::strong_ordering equal;
        static const std::strong_ordering equivalent;
        static const std::strong_ordering greater;
        constexpr operator partial_ordering() const noexcept [[nodiscard("")]]         {
            return std::partial_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        constexpr operator weak_ordering() const noexcept [[nodiscard("")]]         {
            return std::weak_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        friend constexpr bool operator==(std::strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value == 0;
        }
;
        friend bool operator==(std::strong_ordering, std::strong_ordering) noexcept [[nodiscard("")]] = default;
        friend constexpr bool operator<(std::strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value < 0;
        }
;
        friend constexpr bool operator>(std::strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value > 0;
        }
;
        friend constexpr bool operator<=(std::strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(std::strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v._M_value >= 0;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, std::strong_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 < __v._M_value;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, std::strong_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 > __v._M_value;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, std::strong_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 <= __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, std::strong_ordering __v) noexcept [[nodiscard("")]]         {
            return 0 >= __v._M_value;
        }
;
        friend constexpr std::strong_ordering operator<=>(std::strong_ordering __v, __cmp_cat::__unspec) noexcept [[nodiscard("")]]         {
            return __v;
        }
;
        friend constexpr std::strong_ordering operator<=>(__cmp_cat::__unspec, std::strong_ordering __v) noexcept [[nodiscard("")]]         {
            return std::strong_ordering(__cmp_cat::_Ord(-__v._M_value));
        }
;
    };
    constexpr std::strong_ordering less(__cmp_cat::_Ord::less);
    constexpr std::strong_ordering equal(__cmp_cat::_Ord::equivalent);
    constexpr std::strong_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr std::strong_ordering greater(__cmp_cat::_Ord::greater);
    constexpr bool is_eq(std::partial_ordering __cmp) noexcept [[nodiscard("")]]     {
        return __cmp == 0;
    }
    constexpr bool is_neq(std::partial_ordering __cmp) noexcept [[nodiscard("")]]     {
        return __cmp != 0;
    }
    constexpr bool is_lt(std::partial_ordering __cmp) noexcept [[nodiscard("")]]     {
        return __cmp < 0;
    }
    constexpr bool is_lteq(std::partial_ordering __cmp) noexcept [[nodiscard("")]]     {
        return __cmp <= 0;
    }
    constexpr bool is_gt(std::partial_ordering __cmp) noexcept [[nodiscard("")]]     {
        return __cmp > 0;
    }
    constexpr bool is_gteq(std::partial_ordering __cmp) noexcept [[nodiscard("")]]     {
        return __cmp >= 0;
    }
    namespace __detail {
        template <typename _Tp> constexpr unsigned int __cmp_cat_id = 1;
        constexpr unsigned int __cmp_cat_id = 2;
        constexpr unsigned int __cmp_cat_id = 4;
        constexpr unsigned int __cmp_cat_id = 8;
        template <typename ..._Ts> constexpr auto __common_cmp_cat()         {
            constexpr unsigned int __cats = (__cmp_cat_id<_Ts> | ...);
            if (__cats & 1)
                return;
            else if (bool(__cats & __cmp_cat_id<std::partial_ordering>))
                return partial_ordering::equivalent;
            else if (bool(__cats & __cmp_cat_id<std::weak_ordering>))
                return weak_ordering::equivalent;
            else
                return strong_ordering::equivalent;
        }
        template<> constexpr std::partial_ordering __common_cmp_cat<<std::strong_ordering, std::partial_ordering>>()         {
            constexpr unsigned int __cats = __cmp_cat_id<std::strong_ordering> | __cmp_cat_id<std::partial_ordering>;
            if (__cats & 1)
                ;
            else if (bool(__cats & __cmp_cat_id<std::partial_ordering>))
                return partial_ordering::equivalent;
        }
    }
    template <typename ..._Ts> struct common_comparison_category {
        using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };
template<> struct common_comparison_category<<std::strong_ordering, std::partial_ordering>> {
        using type = decltype(__detail::__common_cmp_cat<std::strong_ordering, std::partial_ordering>());
    };
    template <typename _Tp> struct common_comparison_category<_Tp> {
        using type = void;
    };
    template<> struct common_comparison_category<std::partial_ordering> {
        using type = std::partial_ordering;
    };
    template<> struct common_comparison_category<std::weak_ordering> {
        using type = std::weak_ordering;
    };
    template<> struct common_comparison_category<std::strong_ordering> {
        using type = std::strong_ordering;
    };
    template<> struct common_comparison_category<> {
        using type = std::strong_ordering;
    };
    template <typename ..._Ts> using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;
    namespace __detail {
        template <typename _Tp, typename _Cat> concept __compares_as = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;;
    }
    template <typename _Tp, typename _Cat = std::partial_ordering> concept three_way_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp> && __detail::__partially_ordered_with<_Tp, _Tp> && requires (const remove_reference_t<_Tp> &__a, const remove_reference_t<_Tp> &__b) { { __a <=> __b } -> __detail::__compares_as<_Cat>; };;
    template <typename _Tp, typename _Up, typename _Cat = std::partial_ordering> concept three_way_comparable_with = three_way_comparable<_Tp, _Cat> && three_way_comparable<_Up, _Cat> && common_reference_with<const remove_reference_t<_Tp> &, const remove_reference_t<_Up> &> && three_way_comparable<common_reference_t<const remove_reference_t<_Tp> &, const remove_reference_t<_Up> &>, _Cat> && __detail::__weakly_eq_cmp_with<_Tp, _Up> && __detail::__partially_ordered_with<_Tp, _Up> && requires (const remove_reference_t<_Tp> &__t, const remove_reference_t<_Up> &__u) { { __t <=> __u } -> __detail::__compares_as<_Cat>; { __u <=> __t } -> __detail::__compares_as<_Cat>; };;
    namespace __detail {
        template <typename _Tp, typename _Up> using __cmp3way_res_t = decltype(std::declval<_Tp>() <=> std::declval<_Up>());
        template <typename _Tp, typename _Up> struct __cmp3way_res_impl {
        };
        template <typename _Tp, typename _Up> struct __cmp3way_res_impl<_Tp, _Up> {
            using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
        };
    }
    template <typename _Tp, typename _Up = _Tp> struct compare_three_way_result : __detail::__cmp3way_res_impl<_Tp, _Up> {
    };
    template <typename _Tp, typename _Up = _Tp> using compare_three_way_result_t = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;
    namespace __detail {
        template <typename _Tp, typename _Up> concept __3way_builtin_ptr_cmp = requires (_Tp &&__t, _Up &&__u) { static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u); } && convertible_to<_Tp, const volatile void *> && convertible_to<_Up, const volatile void *> && !requires (_Tp &&__t, _Up &&__u) { operator<=>(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); } && !requires (_Tp &&__t, _Up &&__u) { static_cast<_Tp &&>(__t).operator<=>(static_cast<_Up &&>(__u)); };;
    }
    struct compare_three_way {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>())) [[nodiscard("")]]         {
            if (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>) {
                auto __pt = static_cast<const volatile void *>(__t);
                auto __pu = static_cast<const volatile void *>(__u);
                if (std::__is_constant_evaluated())
                    return __pt <=> __pu;
                auto __it = reinterpret_cast<unsigned long>(__pt);
                auto __iu = reinterpret_cast<unsigned long>(__pu);
                return __it <=> __iu;
            } else
                return static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u);
        }
        template<> constexpr std::strong_ordering operator()<const std::_V2::error_category *, const std::_V2::error_category *>(const std::_V2::error_category *&&__t, const std::_V2::error_category *&&__u) const noexcept(noexcept(std::declval<const std::_V2::error_category *>() <=> std::declval<const std::_V2::error_category *>())operator()<const std::_V2::error_category *, const std::_V2::error_category *>(const std::_V2::error_category *&&__t, const std::_V2::error_category *&&__u) const noexcept(noexcept(std::declval<const std::_V2::error_category *>() <=> std::declval<const std::_V2::error_category *>())) [[nodiscard("")]]         {
            if (__detail::__3way_builtin_ptr_cmp<const std::_V2::error_category *, const std::_V2::error_category *>) {
                auto __pt = static_cast<const volatile void *>(__t);
                auto __pu = static_cast<const volatile void *>(__u);
                if (std::__is_constant_evaluated())
                    return __pt <=> __pu;
                auto __it = reinterpret_cast<unsigned long>(__pt);
                auto __iu = reinterpret_cast<unsigned long>(__pu);
                return __it <=> __iu;
            }
        }
        using is_transparent = void;
    };
    namespace __cmp_cust {
        template <floating_point _Tp> constexpr std::weak_ordering __fp_weak_ordering(_Tp __e, _Tp __f)         {
            auto __cat = [](_Tp __fp) -> int {
                const int __sign = __builtin_signbit(__fp) ? -1 : 1;
                if (__builtin_isnormal(__fp))
                    return (__fp == 0 ? 1 : 3) * __sign;
                if (__builtin_isnan(__fp))
                    return 5 * __sign;
                if (int __inf = __builtin_isinf_sign(__fp))
                    return 4 * __inf;
                return 2 * __sign;
            };
            auto __po = __e <=> __f;
            if (is_lt(__po))
                return weak_ordering::less;
            else if (is_gt(__po))
                return weak_ordering::greater;
            else if (__po == partial_ordering::equivalent)
                return weak_ordering::equivalent;
            else {
                auto __isnan_sign = [](_Tp __fp) -> int {
                    return __builtin_isnan(__fp) ? __builtin_signbit(__fp) ? -1 : 1 : 0;
                };
                auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
                if (is_eq(__ord))
                    return weak_ordering::equivalent;
                else if (is_lt(__ord))
                    return weak_ordering::less;
                else
                    return weak_ordering::greater;
            }
        }
        template <typename _Tp, typename _Up> concept __adl_strong = requires (_Tp &&__t, _Up &&__u) { std::strong_ordering(strong_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Tp, typename _Up> concept __adl_weak = requires (_Tp &&__t, _Up &&__u) { std::weak_ordering(weak_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Tp, typename _Up> concept __adl_partial = requires (_Tp &&__t, _Up &&__u) { std::partial_ordering(partial_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Ord, typename _Tp, typename _Up> concept __cmp3way = requires (_Tp &&__t, _Up &&__u, std::compare_three_way __c) { _Ord(__c(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Tp, typename _Up> concept __strongly_ordered = __adl_strong<_Tp, _Up> || floating_point<remove_reference_t<_Tp>> || __cmp3way<std::strong_ordering, _Tp, _Up>;;
        template <typename _Tp, typename _Up> concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;;
        class _Strong_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (floating_point<decay_t<_Tp>>)
                    return true;
                else if (__adl_strong<_Tp, _Up>)
                    return noexcept(std::strong_ordering(strong_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<std::strong_ordering, _Tp, _Up>)
                    return noexcept(std::compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
            }
            friend  class _Weak_order;
            friend  class _Strong_fallback;
            enum class _Fp_fmt : int {
                _Binary16,
                _Binary32,
                _Binary64,
                _Binary128,
                _X86_80bit,
                _M68k_80bit,
                _Dbldbl
            };
            static constexpr std::__cmp_cust::_Strong_order::_Fp_fmt _Binary16 = _Fp_fmt::_Binary16;
            static constexpr std::__cmp_cust::_Strong_order::_Fp_fmt _Binary32 = _Fp_fmt::_Binary32;
            static constexpr std::__cmp_cust::_Strong_order::_Fp_fmt _Binary64 = _Fp_fmt::_Binary64;
            static constexpr std::__cmp_cust::_Strong_order::_Fp_fmt _Binary128 = _Fp_fmt::_Binary128;
            static constexpr std::__cmp_cust::_Strong_order::_Fp_fmt _X86_80bit = _Fp_fmt::_X86_80bit;
            static constexpr std::__cmp_cust::_Strong_order::_Fp_fmt _M68k_80bit = _Fp_fmt::_M68k_80bit;
            static constexpr std::__cmp_cust::_Strong_order::_Fp_fmt _Dbldbl = _Fp_fmt::_Dbldbl;
            template <typename _Tp> static consteval std::__cmp_cust::_Strong_order::_Fp_fmt _S_fp_fmt() noexcept             {
                if (__is_same(_Tp, long double))
                    return (-16381) == -16381 ? _X86_80bit : _M68k_80bit;
                constexpr int __width = sizeof(_Tp) * 8;
                if (__width == 16)
                    return _Binary16;
                else if (__width == 32)
                    return _Binary32;
                else if (__width == 64)
                    return _Binary64;
                else if (__width == 128)
                    return _Binary128;
            }
            using int64_t = long;
            using int32_t = int;
            using int16_t = short;
            using uint64_t = unsigned long;
            using uint16_t = unsigned short;
            template <typename _Tp> struct _Int {
                std::__cmp_cust::_Strong_order::uint64_t _M_lo;
                _Tp _M_hi;
                constexpr explicit _Int<_Tp>(_Tp __hi, std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept : _M_hi(__hi)                 {
                    this->_M_lo = __lo;
                }
                constexpr explicit _Int<_Tp>(std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept : _M_hi(0)                 {
                    this->_M_lo = __lo;
                }
                bool operator==(const _Int<_Tp> &) const = default
                constexpr _Int<_Tp> &operator^=(const _Int<_Tp> &__rhs) noexcept                 {
                    this->_M_hi ^= __rhs._M_hi;
                    this->_M_lo ^= __rhs._M_lo;
                    return *this;
                }
                constexpr std::strong_ordering operator<=>(const _Int<_Tp> &__rhs) const noexcept                 {
                    std::strong_ordering __cmp = this->_M_hi <=> __rhs._M_hi;
                    if (__cmp != strong_ordering::equal)
                        return __cmp;
                    return this->_M_lo <=> __rhs._M_lo;
                }
            };
template<> struct _Int<int> {
                std::__cmp_cust::_Strong_order::uint64_t _M_lo;
                int _M_hi;
                constexpr explicit _Int(int __hi, std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept;
                constexpr explicit _Int(std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept;
                bool operator==(const std::__cmp_cust::_Strong_order::_Int<int> &) const = default
                constexpr std::__cmp_cust::_Strong_order::_Int<int> &operator^=(const std::__cmp_cust::_Strong_order::_Int<int> &__rhs) noexcept;
                constexpr std::strong_ordering operator<=>(const std::__cmp_cust::_Strong_order::_Int<int> &__rhs) const noexcept;
            };
template<> struct _Int<short> {
                std::__cmp_cust::_Strong_order::uint64_t _M_lo;
                short _M_hi;
                constexpr explicit _Int(short __hi, std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept : _M_hi(__hi)                 {
                    this->_M_lo = __lo;
                }
                constexpr explicit _Int(std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept;
                bool operator==(const std::__cmp_cust::_Strong_order::_Int<short> &) const = default
                constexpr std::__cmp_cust::_Strong_order::_Int<short> &operator^=(const std::__cmp_cust::_Strong_order::_Int<short> &__rhs) noexcept;
                constexpr std::strong_ordering operator<=>(const std::__cmp_cust::_Strong_order::_Int<short> &__rhs) const noexcept;
            };
template<> struct _Int<long> {
                std::__cmp_cust::_Strong_order::uint64_t _M_lo;
                long _M_hi;
                constexpr explicit _Int(long __hi, std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept;
                constexpr explicit _Int(std::__cmp_cust::_Strong_order::uint64_t __lo) noexcept;
                bool operator==(const std::__cmp_cust::_Strong_order::_Int<long> &) const = default
                constexpr std::__cmp_cust::_Strong_order::_Int<long> &operator^=(const std::__cmp_cust::_Strong_order::_Int<long> &__rhs) noexcept;
                constexpr std::strong_ordering operator<=>(const std::__cmp_cust::_Strong_order::_Int<long> &__rhs) const noexcept;
            };
            template <typename _Tp> static constexpr _Tp _S_compl(_Tp __t) noexcept             {
                constexpr int __width = sizeof(_Tp) * 8;
                make_unsigned_t<_Tp> __sign = __t >> (__width - 1);
                return __t ^ (__sign >> 1);
            }
            template <typename _Tp> static constexpr _Int<_Tp> _S_compl(_Int<_Tp> __t) noexcept             {
                constexpr int __width = sizeof(_Tp) * 8;
                make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);
                __t._M_hi ^= (__sign >> 1);
                std::__cmp_cust::_Strong_order::uint64_t __sign64 = (_Tp)__sign;
                __t._M_lo ^= __sign64;
                return __t;
            }
            template <typename _Tp> static constexpr auto _S_fp_bits(_Tp __val) noexcept             {
                if (sizeof(_Tp) == sizeof(std::__cmp_cust::_Strong_order::int64_t))
                    return __builtin_bit_cast(std::__cmp_cust::_Strong_order::int64_t, __val);
                else if (sizeof(_Tp) == sizeof(std::__cmp_cust::_Strong_order::int32_t))
                    return __builtin_bit_cast(std::__cmp_cust::_Strong_order::int32_t, __val);
                else if (sizeof(_Tp) == sizeof(std::__cmp_cust::_Strong_order::int16_t))
                    return __builtin_bit_cast(std::__cmp_cust::_Strong_order::int16_t, __val);
                else {
                    constexpr auto __fmt = _S_fp_fmt<_Tp>();
                    if (__fmt == _X86_80bit || __fmt == _M68k_80bit) {
                        if (sizeof(_Tp) == 3 * sizeof(std::__cmp_cust::_Strong_order::int32_t)) {
                            auto __ival = __builtin_bit_cast(_Int<std::__cmp_cust::_Strong_order::int32_t>, __val);
                            return _Int<std::__cmp_cust::_Strong_order::int16_t>(__ival._M_hi, __ival._M_lo);
                        } else {
                            auto __ival = __builtin_bit_cast(_Int<std::__cmp_cust::_Strong_order::int64_t>, __val);
                            return _Int<std::__cmp_cust::_Strong_order::int16_t>(__ival._M_hi, __ival._M_lo);
                        }
                    } else if (sizeof(_Tp) == 2 * sizeof(std::__cmp_cust::_Strong_order::int64_t)) {
                        return __builtin_bit_cast(__int128, __val);
                    } else
                        static_assert(sizeof(_Tp) == sizeof(std::__cmp_cust::_Strong_order::int64_t), "unsupported floating-point type");
                }
            }
            template <typename _Tp> static constexpr std::strong_ordering _S_fp_cmp(_Tp __x, _Tp __y) noexcept             {
                auto __ix = _S_fp_bits(__x);
                auto __iy = _S_fp_bits(__y);
                if (__ix == __iy)
                    return strong_ordering::equal;
                constexpr auto __fmt = _S_fp_fmt<_Tp>();
                if (__fmt == _Dbldbl) {
                    struct _Unpacked {
                        double _M_hi;
                        std::__cmp_cust::_Strong_order::int64_t _M_lo;
                    };
                    auto __x2 = __builtin_bit_cast(_Unpacked, __x);
                    auto __y2 = __builtin_bit_cast(_Unpacked, __y);
                    auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);
                    if (__cmp != strong_ordering::equal)
                        return __cmp;
                    if (__builtin_isnan(__x2._M_hi))
                        return strong_ordering::equal;
                    if (((__x2._M_lo | __y2._M_lo) & 9223372036854775807ULL) == 0)
                        return strong_ordering::equal;
                    return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);
                } else {
                    if (__fmt == _M68k_80bit) {
                        constexpr std::__cmp_cust::_Strong_order::uint16_t __maxexp = 32767;
                        if ((__ix._M_hi & __maxexp) == __maxexp)
                            __ix._M_lo |= 1ULL << 63;
                        if ((__iy._M_hi & __maxexp) == __maxexp)
                            __iy._M_lo |= 1ULL << 63;
                    } else {
                    }
                    return _S_compl(__ix) <=> _S_compl(__iy);
                }
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr std::strong_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]]             {
                if (floating_point<decay_t<_Tp>>)
                    return _S_fp_cmp(__e, __f);
                else if (__adl_strong<_Tp, _Up>)
                    return std::strong_ordering(strong_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<std::strong_ordering, _Tp, _Up>)
                    return std::compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __weakly_ordered = floating_point<remove_reference_t<_Tp>> || __adl_weak<_Tp, _Up> || __cmp3way<std::weak_ordering, _Tp, _Up> || __strongly_ordered<_Tp, _Up>;;
        class _Weak_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (floating_point<decay_t<_Tp>>)
                    return true;
                else if (__adl_weak<_Tp, _Up>)
                    return noexcept(std::weak_ordering(weak_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<std::weak_ordering, _Tp, _Up>)
                    return noexcept(std::compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
                else if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order::_S_noexcept<_Tp, _Up>();
            }
            friend  class _Partial_order;
            friend  class _Weak_fallback;
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr std::weak_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]]             {
                if (floating_point<decay_t<_Tp>>)
                    return __cmp_cust::__fp_weak_ordering(__e, __f);
                else if (__adl_weak<_Tp, _Up>)
                    return std::weak_ordering(weak_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<std::weak_ordering, _Tp, _Up>)
                    return std::compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__strongly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Strong_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __partially_ordered = __adl_partial<_Tp, _Up> || __cmp3way<std::partial_ordering, _Tp, _Up> || __weakly_ordered<_Tp, _Up>;;
        class _Partial_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__adl_partial<_Tp, _Up>)
                    return noexcept(std::partial_ordering(partial_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<std::partial_ordering, _Tp, _Up>)
                    return noexcept(std::compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
                else if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order::_S_noexcept<_Tp, _Up>();
            }
            friend  class _Partial_fallback;
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr std::partial_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]]             {
                if (__adl_partial<_Tp, _Up>)
                    return std::partial_ordering(partial_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<std::partial_ordering, _Tp, _Up>)
                    return std::compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__weakly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Weak_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __op_eq_lt = requires (_Tp &&__t, _Up &&__u) { { static_cast<_Tp &&>(__t) == static_cast<_Up &&>(__u) } -> convertible_to<bool>; { static_cast<_Tp &&>(__t) < static_cast<_Up &&>(__u) } -> convertible_to<bool>; };;
        class _Strong_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr std::strong_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]]             {
                if (__strongly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Strong_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? strong_ordering::equal : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? strong_ordering::less : strong_ordering::greater;
            }
        };
        class _Weak_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr std::weak_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]]             {
                if (__weakly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Weak_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? weak_ordering::equivalent : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? weak_ordering::less : weak_ordering::greater;
            }
        };
        template <typename _Tp, typename _Up> concept __op_eq_lt_lt = __op_eq_lt<_Tp, _Up> && requires (_Tp &&__t, _Up &&__u) { { static_cast<_Up &&>(__u) < static_cast<_Tp &&>(__t) } -> convertible_to<bool>; };;
        class _Partial_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__partially_ordered<_Tp, _Up>)
                    return _Partial_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, __decayed_same_as<_Tp> _Up> constexpr std::partial_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()) [[nodiscard("")]]             {
                if (__partially_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Partial_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? partial_ordering::equivalent : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? partial_ordering::less : static_cast<_Up &&>(__f) < static_cast<_Tp &&>(__e) ? partial_ordering::greater : partial_ordering::unordered;
            }
        };
    }
    inline namespace __cmp_alg {
        constexpr __cmp_cust::_Strong_order strong_order{};
        constexpr __cmp_cust::_Weak_order weak_order{};
        constexpr __cmp_cust::_Partial_order partial_order{};
        constexpr __cmp_cust::_Strong_fallback compare_strong_order_fallback{};
        constexpr __cmp_cust::_Weak_fallback compare_weak_order_fallback{};
        constexpr __cmp_cust::_Partial_fallback compare_partial_order_fallback{};
    }
    namespace __detail {
        constexpr struct _Synth3way {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept(const _Tp *__t = nullptr, const _Up *__u = nullptr)             {
                if (three_way_comparable_with<_Tp, _Up>)
                    return noexcept(*__t <=> *__u);
                else
                    return noexcept(*__t < *__u) && noexcept(*__u < *__t);
            }
            template <typename _Tp, typename _Up> constexpr auto operator()(const _Tp &__t, const _Up &__u) const noexcept(_S_noexcept<_Tp, _Up>()operator()(const _Tp &__t, const _Up &__u) const noexcept(_S_noexcept<_Tp, _Up>()) requires requires { { __t < __u } -> __boolean_testable; { __u < __t } -> __boolean_testable; } [[nodiscard("")]]             {
                if (three_way_comparable_with<_Tp, _Up>)
                    return __t <=> __u;
                else {
                    if (__t < __u)
                        return weak_ordering::less;
                    else if (__u < __t)
                        return weak_ordering::greater;
                    else
                        return weak_ordering::equivalent;
                }
            }
        } __synth3way = {};
        template <typename _Tp, typename _Up = _Tp> using __synth3way_t = decltype(__detail::__synth3way(std::declval<_Tp &>(), std::declval<_Up &>()));
    }
}
extern "C++" {
    namespace std {
        class exception {
        public:
            exception() noexcept             {
            }
            virtual ~exception() noexcept;
            exception(const std::exception &) = default
            std::exception &operator=(const std::exception &) = default
            exception(std::exception &&) = default
            std::exception &operator=(std::exception &&) = default
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_alloc : public std::exception {
        public:
            bad_alloc() throw() : std::exception()             {
            }
            bad_alloc(const std::bad_alloc &) = default
            std::bad_alloc &operator=(const std::bad_alloc &) = default
            virtual ~bad_alloc() throw();
            virtual const char *what() const throw();
        };
        class bad_array_new_length : public std::bad_alloc {
        public:
            bad_array_new_length() throw() : std::bad_alloc()             {
            }
            virtual ~bad_array_new_length() throw();
            virtual const char *what() const throw();
        };
        enum class align_val_t : std::size_t {
        };
        struct nothrow_t {
            explicit nothrow_t() = default
        };
        extern const std::nothrow_t nothrow;
        typedef void (*new_handler)();
        std::new_handler set_new_handler(std::new_handler) throw();
        std::new_handler get_new_handler() noexcept;
    }
    void *operator new(std::size_t) [[nodiscard("")]];
    void *operator new[](std::size_t) [[nodiscard("")]];
    void operator delete(void *) noexcept;
    void operator delete[](void *) noexcept;
    void *operator new(std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void *operator new[](std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void operator delete(void *, const std::nothrow_t &) noexcept;
    void operator delete[](void *, const std::nothrow_t &) noexcept;
    void *operator new(std::size_t, std::align_val_t) [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void *operator new(std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void operator delete(void *, std::align_val_t) noexcept;
    void operator delete(void *, std::align_val_t, const std::nothrow_t &) noexcept;
    void *operator new[](std::size_t, std::align_val_t) [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void *operator new[](std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((alloc_size(1))) __attribute__((malloc));
    void operator delete[](void *, std::align_val_t) noexcept;
    void operator delete[](void *, std::align_val_t, const std::nothrow_t &) noexcept;
    inline void *operator new(std::size_t, void *__p) noexcept [[nodiscard("")]]     {
        return __p;
    }
    inline void *operator new[](std::size_t, void *__p) noexcept [[nodiscard("")]]     {
        return __p;
    }
    inline void operator delete(void *, void *) noexcept     {
    }
    inline void operator delete[](void *, void *) noexcept     {
    }
}
namespace std {
    template <typename _Tp> constexpr _Tp *launder(_Tp *__p) noexcept [[nodiscard("")]]     {
        return __builtin_launder(__p);
    }
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args...) noexcept(_NE)) = delete
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args..., ...) noexcept(_NE)) = delete
    void launder(void *) = delete
    void launder(const void *) = delete
    void launder(volatile void *) = delete
    void launder(const volatile void *) = delete
}
namespace std {
    struct destroying_delete_t {
        explicit destroying_delete_t() noexcept = default
    };
    constexpr std::destroying_delete_t destroying_delete{};
}
namespace std {
    template <typename _Tp> inline constexpr _Tp *__addressof(_Tp &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char *__addressof<char>(char &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char *__addressof<const char>(const char &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const wchar_t *__addressof<const wchar_t>(const wchar_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr wchar_t *__addressof<wchar_t>(wchar_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char8_t *__addressof<char8_t>(char8_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char8_t *__addressof<const char8_t>(const char8_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char16_t *__addressof<char16_t>(char16_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char16_t *__addressof<const char16_t>(const char16_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char32_t *__addressof<char32_t>(char32_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char32_t *__addressof<const char32_t>(const char32_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
}
namespace std {
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<_Tp &&>(__t);
    }
    template<> constexpr const char &forward<const char &>(typename std::remove_reference<const char &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<const char &>(__t);
    }
    template<> constexpr char &forward<char &>(typename std::remove_reference<char &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<char &>(__t);
    }
    template<> constexpr const wchar_t &forward<const wchar_t &>(typename std::remove_reference<const wchar_t &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<const wchar_t &>(__t);
    }
    template<> constexpr wchar_t &forward<wchar_t &>(typename std::remove_reference<wchar_t &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<wchar_t &>(__t);
    }
    template<> constexpr const char8_t &forward<const char8_t &>(typename std::remove_reference<const char8_t &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<const char8_t &>(__t);
    }
    template<> constexpr char8_t &forward<char8_t &>(typename std::remove_reference<char8_t &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<char8_t &>(__t);
    }
    template<> constexpr const char16_t &forward<const char16_t &>(typename std::remove_reference<const char16_t &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<const char16_t &>(__t);
    }
    template<> constexpr const char32_t &forward<const char32_t &>(typename std::remove_reference<const char32_t &>::type &__t) noexcept [[nodiscard("")]]     {
        return static_cast<const char32_t &>(__t);
    }
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &&__t) noexcept [[nodiscard("")]]     {
        static_assert(!std::is_lvalue_reference<_Tp>::value, "std::forward must not be used to convert an rvalue to an lvalue");
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept [[nodiscard("")]]     {
        return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char> &>::type &&move<std::allocator<char> &>(std::allocator<char> &__t) noexcept [[nodiscard("")]]     {
        return static_cast<typename std::remove_reference<allocator<char> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<basic_string<char, char_traits<char>, allocator<char>> &>::type &&move<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__t) noexcept [[nodiscard("")]]     {
        return static_cast<typename std::remove_reference<basic_string<char, char_traits<char>, allocator<char>> &>::type &&>(__t);
    }
    template <typename _Tp> struct __move_if_noexcept_cond : public __and_<__not_<is_nothrow_move_constructible<_Tp>>, is_copy_constructible<_Tp>>::type {
    };
    template <typename _Tp> constexpr __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&> move_if_noexcept(_Tp &__x) noexcept [[nodiscard("")]]     {
        return std::move(__x);
    }
    template <typename _Tp> inline constexpr _Tp *addressof(_Tp &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr char *addressof<char>(char &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const char *addressof<const char>(const char &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const wchar_t *addressof<const wchar_t>(const wchar_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr wchar_t *addressof<wchar_t>(wchar_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr char8_t *addressof<char8_t>(char8_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const char8_t *addressof<const char8_t>(const char8_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr char16_t *addressof<char16_t>(char16_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const char16_t *addressof<const char16_t>(const char16_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr char32_t *addressof<char32_t>(char32_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template<> inline constexpr const char32_t *addressof<const char32_t>(const char32_t &__r) noexcept [[nodiscard("")]]     {
        return std::__addressof(__r);
    }
    template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete    template<> const char *addressof<char>(const char &&) = delete    template<> const wchar_t *addressof<wchar_t>(const wchar_t &&) = delete    template<> const char8_t *addressof<char8_t>(const char8_t &&) = delete    template<> const char16_t *addressof<char16_t>(const char16_t &&) = delete    template<> const char32_t *addressof<char32_t>(const char32_t &&) = delete
    template <typename _Tp, typename _Up = _Tp> inline constexpr _Tp __exchange(_Tp &__obj, _Up &&__new_val)     {
        _Tp __old_val = std::move(__obj);
        __obj = std::forward<_Up>(__new_val);
        return __old_val;
    }
    template <typename _Tp> inline constexpr typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value>::type swap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::valueswap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)     {
        _Tp __tmp = std::move(__a);
        __a = std::move(__b);
        __b = std::move(__tmp);
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value)     {
        for (std::size_t __n = 0; __n < _Nm; ++__n)
            swap(__a[__n], __b[__n]);
    }
}
namespace __gnu_debug {
    struct _Safe_iterator_base;
}
namespace std {
    class __undefined;
    template <typename _Tp> struct __get_first_arg {
        using type = std::__undefined;
    };
    template <template <typename, typename ...> class _SomeTemplate, typename _Tp, typename ..._Types> struct __get_first_arg<_SomeTemplate<_Tp, _Types...>> {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __replace_first_arg {
    };
    template <template <typename, typename ...> class _SomeTemplate, typename _Up, typename _Tp, typename ..._Types> struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up> {
        using type = _SomeTemplate<_Up, _Types...>;
    };
    template <typename _Ptr> using __ptr_traits_elem_t = typename __get_first_arg<_Ptr>::type;
    template <typename _Ptr, typename _Elt, bool = is_void<_Elt>::value> struct __ptr_traits_ptr_to {
        using pointer = _Ptr;
        using element_type = _Elt;
        static std::__ptr_traits_ptr_to::pointer pointer_to(std::__ptr_traits_ptr_to::element_type &__e) requires requires { { pointer::pointer_to(__e) } -> convertible_to<std::__ptr_traits_ptr_to::pointer>; }         {
            return pointer::pointer_to(__e);
        }
    };
template<> struct __ptr_traits_ptr_to<char *, char, false> {
        using pointer = char *;
        using element_type = char;
        static constexpr std::__ptr_traits_ptr_to<char *, char, false>::pointer pointer_to(std::__ptr_traits_ptr_to<char *, char, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<const char *, const char, false> {
        using pointer = const char *;
        using element_type = const char;
        static constexpr std::__ptr_traits_ptr_to<const char *, const char, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const char *, const char, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<const wchar_t *, const wchar_t, false> {
        using pointer = const wchar_t *;
        using element_type = const wchar_t;
        static constexpr std::__ptr_traits_ptr_to<const wchar_t *, const wchar_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const wchar_t *, const wchar_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<wchar_t *, wchar_t, false> {
        using pointer = wchar_t *;
        using element_type = wchar_t;
        static constexpr std::__ptr_traits_ptr_to<wchar_t *, wchar_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<wchar_t *, wchar_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<char8_t *, char8_t, false> {
        using pointer = char8_t *;
        using element_type = char8_t;
        static constexpr std::__ptr_traits_ptr_to<char8_t *, char8_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<char8_t *, char8_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<const char8_t *, const char8_t, false> {
        using pointer = const char8_t *;
        using element_type = const char8_t;
        static constexpr std::__ptr_traits_ptr_to<const char8_t *, const char8_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const char8_t *, const char8_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<char16_t *, char16_t, false> {
        using pointer = char16_t *;
        using element_type = char16_t;
        static constexpr std::__ptr_traits_ptr_to<char16_t *, char16_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<char16_t *, char16_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<const char16_t *, const char16_t, false> {
        using pointer = const char16_t *;
        using element_type = const char16_t;
        static constexpr std::__ptr_traits_ptr_to<const char16_t *, const char16_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const char16_t *, const char16_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<char32_t *, char32_t, false> {
        using pointer = char32_t *;
        using element_type = char32_t;
        static constexpr std::__ptr_traits_ptr_to<char32_t *, char32_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<char32_t *, char32_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct __ptr_traits_ptr_to<const char32_t *, const char32_t, false> {
        using pointer = const char32_t *;
        using element_type = const char32_t;
        static constexpr std::__ptr_traits_ptr_to<const char32_t *, const char32_t, false>::pointer pointer_to(std::__ptr_traits_ptr_to<const char32_t *, const char32_t, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Elt> struct __ptr_traits_ptr_to<_Ptr, _Elt, true> {
    };
    template <typename _Tp> struct __ptr_traits_ptr_to<_Tp *, _Tp, false> {
        using pointer = _Tp *;
        using element_type = _Tp;
        static constexpr std::__ptr_traits_ptr_to<type-parameter-0-0 *, type-parameter-0-0, false>::pointer pointer_to(std::__ptr_traits_ptr_to<type-parameter-0-0 *, type-parameter-0-0, false>::element_type &__r) noexcept         {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Elt> struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt> {
    private:
        template <typename _Tp, typename = void> struct __difference {
            using type = std::ptrdiff_t;
        };
        template <typename _Tp> struct __difference<_Tp> {
            using type = typename _Tp::difference_type;
        };
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up> {
            using type = typename _Tp::template rebind<_Up>;
        };
    public:
        using pointer = _Ptr;
        using element_type = _Elt;
        using difference_type = typename __difference<_Ptr>::type;
        template <typename _Up> using rebind = typename __rebind<_Ptr, _Up>::type;
    };
    template <typename _Ptr> struct __ptr_traits_impl<_Ptr, std::__undefined> {
    };
    template <typename _Ptr> struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>> {
    };
template<> struct pointer_traits<char *> : __ptr_traits_ptr_to<char *, char> {
        typedef char *pointer;
        typedef char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<const char *> : __ptr_traits_ptr_to<const char *, const char> {
        typedef const char *pointer;
        typedef const char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<const wchar_t *> : __ptr_traits_ptr_to<const wchar_t *, const wchar_t> {
        typedef const wchar_t *pointer;
        typedef const wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<wchar_t *> : __ptr_traits_ptr_to<wchar_t *, wchar_t> {
        typedef wchar_t *pointer;
        typedef wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<char8_t *> : __ptr_traits_ptr_to<char8_t *, char8_t> {
        typedef char8_t *pointer;
        typedef char8_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<const char8_t *> : __ptr_traits_ptr_to<const char8_t *, const char8_t> {
        typedef const char8_t *pointer;
        typedef const char8_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<char16_t *> : __ptr_traits_ptr_to<char16_t *, char16_t> {
        typedef char16_t *pointer;
        typedef char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<const char16_t *> : __ptr_traits_ptr_to<const char16_t *, const char16_t> {
        typedef const char16_t *pointer;
        typedef const char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<char32_t *> : __ptr_traits_ptr_to<char32_t *, char32_t> {
        typedef char32_t *pointer;
        typedef char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
template<> struct pointer_traits<const char32_t *> : __ptr_traits_ptr_to<const char32_t *, const char32_t> {
        typedef const char32_t *pointer;
        typedef const char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template <typename _Ptr> struct pointer_traits<_Ptr> : __ptr_traits_impl<_Ptr, typename _Ptr::element_type> {
    };
    template <typename _Tp> struct pointer_traits<_Tp *> : __ptr_traits_ptr_to<_Tp *, _Tp> {
        typedef _Tp *pointer;
        typedef _Tp element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
    };
    template <typename _Ptr, typename _Tp> using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
    template <typename _Tp> constexpr _Tp *__to_address(_Tp *__ptr) noexcept     {
        static_assert(!std::is_function<_Tp>::value, "not a function pointer");
        return __ptr;
    }
    template <typename _Ptr> constexpr auto __to_address(const _Ptr &__ptr) noexcept -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))     {
        return std::pointer_traits<_Ptr>::to_address(__ptr);
    }
    template <typename _Ptr, typename ..._None> constexpr auto __to_address(const _Ptr &__ptr, _None ...) noexcept     {
        if (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
            return std::__to_address(__ptr.base().operator->());
        else
            return std::__to_address(__ptr.operator->());
    }
    template <typename _Tp> constexpr _Tp *to_address(_Tp *__ptr) noexcept     {
        return std::__to_address(__ptr);
    }
    template<> constexpr const char *to_address<const char>(const char *__ptr) noexcept    template<> constexpr const wchar_t *to_address<const wchar_t>(const wchar_t *__ptr) noexcept    template<> constexpr const char8_t *to_address<const char8_t>(const char8_t *__ptr) noexcept    template<> constexpr const char16_t *to_address<const char16_t>(const char16_t *__ptr) noexcept    template<> constexpr const char32_t *to_address<const char32_t>(const char32_t *__ptr) noexcept    template <typename _Ptr> constexpr auto to_address(const _Ptr &__ptr) noexcept     {
        return std::__to_address(__ptr);
    }
    template<> constexpr auto to_address<const char *>(const char *const &__ptr) noexcept    template<> constexpr auto to_address<const wchar_t *>(const wchar_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char8_t *>(const char8_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char16_t *>(const char16_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char32_t *>(const char32_t *const &__ptr) noexcept}
namespace std {
    struct __is_transparent;
    struct identity {
        template <typename _Tp> constexpr _Tp &&operator()(_Tp &&__t) const noexcept [[nodiscard("")]]         {
            return std::forward<_Tp>(__t);
        }
        using is_transparent = std::__is_transparent;
    };
    namespace ranges {
        namespace __detail {
            template <typename _Tp, typename _Up> concept __less_builtin_ptr_cmp = requires (_Tp &&__t, _Up &&__u) { { __t < __u } -> same_as<bool>; } && convertible_to<_Tp, const volatile void *> && convertible_to<_Up, const volatile void *> && (!requires (_Tp &&__t, _Up &&__u) { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); } && !requires (_Tp &&__t, _Up &&__u) { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });;
        }
        struct equal_to {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>()))             {
                return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
            }
            using is_transparent = std::__is_transparent;
        };
        struct not_equal_to {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>()))             {
                return !std::ranges::equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
            }
            using is_transparent = std::__is_transparent;
        };
        struct less {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))             {
                if (__detail::__less_builtin_ptr_cmp<_Tp, _Up>) {
                    if (std::__is_constant_evaluated())
                        return __t < __u;
                    auto __x = reinterpret_cast<unsigned long>(static_cast<const volatile void *>(std::forward<_Tp>(__t)));
                    auto __y = reinterpret_cast<unsigned long>(static_cast<const volatile void *>(std::forward<_Up>(__u)));
                    return __x < __y;
                } else
                    return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
            }
            using is_transparent = std::__is_transparent;
        };
        struct greater {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))             {
                return std::ranges::less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
            }
            using is_transparent = std::__is_transparent;
        };
        struct greater_equal {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))             {
                return !std::ranges::less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
            }
            using is_transparent = std::__is_transparent;
        };
        struct less_equal {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))             {
                return !std::ranges::less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
            }
            using is_transparent = std::__is_transparent;
        };
    }
}
namespace std {
    struct input_iterator_tag;
    struct output_iterator_tag;
    struct forward_iterator_tag;
    struct bidirectional_iterator_tag;
    struct random_access_iterator_tag;
    struct contiguous_iterator_tag;
    template <typename _Iterator> struct iterator_traits
template<> struct iterator_traits<const char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    }
template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    }
template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    }
template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    }
template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    }
template<> struct iterator_traits<char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = std::ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    }
template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    };
    template <typename _Tp> struct iterator_traits<_Tp *>;
    template <typename _Iterator, typename> struct __iterator_traits;
    namespace __detail {
        template <typename _Tp> using __with_ref = _Tp &;
        template <typename _Tp> concept __can_reference = requires { typename __with_ref<_Tp>; };;
        template <typename _Tp> concept __dereferenceable = requires (_Tp &__t) { { *__t } -> __can_reference; };;
    }
    template <__detail::__dereferenceable _Tp> using iter_reference_t = decltype(*std::declval<_Tp &>());
    namespace ranges {
        namespace __cust_imove {
            void iter_move();
            template <typename _Tp> concept __adl_imove = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>) && requires (_Tp &&__t) { iter_move(static_cast<_Tp &&>(__t)); };;
            struct _IMove {
            private:
                template <typename _Tp> struct __result {
                    using type = iter_reference_t<_Tp>;
                };
template<> struct __result<const char *&> {
                    using type = remove_reference_t<iter_reference_t<const char *&>> &&;
                };
template<> struct __result<const char *const &> {
                    using type = remove_reference_t<iter_reference_t<const char *const &>> &&;
                };
template<> struct __result<const wchar_t *&> {
                    using type = remove_reference_t<iter_reference_t<const wchar_t *&>> &&;
                };
template<> struct __result<const wchar_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const wchar_t *const &>> &&;
                };
template<> struct __result<const char8_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char8_t *&>> &&;
                };
template<> struct __result<const char8_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char8_t *const &>> &&;
                };
template<> struct __result<const char16_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char16_t *&>> &&;
                };
template<> struct __result<const char16_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char16_t *const &>> &&;
                };
template<> struct __result<const char32_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char32_t *&>> &&;
                };
template<> struct __result<const char32_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char32_t *const &>> &&;
                };
                template <typename _Tp> struct __result<_Tp> {
                    using type = decltype(iter_move(std::declval<_Tp>()));
                };
                template <typename _Tp> struct __result<_Tp> {
                    using type = remove_reference_t<iter_reference_t<_Tp>> &&;
                };
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__adl_imove<_Tp>)
                        return noexcept(iter_move(std::declval<_Tp>()));
                    else
                        return noexcept(*std::declval<_Tp>());
                }
            public:
                template <std::__detail::__dereferenceable _Tp> using __type = typename __result<_Tp>::type;
                template <std::__detail::__dereferenceable _Tp> constexpr __type<_Tp> operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>()) [[nodiscard("")]]                 {
                    if (__adl_imove<_Tp>)
                        return iter_move(static_cast<_Tp &&>(__e));
                    else if (is_lvalue_reference_v<iter_reference_t<_Tp>>)
                        return static_cast<__type<_Tp>>(*__e);
                    else
                        return *__e;
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_imove::_IMove iter_move{};
        }
    }
    template <__detail::__dereferenceable _Tp> using iter_rvalue_reference_t = ranges::__cust_imove::_IMove::__type<_Tp &>;
    template <typename> struct incrementable_traits {
    };
    template <typename _Tp> struct incrementable_traits<_Tp *> {
        using difference_type = std::ptrdiff_t;
    };
    template <typename _Iter> struct incrementable_traits<const _Iter> : incrementable_traits<_Iter> {
    };
    template <typename _Tp> struct incrementable_traits<_Tp> {
        using difference_type = typename _Tp::difference_type;
    };
    template <typename _Tp> struct incrementable_traits<_Tp> {
        using difference_type = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };
    template<> struct incrementable_traits<__int128> {
        using difference_type = __int128;
    };
    template<> struct incrementable_traits<unsigned __int128> {
        using difference_type = __int128;
    };
    namespace __detail {
        template <typename _Iter> concept __primary_traits_iter = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);;
        template <typename _Iter, typename _Tp> struct __iter_traits_impl {
            using type = iterator_traits<_Iter>;
        };
template<> struct __iter_traits_impl<const char *, std::incrementable_traits<const char *>> {
            using type = iterator_traits<const char *>;
        };
template<> struct __iter_traits_impl<const char *, std::indirectly_readable_traits<const char *>> {
            using type = iterator_traits<const char *>;
        };
template<> struct __iter_traits_impl<const char *, const char *> {
            using type = iterator_traits<const char *>;
        };
template<> struct __iter_traits_impl<const wchar_t *, std::incrementable_traits<const wchar_t *>> {
            using type = iterator_traits<const wchar_t *>;
        };
template<> struct __iter_traits_impl<const wchar_t *, std::indirectly_readable_traits<const wchar_t *>> {
            using type = iterator_traits<const wchar_t *>;
        };
template<> struct __iter_traits_impl<const wchar_t *, const wchar_t *> {
            using type = iterator_traits<const wchar_t *>;
        };
template<> struct __iter_traits_impl<const char8_t *, std::incrementable_traits<const char8_t *>> {
            using type = iterator_traits<const char8_t *>;
        };
template<> struct __iter_traits_impl<const char8_t *, std::indirectly_readable_traits<const char8_t *>> {
            using type = iterator_traits<const char8_t *>;
        };
template<> struct __iter_traits_impl<const char8_t *, const char8_t *> {
            using type = iterator_traits<const char8_t *>;
        };
template<> struct __iter_traits_impl<const char16_t *, std::incrementable_traits<const char16_t *>> {
            using type = iterator_traits<const char16_t *>;
        };
template<> struct __iter_traits_impl<const char16_t *, std::indirectly_readable_traits<const char16_t *>> {
            using type = iterator_traits<const char16_t *>;
        };
template<> struct __iter_traits_impl<const char16_t *, const char16_t *> {
            using type = iterator_traits<const char16_t *>;
        };
template<> struct __iter_traits_impl<const char32_t *, std::incrementable_traits<const char32_t *>> {
            using type = iterator_traits<const char32_t *>;
        };
template<> struct __iter_traits_impl<const char32_t *, std::indirectly_readable_traits<const char32_t *>> {
            using type = iterator_traits<const char32_t *>;
        };
template<> struct __iter_traits_impl<const char32_t *, const char32_t *> {
            using type = iterator_traits<const char32_t *>;
        };
template<> struct __iter_traits_impl<char *, char *> {
            using type = iterator_traits<char *>;
        };
template<> struct __iter_traits_impl<wchar_t *, wchar_t *> {
            using type = iterator_traits<wchar_t *>;
        };
        template <typename _Iter, typename _Tp> struct __iter_traits_impl<_Iter, _Tp> {
            using type = _Tp;
        };
        template <typename _Iter, typename _Tp = _Iter> using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;
        template <typename _Tp> using __iter_diff_t = typename __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
    }
    template <typename _Tp> using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;
    namespace __detail {
        template <typename> struct __cond_value_type {
        };
        template <typename _Tp> struct __cond_value_type<_Tp> {
            using value_type = remove_cv_t<_Tp>;
        };
        template <typename _Tp> concept __has_member_value_type = requires { typename _Tp::value_type; };;
        template <typename _Tp> concept __has_member_element_type = requires { typename _Tp::element_type; };;
    }
    template <typename> struct indirectly_readable_traits {
    };
    template <typename _Tp> struct indirectly_readable_traits<_Tp *> : __detail::__cond_value_type<_Tp> {
    };
    template <typename _Iter> struct indirectly_readable_traits<_Iter> {
        using value_type = remove_cv_t<remove_extent_t<_Iter>>;
    };
    template <typename _Iter> struct indirectly_readable_traits<const _Iter> : indirectly_readable_traits<_Iter> {
    };
    template <__detail::__has_member_value_type _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::value_type> {
    };
    template <__detail::__has_member_element_type _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::element_type> {
    };
    template <__detail::__has_member_value_type _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::value_type> {
    };
    template <__detail::__has_member_value_type _Tp> struct indirectly_readable_traits<_Tp> {
    };
    namespace __detail {
        template <typename _Tp> using __iter_value_t = typename __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
    }
    template <typename _Tp> using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;
    namespace __detail {
        template <typename _Iter> concept __cpp17_iterator = requires (_Iter __it) { { *__it } -> __can_reference; { ++__it } -> same_as<_Iter &>; { *__it++ } -> __can_reference; } && copyable<_Iter>;;
        template <typename _Iter> concept __cpp17_input_iterator = __cpp17_iterator<_Iter> && equality_comparable<_Iter> && requires (_Iter __it) { typename incrementable_traits<_Iter>::difference_type; typename indirectly_readable_traits<_Iter>::value_type; typename common_reference_t<iter_reference_t<_Iter> &&, typename indirectly_readable_traits<_Iter>::value_type &>; typename common_reference_t<decltype(*__it++) &&, typename indirectly_readable_traits<_Iter>::value_type &>; requires signed_integral<typename incrementable_traits<_Iter>::difference_type>; };;
        template <typename _Iter> concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter> && constructible_from<_Iter> && is_lvalue_reference_v<iter_reference_t<_Iter>> && same_as<remove_cvref_t<iter_reference_t<_Iter>>, typename indirectly_readable_traits<_Iter>::value_type> && requires (_Iter __it) { { __it++ } -> convertible_to<const _Iter &>; { *__it++ } -> same_as<iter_reference_t<_Iter>>; };;
        template <typename _Iter> concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter> && requires (_Iter __it) { { --__it } -> same_as<_Iter &>; { __it-- } -> convertible_to<const _Iter &>; { *__it-- } -> same_as<iter_reference_t<_Iter>>; };;
        template <typename _Iter> concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter> && totally_ordered<_Iter> && requires (_Iter __it, typename incrementable_traits<_Iter>::difference_type __n) { { __it += __n } -> same_as<_Iter &>; { __it -= __n } -> same_as<_Iter &>; { __it + __n } -> same_as<_Iter>; { __n + __it } -> same_as<_Iter>; { __it - __n } -> same_as<_Iter>; { __it - __it } -> same_as<decltype(__n)>; { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>; };;
        template <typename _Iter> concept __iter_with_nested_types = requires { typename _Iter::iterator_category; typename _Iter::value_type; typename _Iter::difference_type; typename _Iter::reference; };;
        template <typename _Iter> concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;;
        template <typename _Iter> concept __iter_without_category = !requires { typename _Iter::iterator_category; };;
    }
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = typename _Iter::pointer;
        };
    public:
        using iterator_category = typename _Iterator::iterator_category;
        using value_type = typename _Iterator::value_type;
        using difference_type = typename _Iterator::difference_type;
        using pointer = typename __ptr<_Iterator>::type;
        using reference = typename _Iterator::reference;
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __cat {
            using type = std::input_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = typename _Iter::iterator_category;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = std::random_access_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = std::bidirectional_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = std::forward_iterator_tag;
        };
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = typename _Iter::pointer;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = decltype(std::declval<_Iter &>().operator->());
        };
        template <typename _Iter> struct __ref {
            using type = iter_reference_t<_Iter>;
        };
        template <typename _Iter> struct __ref<_Iter> {
            using type = typename _Iter::reference;
        };
    public:
        using iterator_category = typename __cat<_Iterator>::type;
        using value_type = typename indirectly_readable_traits<_Iterator>::value_type;
        using difference_type = typename incrementable_traits<_Iterator>::difference_type;
        using pointer = typename __ptr<_Iterator>::type;
        using reference = typename __ref<_Iterator>::type;
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __diff {
            using type = void;
        };
        template <typename _Iter> struct __diff<_Iter> {
            using type = typename incrementable_traits<_Iter>::difference_type;
        };
    public:
        using iterator_category = std::output_iterator_tag;
        using value_type = void;
        using difference_type = typename __diff<_Iterator>::type;
        using pointer = void;
        using reference = void;
    };
    namespace __detail {
        template <typename _Iter> struct __iter_concept_impl
template<> struct __iter_concept_impl<const char *> {
            using type = typename __iter_traits<const char *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const wchar_t *> {
            using type = typename __iter_traits<const wchar_t *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const char8_t *> {
            using type = typename __iter_traits<const char8_t *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const char16_t *> {
            using type = typename __iter_traits<const char16_t *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const char32_t *> {
            using type = typename __iter_traits<const char32_t *>::iterator_concept;
        }
template<> struct __iter_concept_impl<char *> {
            using type = typename __iter_traits<char *>::iterator_concept;
        }
template<> struct __iter_concept_impl<wchar_t *> {
            using type = typename __iter_traits<wchar_t *>::iterator_concept;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = typename __iter_traits<_Iter>::iterator_concept;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = typename __iter_traits<_Iter>::iterator_category;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = std::random_access_iterator_tag;
        };
        template <typename _Iter> struct __iter_concept_impl {
        };
template<> struct __iter_concept_impl<const char *> {
            using type = typename __iter_traits<const char *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const wchar_t *> {
            using type = typename __iter_traits<const wchar_t *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const char8_t *> {
            using type = typename __iter_traits<const char8_t *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const char16_t *> {
            using type = typename __iter_traits<const char16_t *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const char32_t *> {
            using type = typename __iter_traits<const char32_t *>::iterator_concept;
        };
template<> struct __iter_concept_impl<char *> {
            using type = typename __iter_traits<char *>::iterator_concept;
        };
template<> struct __iter_concept_impl<wchar_t *> {
            using type = typename __iter_traits<wchar_t *>::iterator_concept;
        };
        template <typename _Iter> using __iter_concept = typename __iter_concept_impl<_Iter>::type;
        template <typename _In> concept __indirectly_readable_impl = requires { typename iter_value_t<_In>; typename iter_reference_t<_In>; typename iter_rvalue_reference_t<_In>; requires same_as<iter_reference_t<const _In>, iter_reference_t<_In>>; requires same_as<iter_rvalue_reference_t<const _In>, iter_rvalue_reference_t<_In>>; } && common_reference_with<iter_reference_t<_In> &&, iter_value_t<_In> &> && common_reference_with<iter_reference_t<_In> &&, iter_rvalue_reference_t<_In> &&> && common_reference_with<iter_rvalue_reference_t<_In> &&, const iter_value_t<_In> &>;;
    }
    template <typename _In> concept indirectly_readable = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;;
    template <indirectly_readable _Tp> using iter_common_reference_t = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp> &>;
    template <typename _Out, typename _Tp> concept indirectly_writable = requires (_Out &&__o, _Tp &&__t) { *__o = std::forward<_Tp>(__t); *std::forward<_Out>(__o) = std::forward<_Tp>(__t); const_cast<const iter_reference_t<_Out> &&>(*__o) = std::forward<_Tp>(__t); const_cast<const iter_reference_t<_Out> &&>(*std::forward<_Out>(__o)) = std::forward<_Tp>(__t); };;
    namespace ranges {
        namespace __detail {
            class __max_diff_type;
            class __max_size_type;
            template <typename _Tp> concept __is_signed_int128 = same_as<_Tp, __int128>;;
            template <typename _Tp> concept __is_unsigned_int128 = same_as<_Tp, unsigned __int128>;;
            template <typename _Tp> concept __cv_bool = same_as<const volatile _Tp, const volatile bool>;;
            template <typename _Tp> concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;;
            template <typename _Tp> concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;;
            template <typename _Tp> concept __is_integer_like = __integral_nonbool<_Tp> || __is_int128<_Tp> || same_as<_Tp, std::ranges::__detail::__max_diff_type> || same_as<_Tp, std::ranges::__detail::__max_size_type>;;
            template <typename _Tp> concept __is_signed_integer_like = signed_integral<_Tp> || __is_signed_int128<_Tp> || same_as<_Tp, std::ranges::__detail::__max_diff_type>;;
        }
    }
    namespace __detail {
        using ranges::__detail::__is_signed_integer_like;
    }
    template <typename _Iter> concept weakly_incrementable = movable<_Iter> && requires (_Iter __i) { typename iter_difference_t<_Iter>; requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>; { ++__i } -> same_as<_Iter &>; __i++; };;
    template <typename _Iter> concept incrementable = regular<_Iter> && weakly_incrementable<_Iter> && requires (_Iter __i) { { __i++ } -> same_as<_Iter>; };;
    template <typename _Iter> concept input_or_output_iterator = requires (_Iter __i) { { *__i } -> __detail::__can_reference; } && weakly_incrementable<_Iter>;;
    template <typename _Sent, typename _Iter> concept sentinel_for = semiregular<_Sent> && input_or_output_iterator<_Iter> && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;;
    template <typename _Sent, typename _Iter> constexpr bool disable_sized_sentinel_for = false;
    template <typename _Sent, typename _Iter> concept sized_sentinel_for = sentinel_for<_Sent, _Iter> && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>> && requires (const _Iter &__i, const _Sent &__s) { { __s - __i } -> same_as<iter_difference_t<_Iter>>; { __i - __s } -> same_as<iter_difference_t<_Iter>>; };;
    template <typename _Iter> concept input_iterator = input_or_output_iterator<_Iter> && indirectly_readable<_Iter> && requires { typename __detail::__iter_concept<_Iter>; } && derived_from<__detail::__iter_concept<_Iter>, std::input_iterator_tag>;;
    template <typename _Iter, typename _Tp> concept output_iterator = input_or_output_iterator<_Iter> && indirectly_writable<_Iter, _Tp> && requires (_Iter __i, _Tp &&__t) { *__i++ = std::forward<_Tp>(__t); };;
    template <typename _Iter> concept forward_iterator = input_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::forward_iterator_tag> && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;;
    template <typename _Iter> concept bidirectional_iterator = forward_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::bidirectional_iterator_tag> && requires (_Iter __i) { { --__i } -> same_as<_Iter &>; { __i-- } -> same_as<_Iter>; };;
    template <typename _Iter> concept random_access_iterator = bidirectional_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::random_access_iterator_tag> && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter> && requires (_Iter __i, const _Iter __j, const iter_difference_t<_Iter> __n) { { __i += __n } -> same_as<_Iter &>; { __j + __n } -> same_as<_Iter>; { __n + __j } -> same_as<_Iter>; { __i -= __n } -> same_as<_Iter &>; { __j - __n } -> same_as<_Iter>; { __j[__n] } -> same_as<iter_reference_t<_Iter>>; };;
    template <typename _Iter> concept contiguous_iterator = random_access_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::contiguous_iterator_tag> && is_lvalue_reference_v<iter_reference_t<_Iter>> && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>> && requires (const _Iter &__i) { { std::to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_Iter>>>; };;
    template <typename _Fn, typename _Iter> concept indirectly_unary_invocable = indirectly_readable<_Iter> && copy_constructible<_Fn> && invocable<_Fn &, iter_value_t<_Iter> &> && invocable<_Fn &, iter_reference_t<_Iter>> && invocable<_Fn &, iter_common_reference_t<_Iter>> && common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>, invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;;
    template <typename _Fn, typename _Iter> concept indirectly_regular_unary_invocable = indirectly_readable<_Iter> && copy_constructible<_Fn> && regular_invocable<_Fn &, iter_value_t<_Iter> &> && regular_invocable<_Fn &, iter_reference_t<_Iter>> && regular_invocable<_Fn &, iter_common_reference_t<_Iter>> && common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>, invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;;
    template <typename _Fn, typename _Iter> concept indirect_unary_predicate = indirectly_readable<_Iter> && copy_constructible<_Fn> && predicate<_Fn &, iter_value_t<_Iter> &> && predicate<_Fn &, iter_reference_t<_Iter>> && predicate<_Fn &, iter_common_reference_t<_Iter>>;;
    template <typename _Fn, typename _I1, typename _I2> concept indirect_binary_predicate = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && predicate<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && predicate<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && predicate<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && predicate<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && predicate<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;;
    template <typename _Fn, typename _I1, typename _I2 = _I1> concept indirect_equivalence_relation = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && equivalence_relation<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && equivalence_relation<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && equivalence_relation<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;;
    template <typename _Fn, typename _I1, typename _I2 = _I1> concept indirect_strict_weak_order = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && strict_weak_order<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;;
    template <typename _Fn, typename ..._Is> using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;
    template <indirectly_readable _Iter, indirectly_regular_unary_invocable<_Iter> _Proj> struct projected {
        using value_type = remove_cvref_t<indirect_result_t<_Proj &, _Iter>>;
        indirect_result_t<_Proj &, _Iter> operator*() const;
    };
    template <weakly_incrementable _Iter, typename _Proj> struct incrementable_traits<projected<_Iter, _Proj>> {
        using difference_type = iter_difference_t<_Iter>;
    };
    template <typename _In, typename _Out> concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;;
    template <typename _In, typename _Out> concept indirectly_movable_storable = indirectly_movable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>> && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> && assignable_from<iter_value_t<_In> &, iter_rvalue_reference_t<_In>>;;
    template <typename _In, typename _Out> concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;;
    template <typename _In, typename _Out> concept indirectly_copyable_storable = indirectly_copyable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In> &> && indirectly_writable<_Out, const iter_value_t<_In> &> && indirectly_writable<_Out, iter_value_t<_In> &&> && indirectly_writable<_Out, const iter_value_t<_In> &&> && copyable<iter_value_t<_In>> && constructible_from<iter_value_t<_In>, iter_reference_t<_In>> && assignable_from<iter_value_t<_In> &, iter_reference_t<_In>>;;
    namespace ranges {
        namespace __cust_iswap {
            template <typename _It1, typename _It2> void iter_swap(_It1, _It2) = delete
            template <typename _Tp, typename _Up> concept __adl_iswap = (std::__detail::__class_or_enum<remove_reference_t<_Tp>> || std::__detail::__class_or_enum<remove_reference_t<_Up>>) && requires (_Tp &&__t, _Up &&__u) { iter_swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); };;
            template <typename _Xp, typename _Yp> constexpr iter_value_t<_Xp> __iter_exchange_move(_Xp &&__x, _Yp &&__y) noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x))) && noexcept(*__x = iter_move(__y))__iter_exchange_move(_Xp &&__x, _Yp &&__y) noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x))) && noexcept(*__x = iter_move(__y)))             {
                iter_value_t<_Xp> __old_value(iter_move(__x));
                *__x = iter_move(__y);
                return __old_value;
            }
            struct _IterSwap {
            private:
                template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()                 {
                    if (__adl_iswap<_Tp, _Up>)
                        return noexcept(iter_swap(std::declval<_Tp>(), std::declval<_Up>()));
                    else if (indirectly_readable<_Tp> && indirectly_readable<_Up> && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
                        return noexcept(ranges::swap(*std::declval<_Tp>(), *std::declval<_Up>()));
                    else
                        return noexcept(*std::declval<_Tp>() = __iter_exchange_move(std::declval<_Up>(), std::declval<_Tp>()));
                }
            public:
                template <typename _Tp, typename _Up> constexpr void operator()(_Tp &&__e1, _Up &&__e2) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e1, _Up &&__e2) const noexcept(_S_noexcept<_Tp, _Up>())                 {
                    if (__adl_iswap<_Tp, _Up>)
                        iter_swap(static_cast<_Tp &&>(__e1), static_cast<_Up &&>(__e2));
                    else if (indirectly_readable<_Tp> && indirectly_readable<_Up> && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
                        ranges::swap(*__e1, *__e2);
                    else
                        *__e1 = __iter_exchange_move(__e2, __e1);
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_iswap::_IterSwap iter_swap{};
        }
    }
    template <typename _I1, typename _I2 = _I1> concept indirectly_swappable = indirectly_readable<_I1> && indirectly_readable<_I2> && requires (const _I1 __i1, const _I2 __i2) { ranges::iter_swap(__i1, __i1); ranges::iter_swap(__i2, __i2); ranges::iter_swap(__i1, __i2); ranges::iter_swap(__i2, __i1); };;
    template <typename _I1, typename _I2, typename _Rel, typename _P1 = std::identity, typename _P2 = std::identity> concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;;
    template <typename _Iter> concept permutable = forward_iterator<_Iter> && indirectly_movable_storable<_Iter, _Iter> && indirectly_swappable<_Iter, _Iter>;;
    template <typename _I1, typename _I2, typename _Out, typename _Rel = ranges::less, typename _P1 = std::identity, typename _P2 = std::identity> concept mergeable = input_iterator<_I1> && input_iterator<_I2> && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out> && indirectly_copyable<_I2, _Out> && indirect_strict_weak_order<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;;
    template <typename _Iter, typename _Rel = ranges::less, typename _Proj = std::identity> concept sortable = permutable<_Iter> && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;;
    struct unreachable_sentinel_t {
        friend template <weakly_incrementable _It> constexpr bool operator==(std::unreachable_sentinel_t, const _It &) noexcept         {
            return false;
        }
;
    };
    constexpr std::unreachable_sentinel_t unreachable_sentinel{};
    struct default_sentinel_t {
    };
    constexpr std::default_sentinel_t default_sentinel{};
    namespace ranges {
        namespace __cust_access {
            using std::__detail::__class_or_enum;
            constexpr struct final _Decay_copy {
                template <typename _Tp> constexpr decay_t<_Tp> operator()(_Tp &&__t) const noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>operator()(_Tp &&__t) const noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)                 {
                    return std::forward<_Tp>(__t);
                }
            } __decay_copy{};
            template <typename _Tp> concept __member_begin = requires (_Tp &__t) { { __decay_copy(__t.begin()) } -> input_or_output_iterator; };;
            template <> void begin(auto &) = delete
            template <> void begin(const auto &) = delete
            template <typename _Tp> concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(begin(__t)) } -> input_or_output_iterator; };;
            template <typename _Tp> auto __begin(_Tp &__t)             {
                if (is_array_v<_Tp>)
                    return __t + 0;
                else if (__member_begin<_Tp &>)
                    return __t.begin();
                else
                    return begin(__t);
            }
        }
    }
    namespace __detail {
        template <typename _Tp> using __range_iter_t = decltype(ranges::__cust_access::__begin(std::declval<_Tp &>()));
    }
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
}
namespace std {
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : public std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : public std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : public std::bidirectional_iterator_tag {
    };
    struct contiguous_iterator_tag : public std::random_access_iterator_tag {
    };
    template <typename _Category, typename _Tp, typename _Distance = std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp &> struct [[deprecated("")]] iterator {
        typedef _Category iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef _Pointer pointer;
        typedef _Reference reference;
    };
template<> struct [[deprecated("")]] [[deprecated("")]] iterator<std::output_iterator_tag, void, void, void, void> {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
    };
    template <typename _Iterator> struct iterator_traits
template<> struct iterator_traits<const char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    }
template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    }
template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    }
template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    }
template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    }
template<> struct iterator_traits<char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = std::ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    }
template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    };
    template <typename _Iterator, typename = __void_t<>> struct __iterator_traits {
    };
    template <typename _Iterator> struct iterator_traits : public __iterator_traits<_Iterator> {
    };
template<> struct iterator_traits<const char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    };
template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    };
template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    };
template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    };
template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    };
template<> struct iterator_traits<char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = std::ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    };
template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    };
    template <typename _Tp> struct iterator_traits<_Tp *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<_Tp>;
        using difference_type = std::ptrdiff_t;
        using pointer = _Tp *;
        using reference = _Tp &;
    };
    template <typename _Iter> inline constexpr typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)     {
        return typename iterator_traits<_Iter>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<char *>::iterator_category __iterator_category<char *>(char *const &)     {
        return typename iterator_traits<char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::iterator_category __iterator_category<wchar_t *>(wchar_t *const &)     {
        return typename iterator_traits<wchar_t *>::iterator_category();
    }
    template <typename _Iter> using __iterator_category_t = typename iterator_traits<_Iter>::iterator_category;
    template <typename _InIter> using _RequireInputIter = __enable_if_t<is_convertible<__iterator_category_t<_InIter>, input_iterator_tag>::value>;
    template <typename _It, typename _Cat = __iterator_category_t<_It>> struct __is_random_access_iter : is_base_of<std::random_access_iterator_tag, _Cat> {
        typedef is_base_of<std::random_access_iterator_tag, _Cat> _Base;
        enum  {
            __value = _Base::value
        };
    };
}
namespace std {
    template <typename> struct _List_iterator;
    template <typename> struct _List_const_iterator;
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        while (__first != __last)
            {
                ++__first;
                ++__n;
            }
        return __n;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::input_iterator_tag)    template <typename _RandomAccessIterator> inline constexpr typename iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>, std::input_iterator_tag);
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_const_iterator<_Tp>, std::_List_const_iterator<_Tp>, std::input_iterator_tag);
    template <typename _OutputIterator> void __distance(_OutputIterator, _OutputIterator, std::output_iterator_tag) = delete
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last) [[nodiscard("")]]     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type distance<char *>(char *__first, char *__last) [[nodiscard("")]]     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type distance<wchar_t *>(wchar_t *__first, wchar_t *__last) [[nodiscard("")]]     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void __advance(_InputIterator &__i, _Distance __n, std::input_iterator_tag)     {
        do {
            if (std::__is_constant_evaluated() && !bool(__n >= 0))
                __builtin_unreachable();
        } while (false);
        while (__n--)
            ++__i;
    }
    template <typename _BidirectionalIterator, typename _Distance> inline constexpr void __advance(_BidirectionalIterator &__i, _Distance __n, std::bidirectional_iterator_tag)     {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }
    template <typename _RandomAccessIterator, typename _Distance> inline constexpr void __advance(_RandomAccessIterator &__i, _Distance __n, std::random_access_iterator_tag)     {
        if (__builtin_constant_p(__n) && __n == 1)
            ++__i;
        else if (__builtin_constant_p(__n) && __n == -1)
            --__i;
        else
            __i += __n;
    }
    template <typename _OutputIterator, typename _Distance> void __advance(_OutputIterator &, _Distance, std::output_iterator_tag) = delete
    template <typename _InputIterator, typename _Distance> inline constexpr void advance(_InputIterator &__i, _Distance __n)     {
        typename iterator_traits<_InputIterator>::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }
    template <typename _InputIterator> inline constexpr _InputIterator next(_InputIterator __x, typename iterator_traits<_InputIterator>::difference_type __n = 1) [[nodiscard("")]]     {
        std::advance(__x, __n);
        return __x;
    }
    template <typename _BidirectionalIterator> inline constexpr _BidirectionalIterator prev(_BidirectionalIterator __x, typename iterator_traits<_BidirectionalIterator>::difference_type __n = 1) [[nodiscard("")]]     {
        std::advance(__x, -__n);
        return __x;
    }
}
namespace std {
    template <typename _Tp> inline constexpr void destroy_at(_Tp *__location)     {
        if (202002L > 201703L && is_array_v<_Tp>) {
            for (auto &__x : *__location)
                std::destroy_at(std::__addressof(__x));
        } else
            __location->~_Tp();
    }
    template <typename _Tp, typename ..._Args> constexpr auto construct_at(_Tp *__location, _Args &&...__args) noexcept(noexcept(::new ((void *)0) _Tp((std::declval<_Args>()...)))construct_at(_Tp *__location, _Args &&...__args) noexcept(noexcept(::new ((void *)0) _Tp((std::declval<_Args>()...)))) -> decltype(::new ((void *)0) _Tp((std::declval<_Args>()...)))     {
        return ::new ((void *)__location) _Tp((std::forward<_Args>(__args)...));
    }
    template<> constexpr auto construct_at<char, <const char &>>(char *__location, const char &__args) noexcept(noexcept(::new ((void *)0) char(std::declval<const char &>()))construct_at<char, <const char &>>(char *__location, const char &__args) noexcept(noexcept(::new ((void *)0) char(std::declval<const char &>()))) -> decltype(::new ((void *)0) char(std::declval<const char &>()))     {
        return ::new ((void *)__location) char(std::forward<const char &>(__args));
    }
    template<> constexpr auto construct_at<char, <char &>>(char *__location, char &__args) noexcept(noexcept(::new ((void *)0) char(std::declval<char &>()))construct_at<char, <char &>>(char *__location, char &__args) noexcept(noexcept(::new ((void *)0) char(std::declval<char &>()))) -> decltype(::new ((void *)0) char(std::declval<char &>()))     {
        return ::new ((void *)__location) char(std::forward<char &>(__args));
    }
    template<> constexpr auto construct_at<wchar_t, <const wchar_t &>>(wchar_t *__location, const wchar_t &__args) noexcept(noexcept(::new ((void *)0) wchar_t(std::declval<const wchar_t &>()))construct_at<wchar_t, <const wchar_t &>>(wchar_t *__location, const wchar_t &__args) noexcept(noexcept(::new ((void *)0) wchar_t(std::declval<const wchar_t &>()))) -> decltype(::new ((void *)0) wchar_t(std::declval<const wchar_t &>()))     {
        return ::new ((void *)__location) wchar_t(std::forward<const wchar_t &>(__args));
    }
    template<> constexpr auto construct_at<wchar_t, <wchar_t &>>(wchar_t *__location, wchar_t &__args) noexcept(noexcept(::new ((void *)0) wchar_t(std::declval<wchar_t &>()))construct_at<wchar_t, <wchar_t &>>(wchar_t *__location, wchar_t &__args) noexcept(noexcept(::new ((void *)0) wchar_t(std::declval<wchar_t &>()))) -> decltype(::new ((void *)0) wchar_t(std::declval<wchar_t &>()))     {
        return ::new ((void *)__location) wchar_t(std::forward<wchar_t &>(__args));
    }
    template<> constexpr auto construct_at<char8_t, <const char8_t &>>(char8_t *__location, const char8_t &__args) noexcept(noexcept(::new ((void *)0) char8_t(std::declval<const char8_t &>()))construct_at<char8_t, <const char8_t &>>(char8_t *__location, const char8_t &__args) noexcept(noexcept(::new ((void *)0) char8_t(std::declval<const char8_t &>()))) -> decltype(::new ((void *)0) char8_t(std::declval<const char8_t &>()))     {
        return ::new ((void *)__location) char8_t(std::forward<const char8_t &>(__args));
    }
    template<> constexpr auto construct_at<char8_t, <char8_t &>>(char8_t *__location, char8_t &__args) noexcept(noexcept(::new ((void *)0) char8_t(std::declval<char8_t &>()))construct_at<char8_t, <char8_t &>>(char8_t *__location, char8_t &__args) noexcept(noexcept(::new ((void *)0) char8_t(std::declval<char8_t &>()))) -> decltype(::new ((void *)0) char8_t(std::declval<char8_t &>()))     {
        return ::new ((void *)__location) char8_t(std::forward<char8_t &>(__args));
    }
    template<> constexpr auto construct_at<char16_t, <const char16_t &>>(char16_t *__location, const char16_t &__args) noexcept(noexcept(::new ((void *)0) char16_t(std::declval<const char16_t &>()))construct_at<char16_t, <const char16_t &>>(char16_t *__location, const char16_t &__args) noexcept(noexcept(::new ((void *)0) char16_t(std::declval<const char16_t &>()))) -> decltype(::new ((void *)0) char16_t(std::declval<const char16_t &>()))     {
        return ::new ((void *)__location) char16_t(std::forward<const char16_t &>(__args));
    }
    template<> constexpr auto construct_at<char32_t, <const char32_t &>>(char32_t *__location, const char32_t &__args) noexcept(noexcept(::new ((void *)0) char32_t(std::declval<const char32_t &>()))construct_at<char32_t, <const char32_t &>>(char32_t *__location, const char32_t &__args) noexcept(noexcept(::new ((void *)0) char32_t(std::declval<const char32_t &>()))) -> decltype(::new ((void *)0) char32_t(std::declval<const char32_t &>()))     {
        return ::new ((void *)__location) char32_t(std::forward<const char32_t &>(__args));
    }
    template <typename _Tp, typename ..._Args> inline constexpr void _Construct(_Tp *__p, _Args &&...__args)     {
        if (std::__is_constant_evaluated()) {
            std::construct_at(__p, std::forward<_Args>(__args)...);
            return;
        }
        ::new ((void *)__p) _Tp((std::forward<_Args>(__args)...));
    }
    template <typename _T1> inline void _Construct_novalue(_T1 *__p)     {
        ::new ((void *)__p) _T1;
    }
    template <typename _ForwardIterator> constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last);
    template <typename _Tp> inline constexpr void _Destroy(_Tp *__pointer)     {
        std::destroy_at(__pointer);
    }
    template <bool> struct _Destroy_aux {
        template <typename _ForwardIterator> static constexpr void __destroy(_ForwardIterator __first, _ForwardIterator __last)         {
            for (; __first != __last; ++__first)
                std::_Destroy(std::__addressof(*__first));
        }
    };
template<> struct _Destroy_aux<false> {
        template <typename _ForwardIterator> static constexpr void __destroy(_ForwardIterator __first, _ForwardIterator __last);
    };
    template<> struct _Destroy_aux<true> {
        template <typename _ForwardIterator> static void __destroy(_ForwardIterator, _ForwardIterator)         {
        }
    };
    template <typename _ForwardIterator> inline constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        if (std::__is_constant_evaluated())
            return _Destroy_aux<false>::__destroy(__first, __last);
        std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first, __last);
    }
    template <bool> struct _Destroy_n_aux {
        template <typename _ForwardIterator, typename _Size> static constexpr _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count)         {
            for (; __count > 0; (void)++__first , --__count)
                std::_Destroy(std::__addressof(*__first));
            return __first;
        }
    };
template<> struct _Destroy_n_aux<false> {
        template <typename _ForwardIterator, typename _Size> static constexpr _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count);
    };
    template<> struct _Destroy_n_aux<true> {
        template <typename _ForwardIterator, typename _Size> static _ForwardIterator __destroy_n(_ForwardIterator __first, _Size __count)         {
            std::advance(__first, __count);
            return __first;
        }
    };
    template <typename _ForwardIterator, typename _Size> inline constexpr _ForwardIterator _Destroy_n(_ForwardIterator __first, _Size __count)     {
        typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;
        static_assert(is_destructible<_Value_type>::value, "value type is destructible");
        if (std::__is_constant_evaluated())
            return _Destroy_n_aux<false>::__destroy_n(__first, __count);
        return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::__destroy_n(__first, __count);
    }
    template <typename _ForwardIterator> inline constexpr void destroy(_ForwardIterator __first, _ForwardIterator __last)     {
        std::_Destroy(__first, __last);
    }
    template <typename _ForwardIterator, typename _Size> inline constexpr _ForwardIterator destroy_n(_ForwardIterator __first, _Size __count)     {
        return std::_Destroy_n(__first, __count);
    }
}
namespace __gnu_cxx {
    template <typename _CharT> struct _Char_types {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<wchar_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char8_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char16_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char32_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template <typename _CharT> struct char_traits {
        typedef _CharT char_type;
        typedef typename _Char_types<_CharT>::int_type int_type;
        typedef typename _Char_types<_CharT>::pos_type pos_type;
        typedef typename _Char_types<_CharT>::off_type off_type;
        typedef typename _Char_types<_CharT>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits::char_type *__s);
        static constexpr const __gnu_cxx::char_traits::char_type *find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a);
        static constexpr __gnu_cxx::char_traits::char_type *move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr __gnu_cxx::char_traits::char_type *copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr __gnu_cxx::char_traits::char_type *assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a);
        static constexpr __gnu_cxx::char_traits::char_type to_char_type(const __gnu_cxx::char_traits::int_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::char_type>(__c);
        }
        static constexpr __gnu_cxx::char_traits::int_type to_int_type(const __gnu_cxx::char_traits::char_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::int_type>(__c);
        }
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits::int_type &__c1, const __gnu_cxx::char_traits::int_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr __gnu_cxx::char_traits::int_type eof()         {
            return static_cast<__gnu_cxx::char_traits::int_type>(-1);
        }
        static constexpr __gnu_cxx::char_traits::int_type not_eof(const __gnu_cxx::char_traits::int_type &__c)         {
            return !eq_int_type(__c, eof()) ? __c : to_int_type(__gnu_cxx::char_traits::char_type());
        }
    };
template<> struct char_traits<char> {
        typedef char char_type;
        typedef typename _Char_types<char>::int_type int_type;
        typedef typename _Char_types<char>::pos_type pos_type;
        typedef typename _Char_types<char>::off_type off_type;
        typedef typename _Char_types<char>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2);
        static constexpr int compare(const __gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n);
        static constexpr std::size_t char_traits<char>::length(const __gnu_cxx::char_traits<char>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<char>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<char>::char_type *char_traits<char>::find(const __gnu_cxx::char_traits<char>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type *char_traits<char>::move(__gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                __gnu_cxx::char_traits<char>::char_type *__tmp = new __gnu_cxx::char_traits<char>::char_type [__n];
                copy(__tmp, __s2, __n);
                copy(__s1, __tmp, __n);
                delete [] __tmp;
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type *char_traits<char>::copy(__gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type *char_traits<char>::assign(__gnu_cxx::char_traits<char>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char>::char_type __a)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s + __i, __a);
                return __s;
            }
            if (sizeof(char) == 1 && __is_trivial(char)) {
                unsigned char __c;
                __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
                __builtin_memset(__s, __c, __n);
            }
            return __s;
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type to_char_type(const __gnu_cxx::char_traits<char>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char>::int_type to_int_type(const __gnu_cxx::char_traits<char>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char>::int_type &__c1, const __gnu_cxx::char_traits<char>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char>::int_type not_eof(const __gnu_cxx::char_traits<char>::int_type &__c);
    };
template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef typename _Char_types<wchar_t>::int_type int_type;
        typedef typename _Char_types<wchar_t>::pos_type pos_type;
        typedef typename _Char_types<wchar_t>::off_type off_type;
        typedef typename _Char_types<wchar_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int char_traits<wchar_t>::compare(const __gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<wchar_t>::length(const __gnu_cxx::char_traits<wchar_t>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<wchar_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::find(const __gnu_cxx::char_traits<wchar_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<wchar_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::move(__gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                __gnu_cxx::char_traits<wchar_t>::char_type *__tmp = new __gnu_cxx::char_traits<wchar_t>::char_type [__n];
                copy(__tmp, __s2, __n);
                copy(__s1, __tmp, __n);
                delete [] __tmp;
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<wchar_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::copy(__gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<wchar_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::assign(__gnu_cxx::char_traits<wchar_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<wchar_t>::char_type __a)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s + __i, __a);
                return __s;
            }
            if (sizeof(wchar_t) == 1 && __is_trivial(wchar_t))
                ;
            else {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    __s[__i] = __a;
            }
            return __s;
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type to_char_type(const __gnu_cxx::char_traits<wchar_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type to_int_type(const __gnu_cxx::char_traits<wchar_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<wchar_t>::int_type &__c1, const __gnu_cxx::char_traits<wchar_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type not_eof(const __gnu_cxx::char_traits<wchar_t>::int_type &__c);
    };
template<> struct char_traits<char8_t> {
        typedef char8_t char_type;
        typedef typename _Char_types<char8_t>::int_type int_type;
        typedef typename _Char_types<char8_t>::pos_type pos_type;
        typedef typename _Char_types<char8_t>::off_type off_type;
        typedef typename _Char_types<char8_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char8_t>::char_type &__c1, const __gnu_cxx::char_traits<char8_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char8_t>::char_type &__c1, const __gnu_cxx::char_traits<char8_t>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<char8_t>::char_type &__c1, const __gnu_cxx::char_traits<char8_t>::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int char_traits<char8_t>::compare(const __gnu_cxx::char_traits<char8_t>::char_type *__s1, const __gnu_cxx::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<char8_t>::length(const __gnu_cxx::char_traits<char8_t>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<char8_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::find(const __gnu_cxx::char_traits<char8_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char8_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::move(__gnu_cxx::char_traits<char8_t>::char_type *__s1, const __gnu_cxx::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                __gnu_cxx::char_traits<char8_t>::char_type *__tmp = new __gnu_cxx::char_traits<char8_t>::char_type [__n];
                copy(__tmp, __s2, __n);
                copy(__s1, __tmp, __n);
                delete [] __tmp;
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char8_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::copy(__gnu_cxx::char_traits<char8_t>::char_type *__s1, const __gnu_cxx::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char8_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::assign(__gnu_cxx::char_traits<char8_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char8_t>::char_type __a)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s + __i, __a);
                return __s;
            }
            if (sizeof(char8_t) == 1 && __is_trivial(char8_t)) {
                unsigned char __c;
                __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
                __builtin_memset(__s, __c, __n);
            }
            return __s;
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type to_char_type(const __gnu_cxx::char_traits<char8_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char8_t>::int_type to_int_type(const __gnu_cxx::char_traits<char8_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char8_t>::int_type &__c1, const __gnu_cxx::char_traits<char8_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char8_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char8_t>::int_type not_eof(const __gnu_cxx::char_traits<char8_t>::int_type &__c);
    };
template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef typename _Char_types<char16_t>::int_type int_type;
        typedef typename _Char_types<char16_t>::pos_type pos_type;
        typedef typename _Char_types<char16_t>::off_type off_type;
        typedef typename _Char_types<char16_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char16_t>::char_type &__c1, const __gnu_cxx::char_traits<char16_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char16_t>::char_type &__c1, const __gnu_cxx::char_traits<char16_t>::char_type &__c2);
        static constexpr bool lt(const __gnu_cxx::char_traits<char16_t>::char_type &__c1, const __gnu_cxx::char_traits<char16_t>::char_type &__c2);
        static constexpr int compare(const __gnu_cxx::char_traits<char16_t>::char_type *__s1, const __gnu_cxx::char_traits<char16_t>::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits<char16_t>::char_type *__s);
        static constexpr const __gnu_cxx::char_traits<char16_t>::char_type *find(const __gnu_cxx::char_traits<char16_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char16_t>::char_type &__a);
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type *char_traits<char16_t>::move(__gnu_cxx::char_traits<char16_t>::char_type *__s1, const __gnu_cxx::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                __gnu_cxx::char_traits<char16_t>::char_type *__tmp = new __gnu_cxx::char_traits<char16_t>::char_type [__n];
                copy(__tmp, __s2, __n);
                copy(__s1, __tmp, __n);
                delete [] __tmp;
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char16_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type *char_traits<char16_t>::copy(__gnu_cxx::char_traits<char16_t>::char_type *__s1, const __gnu_cxx::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char16_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type *assign(__gnu_cxx::char_traits<char16_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char16_t>::char_type __a);
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type to_char_type(const __gnu_cxx::char_traits<char16_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char16_t>::int_type to_int_type(const __gnu_cxx::char_traits<char16_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char16_t>::int_type &__c1, const __gnu_cxx::char_traits<char16_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char16_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char16_t>::int_type not_eof(const __gnu_cxx::char_traits<char16_t>::int_type &__c);
    };
template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef typename _Char_types<char32_t>::int_type int_type;
        typedef typename _Char_types<char32_t>::pos_type pos_type;
        typedef typename _Char_types<char32_t>::off_type off_type;
        typedef typename _Char_types<char32_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char32_t>::char_type &__c1, const __gnu_cxx::char_traits<char32_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char32_t>::char_type &__c1, const __gnu_cxx::char_traits<char32_t>::char_type &__c2);
        static constexpr bool lt(const __gnu_cxx::char_traits<char32_t>::char_type &__c1, const __gnu_cxx::char_traits<char32_t>::char_type &__c2);
        static constexpr int compare(const __gnu_cxx::char_traits<char32_t>::char_type *__s1, const __gnu_cxx::char_traits<char32_t>::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits<char32_t>::char_type *__s);
        static constexpr const __gnu_cxx::char_traits<char32_t>::char_type *find(const __gnu_cxx::char_traits<char32_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char32_t>::char_type &__a);
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type *char_traits<char32_t>::move(__gnu_cxx::char_traits<char32_t>::char_type *__s1, const __gnu_cxx::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated()) {
                if (__s1 == __s2)
                    return __s1;
                __gnu_cxx::char_traits<char32_t>::char_type *__tmp = new __gnu_cxx::char_traits<char32_t>::char_type [__n];
                copy(__tmp, __s2, __n);
                copy(__s1, __tmp, __n);
                delete [] __tmp;
                return __s1;
            }
            __builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char32_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type *char_traits<char32_t>::copy(__gnu_cxx::char_traits<char32_t>::char_type *__s1, const __gnu_cxx::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    std::construct_at(__s1 + __i, __s2[__i]);
                return __s1;
            }
            __builtin_memcpy(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char32_t>::char_type));
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type *assign(__gnu_cxx::char_traits<char32_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char32_t>::char_type __a);
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type to_char_type(const __gnu_cxx::char_traits<char32_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char32_t>::int_type to_int_type(const __gnu_cxx::char_traits<char32_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char32_t>::int_type &__c1, const __gnu_cxx::char_traits<char32_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char32_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char32_t>::int_type not_eof(const __gnu_cxx::char_traits<char32_t>::int_type &__c);
    };
    template <typename _CharT> constexpr int char_traits<_CharT>::compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (lt(__s1[__i], __s2[__i]))
                return -1;
            else if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }
    template <typename _CharT> constexpr std::size_t char_traits<_CharT>::length(const __gnu_cxx::char_traits::char_type *__p)     {
        std::size_t __i = 0;
        while (!eq(__p[__i], __gnu_cxx::char_traits::char_type()))
            ++__i;
        return __i;
    }
    template <typename _CharT> constexpr const typename char_traits<_CharT>::char_type *char_traits<_CharT>::find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (eq(__s[__i], __a))
                return __s + __i;
        return 0;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        if (__n == 0)
            return __s1;
        if (std::__is_constant_evaluated()) {
            if (__s1 == __s2)
                return __s1;
            __gnu_cxx::char_traits::char_type *__tmp = new __gnu_cxx::char_traits::char_type [__n];
            copy(__tmp, __s2, __n);
            copy(__s1, __tmp, __n);
            delete [] __tmp;
            return __s1;
        }
        __builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits::char_type));
        return __s1;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        if (std::__is_constant_evaluated()) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                std::construct_at(__s1 + __i, __s2[__i]);
            return __s1;
        }
        __builtin_memcpy(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits::char_type));
        return __s1;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a)     {
        if (std::__is_constant_evaluated()) {
            for (std::size_t __i = 0; __i < __n; ++__i)
                std::construct_at(__s + __i, __a);
            return __s;
        }
        if (sizeof(_CharT) == 1 && __is_trivial(_CharT)) {
            unsigned char __c;
            __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
            __builtin_memset(__s, __c, __n);
        } else {
            for (std::size_t __i = 0; __i < __n; ++__i)
                __s[__i] = __a;
        }
        return __s;
    }
}
namespace std {
    template <typename _CharT> struct char_traits : public __gnu_cxx::char_traits<_CharT> {
    };
    template<> struct char_traits<char> {
        typedef char char_type;
        typedef int int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }
        static constexpr int compare(const std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated()) {
                for (std::size_t __i = 0; __i < __n; ++__i)
                    if (lt(__s1[__i], __s2[__i]))
                        return -1;
                    else if (lt(__s2[__i], __s1[__i]))
                        return 1;
                return 0;
            }
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<char>::char_type *__s)         {
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return __builtin_strlen(__s);
        }
        static constexpr const std::char_traits<char>::char_type *find(const std::char_traits<char>::char_type *__s, std::size_t __n, const std::char_traits<char>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return static_cast<const std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static constexpr std::char_traits<char>::char_type *move(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char>::char_type *copy(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char>::char_type *assign(std::char_traits<char>::char_type *__s, std::size_t __n, std::char_traits<char>::char_type __a)         {
            if (__n == 0)
                return __s;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr std::char_traits<char>::char_type to_char_type(const std::char_traits<char>::int_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::char_type>(__c);
        }
        static constexpr std::char_traits<char>::int_type to_int_type(const std::char_traits<char>::char_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
        }
        static constexpr bool eq_int_type(const std::char_traits<char>::int_type &__c1, const std::char_traits<char>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char>::int_type>(-1);
        }
        static constexpr std::char_traits<char>::int_type not_eof(const std::char_traits<char>::int_type &__c) noexcept         {
            return (__c == eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef std::streamoff off_type;
        typedef std::wstreampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return wmemcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<wchar_t>::char_type *__s)         {
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return wcslen(__s);
        }
        static constexpr const std::char_traits<wchar_t>::char_type *find(const std::char_traits<wchar_t>::char_type *__s, std::size_t __n, const std::char_traits<wchar_t>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return wmemchr(__s, __a, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type *move(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return wmemmove(__s1, __s2, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type *copy(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return wmemcpy(__s1, __s2, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type *assign(std::char_traits<wchar_t>::char_type *__s, std::size_t __n, std::char_traits<wchar_t>::char_type __a)         {
            if (__n == 0)
                return __s;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return wmemset(__s, __a, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type to_char_type(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return std::char_traits<wchar_t>::char_type(__c);
        }
        static constexpr std::char_traits<wchar_t>::int_type to_int_type(const std::char_traits<wchar_t>::char_type &__c) noexcept         {
            return std::char_traits<wchar_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<wchar_t>::int_type &__c1, const std::char_traits<wchar_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<wchar_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<wchar_t>::int_type>((4294967295U));
        }
        static constexpr std::char_traits<wchar_t>::int_type not_eof(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char8_t> {
        typedef char8_t char_type;
        typedef unsigned int int_type;
        typedef std::u8streampos pos_type;
        typedef std::streamoff off_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char8_t>::char_type &__c1, const std::char_traits<char8_t>::char_type &__c2) noexcept         {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char8_t>::char_type &__c1, const std::char_traits<char8_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char8_t>::char_type &__c1, const std::char_traits<char8_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char8_t>::char_type *__s1, const std::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<char8_t>::char_type *__s)         {
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::length(__s);
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char8_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char8_t>::char_type *find(const std::char_traits<char8_t>::char_type *__s, std::size_t __n, const std::char_traits<char8_t>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return static_cast<const std::char_traits<char8_t>::char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type *move(std::char_traits<char8_t>::char_type *__s1, const std::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return static_cast<std::char_traits<char8_t>::char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type *copy(std::char_traits<char8_t>::char_type *__s1, const std::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return static_cast<std::char_traits<char8_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type *assign(std::char_traits<char8_t>::char_type *__s, std::size_t __n, std::char_traits<char8_t>::char_type __a)         {
            if (__n == 0)
                return __s;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return static_cast<std::char_traits<char8_t>::char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type to_char_type(const std::char_traits<char8_t>::int_type &__c) noexcept         {
            return std::char_traits<char8_t>::char_type(__c);
        }
        static constexpr std::char_traits<char8_t>::int_type to_int_type(const std::char_traits<char8_t>::char_type &__c) noexcept         {
            return std::char_traits<char8_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char8_t>::int_type &__c1, const std::char_traits<char8_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char8_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char8_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char8_t>::int_type not_eof(const std::char_traits<char8_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef struct {
    int __val[2];
} __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef long __suseconds64_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
namespace std {
    using ::int8_t;
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::int_fast8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::int_least8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uint8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::uint_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::uint_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::uintmax_t;
    using ::uintptr_t;
}
namespace std {
    template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef uint_least16_t int_type;
        typedef std::streamoff off_type;
        typedef std::u16streampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t length(const std::char_traits<char16_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char16_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char16_t>::char_type *find(const std::char_traits<char16_t>::char_type *__s, std::size_t __n, const std::char_traits<char16_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr std::char_traits<char16_t>::char_type *move(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static constexpr std::char_traits<char16_t>::char_type *copy(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static constexpr std::char_traits<char16_t>::char_type *assign(std::char_traits<char16_t>::char_type *__s, std::size_t __n, std::char_traits<char16_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char16_t>::char_type to_char_type(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return std::char_traits<char16_t>::char_type(__c);
        }
        static constexpr std::char_traits<char16_t>::int_type to_int_type(const std::char_traits<char16_t>::char_type &__c) noexcept         {
            return __c == eof() ? std::char_traits<char16_t>::int_type(65533) : std::char_traits<char16_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char16_t>::int_type &__c1, const std::char_traits<char16_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char16_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char16_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char16_t>::int_type not_eof(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef uint_least32_t int_type;
        typedef std::streamoff off_type;
        typedef std::u32streampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            if (std::__is_constant_evaluated())
                std::construct_at(__builtin_addressof(__c1), __c2);
            else
                __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t length(const std::char_traits<char32_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char32_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char32_t>::char_type *find(const std::char_traits<char32_t>::char_type *__s, std::size_t __n, const std::char_traits<char32_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr std::char_traits<char32_t>::char_type *move(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static constexpr std::char_traits<char32_t>::char_type *copy(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::__is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static constexpr std::char_traits<char32_t>::char_type *assign(std::char_traits<char32_t>::char_type *__s, std::size_t __n, std::char_traits<char32_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char32_t>::char_type to_char_type(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return std::char_traits<char32_t>::char_type(__c);
        }
        static constexpr std::char_traits<char32_t>::int_type to_int_type(const std::char_traits<char32_t>::char_type &__c) noexcept         {
            return std::char_traits<char32_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char32_t>::int_type &__c1, const std::char_traits<char32_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char32_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char32_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char32_t>::int_type not_eof(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    namespace __detail {
        template <typename _ChTraits> constexpr auto __char_traits_cmp_cat(int __cmp) noexcept         {
            if (requires { typename _ChTraits::comparison_category; }) {
                using _Cat = typename _ChTraits::comparison_category;
                static_assert(!is_void_v<common_comparison_category_t<_Cat>>);
                return static_cast<_Cat>(__cmp <=> 0);
            } else
                return static_cast<std::weak_ordering>(__cmp <=> 0);
        }
    }
}
namespace std {
    void __throw_bad_exception();
    void __throw_bad_alloc();
    void __throw_bad_array_new_length();
    void __throw_bad_cast();
    void __throw_bad_typeid();
    void __throw_logic_error(const char *);
    void __throw_domain_error(const char *);
    void __throw_invalid_argument(const char *);
    void __throw_length_error(const char *);
    void __throw_out_of_range(const char *);
    void __throw_out_of_range_fmt(const char *, ...);
    void __throw_runtime_error(const char *);
    void __throw_range_error(const char *);
    void __throw_overflow_error(const char *);
    void __throw_underflow_error(const char *);
    void __throw_ios_failure(const char *);
    void __throw_ios_failure(const char *, int);
    void __throw_system_error(int);
    void __throw_future_error(int);
    void __throw_bad_function_call();
}
namespace std {
    std::size_t _Hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
    std::size_t _Fnv_hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
}
namespace std {
    template <typename _Result, typename _Arg> struct __hash_base {
        typedef _Result result_type [[deprecated("")]];
        typedef _Arg argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, bool> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef bool argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, signed char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef signed char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, wchar_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef wchar_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char8_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char8_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char16_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char16_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char32_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char32_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef short argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef int argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned short argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned int argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, float> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef float argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef double argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long double argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, nullptr_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef nullptr_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char, std::char_traits<char>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char, std::char_traits<char>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<wchar_t, std::char_traits<wchar_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char8_t, std::char_traits<char8_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char8_t, std::char_traits<char8_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char16_t, std::char_traits<char16_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char16_t, std::char_traits<char16_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char32_t, std::char_traits<char32_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char32_t, std::char_traits<char32_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::pmr::polymorphic_allocator<char8_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::pmr::polymorphic_allocator<char8_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::error_code> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::error_code argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::error_condition> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::error_condition argument_type [[deprecated("")]];
    };
    template <typename _Tp> struct hash;
    template <typename _Tp, typename = void> struct __poison_hash {
        static constexpr bool __enable_hash_call = false;
    private:
        __poison_hash<_Tp, type-parameter-0-1>(__poison_hash<_Tp, type-parameter-0-1> &&);
        ~__poison_hash<_Tp, type-parameter-0-1>();
    };
    template <typename _Tp> struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
        static constexpr bool __enable_hash_call = true;
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
    private:
        __hash_enum<_Tp, >(__hash_enum<_Tp, > &&);
        ~__hash_enum<_Tp, >();
    };
    template <typename _Tp> struct __hash_enum<_Tp, true> : public __hash_base<std::size_t, _Tp> {
        std::size_t operator()(_Tp __val) const noexcept         {
            using __type = typename underlying_type<_Tp>::type;
            return hash<__type>({})(static_cast<__type>(__val));
        }
    };
    template <typename _Tp> struct hash : __hash_enum<_Tp> {
    };
    template <typename _Tp> struct hash<_Tp *> : public __hash_base<std::size_t, _Tp *> {
        std::size_t operator()(_Tp *__p) const noexcept         {
            return reinterpret_cast<std::size_t>(__p);
        }
    };
    template<> struct hash<bool> : public __hash_base<std::size_t, bool> {
        std::size_t operator()(bool __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char> : public __hash_base<std::size_t, char> {
        std::size_t operator()(char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<signed char> : public __hash_base<std::size_t, signed char> {
        std::size_t operator()(signed char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned char> : public __hash_base<std::size_t, unsigned char> {
        std::size_t operator()(unsigned char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<wchar_t> : public __hash_base<std::size_t, wchar_t> {
        std::size_t operator()(wchar_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char8_t> : public __hash_base<std::size_t, char8_t> {
        std::size_t operator()(char8_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char16_t> : public __hash_base<std::size_t, char16_t> {
        std::size_t operator()(char16_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char32_t> : public __hash_base<std::size_t, char32_t> {
        std::size_t operator()(char32_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<short> : public __hash_base<std::size_t, short> {
        std::size_t operator()(short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<int> : public __hash_base<std::size_t, int> {
        std::size_t operator()(int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long> : public __hash_base<std::size_t, long> {
        std::size_t operator()(long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long long> : public __hash_base<std::size_t, long long> {
        std::size_t operator()(long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned short> : public __hash_base<std::size_t, unsigned short> {
        std::size_t operator()(unsigned short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned int> : public __hash_base<std::size_t, unsigned int> {
        std::size_t operator()(unsigned int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long> : public __hash_base<std::size_t, unsigned long> {
        std::size_t operator()(unsigned long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long long> : public __hash_base<std::size_t, unsigned long long> {
        std::size_t operator()(unsigned long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    struct _Hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(3339675911UL))         {
            return _Hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<float>(const float &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<double>(const double &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<int>(const int &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
        template<> static std::size_t __hash_combine<const std::_V2::error_category *>(const std::_V2::error_category *const &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    struct _Fnv_hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(2166136261UL))         {
            return _Fnv_hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    template<> struct hash<float> : public __hash_base<std::size_t, float> {
        std::size_t operator()(float __val) const noexcept         {
            return __val != 0.F ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<double> : public __hash_base<std::size_t, double> {
        std::size_t operator()(double __val) const noexcept         {
            return __val != 0. ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<long double> : public __hash_base<std::size_t, long double> {
        std::size_t operator()(long double __val) const noexcept __attribute__((pure));
    };
    template<> struct hash<std::nullptr_t> : public __hash_base<std::size_t, std::nullptr_t> {
        std::size_t operator()(std::nullptr_t) const noexcept         {
            return 0;
        }
    };
    template <typename _Hash> struct __is_fast_hash : public std::true_type {
    };
    template<> struct __is_fast_hash<hash<long double>> : public std::false_type {
    };
}
namespace std {
    template <class _E> class initializer_list {
    public:
        typedef _E value_type;
        typedef const _E &reference;
        typedef const _E &const_reference;
        typedef std::size_t size_type;
        typedef const _E *iterator;
        typedef const _E *const_iterator;
    private:
        std::initializer_list::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list<_E>(std::initializer_list::const_iterator __a, std::initializer_list::size_type __l) : _M_array(__a), _M_len(__l)         {
        }
    public:
        constexpr initializer_list<_E>() noexcept : _M_array(0), _M_len(0)         {
        }
        constexpr std::initializer_list::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::initializer_list::const_iterator begin() const noexcept         {
            return this->_M_array;
        }
        constexpr std::initializer_list::const_iterator end() const noexcept         {
            return this->begin() + this->size();
        }
    };
template<> class initializer_list<char> {
    public:
        typedef char value_type;
        typedef const char &reference;
        typedef const char &const_reference;
        typedef std::size_t size_type;
        typedef const char *iterator;
        typedef const char *const_iterator;
    private:
        std::initializer_list<char>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char>::const_iterator end() const noexcept;
    };
template<> class initializer_list<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef const wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef std::size_t size_type;
        typedef const wchar_t *iterator;
        typedef const wchar_t *const_iterator;
    private:
        std::initializer_list<wchar_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<wchar_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator end() const noexcept;
    };
template<> class initializer_list<char8_t> {
    public:
        typedef char8_t value_type;
        typedef const char8_t &reference;
        typedef const char8_t &const_reference;
        typedef std::size_t size_type;
        typedef const char8_t *iterator;
        typedef const char8_t *const_iterator;
    private:
        std::initializer_list<char8_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char8_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char8_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char8_t>::const_iterator end() const noexcept;
    };
template<> class initializer_list<char16_t> {
    public:
        typedef char16_t value_type;
        typedef const char16_t &reference;
        typedef const char16_t &const_reference;
        typedef std::size_t size_type;
        typedef const char16_t *iterator;
        typedef const char16_t *const_iterator;
    private:
        std::initializer_list<char16_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char16_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator end() const noexcept;
    };
template<> class initializer_list<char32_t> {
    public:
        typedef char32_t value_type;
        typedef const char32_t &reference;
        typedef const char32_t &const_reference;
        typedef std::size_t size_type;
        typedef const char32_t *iterator;
        typedef const char32_t *const_iterator;
    private:
        std::initializer_list<char32_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char32_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator end() const noexcept;
    };
    template <class _Tp> constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept     {
        return __ils.begin();
    }
    template <class _Tp> constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept     {
        return __ils.end();
    }
}
extern "C++" {
    namespace std {
        struct __true_type {
        };
        struct __false_type {
        };
        template <bool> struct __truth_type {
            typedef std::__false_type __type;
        };
        template<> struct __truth_type<true> {
            typedef std::__true_type __type;
        };
        template <class _Sp, class _Tp> struct __traitor {
            enum  {
                __value = bool(_Sp::__value) || bool(_Tp::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template <typename, typename> struct __are_same {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<float, float> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
template<> struct __are_same<float, double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<double, float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<double, double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
template<> struct __are_same<long double, float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<long double, double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __are_same<_Tp, _Tp> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_void {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_void<void> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_integer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<long double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<bool> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char8_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char16_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char32_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_floating {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_floating<float> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<long double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_pointer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __is_pointer<_Tp *> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_arithmetic : public __traitor<__is_integer<_Tp>, __is_floating<_Tp>> {
        };
        template <typename _Tp> struct __is_scalar : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>> {
        };
        template <typename _Tp> struct __is_char {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_char<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_char<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_byte {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_byte<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        enum class byte : unsigned char;
        template<> struct __is_byte<std::byte> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<char8_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename> struct iterator_traits
template<> struct iterator_traits<const char *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char *;
            using reference = const char &;
        }
template<> struct iterator_traits<const wchar_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const wchar_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const wchar_t *;
            using reference = const wchar_t &;
        }
template<> struct iterator_traits<const char8_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char8_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char8_t *;
            using reference = const char8_t &;
        }
template<> struct iterator_traits<const char16_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char16_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char16_t *;
            using reference = const char16_t &;
        }
template<> struct iterator_traits<const char32_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char32_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char32_t *;
            using reference = const char32_t &;
        }
template<> struct iterator_traits<char *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<char>;
            using difference_type = std::ptrdiff_t;
            using pointer = char *;
            using reference = char &;
        }
template<> struct iterator_traits<wchar_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<wchar_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = wchar_t *;
            using reference = wchar_t &;
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable {
            enum  {
                __value = __is_trivially_copyable(_Tp)
            };
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
            enum  {
                __value = 0
            };
        };
        template <typename _OutputIter, typename _InputIter> struct __memcpyable {
            enum  {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcpyable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcpyable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Iter1, typename _Iter2> struct __memcmpable {
            enum  {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcmpable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<const _Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp, bool _TreatAsBytes = __is_byte<_Tp>::__value> struct __is_memcmp_ordered {
            static const bool __value = _Tp(-1) > _Tp(1);
        };
        template <typename _Tp> struct __is_memcmp_ordered<_Tp, false> {
            static const bool __value = false;
        };
        template <typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)> struct __is_memcmp_ordered_with {
            static const bool __value = __is_memcmp_ordered<_Tp>::__value && __is_memcmp_ordered<_Up>::__value;
        };
        template <typename _Tp, typename _Up> struct __is_memcmp_ordered_with<_Tp, _Up, false> {
            static const bool __value = false;
        };
        template<> struct __is_memcmp_ordered_with<std::byte, std::byte, true> {
            static constexpr bool __value = true;
        };
        template <typename _Tp, bool _SameSize> struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize> {
            static constexpr bool __value = false;
        };
        template <typename _Up, bool _SameSize> struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize> {
            static constexpr bool __value = false;
        };
        template <typename _Tp> struct __is_move_iterator {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Iterator> inline constexpr _Iterator __miter_base(_Iterator __it)         {
            return __it;
        }
    }
}
extern "C++" {
    namespace __gnu_cxx {
        template <bool, typename> struct __enable_if {
        };
template<> struct __enable_if<false, double> {
        };
template<> struct __enable_if<false, bool> {
        };
        template <typename _Tp> struct __enable_if<true, _Tp> {
            typedef _Tp __type;
        };
        template <bool _Cond, typename _Iftrue, typename _Iffalse> struct __conditional_type {
            typedef _Iftrue __type;
        };
template<> struct __conditional_type<true, unsigned long, unsigned long long> {
            typedef unsigned long __type;
        };
        template <typename _Iftrue, typename _Iffalse> struct __conditional_type<false, _Iftrue, _Iffalse> {
            typedef _Iffalse __type;
        };
        template <typename _Tp> struct __add_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __add_unsigned<char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<signed char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<short> {
            typedef unsigned short __type;
        };
        template<> struct __add_unsigned<int> {
            typedef unsigned int __type;
        };
        template<> struct __add_unsigned<long> {
            typedef unsigned long __type;
        };
        template<> struct __add_unsigned<long long> {
            typedef unsigned long long __type;
        };
        template<> struct __add_unsigned<bool>;
        template<> struct __add_unsigned<wchar_t>;
        template <typename _Tp> struct __remove_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __remove_unsigned<char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned short> {
            typedef short __type;
        };
        template<> struct __remove_unsigned<unsigned int> {
            typedef int __type;
        };
        template<> struct __remove_unsigned<unsigned long> {
            typedef long __type;
        };
        template<> struct __remove_unsigned<unsigned long long> {
            typedef long long __type;
        };
        template<> struct __remove_unsigned<bool>;
        template<> struct __remove_unsigned<wchar_t>;
        template <typename _Type> inline constexpr bool __is_null_pointer(_Type *__ptr)         {
            return __ptr == 0;
        }
        template <typename _Type> inline constexpr bool __is_null_pointer(_Type)         {
            return false;
        }
        constexpr bool __is_null_pointer(std::nullptr_t)         {
            return true;
        }
        template <typename _Tp, bool = std::__is_integer<_Tp>::__value> struct __promote {
            typedef double __type;
        };
        template <typename _Tp> struct __promote<_Tp, false> {
        };
        template<> struct __promote<long double> {
            typedef long double __type;
        };
        template<> struct __promote<double> {
            typedef double __type;
        };
        template<> struct __promote<float> {
            typedef float __type;
        };
        template <typename ..._Tp> using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));
        template <typename _Tp, typename _Up> using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;
        template <typename _Tp, typename _Up, typename _Vp> using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;
        template <typename _Tp, typename _Up, typename _Vp, typename _Wp> using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
    }
}
namespace std {
    namespace __detail {
        template <typename _Cat, typename _Limit, typename _Otherwise = _Cat> using __clamp_iter_cat = __conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
    }
    template <typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference> {
        friend template <typename _Iter> class reverse_iterator;
        template <typename _Iter> static constexpr bool __convertible = !is_same_v<_Iter, _Iterator> && convertible_to<const _Iter &, _Iterator>;
    protected:
        _Iterator current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = __conditional_t<random_access_iterator<_Iterator>, std::random_access_iterator_tag, std::bidirectional_iterator_tag>;
        using iterator_category = __detail::__clamp_iter_cat<typename __traits_type::iterator_category, random_access_iterator_tag>;
        using value_type = iter_value_t<_Iterator>;
        using difference_type = iter_difference_t<_Iterator>;
        using reference = iter_reference_t<_Iterator>;
        constexpr reverse_iterator<_Iterator>() noexcept(noexcept(_Iterator())reverse_iterator<_Iterator>() noexcept(noexcept(_Iterator())) : current()         {
        }
        constexpr explicit reverse_iterator<_Iterator>(std::reverse_iterator::iterator_type __x) noexcept(noexcept(_Iterator(__x))reverse_iterator<_Iterator>(std::reverse_iterator::iterator_type __x) noexcept(noexcept(_Iterator(__x))) : current(__x)         {
        }
        constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) noexcept(noexcept(_Iterator(__x.current))reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) noexcept(noexcept(_Iterator(__x.current))) : current(__x.current)         {
        }
        reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iterator> &) = default
        template <typename _Iter> constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) noexcept(noexcept(_Iterator(__x.current))reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) noexcept(noexcept(_Iterator(__x.current))) : current(__x.current)         {
        }
        template <typename _Iter> constexpr reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iter> &__x) noexcept(noexcept(this->current = __x.current)operator=(const reverse_iterator<_Iter> &__x) noexcept(noexcept(this->current = __x.current))         {
            this->current = __x.current;
            return *this;
        }
        constexpr std::reverse_iterator::iterator_type base() const noexcept(noexcept(_Iterator(this->current))base() const noexcept(noexcept(_Iterator(this->current))) [[nodiscard("")]]         {
            return this->current;
        }
        constexpr std::reverse_iterator::reference operator*() const [[nodiscard("")]]         {
            _Iterator __tmp = this->current;
            return *--__tmp;
        }
        constexpr std::reverse_iterator::pointer operator->() const requires is_pointer_v<_Iterator> || requires (const _Iterator __i) { __i.operator->(); } [[nodiscard("")]]         {
            _Iterator __tmp = this->current;
            --__tmp;
            return _S_to_pointer(__tmp);
        }
        constexpr reverse_iterator<_Iterator> &operator++()         {
            --this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator++(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            --this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> &operator--()         {
            ++this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator--(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            ++this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> operator+(std::reverse_iterator::difference_type __n) const [[nodiscard("")]]         {
            return reverse_iterator<_Iterator>(this->current - __n);
        }
        constexpr reverse_iterator<_Iterator> &operator+=(std::reverse_iterator::difference_type __n)         {
            this->current -= __n;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator-(std::reverse_iterator::difference_type __n) const [[nodiscard("")]]         {
            return reverse_iterator<_Iterator>(this->current + __n);
        }
        constexpr reverse_iterator<_Iterator> &operator-=(std::reverse_iterator::difference_type __n)         {
            this->current += __n;
            return *this;
        }
        constexpr std::reverse_iterator::reference operator[](std::reverse_iterator::difference_type __n) const [[nodiscard("")]]         {
            return *(*this + __n);
        }
        friend constexpr iter_rvalue_reference_t<_Iterator> iter_move(const reverse_iterator<_Iterator> &__i) noexcept(is_nothrow_copy_constructible_v<_Iterator> && noexcept(ranges::iter_move(--std::declval<_Iterator &>()))iter_move(const reverse_iterator<_Iterator> &__i) noexcept(is_nothrow_copy_constructible_v<_Iterator> && noexcept(ranges::iter_move(--std::declval<_Iterator &>()))) [[nodiscard("")]]         {
            auto __tmp = __i.base();
            return ranges::iter_move(--__tmp);
        }
;
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iter2> &__y) noexcept(is_nothrow_copy_constructible_v<_Iterator> && is_nothrow_copy_constructible_v<_Iter2> && noexcept(ranges::iter_swap(--std::declval<_Iterator &>(), --std::declval<_Iter2 &>()))iter_swap(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iter2> &__y) noexcept(is_nothrow_copy_constructible_v<_Iterator> && is_nothrow_copy_constructible_v<_Iter2> && noexcept(ranges::iter_swap(--std::declval<_Iterator &>(), --std::declval<_Iter2 &>())))         {
            auto __xtmp = __x.base();
            auto __ytmp = __y.base();
            ranges::iter_swap(--__xtmp, --__ytmp);
        }
;
    private:
        template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p)         {
            return __p;
        }
        template <typename _Tp> static constexpr std::reverse_iterator::pointer _S_to_pointer(_Tp __t)         {
            return __t.operator->();
        }
    };
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator==(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator!=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() != __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator<(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() > __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator<=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() >= __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator>=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() <= __y.base();
    }
    template <typename _IteratorL, three_way_comparable_with<_IteratorL> _IteratorR> constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) [[nodiscard("")]]     {
        return __y.base() <=> __x.base();
    }
    template <typename _Iterator> constexpr bool operator==(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() == __y.base();
    }
    template <three_way_comparable _Iterator> constexpr compare_three_way_result_t<_Iterator, _Iterator> operator<=>(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y) [[nodiscard("")]]     {
        return __y.base() <=> __x.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base()) [[nodiscard("")]]     {
        return __y.base() - __x.base();
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> operator+(typename reverse_iterator<_Iterator>::difference_type __n, const reverse_iterator<_Iterator> &__x) [[nodiscard("")]]     {
        return reverse_iterator<_Iterator>(__x.base() - __n);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> __make_reverse_iterator(_Iterator __i)     {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> make_reverse_iterator(_Iterator __i) [[nodiscard("")]]     {
        return reverse_iterator<_Iterator>(__i);
    }
    constexpr bool disable_sized_sentinel_for = true;
    template <typename _Iterator> constexpr auto __niter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__niter_base(__it.base())))     {
        return __make_reverse_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<reverse_iterator<_Iterator>> : __is_move_iterator<_Iterator> {
    };
    template <typename _Iterator> constexpr auto __miter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__miter_base(__it.base())))     {
        return __make_reverse_iterator(__miter_base(__it.base()));
    }
    template <typename _Container> class back_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        using difference_type = std::ptrdiff_t;
        constexpr explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        constexpr back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_back(__value);
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_back(std::move(__value));
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator*() [[nodiscard("")]]         {
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        constexpr back_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline constexpr back_insert_iterator<_Container> back_inserter(_Container &__x) [[nodiscard("")]]     {
        return back_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class front_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        using difference_type = std::ptrdiff_t;
        constexpr explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        constexpr front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_front(__value);
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_front(std::move(__value));
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator*() [[nodiscard("")]]         {
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        constexpr front_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline constexpr front_insert_iterator<_Container> front_inserter(_Container &__x) [[nodiscard("")]]     {
        return front_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
        using _Iter = std::__detail::__range_iter_t<_Container>;
    protected:
        _Container *container;
        std::insert_iterator::_Iter iter;
    public:
        typedef _Container container_type;
        using difference_type = std::ptrdiff_t;
        constexpr insert_iterator<_Container>(_Container &__x, std::insert_iterator::_Iter __i) : container(std::__addressof(__x)), iter(__i)         {
        }
        constexpr insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->iter = this->container->insert(this->iter, __value);
            ++this->iter;
            return *this;
        }
        constexpr insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->iter = this->container->insert(this->iter, std::move(__value));
            ++this->iter;
            return *this;
        }
        constexpr insert_iterator<_Container> &operator*() [[nodiscard("")]]         {
            return *this;
        }
        constexpr insert_iterator<_Container> &operator++()         {
            return *this;
        }
        constexpr insert_iterator<_Container> &operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> constexpr insert_iterator<_Container> inserter(_Container &__x, std::__detail::__range_iter_t<_Container> __i) [[nodiscard("")]]     {
        return insert_iterator<_Container>(__x, __i);
    }
}
namespace __gnu_cxx {
    template <typename _Iterator, typename _Container> class __normal_iterator {
    protected:
        _Iterator _M_current;
        typedef std::iterator_traits<_Iterator> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<_Iterator>;
        constexpr __normal_iterator<_Iterator, _Container>() noexcept : _M_current(_Iterator())         {
        }
        constexpr explicit __normal_iterator<_Iterator, _Container>(const _Iterator &__i) noexcept : _M_current(__i)         {
        }
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator<_Iterator, _Container>(const __normal_iterator<_Iter, _Container> &__i) noexcept : _M_current(__i.base())         {
        }
        constexpr __gnu_cxx::__normal_iterator::reference operator*() const noexcept         {
            return *this->_M_current;
        }
        constexpr __gnu_cxx::__normal_iterator::pointer operator->() const noexcept         {
            return this->_M_current;
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator++() noexcept         {
            ++this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator++(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current++);
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator--() noexcept         {
            --this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator--(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current--);
        }
        constexpr __gnu_cxx::__normal_iterator::reference operator[](__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return this->_M_current[__n];
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator+=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current += __n;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator+(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current + __n);
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator-=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current -= __n;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator-(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current - __n);
        }
        constexpr const _Iterator &base() const noexcept         {
            return this->_M_current;
        }
    };
template<> class __normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> {
    protected:
        char *_M_current;
        typedef std::iterator_traits<char *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, char *>::value>;
    public:
        typedef char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<char *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(char *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &__i) noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::reference operator*() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::pointer operator->() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator++() noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator++(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator--() noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator--(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::reference operator[](__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator+=(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator+(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator-=(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator-(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) const noexcept;
        constexpr char *const &base() const noexcept;
    };
template<> class __normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> {
    protected:
        const char *_M_current;
        typedef std::iterator_traits<const char *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const char *>::value>;
    public:
        typedef const char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<const char *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(const char *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &__i) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::reference operator*() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::pointer operator->() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator++() noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator++(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator--() noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator--(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::reference operator[](__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator+=(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator+(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &operator-=(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> operator-(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>::difference_type __n) const noexcept;
        constexpr const char *const &base() const noexcept;
    };
template<> class __normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> {
    protected:
        wchar_t *_M_current;
        typedef std::iterator_traits<wchar_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, wchar_t *>::value>;
    public:
        typedef wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<wchar_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(wchar_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &__i) noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::reference operator*() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::pointer operator->() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator++() noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator++(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator--() noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator--(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::reference operator[](__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator+=(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator+(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator-=(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator-(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) const noexcept;
        constexpr wchar_t *const &base() const noexcept;
    };
template<> class __normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> {
    protected:
        const wchar_t *_M_current;
        typedef std::iterator_traits<const wchar_t *> __traits_type;
        template <typename _Iter> using __convertible_from = std::__enable_if_t<std::is_convertible<_Iter, const wchar_t *>::value>;
    public:
        typedef const wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<const wchar_t *>;
        constexpr __normal_iterator() noexcept;
        constexpr explicit __normal_iterator(const wchar_t *const &__i) noexcept;
        template <typename _Iter, typename = __convertible_from<_Iter>> constexpr __normal_iterator(const __normal_iterator<_Iter, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &__i) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::reference operator*() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::pointer operator->() const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator++() noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator++(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator--() noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator--(int) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::reference operator[](__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator+=(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator+(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) const noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> &operator-=(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) noexcept;
        constexpr __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>> operator-(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>>::difference_type __n) const noexcept;
        constexpr const wchar_t *const &base() const noexcept;
    };
    template <typename _IteratorL, typename _IteratorR, typename _Container> constexpr bool operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]]     {
        return __lhs.base() == __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL> operator<=>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base()))operator<=>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base()))) [[nodiscard("")]]     {
        return std::__detail::__synth3way(__lhs.base(), __rhs.base());
    }
    template <typename _Iterator, typename _Container> constexpr bool operator==(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())operator==(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())) requires requires { { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>; } [[nodiscard("")]]     {
        return __lhs.base() == __rhs.base();
    }
    template <typename _Iterator, typename _Container> constexpr std::__detail::__synth3way_t<_Iterator> operator<=>(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base()))operator<=>(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base()))) [[nodiscard("")]]     {
        return std::__detail::__synth3way(__lhs.base(), __rhs.base());
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline constexpr auto operator-(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base()) [[nodiscard("")]]     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline constexpr typename __normal_iterator<_Iterator, _Container>::difference_type operator-(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept [[nodiscard("")]]     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline constexpr __normal_iterator<_Iterator, _Container> operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n, const __normal_iterator<_Iterator, _Container> &__i) noexcept [[nodiscard("")]]     {
        return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
    }
}
namespace std {
    template <typename _Iterator, typename _Container> constexpr _Iterator __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it.base();
    }
    template <semiregular _Sent> class move_sentinel {
    public:
        constexpr move_sentinel<_Sent>() noexcept(is_nothrow_default_constructible_v<_Sent>move_sentinel<_Sent>() noexcept(is_nothrow_default_constructible_v<_Sent>) : _M_last()         {
        }
        constexpr explicit move_sentinel<_Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>move_sentinel<_Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>) : _M_last(std::move(__s))         {
        }
        template <typename _S2> constexpr move_sentinel<_Sent>(const move_sentinel<_S2> &__s) noexcept(is_nothrow_constructible_v<_Sent, const _S2 &>move_sentinel<_Sent>(const move_sentinel<_S2> &__s) noexcept(is_nothrow_constructible_v<_Sent, const _S2 &>) : _M_last(__s.base())         {
        }
        template <typename _S2> constexpr move_sentinel<_Sent> &operator=(const move_sentinel<_S2> &__s) noexcept(is_nothrow_assignable_v<_Sent, const _S2 &>operator=(const move_sentinel<_S2> &__s) noexcept(is_nothrow_assignable_v<_Sent, const _S2 &>)         {
            this->_M_last = __s.base();
            return *this;
        }
        constexpr _Sent base() const noexcept(is_nothrow_copy_constructible_v<_Sent>base() const noexcept(is_nothrow_copy_constructible_v<_Sent>) [[nodiscard("")]]         {
            return this->_M_last;
        }
    private:
        _Sent _M_last;
    };
    namespace __detail {
        template <typename _Iterator> struct __move_iter_cat {
        };
        template <typename _Iterator> struct __move_iter_cat<_Iterator> {
            using iterator_category = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category, std::random_access_iterator_tag>;
        };
    }
    template <typename _Iterator> class move_iterator : public __detail::__move_iter_cat<_Iterator> {
        _Iterator _M_current;
        using __traits_type = iterator_traits<_Iterator>;
        friend template <typename _Iter2> class move_iterator;
        template <typename _Iter2> static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator> && convertible_to<const _Iter2 &, _Iterator>;
    public:
        using iterator_type = _Iterator;
        using iterator_concept = std::input_iterator_tag;
        using value_type = iter_value_t<_Iterator>;
        using difference_type = iter_difference_t<_Iterator>;
        using pointer = _Iterator;
        using reference = iter_rvalue_reference_t<_Iterator>;
        constexpr move_iterator<_Iterator>() : _M_current()         {
        }
        constexpr explicit move_iterator<_Iterator>(std::move_iterator::iterator_type __i) : _M_current(std::move(__i))         {
        }
        template <typename _Iter> constexpr move_iterator<_Iterator>(const move_iterator<_Iter> &__i) : _M_current(__i._M_current)         {
        }
        template <typename _Iter> constexpr move_iterator<_Iterator> &operator=(const move_iterator<_Iter> &__i)         {
            this->_M_current = __i._M_current;
            return *this;
        }
        constexpr const std::move_iterator::iterator_type &base() const & noexcept [[nodiscard("")]]         {
            return this->_M_current;
        }
        constexpr std::move_iterator::iterator_type base() && [[nodiscard("")]]         {
            return std::move(this->_M_current);
        }
        constexpr std::move_iterator::reference operator*() const [[nodiscard("")]]         {
            return ranges::iter_move(this->_M_current);
        }
        constexpr std::move_iterator::pointer operator->() const [[nodiscard("")]]         {
            return this->_M_current;
        }
        constexpr move_iterator<_Iterator> &operator++()         {
            ++this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator++(int)         {
            move_iterator<_Iterator> __tmp = *this;
            ++this->_M_current;
            return __tmp;
        }
        constexpr void operator++(int) requires (!forward_iterator<_Iterator>)         {
            ++this->_M_current;
        }
        constexpr move_iterator<_Iterator> &operator--()         {
            --this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator--(int)         {
            move_iterator<_Iterator> __tmp = *this;
            --this->_M_current;
            return __tmp;
        }
        constexpr move_iterator<_Iterator> operator+(std::move_iterator::difference_type __n) const [[nodiscard("")]]         {
            return move_iterator<_Iterator>(this->_M_current + __n);
        }
        constexpr move_iterator<_Iterator> &operator+=(std::move_iterator::difference_type __n)         {
            this->_M_current += __n;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator-(std::move_iterator::difference_type __n) const [[nodiscard("")]]         {
            return move_iterator<_Iterator>(this->_M_current - __n);
        }
        constexpr move_iterator<_Iterator> &operator-=(std::move_iterator::difference_type __n)         {
            this->_M_current -= __n;
            return *this;
        }
        constexpr std::move_iterator::reference operator[](std::move_iterator::difference_type __n) const [[nodiscard("")]]         {
            return ranges::iter_move(this->_M_current + __n);
        }
        friend template <sentinel_for<_Iterator> _Sent> constexpr bool operator==(const move_iterator<_Iterator> &__x, const move_sentinel<_Sent> &__y) [[nodiscard("")]]         {
            return __x.base() == __y.base();
        }
;
        friend template <sized_sentinel_for<_Iterator> _Sent> constexpr iter_difference_t<_Iterator> operator-(const move_sentinel<_Sent> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]]         {
            return __x.base() - __y.base();
        }
;
        friend template <sized_sentinel_for<_Iterator> _Sent> constexpr iter_difference_t<_Iterator> operator-(const move_iterator<_Iterator> &__x, const move_sentinel<_Sent> &__y) [[nodiscard("")]]         {
            return __x.base() - __y.base();
        }
;
        friend constexpr iter_rvalue_reference_t<_Iterator> iter_move(const move_iterator<_Iterator> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))iter_move(const move_iterator<_Iterator> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))) [[nodiscard("")]]         {
            return ranges::iter_move(__i._M_current);
        }
;
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const move_iterator<_Iterator> &__x, const move_iterator<_Iter2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current))iter_swap(const move_iterator<_Iterator> &__x, const move_iterator<_Iter2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))         {
            return ranges::iter_swap(__x._M_current, __y._M_current);
        }
;
    };
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator==(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, three_way_comparable_with<_IteratorL> _IteratorR> constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) [[nodiscard("")]]     {
        return __x.base() <=> __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; } [[nodiscard("")]]     {
        return !(__x < __y);
    }
    template <typename _Iterator> inline constexpr bool operator==(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]]     {
        return __x.base() == __y.base();
    }
    template <three_way_comparable _Iterator> constexpr compare_three_way_result_t<_Iterator> operator<=>(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y) [[nodiscard("")]]     {
        return __x.base() <=> __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base()) [[nodiscard("")]]     {
        return __x.base() - __y.base();
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> operator+(typename move_iterator<_Iterator>::difference_type __n, const move_iterator<_Iterator> &__x) [[nodiscard("")]]     {
        return __x + __n;
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> make_move_iterator(_Iterator __i) [[nodiscard("")]]     {
        return move_iterator<_Iterator>(std::move(__i));
    }
    template <typename _Iterator, typename _ReturnType = __conditional_t<__move_if_noexcept_cond<typename iterator_traits<_Iterator>::value_type>::value, _Iterator, move_iterator<_Iterator>>> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Iterator __i)     {
        return _ReturnType(__i);
    }
    template <typename _Tp, typename _ReturnType = __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp *, move_iterator<_Tp *>>> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Tp *__i)     {
        return _ReturnType(__i);
    }
    namespace __detail {
        template <typename _It> concept __common_iter_has_arrow = indirectly_readable<const _It> && (requires (const _It &__it) { __it.operator->(); } || is_reference_v<iter_reference_t<_It>> || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);;
        template <typename _It> concept __common_iter_use_postfix_proxy = (!requires (_It &__i) { { *__i++ } -> __can_reference; }) && constructible_from<iter_value_t<_It>, iter_reference_t<_It>> && move_constructible<iter_value_t<_It>>;;
    }
    template <input_or_output_iterator _It, sentinel_for<_It> _Sent> class common_iterator {
        template <typename _Tp, typename _Up> static constexpr bool _S_noexcept1()         {
            if (is_trivially_default_constructible_v<_Tp>)
                return is_nothrow_assignable_v<_Tp &, _Up>;
            else
                return is_nothrow_constructible_v<_Tp, _Up>;
        }
        template <typename _It2, typename _Sent2> static constexpr bool _S_noexcept()         {
            return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>();
        }
        class __arrow_proxy {
            iter_value_t<_It> _M_keep;
            constexpr __arrow_proxy(iter_reference_t<_It> &&__x) : _M_keep(std::move(__x))             {
            }
            friend  class common_iterator<_It, _Sent>;
        public:
            constexpr const iter_value_t<_It> *operator->() const noexcept             {
                return std::__addressof(this->_M_keep);
            }
        };
        class __postfix_proxy {
            iter_value_t<_It> _M_keep;
            constexpr __postfix_proxy(iter_reference_t<_It> &&__x) : _M_keep(std::forward<iter_reference_t<_It>>(__x))             {
            }
            friend  class common_iterator<_It, _Sent>;
        public:
            constexpr const iter_value_t<_It> &operator*() const noexcept             {
                return this->_M_keep;
            }
        };
    public:
        constexpr common_iterator<_It, _Sent>() noexcept(is_nothrow_default_constructible_v<_It>common_iterator<_It, _Sent>() noexcept(is_nothrow_default_constructible_v<_It>) : _M_it(), _M_index(0) requires default_initializable<_It>         {
        }
        constexpr common_iterator<_It, _Sent>(_It __i) noexcept(is_nothrow_move_constructible_v<_It>common_iterator<_It, _Sent>(_It __i) noexcept(is_nothrow_move_constructible_v<_It>) : _M_it(std::move(__i)), _M_index(0)         {
        }
        constexpr common_iterator<_It, _Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>common_iterator<_It, _Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>) : _M_sent(std::move(__s)), _M_index(1)         {
        }
        template <typename _It2, typename _Sent2> constexpr common_iterator<_It, _Sent>(const common_iterator<_It2, _Sent2> &__x) noexcept(_S_noexcept<const _It2 &, const _Sent2 &>()common_iterator<_It, _Sent>(const common_iterator<_It2, _Sent2> &__x) noexcept(_S_noexcept<const _It2 &, const _Sent2 &>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index)         {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                    __builtin_unreachable();
            } while (false);
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = std::move(__x._M_it);
                else
                    std::construct_at(std::__addressof(this->_M_it), __x._M_it);
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = std::move(__x._M_sent);
                else
                    std::construct_at(std::__addressof(this->_M_sent), __x._M_sent);
            }
        }
        constexpr common_iterator<_It, _Sent>(const common_iterator<_It, _Sent> &__x) noexcept(_S_noexcept<const _It &, const _Sent &>()common_iterator<_It, _Sent>(const common_iterator<_It, _Sent> &__x) noexcept(_S_noexcept<const _It &, const _Sent &>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index)         {
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = __x._M_it;
                else
                    std::construct_at(std::__addressof(this->_M_it), __x._M_it);
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = __x._M_sent;
                else
                    std::construct_at(std::__addressof(this->_M_sent), __x._M_sent);
            }
        }
        constexpr common_iterator<_It, _Sent>(common_iterator<_It, _Sent> &&__x) noexcept(_S_noexcept<_It, _Sent>()common_iterator<_It, _Sent>(common_iterator<_It, _Sent> &&__x) noexcept(_S_noexcept<_It, _Sent>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index)         {
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = std::move(__x._M_it);
                else
                    std::construct_at(std::__addressof(this->_M_it), std::move(__x._M_it));
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = std::move(__x._M_sent);
                else
                    std::construct_at(std::__addressof(this->_M_sent), std::move(__x._M_sent));
            }
        }
        common_iterator<_It, _Sent> &operator=(const common_iterator<_It, _Sent> &) = default
        constexpr common_iterator<_It, _Sent> &operator=(const common_iterator<_It, _Sent> &__x) noexcept(is_nothrow_copy_assignable_v<_It> && is_nothrow_copy_assignable_v<_Sent> && is_nothrow_copy_constructible_v<_It> && is_nothrow_copy_constructible_v<_Sent>operator=(const common_iterator<_It, _Sent> &__x) noexcept(is_nothrow_copy_assignable_v<_It> && is_nothrow_copy_assignable_v<_Sent> && is_nothrow_copy_constructible_v<_It> && is_nothrow_copy_constructible_v<_Sent>) requires (!is_trivially_copy_assignable_v<_It> || !is_trivially_copy_assignable_v<_Sent>)         {
            _M_assign(__x);
            return *this;
        }
        common_iterator<_It, _Sent> &operator=(common_iterator<_It, _Sent> &&) = default
        constexpr common_iterator<_It, _Sent> &operator=(common_iterator<_It, _Sent> &&__x) noexcept(is_nothrow_move_assignable_v<_It> && is_nothrow_move_assignable_v<_Sent> && is_nothrow_move_constructible_v<_It> && is_nothrow_move_constructible_v<_Sent>operator=(common_iterator<_It, _Sent> &&__x) noexcept(is_nothrow_move_assignable_v<_It> && is_nothrow_move_assignable_v<_Sent> && is_nothrow_move_constructible_v<_It> && is_nothrow_move_constructible_v<_Sent>) requires (!is_trivially_move_assignable_v<_It> || !is_trivially_move_assignable_v<_Sent>)         {
            _M_assign(std::move(__x));
            return *this;
        }
        template <typename _It2, typename _Sent2> constexpr common_iterator<_It, _Sent> &operator=(const common_iterator<_It2, _Sent2> &__x) noexcept(is_nothrow_constructible_v<_It, const _It2 &> && is_nothrow_constructible_v<_Sent, const _Sent2 &> && is_nothrow_assignable_v<_It &, const _It2 &> && is_nothrow_assignable_v<_Sent &, const _Sent2 &>operator=(const common_iterator<_It2, _Sent2> &__x) noexcept(is_nothrow_constructible_v<_It, const _It2 &> && is_nothrow_constructible_v<_Sent, const _Sent2 &> && is_nothrow_assignable_v<_It &, const _It2 &> && is_nothrow_assignable_v<_Sent &, const _Sent2 &>)         {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                    __builtin_unreachable();
            } while (false);
            _M_assign(__x);
            return *this;
        }
        constexpr ~common_iterator<_It, _Sent>()         {
            if (this->_M_index == 0)
                this->_M_it.~_It();
            else if (this->_M_index == 1)
                this->_M_sent.~_Sent();
        }
        constexpr decltype(auto) operator*() [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_it;
        }
        constexpr decltype(auto) operator*() const requires __detail::__dereferenceable<const _It> [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_it;
        }
        constexpr auto operator->() const requires __detail::__common_iter_has_arrow<_It> [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            if (is_pointer_v<_It> || requires { this->_M_it.operator->(); })
                return this->_M_it;
            else if (is_reference_v<iter_reference_t<_It>>) {
                auto &&__tmp = *this->_M_it;
                return std::__addressof(__tmp);
            } else
                return std::common_iterator::__arrow_proxy({*this->_M_it});
        }
        constexpr common_iterator<_It, _Sent> &operator++()         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            ++this->_M_it;
            return *this;
        }
        constexpr decltype(auto) operator++(int)         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_index == 0))
                    __builtin_unreachable();
            } while (false);
            if (forward_iterator<_It>) {
                common_iterator<_It, _Sent> __tmp = *this;
                ++*this;
                return __tmp;
            } else if (!__detail::__common_iter_use_postfix_proxy<_It>)
                return this->_M_it++;
            else {
                std::common_iterator::__postfix_proxy __p(**this);
                ++*this;
                return __p;
            }
        }
        friend template <typename _It2, sentinel_for<_It> _Sent2> constexpr bool operator==(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) [[nodiscard("")]]         {
            switch (__x._M_index << 2 | __y._M_index) {
              case 0:
              case 5:
                return true;
              case 1:
                return __x._M_it == __y._M_sent;
              case 4:
                return __x._M_sent == __y._M_it;
              default:
                do {
                    if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                do {
                    if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                __builtin_unreachable();
            }
        }
;
        friend template <typename _It2, sentinel_for<_It> _Sent2> constexpr bool operator==(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) [[nodiscard("")]]         {
            switch (__x._M_index << 2 | __y._M_index) {
              case 5:
                return true;
              case 0:
                return __x._M_it == __y._M_it;
              case 1:
                return __x._M_it == __y._M_sent;
              case 4:
                return __x._M_sent == __y._M_it;
              default:
                do {
                    if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                do {
                    if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                __builtin_unreachable();
            }
        }
;
        friend template <sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2> constexpr iter_difference_t<_It2> operator-(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) [[nodiscard("")]]         {
            switch (__x._M_index << 2 | __y._M_index) {
              case 5:
                return 0;
              case 0:
                return __x._M_it - __y._M_it;
              case 1:
                return __x._M_it - __y._M_sent;
              case 4:
                return __x._M_sent - __y._M_it;
              default:
                do {
                    if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                do {
                    if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
                        __builtin_unreachable();
                } while (false);
                __builtin_unreachable();
            }
        }
;
        friend constexpr iter_rvalue_reference_t<_It> iter_move(const common_iterator<_It, _Sent> &__i) noexcept(noexcept(ranges::iter_move(std::declval<const _It &>()))iter_move(const common_iterator<_It, _Sent> &__i) noexcept(noexcept(ranges::iter_move(std::declval<const _It &>()))) requires input_iterator<_It> [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(__i._M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return ranges::iter_move(__i._M_it);
        }
;
        friend template <indirectly_swappable<_It> _It2, typename _Sent2> constexpr void iter_swap(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) noexcept(noexcept(ranges::iter_swap(std::declval<const _It &>(), std::declval<const _It2 &>()))iter_swap(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) noexcept(noexcept(ranges::iter_swap(std::declval<const _It &>(), std::declval<const _It2 &>())))         {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_index == 0))
                    __builtin_unreachable();
            } while (false);
            do {
                if (std::__is_constant_evaluated() && !bool(__y._M_index == 0))
                    __builtin_unreachable();
            } while (false);
            return ranges::iter_swap(__x._M_it, __y._M_it);
        }
;
    private:
        friend template <input_or_output_iterator _It2, sentinel_for<_It2> _Sent2> class common_iterator;
        constexpr bool _M_has_value() const noexcept         {
            return this->_M_index != _S_valueless;
        }
        template <typename _CIt> constexpr void _M_assign(_CIt &&__x)         {
            if (this->_M_index == __x._M_index) {
                if (this->_M_index == 0)
                    this->_M_it = std::forward<_CIt>(__x)._M_it;
                else if (this->_M_index == 1)
                    this->_M_sent = std::forward<_CIt>(__x)._M_sent;
            } else {
                if (this->_M_index == 0)
                    this->_M_it.~_It();
                else if (this->_M_index == 1)
                    this->_M_sent.~_Sent();
                this->_M_index = _S_valueless;
                if (__x._M_index == 0)
                    std::construct_at(std::__addressof(this->_M_it), std::forward<_CIt>(__x)._M_it);
                else if (__x._M_index == 1)
                    std::construct_at(std::__addressof(this->_M_sent), std::forward<_CIt>(__x)._M_sent);
                this->_M_index = __x._M_index;
            }
        }
        union {
            _It _M_it;
            _Sent _M_sent;
            unsigned char _M_valueless;
        };
        unsigned char _M_index;
        static constexpr unsigned char _S_valueless{2};
    };
    template <typename _It, typename _Sent> struct incrementable_traits<common_iterator<_It, _Sent>> {
        using difference_type = iter_difference_t<_It>;
    };
    template <input_iterator _It, typename _Sent> struct iterator_traits<common_iterator<_It, _Sent>> {
    private:
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using _CIter = common_iterator<_Iter, _Sent>;
            using type = decltype(std::declval<const std::iterator_traits<common_iterator<type-parameter-0-0, type-parameter-0-1>>::__ptr<type-parameter-1-0>::_CIter &>().operator->());
        };
        static auto _S_iter_cat()         {
            using _Traits = iterator_traits<_It>;
            if (requires { requires derived_from<typename _Traits::iterator_category, std::forward_iterator_tag>; })
                return std::forward_iterator_tag{};
            else
                return std::input_iterator_tag{};
        }
    public:
        using iterator_concept = __conditional_t<forward_iterator<_It>, std::forward_iterator_tag, std::input_iterator_tag>;
        using iterator_category = decltype(_S_iter_cat());
        using value_type = iter_value_t<_It>;
        using difference_type = iter_difference_t<_It>;
        using pointer = typename __ptr<_It>::type;
        using reference = iter_reference_t<_It>;
    };
    namespace __detail {
        template <typename _It> struct __counted_iter_value_type {
        };
        template <indirectly_readable _It> struct __counted_iter_value_type<_It> {
            using value_type = iter_value_t<_It>;
        };
        template <typename _It> struct __counted_iter_concept {
        };
        template <typename _It> struct __counted_iter_concept<_It> {
            using iterator_concept = typename _It::iterator_concept;
        };
        template <typename _It> struct __counted_iter_cat {
        };
        template <typename _It> struct __counted_iter_cat<_It> {
            using iterator_category = typename _It::iterator_category;
        };
    }
    template <input_or_output_iterator _It> class counted_iterator : public __detail::__counted_iter_value_type<_It>, public __detail::__counted_iter_concept<_It>, public __detail::__counted_iter_cat<_It> {
    public:
        using iterator_type = _It;
        using difference_type = iter_difference_t<_It>;
        counted_iterator<_It>() requires default_initializable<_It> = default
        constexpr counted_iterator<_It>(_It __i, iter_difference_t<_It> __n) : _M_current(std::move(__i)), _M_length(__n)         {
            do {
                if (std::__is_constant_evaluated() && !bool(__n >= 0))
                    __builtin_unreachable();
            } while (false);
        }
        template <typename _It2> constexpr counted_iterator<_It>(const counted_iterator<_It2> &__x) : _M_current(__x._M_current), _M_length(__x._M_length)         {
        }
        template <typename _It2> constexpr counted_iterator<_It> &operator=(const counted_iterator<_It2> &__x)         {
            this->_M_current = __x._M_current;
            this->_M_length = __x._M_length;
            return *this;
        }
        constexpr const _It &base() const & noexcept [[nodiscard("")]]         {
            return this->_M_current;
        }
        constexpr _It base() && noexcept(is_nothrow_move_constructible_v<_It>base() && noexcept(is_nothrow_move_constructible_v<_It>) [[nodiscard("")]]         {
            return std::move(this->_M_current);
        }
        constexpr iter_difference_t<_It> count() const noexcept [[nodiscard("")]]         {
            return this->_M_length;
        }
        constexpr decltype(auto) operator*() noexcept(noexcept(*this->_M_current)operator*() noexcept(noexcept(*this->_M_current)) [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_current;
        }
        constexpr decltype(auto) operator*() const noexcept(noexcept(*this->_M_current)operator*() const noexcept(noexcept(*this->_M_current)) requires __detail::__dereferenceable<const _It> [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_current;
        }
        constexpr auto operator->() const noexcept requires contiguous_iterator<_It> [[nodiscard("")]]         {
            return std::to_address(this->_M_current);
        }
        constexpr counted_iterator<_It> &operator++()         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            ++this->_M_current;
            --this->_M_length;
            return *this;
        }
        constexpr decltype(auto) operator++(int)         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_length > 0))
                    __builtin_unreachable();
            } while (false);
            --this->_M_length;
            try {
                return this->_M_current++;
            } catch (...) {
                ++this->_M_length;
                throw;
            }
        }
        constexpr counted_iterator<_It> operator++(int) requires forward_iterator<_It>         {
            auto __tmp = *this;
            ++*this;
            return __tmp;
        }
        constexpr counted_iterator<_It> &operator--() requires bidirectional_iterator<_It>         {
            --this->_M_current;
            ++this->_M_length;
            return *this;
        }
        constexpr counted_iterator<_It> operator--(int) requires bidirectional_iterator<_It>         {
            auto __tmp = *this;
            --*this;
            return __tmp;
        }
        constexpr counted_iterator<_It> operator+(iter_difference_t<_It> __n) const requires random_access_iterator<_It> [[nodiscard("")]]         {
            return counted_iterator<_It>(this->_M_current + __n, this->_M_length - __n);
        }
        friend constexpr counted_iterator<_It> operator+(iter_difference_t<_It> __n, const counted_iterator<_It> &__x) requires random_access_iterator<_It> [[nodiscard("")]]         {
            return __x + __n;
        }
;
        constexpr counted_iterator<_It> &operator+=(iter_difference_t<_It> __n) requires random_access_iterator<_It>         {
            do {
                if (std::__is_constant_evaluated() && !bool(__n <= this->_M_length))
                    __builtin_unreachable();
            } while (false);
            this->_M_current += __n;
            this->_M_length -= __n;
            return *this;
        }
        constexpr counted_iterator<_It> operator-(iter_difference_t<_It> __n) const requires random_access_iterator<_It> [[nodiscard("")]]         {
            return counted_iterator<_It>(this->_M_current - __n, this->_M_length + __n);
        }
        friend template <common_with<_It> _It2> constexpr iter_difference_t<_It2> operator-(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) [[nodiscard("")]]         {
            return __y._M_length - __x._M_length;
        }
;
        friend constexpr iter_difference_t<_It> operator-(const counted_iterator<_It> &__x, std::default_sentinel_t) [[nodiscard("")]]         {
            return - __x._M_length;
        }
;
        friend constexpr iter_difference_t<_It> operator-(std::default_sentinel_t, const counted_iterator<_It> &__y) [[nodiscard("")]]         {
            return __y._M_length;
        }
;
        constexpr counted_iterator<_It> &operator-=(iter_difference_t<_It> __n) requires random_access_iterator<_It>         {
            do {
                if (std::__is_constant_evaluated() && !bool(- __n <= this->_M_length))
                    __builtin_unreachable();
            } while (false);
            this->_M_current -= __n;
            this->_M_length += __n;
            return *this;
        }
        constexpr decltype(auto) operator[](iter_difference_t<_It> __n) const noexcept(noexcept(this->_M_current[__n])operator[](iter_difference_t<_It> __n) const noexcept(noexcept(this->_M_current[__n])) requires random_access_iterator<_It> [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(__n < this->_M_length))
                    __builtin_unreachable();
            } while (false);
            return this->_M_current[__n];
        }
        friend template <common_with<_It> _It2> constexpr bool operator==(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) [[nodiscard("")]]         {
            return __x._M_length == __y._M_length;
        }
;
        friend constexpr bool operator==(const counted_iterator<_It> &__x, std::default_sentinel_t) [[nodiscard("")]]         {
            return __x._M_length == 0;
        }
;
        friend template <common_with<_It> _It2> constexpr std::strong_ordering operator<=>(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) [[nodiscard("")]]         {
            return __y._M_length <=> __x._M_length;
        }
;
        friend constexpr iter_rvalue_reference_t<_It> iter_move(const counted_iterator<_It> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))iter_move(const counted_iterator<_It> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))) requires input_iterator<_It> [[nodiscard("")]]         {
            do {
                if (std::__is_constant_evaluated() && !bool(__i._M_length > 0))
                    __builtin_unreachable();
            } while (false);
            return ranges::iter_move(__i._M_current);
        }
;
        friend template <indirectly_swappable<_It> _It2> constexpr void iter_swap(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current))iter_swap(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))         {
            do {
                if (std::__is_constant_evaluated() && !bool(__x._M_length > 0 && __y._M_length > 0))
                    __builtin_unreachable();
            } while (false);
            ranges::iter_swap(__x._M_current, __y._M_current);
        }
;
    private:
        friend template <input_or_output_iterator _It2> class counted_iterator;
        _It _M_current = _It();
        iter_difference_t<_It> _M_length = 0;
    };
    template <input_iterator _It> struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It> {
        using pointer = __conditional_t<contiguous_iterator<_It>, add_pointer_t<iter_reference_t<_It>>, void>;
    };
    template <typename _Iterator> constexpr auto __niter_base(move_iterator<_Iterator> __it) -> decltype(make_move_iterator(__niter_base(__it.base())))     {
        return make_move_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<move_iterator<_Iterator>> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Iterator> constexpr auto __miter_base(move_iterator<_Iterator> __it) -> decltype(__miter_base(__it.base()))     {
        return __miter_base(__it.base());
    }
    template <typename _InputIterator> using __iter_key_t = remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;
    template <typename _InputIterator> using __iter_val_t = typename iterator_traits<_InputIterator>::value_type::second_type;
    template <typename _T1, typename _T2> struct pair;
    template <typename _InputIterator> using __iter_to_alloc_t = pair<add_const_t<__iter_key_t<_InputIterator>>, __iter_val_t<_InputIterator>>;
}
namespace std {
    template <typename _Container> inline constexpr auto begin(_Container &__cont) -> decltype(__cont.begin()) [[nodiscard("")]]     {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto begin(const _Container &__cont) -> decltype(__cont.begin()) [[nodiscard("")]]     {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto end(_Container &__cont) -> decltype(__cont.end()) [[nodiscard("")]]     {
        return __cont.end();
    }
    template <typename _Container> inline constexpr auto end(const _Container &__cont) -> decltype(__cont.end()) [[nodiscard("")]]     {
        return __cont.end();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *begin(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]]     {
        return __arr;
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *end(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]]     {
        return __arr + _Nm;
    }
    template <typename _Tp> class valarray;
    template <typename _Tp> _Tp *begin(valarray<_Tp> &) noexcept;
    template <typename _Tp> const _Tp *begin(const valarray<_Tp> &) noexcept;
    template <typename _Tp> _Tp *end(valarray<_Tp> &) noexcept;
    template <typename _Tp> const _Tp *end(const valarray<_Tp> &) noexcept;
    template <typename _Container> constexpr auto cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))) -> decltype(std::begin(__cont)) [[nodiscard("")]]     {
        return std::begin(__cont);
    }
    template <typename _Container> constexpr auto cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))) -> decltype(std::end(__cont)) [[nodiscard("")]]     {
        return std::end(__cont);
    }
    template <typename _Container> inline constexpr auto rbegin(_Container &__cont) -> decltype(__cont.rbegin()) [[nodiscard("")]]     {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rbegin(const _Container &__cont) -> decltype(__cont.rbegin()) [[nodiscard("")]]     {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rend(_Container &__cont) -> decltype(__cont.rend()) [[nodiscard("")]]     {
        return __cont.rend();
    }
    template <typename _Container> inline constexpr auto rend(const _Container &__cont) -> decltype(__cont.rend()) [[nodiscard("")]]     {
        return __cont.rend();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr reverse_iterator<_Tp *> rbegin(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]]     {
        return reverse_iterator<_Tp *>(__arr + _Nm);
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr reverse_iterator<_Tp *> rend(_Tp (&__arr)[_Nm]) noexcept [[nodiscard("")]]     {
        return reverse_iterator<_Tp *>(__arr);
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rbegin(initializer_list<_Tp> __il) noexcept [[nodiscard("")]]     {
        return reverse_iterator<const _Tp *>(__il.end());
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rend(initializer_list<_Tp> __il) noexcept [[nodiscard("")]]     {
        return reverse_iterator<const _Tp *>(__il.begin());
    }
    template <typename _Container> inline constexpr auto crbegin(const _Container &__cont) -> decltype(std::rbegin(__cont)) [[nodiscard("")]]     {
        return std::rbegin(__cont);
    }
    template <typename _Container> inline constexpr auto crend(const _Container &__cont) -> decltype(std::rend(__cont)) [[nodiscard("")]]     {
        return std::rend(__cont);
    }
    template <typename _Container> constexpr auto size(const _Container &__cont) noexcept(noexcept(__cont.size())size(const _Container &__cont) noexcept(noexcept(__cont.size())) -> decltype(__cont.size()) [[nodiscard("")]]     {
        return __cont.size();
    }
    template <typename _Tp, std::size_t _Nm> constexpr std::size_t size(const _Tp (&)[_Nm]) noexcept [[nodiscard("")]]     {
        return _Nm;
    }
    template <typename _Container> constexpr auto empty(const _Container &__cont) noexcept(noexcept(__cont.empty())empty(const _Container &__cont) noexcept(noexcept(__cont.empty())) -> decltype(__cont.empty()) [[nodiscard("")]]     {
        return __cont.empty();
    }
    template <typename _Tp, std::size_t _Nm> constexpr bool empty(const _Tp (&)[_Nm]) noexcept [[nodiscard("")]]     {
        return false;
    }
    template <typename _Tp> constexpr bool empty(initializer_list<_Tp> __il) noexcept [[nodiscard("")]]     {
        return __il.size() == 0;
    }
    template <typename _Container> constexpr auto data(_Container &__cont) noexcept(noexcept(__cont.data())data(_Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data()) [[nodiscard("")]]     {
        return __cont.data();
    }
    template <typename _Container> constexpr auto data(const _Container &__cont) noexcept(noexcept(__cont.data())data(const _Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data()) [[nodiscard("")]]     {
        return __cont.data();
    }
    template <typename _Tp, std::size_t _Nm> constexpr _Tp *data(_Tp (&__array)[_Nm]) noexcept [[nodiscard("")]]     {
        return __array;
    }
    template <typename _Tp> constexpr const _Tp *data(initializer_list<_Tp> __il) noexcept [[nodiscard("")]]     {
        return __il.begin();
    }
    template <typename _Container> constexpr auto ssize(const _Container &__cont) noexcept(noexcept(__cont.size())ssize(const _Container &__cont) noexcept(noexcept(__cont.size())) -> common_type_t<std::ptrdiff_t, make_signed_t<decltype(__cont.size())>> [[nodiscard("")]]     {
        using type = make_signed_t<decltype(__cont.size())>;
        return static_cast<common_type_t<std::ptrdiff_t, type>>(__cont.size());
    }
    template <typename _Tp, std::ptrdiff_t _Num> constexpr std::ptrdiff_t ssize(const _Tp (&)[_Num]) noexcept [[nodiscard("")]]     {
        return _Num;
    }
}
namespace __cxxabiv1 {
    class __forced_unwind {
        virtual ~__forced_unwind() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace std {
    template <typename _CharT, typename _Traits> inline void __ostream_write(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }
    template <typename _CharT, typename _Traits> inline void __ostream_fill(basic_ostream<_CharT, _Traits> &__out, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (; __n > 0; --__n) {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof())) {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &__ostream_insert(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb) {
            try {
                const std::streamsize __w = __out.width();
                if (__w > __n) {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                } else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }
}
namespace __gnu_cxx {
    template <typename _Tp> struct __is_integer_nonstrict : public std::__is_integer<_Tp> {
        using std::__is_integer<_Tp>::__value;
        enum  {
            __width = __value ? sizeof(_Tp) * 8 : 0
        };
    };
template<> struct __is_integer_nonstrict<long> : public std::__is_integer<long> {
        using std::__is_integer<long>::__value;
        enum  {
            __width = __value ? sizeof(long) * 8 : 0
        };
    };
template<> struct __is_integer_nonstrict<int> : public std::__is_integer<int> {
        using std::__is_integer<int>::__value;
        enum  {
            __width = __value ? sizeof(int) * 8 : 0
        };
    };
template<> struct __is_integer_nonstrict<unsigned long> : public std::__is_integer<unsigned long> {
        using std::__is_integer<unsigned long>::__value;
        enum  {
            __width = __value ? sizeof(unsigned long) * 8 : 0
        };
    };
template<> struct __is_integer_nonstrict<char> : public std::__is_integer<char> {
        using std::__is_integer<char>::__value;
        enum  {
            __width = __value ? sizeof(char) * 8 : 0
        };
    };
template<> struct __is_integer_nonstrict<short> : public std::__is_integer<short> {
        using std::__is_integer<short>::__value;
        enum  {
            __width = __value ? sizeof(short) * 8 : 0
        };
    };
    template <typename _Value> struct __numeric_traits_integer {
        static_assert(__is_integer_nonstrict<_Value>::__value, "invalid specialization");
        static const bool __is_signed = (_Value)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<_Value>::__width - __is_signed;
        static const _Value __max = __is_signed ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1) : ~(_Value)0;
        static const _Value __min = __is_signed ? - __max - 1 : (_Value)0;
    };
template<> struct __numeric_traits_integer<unsigned __int128> {
        static_assert(__is_integer_nonstrict<unsigned __int128>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned __int128)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned __int128>::__width - __is_signed;
        static const unsigned __int128 __max = __is_signed ? (((((unsigned __int128)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0;
        static const unsigned __int128 __min = __is_signed ? -__max - 1 : (unsigned __int128)0;
    };
template<> struct __numeric_traits_integer<long> {
        static_assert(__is_integer_nonstrict<long>::__value, "invalid specialization");
        static const bool __is_signed = (long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<long>::__width - __is_signed;
        static const long __max = __is_signed ? (((((long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(long)0;
        static const long __min = __is_signed ? -__max - 1 : (long)0;
    };
template<> struct __numeric_traits_integer<int> {
        static_assert(__is_integer_nonstrict<int>::__value, "invalid specialization");
        static const bool __is_signed = (int)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<int>::__width - __is_signed;
        static const int __max = __is_signed ? (((((int)1 << (__digits - 1)) - 1) << 1) + 1) : ~(int)0;
        static const int __min = __is_signed ? -__max - 1 : (int)0;
    };
template<> struct __numeric_traits_integer<unsigned long> {
        static_assert(__is_integer_nonstrict<unsigned long>::__value, "invalid specialization");
        static const bool __is_signed = (unsigned long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<unsigned long>::__width - __is_signed;
        static const unsigned long __max = __is_signed ? (((((unsigned long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(unsigned long)0;
        static const unsigned long __min = __is_signed ? -__max - 1 : (unsigned long)0;
    };
template<> struct __numeric_traits_integer<char> {
        static_assert(__is_integer_nonstrict<char>::__value, "invalid specialization");
        static const bool __is_signed = (char)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<char>::__width - __is_signed;
        static const char __max = __is_signed ? (((((char)1 << (__digits - 1)) - 1) << 1) + 1) : ~(char)0;
        static const char __min = __is_signed ? -__max - 1 : (char)0;
    };
template<> struct __numeric_traits_integer<short> {
        static_assert(__is_integer_nonstrict<short>::__value, "invalid specialization");
        static const bool __is_signed = (short)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<short>::__width - __is_signed;
        static const short __max = __is_signed ? (((((short)1 << (__digits - 1)) - 1) << 1) + 1) : ~(short)0;
        static const short __min = __is_signed ? -__max - 1 : (short)0;
    };
    const _Value __min;
    const _Value __max;
    const bool __is_signed;
    const int __digits;
    template<> struct __is_integer_nonstrict<__int128> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
        enum  {
            __width = 128
        };
    };
    template<> struct __is_integer_nonstrict<unsigned __int128> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
        enum  {
            __width = 128
        };
    };
    template <typename _Tp> using __int_traits = __numeric_traits_integer<_Tp>;
    template <typename _Value> struct __numeric_traits_floating {
        static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<float> {
        static const int __max_digits10 = (2 + (std::__are_same<float, float>::__value ? 24 : std::__are_same<float, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<float, float>::__value ? 6 : std::__are_same<float, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<float, float>::__value ? 38 : std::__are_same<float, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<double> {
        static const int __max_digits10 = (2 + (std::__are_same<double, float>::__value ? 24 : std::__are_same<double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<double, float>::__value ? 6 : std::__are_same<double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<double, float>::__value ? 38 : std::__are_same<double, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<long double> {
        static const int __max_digits10 = (2 + (std::__are_same<long double, float>::__value ? 24 : std::__are_same<long double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<long double, float>::__value ? 6 : std::__are_same<long double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<long double, float>::__value ? 38 : std::__are_same<long double, double>::__value ? 308 : 4932);
    };
    const int __max_digits10;
    const bool __is_signed;
    const int __digits10;
    const int __max_exponent10;
    template <typename _Value> struct __numeric_traits : public __numeric_traits_integer<_Value> {
    };
template<> struct __numeric_traits<int> : public __numeric_traits_integer<int> {
    };
template<> struct __numeric_traits<unsigned long> : public __numeric_traits_integer<unsigned long> {
    };
template<> struct __numeric_traits<char> : public __numeric_traits_integer<char> {
    };
template<> struct __numeric_traits<long> : public __numeric_traits_integer<long> {
    };
template<> struct __numeric_traits<short> : public __numeric_traits_integer<short> {
    };
    template<> struct __numeric_traits<float> : public __numeric_traits_floating<float> {
    };
    template<> struct __numeric_traits<double> : public __numeric_traits_floating<double> {
    };
    template<> struct __numeric_traits<long double> : public __numeric_traits_floating<long double> {
    };
    const bool __is_signed;
    const int __digits;
    const unsigned __int128 __max;
    const bool __is_signed;
    const int __digits;
    const long __max;
    const bool __is_signed;
    const int __digits;
    const int __max;
    const int __min;
    const int __max_exponent10;
    const int __max_exponent10;
    const int __max_exponent10;
    const bool __is_signed;
    const int __digits;
    const unsigned long __max;
    const bool __is_signed;
    const int __digits;
    const char __max;
    const bool __is_signed;
    const int __digits;
    const short __max;
    const short __min;
    const long __min;
}
namespace std {
    template <typename _Tp> struct tuple_size;
    template <typename _Tp, typename _Up = typename remove_cv<_Tp>::type, typename = typename enable_if<is_same<_Tp, _Up>::value>::type, std::size_t = tuple_size<_Tp>::value> using __enable_if_has_tuple_size = _Tp;
    template <typename _Tp> struct tuple_size<const __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>> : public tuple_size<_Tp> {
    };
    template <typename _Tp> constexpr std::size_t tuple_size_v = tuple_size<_Tp>::value;
    template <std::size_t __i, typename _Tp> struct tuple_element;
    template <std::size_t __i, typename _Tp> using __tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, const _Tp> {
        typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, volatile _Tp> {
        typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <std::size_t __i, typename _Tp> struct tuple_element<__i, const volatile _Tp> {
        typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };
    template <typename _Tp, typename ..._Types> constexpr std::size_t __find_uniq_type_in_pack()     {
        constexpr std::size_t __sz = sizeof...(_Types);
        constexpr bool __found[__sz] = {__is_same(_Tp, _Types)...};
        std::size_t __n = __sz;
        for (std::size_t __i = 0; __i < __sz; ++__i) {
            if (__found[__i]) {
                if (__n < __sz)
                    return __sz;
                __n = __i;
            }
        }
        return __n;
    }
    template <std::size_t __i, typename _Tp> using tuple_element_t = typename tuple_element<__i, _Tp>::type;
    template <std::size_t ..._Indexes> struct _Index_tuple {
    };
    template <std::size_t _Num> struct _Build_index_tuple {
        template <typename, std::size_t ..._Indices> using _IdxTuple = _Index_tuple<_Indices...>;
        using __type = __make_integer_seq<_IdxTuple, std::size_t, _Num>;
    };
    template <typename _Tp, _Tp ..._Idx> struct integer_sequence {
        typedef _Tp value_type;
        static constexpr std::size_t size() noexcept         {
            return sizeof...(_Idx);
        }
    };
    template <typename _Tp, _Tp _Num> using make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Num>;
    template <std::size_t ..._Idx> using index_sequence = integer_sequence<std::size_t, _Idx...>;
    template <std::size_t _Num> using make_index_sequence = make_integer_sequence<std::size_t, _Num>;
    template <typename ..._Types> using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
    struct in_place_t {
        explicit in_place_t() noexcept = default
    };
    constexpr std::in_place_t in_place{};
    template <typename _Tp> struct in_place_type_t {
        explicit in_place_type_t<_Tp>() = default
    };
    template <typename _Tp> constexpr in_place_type_t<_Tp> in_place_type{};
    template <std::size_t _Idx> struct in_place_index_t {
        explicit in_place_index_t<_Idx>() = default
    };
    template <std::size_t _Idx> constexpr in_place_index_t<_Idx> in_place_index{};
    template <typename> constexpr bool __is_in_place_type_v = false;
    constexpr bool __is_in_place_type_v = true;
    template <typename _Tp> using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;
    template <std::size_t _Np, typename ..._Types> struct _Nth_type {
    };
    template <typename _Tp0, typename ..._Rest> struct _Nth_type<0, _Tp0, _Rest...> {
        using type = _Tp0;
    };
    template <typename _Tp0, typename _Tp1, typename ..._Rest> struct _Nth_type<1, _Tp0, _Tp1, _Rest...> {
        using type = _Tp1;
    };
    template <typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...> {
        using type = _Tp2;
    };
    template <std::size_t _Np, typename _Tp0, typename _Tp1, typename _Tp2, typename ..._Rest> struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...> : _Nth_type<_Np - 3, _Rest...> {
    };
}
namespace std {
    struct piecewise_construct_t {
        explicit piecewise_construct_t() noexcept = default
    };
    constexpr std::piecewise_construct_t piecewise_construct = std::piecewise_construct_t();
    template <typename ...> class tuple;
    template <std::size_t ...> struct _Index_tuple;
    template <typename _U1, typename _U2> class __pair_base {
    };
    template <typename _T1, typename _T2> struct pair : public __pair_base<_T1, _T2> {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        pair<_T1, _T2>(const pair<_T1, _T2> &) = default
        pair<_T1, _T2>(pair<_T1, _T2> &&) = default
        template <typename ..._Args1, typename ..._Args2> constexpr pair<_T1, _T2>(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        constexpr void swap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::valueswap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value)         {
            using std::swap;
            swap(this->first, __p.first);
            swap(this->second, __p.second);
        }
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> constexpr pair<_T1, _T2>(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:
        constexpr explicit(__not_<__and_<__is_implicitly_default_constructible<_T1>, __is_implicitly_default_constructible<_T2>>>()) pair<_T1, _T2>() : first(), second() requires is_default_constructible_v<_T1> && is_default_constructible_v<_T2>         {
        }
    private:
        template <typename _U1, typename _U2> static constexpr bool _S_constructible()         {
            if (is_constructible_v<_T1, _U1>)
                return is_constructible_v<_T2, _U2>;
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _S_nothrow_constructible()         {
            if (is_nothrow_constructible_v<_T1, _U1>)
                return is_nothrow_constructible_v<_T2, _U2>;
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _S_convertible()         {
            if (is_convertible_v<_U1, _T1>)
                return is_convertible_v<_U2, _T2>;
            return false;
        }
    public:
        constexpr explicit(!_S_convertible<const _T1 &, const _T2 &>()) pair<_T1, _T2>(const _T1 &__x, const _T2 &__y) noexcept(_S_nothrow_constructible<const _T1 &, const _T2 &>()pair<_T1, _T2>(const _T1 &__x, const _T2 &__y) noexcept(_S_nothrow_constructible<const _T1 &, const _T2 &>()) : first(__x), second(__y) requires (_S_constructible<const _T1 &, const _T2 &>())         {
        }
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<_U1, _U2>()) pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) noexcept(_S_nothrow_constructible<_U1, _U2>()pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) noexcept(_S_nothrow_constructible<_U1, _U2>()) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<const _U1 &, const _U2 &>()) pair<_T1, _T2>(const pair<_U1, _U2> &__p) noexcept(_S_nothrow_constructible<const _U1 &, const _U2 &>()pair<_T1, _T2>(const pair<_U1, _U2> &__p) noexcept(_S_nothrow_constructible<const _U1 &, const _U2 &>()) : first(__p.first), second(__p.second)         {
        }
        template <typename _U1, typename _U2> constexpr explicit(!_S_convertible<_U1, _U2>()) pair<_T1, _T2>(pair<_U1, _U2> &&__p) noexcept(_S_nothrow_constructible<_U1, _U2>()pair<_T1, _T2>(pair<_U1, _U2> &&__p) noexcept(_S_nothrow_constructible<_U1, _U2>()) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))         {
        }
    private:
        template <typename _U1, typename _U2> static constexpr bool _S_assignable()         {
            if (is_assignable_v<_T1 &, _U1>)
                return is_assignable_v<_T2 &, _U2>;
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _S_nothrow_assignable()         {
            if (is_nothrow_assignable_v<_T1 &, _U1>)
                return is_nothrow_assignable_v<_T2 &, _U2>;
            return false;
        }
    public:
        pair<_T1, _T2> &operator=(const pair<_T1, _T2> &) = delete
        constexpr pair<_T1, _T2> &operator=(const pair<_T1, _T2> &__p) noexcept(_S_nothrow_assignable<const _T1 &, const _T2 &>()operator=(const pair<_T1, _T2> &__p) noexcept(_S_nothrow_assignable<const _T1 &, const _T2 &>()) requires (_S_assignable<const _T1 &, const _T2 &>())         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        constexpr pair<_T1, _T2> &operator=(pair<_T1, _T2> &&__p) noexcept(_S_nothrow_assignable<_T1, _T2>()operator=(pair<_T1, _T2> &&__p) noexcept(_S_nothrow_assignable<_T1, _T2>()) requires (_S_assignable<_T1, _T2>())         {
            this->first = std::forward<std::pair::first_type>(__p.first);
            this->second = std::forward<std::pair::second_type>(__p.second);
            return *this;
        }
        template <typename _U1, typename _U2> constexpr pair<_T1, _T2> &operator=(const pair<_U1, _U2> &__p) noexcept(_S_nothrow_assignable<const _U1 &, const _U2 &>()operator=(const pair<_U1, _U2> &__p) noexcept(_S_nothrow_assignable<const _U1 &, const _U2 &>()) requires (_S_assignable<const _U1 &, const _U2 &>())         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        template <typename _U1, typename _U2> constexpr pair<_T1, _T2> &operator=(pair<_U1, _U2> &&__p) noexcept(_S_nothrow_assignable<_U1, _U2>()operator=(pair<_U1, _U2> &&__p) noexcept(_S_nothrow_assignable<_U1, _U2>()) requires (_S_assignable<_U1, _U2>())         {
            this->first = std::forward<_U1>(__p.first);
            this->second = std::forward<_U2>(__p.second);
            return *this;
        }
    };
    template <typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
    template <typename _T1, typename _T2> inline constexpr bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first == __y.first && __x.second == __y.second;
    }
    template <typename _T1, typename _T2> constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>, __detail::__synth3way_t<_T2>> operator<=>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
            return __c;
        return __detail::__synth3way(__x.second, __y.second);
    }
    template <typename _T1, typename _T2> inline constexpr typename enable_if<__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y))swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)))     {
        __x.swap(__y);
    }
    template <typename _T1, typename _T2> typename enable_if<!__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete
    template <typename _T1, typename _T2> constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y)     {
        typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        typedef pair<__ds_type1, __ds_type2> __pair_type;
        return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
    template <typename _T1, typename _T2> struct __is_tuple_like_impl<pair<_T1, _T2>> : std::true_type {
    };
    template <class _Tp1, class _Tp2> struct tuple_size<pair<_Tp1, _Tp2>> : public integral_constant<std::size_t, 2> {
    };
    template <class _Tp1, class _Tp2> struct tuple_element<0, pair<_Tp1, _Tp2>> {
        typedef _Tp1 type;
    };
    template <class _Tp1, class _Tp2> struct tuple_element<1, pair<_Tp1, _Tp2>> {
        typedef _Tp2 type;
    };
    constexpr std::size_t tuple_size_v = 2;
    constexpr std::size_t tuple_size_v = 2;
    template <typename _Tp> constexpr bool __is_pair = false;
    constexpr bool __is_pair = true;
    constexpr bool __is_pair = true;
    template <std::size_t _Int> struct __pair_get;
    template<> struct __pair_get<0> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &__get(pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp1 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<_Tp1>(__pair.first);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.first;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp1 &&__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<const _Tp1>(__pair.first);
        }
    };
    template<> struct __pair_get<1> {
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &__get(pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr _Tp2 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<_Tp2>(__pair.second);
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &__const_get(const pair<_Tp1, _Tp2> &__pair) noexcept         {
            return __pair.second;
        }
        template <typename _Tp1, typename _Tp2> static constexpr const _Tp2 &&__const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept         {
            return std::forward<const _Tp2>(__pair.second);
        }
    };
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(pair<_Tp1, _Tp2> &__in) noexcept     {
        return __pair_get<_Int>::__get(__in);
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(pair<_Tp1, _Tp2> &&__in) noexcept     {
        return __pair_get<_Int>::__move_get(std::move(__in));
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(const pair<_Tp1, _Tp2> &__in) noexcept     {
        return __pair_get<_Int>::__const_get(__in);
    }
    template <std::size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(const pair<_Tp1, _Tp2> &&__in) noexcept     {
        return __pair_get<_Int>::__const_move_get(std::move(__in));
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Tp, _Up> &__p) noexcept     {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Tp, _Up> &__p) noexcept     {
        return __p.first;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Tp, _Up> &&__p) noexcept     {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Tp, _Up> &&__p) noexcept     {
        return std::move(__p.first);
    }
    template <typename _Tp, typename _Up> constexpr _Tp &get(pair<_Up, _Tp> &__p) noexcept     {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &get(const pair<_Up, _Tp> &__p) noexcept     {
        return __p.second;
    }
    template <typename _Tp, typename _Up> constexpr _Tp &&get(pair<_Up, _Tp> &&__p) noexcept     {
        return std::move(__p.second);
    }
    template <typename _Tp, typename _Up> constexpr const _Tp &&get(const pair<_Up, _Tp> &&__p) noexcept     {
        return std::move(__p.second);
    }
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
    template <typename _Ite, typename _Seq, typename _Cat> struct _Safe_iterator;
}
namespace __gnu_cxx {
    namespace __ops {
        struct _Iter_less_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 < *__it2;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_less_iter __iter_less_iter()         {
            return __gnu_cxx::__ops::_Iter_less_iter();
        }
        struct _Iter_less_val {
            _Iter_less_val() noexcept = default
            constexpr explicit _Iter_less_val(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it < __val;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_less_val __iter_less_val()         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        inline constexpr __gnu_cxx::__ops::_Iter_less_val __iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        struct _Val_less_iter {
            _Val_less_iter() noexcept = default
            constexpr explicit _Val_less_iter(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Value, typename _Iterator> constexpr bool operator()(_Value &__val, _Iterator __it) const             {
                return __val < *__it;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Val_less_iter __val_less_iter()         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        inline constexpr __gnu_cxx::__ops::_Val_less_iter __val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        struct _Iter_equal_to_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 == *__it2;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter()         {
            return __gnu_cxx::__ops::_Iter_equal_to_iter();
        }
        struct _Iter_equal_to_val {
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it == __val;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val()         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        inline constexpr __gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter)         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        template <typename _Compare> struct _Iter_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2)             {
                return bool(this->_M_comp(*__it1, *__it2));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)         {
            return _Iter_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Iter_comp_val {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_val<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            constexpr explicit _Iter_comp_val<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            constexpr explicit _Iter_comp_val<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val)             {
                return bool(this->_M_comp(*__it, __val));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline constexpr _Iter_comp_val<_Compare> __iter_comp_val(_Iter_comp_iter<_Compare> __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Val_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Val_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            constexpr explicit _Val_comp_iter<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            constexpr explicit _Val_comp_iter<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Value, typename _Iterator> constexpr bool operator()(_Value &__val, _Iterator __it)             {
                return bool(this->_M_comp(__val, *__it));
            }
        };
        template <typename _Compare> inline constexpr _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline constexpr _Val_comp_iter<_Compare> __val_comp_iter(_Iter_comp_iter<_Compare> __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Value> struct _Iter_equals_val {
            _Value &_M_value;
            constexpr explicit _Iter_equals_val<_Value>(_Value &__value) : _M_value(__value)             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return *__it == this->_M_value;
            }
        };
        template <typename _Value> inline constexpr _Iter_equals_val<_Value> __iter_equals_val(_Value &__val)         {
            return _Iter_equals_val<_Value>(__val);
        }
        template <typename _Iterator1> struct _Iter_equals_iter {
            _Iterator1 _M_it1;
            constexpr explicit _Iter_equals_iter<_Iterator1>(_Iterator1 __it1) : _M_it1(__it1)             {
            }
            template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2)             {
                return *__it2 == *this->_M_it1;
            }
        };
        template <typename _Iterator> inline constexpr _Iter_equals_iter<_Iterator> __iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it)         {
            return _Iter_equals_iter<_Iterator>(__it);
        }
        template <typename _Predicate> struct _Iter_pred {
            _Predicate _M_pred;
            constexpr explicit _Iter_pred<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline constexpr _Iter_pred<_Predicate> __pred_iter(_Predicate __pred)         {
            return _Iter_pred<_Predicate>(std::move(__pred));
        }
        template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
            _Compare _M_comp;
            _Value &_M_value;
            constexpr _Iter_comp_to_val<_Compare, _Value>(_Compare __comp, _Value &__value) : _M_comp(std::move(__comp)), _M_value(__value)             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return bool(this->_M_comp(*__it, this->_M_value));
            }
        };
        template <typename _Compare, typename _Value> constexpr _Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val)         {
            return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
        }
        template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
            _Compare _M_comp;
            _Iterator1 _M_it1;
            constexpr _Iter_comp_to_iter<_Compare, _Iterator1>(_Compare __comp, _Iterator1 __it1) : _M_comp(std::move(__comp)), _M_it1(__it1)             {
            }
            template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2)             {
                return bool(this->_M_comp(*__it2, *this->_M_it1));
            }
        };
        template <typename _Compare, typename _Iterator> inline constexpr _Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)         {
            return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp), __it);
        }
        template <typename _Predicate> struct _Iter_negate {
            _Predicate _M_pred;
            constexpr explicit _Iter_negate<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return !bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline constexpr _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred)         {
            return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
        }
    }
}
namespace std {
    template <typename _Tp, typename _Up> inline constexpr int __memcmp(const _Tp *__first1, const _Up *__first2, std::size_t __num)     {
        static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
        if (std::is_constant_evaluated()) {
            for (; __num > 0; ++__first1 , ++__first2 , --__num)
                if (*__first1 != *__first2)
                    return *__first1 < *__first2 ? -1 : 1;
            return 0;
        } else
            return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline constexpr void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)     {
        swap(*__a, *__b);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> constexpr _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            std::iter_swap(__first1, __first2);
        return __first2;
    }
    template <typename _Tp> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const unsigned long &min<unsigned long>(const unsigned long &__a, const unsigned long &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const long &min<long>(const long &__a, const long &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template <typename _Tp> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<> inline constexpr const int &max<int>(const int &__a, const int &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<> inline constexpr const float &max<float>(const float &__a, const float &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<> inline constexpr const long double &max<long double>(const long double &__a, const long double &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }
    template <typename _Iterator> inline constexpr _Iterator __niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it;
    }
    template <typename _Ite, typename _Seq> _Ite __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, std::random_access_iterator_tag> &);
    template <typename _From, typename _To> inline constexpr _From __niter_wrap(_From __from, _To __res)     {
        return __from + (__res - std::__niter_base(__from));
    }
    template <typename _Iterator> inline constexpr _Iterator __niter_wrap(const _Iterator &, _Iterator __res)     {
        return __res;
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = *__first;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move<true, false, _Category> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = std::move(*__first);
            return __result;
        }
    };
    template<> struct __copy_move<false, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template<> struct __copy_move<true, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = std::move(*__first);
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static constexpr _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = __conditional_t<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::value, "type must be assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
            return __result + _Num;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr> struct _Deque_iterator;
    struct _Bit_iterator;
    template <typename _CharT> struct char_traits;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, _CharT *);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, std::_Deque_iterator<_CharT, _CharT &, _CharT *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a2(_II __first, _II __last, _OI __result)     {
        typedef typename iterator_traits<_II>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<_IsMove, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a1(_II __first, _II __last, _OI __result)     {
        return std::__copy_move_a2<_IsMove>(__first, __last, __result);
    }
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a(_II __first, _II __last, _OI __result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _InputIterator, typename _Size, typename _OutputIterator> constexpr _OutputIterator __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result, bool)     {
        if (__n > 0) {
            while (true)
                {
                    *__result = *__first;
                    ++__result;
                    if (--__n > 0)
                        ++__first;
                    else
                        break;
                }
        }
        return __result;
    }
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, _CharT *, bool);
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, std::_Deque_iterator<_CharT, _CharT &, _CharT *>, bool);
    template <typename _II, typename _OI> inline constexpr _OI copy(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _II, typename _OI> inline constexpr _OI move(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move_backward<true, false, _Category> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template<> struct __copy_move_backward<false, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
    };
    template<> struct __copy_move_backward<true, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move_backward<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static constexpr _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = __conditional_t<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::value, "type must be assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
            return __result - _Num;
        }
    };
    template <bool _IsMove, typename _BI1, typename _BI2> inline constexpr _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)     {
        typedef typename iterator_traits<_BI1>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<_IsMove, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<_IsMove, __memcpyable<_BI2, _BI1>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template <bool _IsMove, typename _BI1, typename _BI2> inline constexpr _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)     {
        return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_backward_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_backward_a(_II __first, _II __last, _OI __result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _BI1, typename _BI2> inline constexpr _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _BI1, typename _BI2> inline constexpr _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        for (; __first != __last; ++__first)
            *__first = __value;
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __first != __last; ++__first)
            *__first = __tmp;
    }
    template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a1(_Tp *__first, _Tp *__last, const _Tp &__c)     {
        const _Tp __tmp = __c;
        if (std::is_constant_evaluated()) {
            for (; __first != __last; ++__first)
                *__first = __tmp;
            return;
        }
        if (const std::size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template <typename _Ite, typename _Cont, typename _Tp> inline constexpr void __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first, ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last, const _Tp &__value)     {
        std::__fill_a1(__first.base(), __last.base(), __value);
    }
    template <typename _Tp, typename _VTp> void __fill_a1(const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const _VTp &);
    constexpr void __fill_a1(std::_Bit_iterator, std::_Bit_iterator, const bool &);
    template <typename _FIte, typename _Tp> inline constexpr void __fill_a(_FIte __first, _FIte __last, const _Tp &__value)     {
        std::__fill_a1(__first, __last, __value);
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Tp> void __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const _Tp &);
    template <typename _ForwardIterator, typename _Tp> inline constexpr void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        ;
        std::__fill_a(__first, __last, __value);
    }
    inline constexpr int __size_to_integer(int __n)     {
        return __n;
    }
    inline constexpr unsigned int __size_to_integer(unsigned int __n)     {
        return __n;
    }
    inline constexpr long __size_to_integer(long __n)     {
        return __n;
    }
    inline constexpr unsigned long __size_to_integer(unsigned long __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(long long __n)     {
        return __n;
    }
    inline constexpr unsigned long long __size_to_integer(unsigned long long __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(float __n)     {
        return (long long)__n;
    }
    inline constexpr long long __size_to_integer(double __n)     {
        return (long long)__n;
    }
    inline constexpr long long __size_to_integer(long double __n)     {
        return (long long)__n;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        for (; __n > 0; --__n , (void)++__first)
            *__first = __value;
        return __first;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __n > 0; --__n , (void)++__first)
            *__first = __tmp;
        return __first;
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Size, typename _Tp> ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first, _Size __n, const _Tp &__value, std::input_iterator_tag);
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::output_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::input_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::random_access_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template <typename _OI, typename _Size, typename _Tp> inline constexpr _OI fill_n(_OI __first, _Size __n, const _Tp &__value)     {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template <bool _BoolType> struct __equal {
        template <typename _II1, typename _II2> static constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2)         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!(*__first1 == *__first2))
                    return false;
            return true;
        }
    };
    template<> struct __equal<true> {
        template <typename _Tp> static constexpr bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)         {
            if (const std::size_t __len = (__last1 - __first1))
                return !std::__memcmp(__first1, __first2, __len);
            return true;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr, typename _II> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _II);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II, typename _Tp, typename _Ref, typename _Ptr> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(_II, _II, std::_Deque_iterator<_Tp, _Ref, _Ptr>);
    template <typename _II1, typename _II2> inline constexpr bool __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        const bool __simple = ((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __memcmpable<_II1, _II2>::__value);
        return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
    template <typename _II1, typename _II2> inline constexpr bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)     {
        return std::__equal_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
    }
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, _II2);
    template <typename _II1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename, typename> struct __lc_rai {
        template <typename _II1, typename _II2> static constexpr _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)         {
            return __last1;
        }
        template <typename _II> static constexpr bool __cnd2(_II __first, _II __last)         {
            return __first != __last;
        }
    };
    template<> struct __lc_rai<std::random_access_iterator_tag, std::random_access_iterator_tag> {
        template <typename _RAI1, typename _RAI2> static constexpr _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)         {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }
        template <typename _RAI> static constexpr bool __cnd2(_RAI, _RAI)         {
            return true;
        }
    };
    template <typename _II1, typename _II2, typename _Compare> constexpr bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        typedef typename iterator_traits<_II1>::iterator_category _Category1;
        typedef typename iterator_traits<_II2>::iterator_category _Category2;
        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ++__first1 , (void)++__first2) {
            if (__comp(__first1, __first2))
                return true;
            if (__comp(__first2, __first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template <bool _BoolType> struct __lexicographical_compare {
        template <typename _II1, typename _II2> static constexpr bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)         {
            using __gnu_cxx::__ops::__iter_less_iter;
            return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __iter_less_iter());
        }
        template <typename _II1, typename _II2> static constexpr int __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)         {
            while (__first1 != __last1)
                {
                    if (__first2 == __last2)
                        return +1;
                    if (*__first1 < *__first2)
                        return -1;
                    if (*__first2 < *__first1)
                        return +1;
                    ++__first1;
                    ++__first2;
                }
            return int(__first2 == __last2) - 1;
        }
    };
    template<> struct __lexicographical_compare<true> {
        template <typename _Tp, typename _Up> static constexpr bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)         {
            return __3way(__first1, __last1, __first2, __last2) < 0;
        }
        template <typename _Tp, typename _Up> static constexpr std::ptrdiff_t __3way(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)         {
            const std::size_t __len1 = __last1 - __first1;
            const std::size_t __len2 = __last2 - __first2;
            if (const std::size_t __len = std::min(__len1, __len2))
                if (int __result = std::__memcmp(__first1, __first2, __len))
                    return __result;
            return std::ptrdiff_t(__len1 - __len2);
        }
    };
    template <typename _II1, typename _II2> inline constexpr bool __lexicographical_compare_aux1(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>> && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>);
        return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
    }
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2> bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, _Tp2 *, _Tp2 *);
    template <typename _Tp1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __lexicographical_compare_aux1(_Tp1 *, _Tp1 *, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II1, typename _II2> inline constexpr bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        return std::__lexicographical_compare_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
    }
    template <typename _Iter1, typename _Seq1, typename _Cat1, typename _II2> bool __lexicographical_compare_aux(const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, _II2, _II2);
    template <typename _II1, typename _Iter2, typename _Seq2, typename _Cat2> bool __lexicographical_compare_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
    template <typename _Iter1, typename _Seq1, typename _Cat1, typename _Iter2, typename _Seq2, typename _Cat2> bool __lexicographical_compare_aux(const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);
    template <typename _ForwardIterator, typename _Tp, typename _Compare> constexpr _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else
                    __len = __half;
            }
        return __first;
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    }
    inline constexpr int __lg(int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr unsigned int __lg(unsigned int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr long __lg(long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr unsigned long __lg(unsigned long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr long long __lg(long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    inline constexpr unsigned long long __lg(unsigned long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    template <typename _II1, typename _II2> inline constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2)     {
        ;
        return std::__equal_aux(__first1, __last1, __first2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline constexpr bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return true;
    }
    template <typename _II1, typename _II2> inline constexpr bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!(*__first1 == *__first2))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2, typename _BinaryPredicate> inline constexpr bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _BinaryPredicate __binary_pred)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2, __binary_pred);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2> inline constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline constexpr bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
    }
    template <typename _II1, typename _II2> inline constexpr bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__lexicographical_compare_aux(__first1, __last1, __first2, __last2);
    }
    template <typename _II1, typename _II2, typename _Compare> inline constexpr bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        ;
        ;
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
    template <typename _Iter> concept __is_byte_iter = contiguous_iterator<_Iter> && __is_memcmp_ordered<iter_value_t<_Iter>>::__value;;
    template <typename _Tp> constexpr auto __min_cmp(_Tp __x, _Tp __y)     {
        struct _Res {
            _Tp _M_min;
            decltype(__x <=> __y) _M_cmp;
        };
        auto __c = __x <=> __y;
        if (__c > 0)
            return _Res({__y, __c});
        return _Res({__x, __c});
    }
    template <typename _InputIter1, typename _InputIter2, typename _Comp> constexpr auto lexicographical_compare_three_way(_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _Comp __comp) -> decltype(__comp(*__first1, *__first2))     {
        ;
        ;
        using _Cat = decltype(__comp(*__first1, *__first2));
        static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);
        if (!std::__is_constant_evaluated())
            if (same_as<_Comp, __detail::_Synth3way> || same_as<_Comp, std::compare_three_way>)
                if (__is_byte_iter<_InputIter1>)
                    if (__is_byte_iter<_InputIter2>) {
                        const auto = std::__min_cmp(__last1 - __first1, __last2 - __first2);
                        if (__len) {
                            const auto __c = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;
                            if (__c != 0)
                                return __c;
                        }
                        return __lencmp;
                    }
        while (__first1 != __last1)
            {
                if (__first2 == __last2)
                    return strong_ordering::greater;
                if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
                    return __cmp;
                ++__first1;
                ++__first2;
            }
        return (__first2 == __last2) <=> true;
    }
    template <typename _InputIter1, typename _InputIter2> constexpr auto lexicographical_compare_three_way(_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2)     {
        return std::lexicographical_compare_three_way(__first1, __last1, __first2, __last2, std::compare_three_way{});
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> constexpr pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> constexpr pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __first2 != __last2 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator, typename _Predicate> inline constexpr _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, std::input_iterator_tag)     {
        while (__first != __last && !__pred(__first))
            ++__first;
        return __first;
    }
    template <typename _RandomAccessIterator, typename _Predicate> constexpr _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, std::random_access_iterator_tag)     {
        typename iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
        for (; __trip_count > 0; --__trip_count) {
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
        }
        switch (__last - __first) {
          case 3:
            if (__pred(__first))
                return __first;
            ++__first;
          case 2:
            if (__pred(__first))
                return __first;
            ++__first;
          case 1:
            if (__pred(__first))
                return __first;
            ++__first;
          case 0:
          default:
            return __last;
        }
    }
    template <typename _Iterator, typename _Predicate> inline constexpr _Iterator __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)     {
        return __find_if(__first, __last, __pred, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Predicate> constexpr typename iterator_traits<_InputIterator>::difference_type __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        for (; __first != __last; ++__first)
            if (__pred(__first))
                ++__n;
        return __n;
    }
    template <typename _ForwardIterator, typename _Predicate> constexpr _ForwardIterator __remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)     {
        __first = std::__find_if(__first, __last, __pred);
        if (__first == __last)
            return __first;
        _ForwardIterator __result = __first;
        ++__first;
        for (; __first != __last; ++__first)
            if (!__pred(__first)) {
                *__result = std::move(*__first);
                ++__result;
            }
        return __result;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> constexpr bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)     {
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!__pred(__first1, __first2))
                break;
        if (__first1 == __last1)
            return true;
        _ForwardIterator2 __last2 = __first2;
        std::advance(__last2, std::distance(__first1, __last1));
        for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
            if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                continue;
            auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
            if (0 == __matches || std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)
                return false;
        }
        return true;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline constexpr bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
}
namespace std {
    namespace numbers {
        template <typename _Tp> using _Enable_if_floating = enable_if_t<is_floating_point_v<_Tp>, _Tp>;
        template <typename _Tp> constexpr _Tp e_v = _Enable_if_floating<_Tp>(2.71828182845904523543L);
        template <typename _Tp> constexpr _Tp log2e_v = _Enable_if_floating<_Tp>(1.44269504088896340739L);
        template <typename _Tp> constexpr _Tp log10e_v = _Enable_if_floating<_Tp>(0.434294481903251827645L);
        template <typename _Tp> constexpr _Tp pi_v = _Enable_if_floating<_Tp>(3.14159265358979323851L);
        template <typename _Tp> constexpr _Tp inv_pi_v = _Enable_if_floating<_Tp>(0.318309886183790671538L);
        template <typename _Tp> constexpr _Tp inv_sqrtpi_v = _Enable_if_floating<_Tp>(0.564189583547756286924L);
        template <typename _Tp> constexpr _Tp ln2_v = _Enable_if_floating<_Tp>(0.693147180559945309429L);
        template <typename _Tp> constexpr _Tp ln10_v = _Enable_if_floating<_Tp>(2.30258509299404568404L);
        template <typename _Tp> constexpr _Tp sqrt2_v = _Enable_if_floating<_Tp>(1.41421356237309504876L);
        template <typename _Tp> constexpr _Tp sqrt3_v = _Enable_if_floating<_Tp>(1.73205080756887729357L);
        template <typename _Tp> constexpr _Tp inv_sqrt3_v = _Enable_if_floating<_Tp>(0.577350269189625764507L);
        template <typename _Tp> constexpr _Tp egamma_v = _Enable_if_floating<_Tp>(0.577215664901532860616L);
        template <typename _Tp> constexpr _Tp phi_v = _Enable_if_floating<_Tp>(1.61803398874989484821L);
        constexpr double e = e_v<double>;
        constexpr double e_v = _Enable_if_floating<double>(2.71828182845904523543L);
        constexpr double log2e = log2e_v<double>;
        constexpr double log2e_v = _Enable_if_floating<double>(1.44269504088896340739L);
        constexpr double log10e = log10e_v<double>;
        constexpr double log10e_v = _Enable_if_floating<double>(0.434294481903251827645L);
        constexpr double pi = pi_v<double>;
        constexpr double pi_v = _Enable_if_floating<double>(3.14159265358979323851L);
        constexpr double inv_pi = inv_pi_v<double>;
        constexpr double inv_pi_v = _Enable_if_floating<double>(0.318309886183790671538L);
        constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
        constexpr double inv_sqrtpi_v = _Enable_if_floating<double>(0.564189583547756286924L);
        constexpr double ln2 = ln2_v<double>;
        constexpr double ln2_v = _Enable_if_floating<double>(0.693147180559945309429L);
        constexpr double ln10 = ln10_v<double>;
        constexpr double ln10_v = _Enable_if_floating<double>(2.30258509299404568404L);
        constexpr double sqrt2 = sqrt2_v<double>;
        constexpr double sqrt2_v = _Enable_if_floating<double>(1.41421356237309504876L);
        constexpr double sqrt3 = sqrt3_v<double>;
        constexpr double sqrt3_v = _Enable_if_floating<double>(1.73205080756887729357L);
        constexpr double inv_sqrt3 = inv_sqrt3_v<double>;
        constexpr double inv_sqrt3_v = _Enable_if_floating<double>(0.577350269189625764507L);
        constexpr double egamma = egamma_v<double>;
        constexpr double egamma_v = _Enable_if_floating<double>(0.577215664901532860616L);
        constexpr double phi = phi_v<double>;
        constexpr double phi_v = _Enable_if_floating<double>(1.61803398874989484821L);
    }
}
namespace std {
    template <typename _Tp> struct numeric_limits;
    namespace ranges {
        namespace __detail {
            class __max_size_type {
            public:
                __max_size_type() = default
                template <typename _Tp> constexpr __max_size_type(_Tp __i) noexcept : _M_val(__i), _M_msb(__i < 0)                 {
                }
                template<> constexpr __max_size_type<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type __i) noexcept                template<> constexpr __max_size_type<int>(int __i) noexcept : _M_val(__i), _M_msb(__i < 0)                 {
                }
                template<> constexpr __max_size_type<unsigned __int128>(unsigned __int128 __i) noexcept : _M_val(__i), _M_msb(__i < 0)                 {
                }
                template<> constexpr __max_size_type<unsigned long>(unsigned long __i) noexcept : _M_val(__i), _M_msb(__i < 0)                 {
                }
                template<> constexpr __max_size_type<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type __i) noexcept                constexpr explicit __max_size_type(const std::ranges::__detail::__max_diff_type &__d) noexcept;
                template <typename _Tp> constexpr explicit operator _Tp() const noexcept                 {
                    return this->_M_val;
                }
                template<> constexpr explicit operator __max_size_type<std::ranges::__detail::__max_size_type>() const noexcept                template<> constexpr explicit operator __max_diff_type<std::ranges::__detail::__max_diff_type>() const noexcept                constexpr explicit operator bool() const noexcept                 {
                    return this->_M_val != 0 || this->_M_msb != 0;
                }
                constexpr std::ranges::__detail::__max_size_type operator+() const noexcept                 {
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type operator~() const noexcept                 {
                    return std::ranges::__detail::__max_size_type{~this->_M_val, !this->_M_msb};
                }
                constexpr std::ranges::__detail::__max_size_type operator-() const noexcept                 {
                    return this->operator~() + 1;
                }
                constexpr std::ranges::__detail::__max_size_type &operator++() noexcept                 {
                    return *this += 1;
                }
                constexpr std::ranges::__detail::__max_size_type operator++(int) noexcept                 {
                    auto __tmp = *this;
                    ++ *this;
                    return __tmp;
                }
                constexpr std::ranges::__detail::__max_size_type &operator--() noexcept                 {
                    return *this -= 1;
                }
                constexpr std::ranges::__detail::__max_size_type operator--(int) noexcept                 {
                    auto __tmp = *this;
                    -- *this;
                    return __tmp;
                }
                constexpr std::ranges::__detail::__max_size_type &operator+=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    const auto __sum = this->_M_val + __r._M_val;
                    const bool __overflow = (__sum < this->_M_val);
                    this->_M_msb = this->_M_msb ^ __r._M_msb ^ __overflow;
                    this->_M_val = __sum;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator-=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    return *this += - __r;
                }
                constexpr std::ranges::__detail::__max_size_type &operator*=(std::ranges::__detail::__max_size_type __r) noexcept                 {
                    constexpr std::ranges::__detail::__max_size_type __threshold = std::ranges::__detail::__max_size_type::__rep(1) << (_S_rep_bits / 2 - 1);
                    if (this->_M_val < __threshold && __r < __threshold)
                        this->_M_val = this->_M_val * __r._M_val;
                    else {
                        const bool __lsb = this->_M_val & 1;
                        const bool __rlsb = __r._M_val & 1;
                        *this >>= 1;
                        __r >>= 1;
                        this->_M_val = (2 * this->_M_val * __r._M_val + this->_M_val * __rlsb + __r._M_val * __lsb);
                        *this <<= 1;
                        *this += __rlsb * __lsb;
                    }
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator/=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r != 0))
                            __builtin_unreachable();
                    } while (false);
                    if (!this->_M_msb && !__r._M_msb)
                        this->_M_val /= __r._M_val;
                    else if (this->_M_msb && __r._M_msb) {
                        this->_M_val = (this->_M_val >= __r._M_val);
                        this->_M_msb = 0;
                    } else if (!this->_M_msb && __r._M_msb)
                        this->_M_val = 0;
                    else if (this->_M_msb && !__r._M_msb) {
                        const auto __orig = *this;
                        *this >>= 1;
                        this->_M_val /= __r._M_val;
                        *this <<= 1;
                        if (__orig - *this * __r >= __r)
                            ++this->_M_val;
                    }
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator%=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    if (!this->_M_msb && !__r._M_msb)
                        this->_M_val %= __r._M_val;
                    else
                        *this -= (*this / __r) * __r;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator<<=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r <= _S_rep_bits))
                            __builtin_unreachable();
                    } while (false);
                    if (__r != 0) {
                        this->_M_msb = (this->_M_val >> (_S_rep_bits - __r._M_val)) & 1;
                        if (__r._M_val == _S_rep_bits)
                            this->_M_val = 0;
                        else
                            this->_M_val <<= __r._M_val;
                    }
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator>>=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r <= _S_rep_bits))
                            __builtin_unreachable();
                    } while (false);
                    if (__r != 0) {
                        if (__r._M_val == _S_rep_bits)
                            this->_M_val = 0;
                        else
                            this->_M_val >>= __r._M_val;
                        if (this->_M_msb) {
                            this->_M_val |= std::ranges::__detail::__max_size_type::__rep(1) << (_S_rep_bits - __r._M_val);
                            this->_M_msb = 0;
                        }
                    }
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator&=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    this->_M_val &= __r._M_val;
                    this->_M_msb &= __r._M_msb;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator|=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    this->_M_val |= __r._M_val;
                    this->_M_msb |= __r._M_msb;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_size_type &operator^=(const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    this->_M_val ^= __r._M_val;
                    this->_M_msb ^= __r._M_msb;
                    return *this;
                }
                friend template <typename _Tp> constexpr _Tp &operator+=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a + __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator+=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator-=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a - __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator-=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator*=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a * __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator*=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator/=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a / __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator/=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator%=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a % __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator%=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator&=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a & __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator&=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator|=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a | __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator|=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator^=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a ^ __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator^=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator<<=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a << __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator<<=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator>>=(_Tp &__a, const std::ranges::__detail::__max_size_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a >> __b));
                }
                template<> constexpr std::ranges::__detail::__max_size_type &operator>>=<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type &__a, const std::ranges::__detail::__max_size_type &__b) noexcept;
                friend constexpr std::ranges::__detail::__max_size_type operator+(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l += __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator-(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l -= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator*(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l *= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator/(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l /= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator%(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l %= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator<<(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l <<= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator>>(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l >>= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator&(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l &= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator|(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l |= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_size_type operator^(std::ranges::__detail::__max_size_type __l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    __l ^= __r;
                    return __l;
                }
;
                friend constexpr bool operator==(const std::ranges::__detail::__max_size_type &__l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    return __l._M_val == __r._M_val && __l._M_msb == __r._M_msb;
                }
;
                friend constexpr std::strong_ordering operator<=>(const std::ranges::__detail::__max_size_type &__l, const std::ranges::__detail::__max_size_type &__r) noexcept                 {
                    if (__l._M_msb ^ __r._M_msb)
                        return __l._M_msb ? strong_ordering::greater : strong_ordering::less;
                    else
                        return __l._M_val <=> __r._M_val;
                }
;
                using __rep = unsigned __int128;
                static constexpr std::size_t _S_rep_bits = sizeof(std::ranges::__detail::__max_size_type::__rep) * 8;
            private:
                std::ranges::__detail::__max_size_type::__rep _M_val = 0;
                unsigned int _M_msb : 1 = 0;
                constexpr explicit __max_size_type(std::ranges::__detail::__max_size_type::__rep __val, int __msb) noexcept : _M_val(__val), _M_msb(__msb)                 {
                }
                friend  std::ranges::__detail::__max_diff_type;
                friend  std::numeric_limits<__max_size_type>;
                friend  std::numeric_limits<__max_diff_type>;
            };
            class __max_diff_type {
            public:
                __max_diff_type() = default
                template <typename _Tp> constexpr __max_diff_type(_Tp __i) noexcept : _M_rep(__i)                 {
                }
                template<> constexpr __max_diff_type<std::ranges::__detail::__max_size_type>(std::ranges::__detail::__max_size_type __i) noexcept                template<> constexpr __max_diff_type<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type __i) noexcept                template<> constexpr __max_diff_type<int>(int __i) noexcept : _M_rep(__i)                 {
                }
                constexpr explicit __max_diff_type(const std::ranges::__detail::__max_size_type &__d) noexcept : _M_rep(__d)                 {
                }
                template <typename _Tp> constexpr explicit operator _Tp() const noexcept                 {
                    return static_cast<_Tp>(this->_M_rep);
                }
                template<> constexpr explicit operator __max_size_type<std::ranges::__detail::__max_size_type>() const noexcept                constexpr explicit operator bool() const noexcept                 {
                    return this->_M_rep != 0;
                }
                constexpr std::ranges::__detail::__max_diff_type operator+() const noexcept                 {
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type operator-() const noexcept                 {
                    return std::ranges::__detail::__max_diff_type(- this->_M_rep);
                }
                constexpr std::ranges::__detail::__max_diff_type operator~() const noexcept                 {
                    return std::ranges::__detail::__max_diff_type(~ this->_M_rep);
                }
                constexpr std::ranges::__detail::__max_diff_type &operator++() noexcept                 {
                    return *this += 1;
                }
                constexpr std::ranges::__detail::__max_diff_type operator++(int) noexcept                 {
                    auto __tmp = *this;
                    ++ *this;
                    return __tmp;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator--() noexcept                 {
                    return *this -= 1;
                }
                constexpr std::ranges::__detail::__max_diff_type operator--(int) noexcept                 {
                    auto __tmp = *this;
                    -- *this;
                    return __tmp;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator+=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    this->_M_rep += __r._M_rep;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator-=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    this->_M_rep -= __r._M_rep;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator*=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    this->_M_rep *= __r._M_rep;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator/=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r != 0))
                            __builtin_unreachable();
                    } while (false);
                    const bool __neg = *this < 0;
                    const bool __rneg = __r < 0;
                    if (!__neg && !__rneg)
                        this->_M_rep = this->_M_rep / __r._M_rep;
                    else if (__neg && __rneg)
                        this->_M_rep = - this->_M_rep / - __r._M_rep;
                    else if (__neg && !__rneg)
                        this->_M_rep = - (- this->_M_rep / __r._M_rep);
                    else
                        this->_M_rep = - (this->_M_rep / - __r._M_rep);
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator%=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__r != 0))
                            __builtin_unreachable();
                    } while (false);
                    if (*this >= 0 && __r > 0)
                        this->_M_rep %= __r._M_rep;
                    else
                        *this -= (*this / __r) * __r;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator<<=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    this->_M_rep.operator<<=(__r._M_rep);
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator>>=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    const auto __msb = this->_M_rep._M_msb;
                    this->_M_rep >>= __r._M_rep;
                    this->_M_rep._M_msb |= __msb;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator&=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    this->_M_rep &= __r._M_rep;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator|=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    this->_M_rep |= __r._M_rep;
                    return *this;
                }
                constexpr std::ranges::__detail::__max_diff_type &operator^=(const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    this->_M_rep ^= __r._M_rep;
                    return *this;
                }
                friend template <typename _Tp> constexpr _Tp &operator+=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a + __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator+=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator-=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a - __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator-=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator*=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a * __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator*=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator/=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a / __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator/=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator%=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a % __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator%=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator&=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a & __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator&=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator|=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a | __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator|=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator^=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a ^ __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator^=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator<<=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a << __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator<<=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend template <typename _Tp> constexpr _Tp &operator>>=(_Tp &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept                 {
                    return (__a = static_cast<_Tp>(__a >> __b));
                }
                template<> constexpr std::ranges::__detail::__max_diff_type &operator>>=<std::ranges::__detail::__max_diff_type>(std::ranges::__detail::__max_diff_type &__a, const std::ranges::__detail::__max_diff_type &__b) noexcept;
                friend constexpr std::ranges::__detail::__max_diff_type operator+(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l += __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator-(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l -= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator*(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l *= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator/(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l /= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator%(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l %= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator<<(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l <<= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator>>(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l >>= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator&(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l &= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator|(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l |= __r;
                    return __l;
                }
;
                friend constexpr std::ranges::__detail::__max_diff_type operator^(std::ranges::__detail::__max_diff_type __l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    __l ^= __r;
                    return __l;
                }
;
                friend constexpr bool operator==(const std::ranges::__detail::__max_diff_type &__l, const std::ranges::__detail::__max_diff_type &__r) noexcept                 {
                    return __l._M_rep == __r._M_rep;
                }
;
                constexpr std::strong_ordering operator<=>(const std::ranges::__detail::__max_diff_type &__r) const noexcept                 {
                    const auto __lsign = this->_M_rep._M_msb;
                    const auto __rsign = __r._M_rep._M_msb;
                    if (__lsign ^ __rsign)
                        return __lsign ? strong_ordering::less : strong_ordering::greater;
                    else
                        return this->_M_rep <=> __r._M_rep;
                }
            private:
                std::ranges::__detail::__max_size_type _M_rep = 0;
                friend  class __max_size_type;
            };
            constexpr explicit __max_size_type::__max_size_type(const std::ranges::__detail::__max_diff_type &__d) noexcept : NULL TYPE(__d._M_rep)             {
            }
        }
    }
    template<> struct numeric_limits<ranges::__detail::__max_size_type> {
        using _Sp = ranges::__detail::__max_size_type;
        static constexpr bool is_specialized = true;
        static constexpr bool is_signed = false;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int digits = __gnu_cxx::__int_traits<_Sp::__rep>::__digits + 1;
        static constexpr int digits10 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);
        static constexpr std::numeric_limits<std::ranges::__detail::__max_size_type>::_Sp min() noexcept         {
            return 0;
        }
        static constexpr std::numeric_limits<std::ranges::__detail::__max_size_type>::_Sp max() noexcept         {
            return std::numeric_limits<std::ranges::__detail::__max_size_type>::_Sp(static_cast<_Sp::__rep>(-1), 1);
        }
        static constexpr std::numeric_limits<std::ranges::__detail::__max_size_type>::_Sp lowest() noexcept         {
            return min();
        }
    };
    template<> struct numeric_limits<ranges::__detail::__max_diff_type> {
        using _Dp = ranges::__detail::__max_diff_type;
        using _Sp = ranges::__detail::__max_size_type;
        static constexpr bool is_specialized = true;
        static constexpr bool is_signed = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_exact = true;
        static constexpr int digits = numeric_limits<_Sp>::digits - 1;
        static constexpr int digits10 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);
        static constexpr std::numeric_limits<std::ranges::__detail::__max_diff_type>::_Dp min() noexcept         {
            return std::numeric_limits<std::ranges::__detail::__max_diff_type>::_Dp(std::numeric_limits<std::ranges::__detail::__max_diff_type>::_Sp(0, 1));
        }
        static constexpr std::numeric_limits<std::ranges::__detail::__max_diff_type>::_Dp max() noexcept         {
            return std::numeric_limits<std::ranges::__detail::__max_diff_type>::_Dp(std::numeric_limits<std::ranges::__detail::__max_diff_type>::_Sp(static_cast<_Sp::__rep>(-1), 0));
        }
        static constexpr std::numeric_limits<std::ranges::__detail::__max_diff_type>::_Dp lowest() noexcept         {
            return min();
        }
    };
}
namespace std {
    namespace ranges {
        template <typename> constexpr bool disable_sized_range = false;
        template <typename _Tp> constexpr bool enable_borrowed_range = false;
        namespace __detail {
            constexpr std::ranges::__detail::__max_size_type __to_unsigned_like(std::ranges::__detail::__max_size_type __t) noexcept             {
                return __t;
            }
            constexpr std::ranges::__detail::__max_size_type __to_unsigned_like(std::ranges::__detail::__max_diff_type __t) noexcept             {
                return std::ranges::__detail::__max_size_type(__t);
            }
            template <integral _Tp> constexpr auto __to_unsigned_like(_Tp __t) noexcept             {
                return static_cast<make_unsigned_t<_Tp>>(__t);
            }
            constexpr unsigned __int128 __to_unsigned_like(__int128 __t) noexcept             {
                return __t;
            }
            constexpr unsigned __int128 __to_unsigned_like(unsigned __int128 __t) noexcept             {
                return __t;
            }
            template <typename _Tp> using __make_unsigned_like_t = decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));
            template <typename _Tp> concept __maybe_borrowed_range = is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;;
        }
        namespace __cust_access {
            using std::ranges::__detail::__maybe_borrowed_range;
            using std::__detail::__range_iter_t;
            struct _Begin {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (is_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_begin<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().begin()));
                    else
                        return noexcept(__decay_copy(begin(std::declval<_Tp &>())));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]]                 {
                    if (is_array_v<remove_reference_t<_Tp>>) {
                        static_assert(is_lvalue_reference_v<_Tp>);
                        return __t + 0;
                    } else if (__member_begin<_Tp>)
                        return __t.begin();
                    else
                        return begin(__t);
                }
            };
            template <typename _Tp> concept __member_end = requires (_Tp &__t) { { __decay_copy(__t.end()) } -> sentinel_for<__range_iter_t<_Tp>>; };;
            template <> void end(auto &) = delete
            template <> void end(const auto &) = delete
            template <typename _Tp> concept __adl_end = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(end(__t)) } -> sentinel_for<__range_iter_t<_Tp>>; };;
            struct _End {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_end<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().end()));
                    else
                        return noexcept(__decay_copy(end(std::declval<_Tp &>())));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]]                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>) {
                        static_assert(is_lvalue_reference_v<_Tp>);
                        return __t + extent_v<remove_reference_t<_Tp>>;
                    } else if (__member_end<_Tp>)
                        return __t.end();
                    else
                        return end(__t);
                }
            };
            template <typename _To, typename _Tp> constexpr decltype(auto) __as_const(_Tp &__t) noexcept             {
                static_assert(std::is_same_v<_To &, _Tp &>);
                if (is_lvalue_reference_v<_To>)
                    return const_cast<const _Tp &>(__t);
                else
                    return static_cast<const _Tp &&>(__t);
            }
            struct _CBegin {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Begin{}(__cust_access::__as_const<_Tp>(__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Begin{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { std::ranges::__cust_access::_Begin{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]]                 {
                    return std::ranges::__cust_access::_Begin{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            struct final _CEnd {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_End{}(__cust_access::__as_const<_Tp>(__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_End{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { std::ranges::__cust_access::_End{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]]                 {
                    return std::ranges::__cust_access::_End{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            template <typename _Tp> concept __member_rbegin = requires (_Tp &__t) { { __decay_copy(__t.rbegin()) } -> input_or_output_iterator; };;
            template <> void rbegin(auto &) = delete
            template <> void rbegin(const auto &) = delete
            template <typename _Tp> concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(rbegin(__t)) } -> input_or_output_iterator; };;
            template <typename _Tp> concept __reversable = requires (_Tp &__t) { { std::ranges::__cust_access::_Begin{}(__t) } -> bidirectional_iterator; { std::ranges::__cust_access::_End{}(__t) } -> same_as<decltype(std::ranges::__cust_access::_Begin{}(__t))>; };;
            struct _RBegin {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_rbegin<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().rbegin()));
                    else if (__adl_rbegin<_Tp>)
                        return noexcept(__decay_copy(rbegin(std::declval<_Tp &>())));
                    else {
                        if (noexcept(std::ranges::__cust_access::_End{}(std::declval<_Tp &>()))) {
                            using _It = decltype(std::ranges::__cust_access::_End{}(std::declval<_Tp &>()));
                            return is_nothrow_copy_constructible_v<_It>;
                        } else
                            return false;
                    }
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]]                 {
                    if (__member_rbegin<_Tp>)
                        return __t.rbegin();
                    else if (__adl_rbegin<_Tp>)
                        return rbegin(__t);
                    else
                        return std::make_reverse_iterator(std::ranges::__cust_access::_End{}(__t));
                }
            };
            template <typename _Tp> concept __member_rend = requires (_Tp &__t) { { __decay_copy(__t.rend()) } -> sentinel_for<decltype(std::ranges::__cust_access::_RBegin{}(std::forward<_Tp>(__t)))>; };;
            template <> void rend(auto &) = delete
            template <> void rend(const auto &) = delete
            template <typename _Tp> concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(rend(__t)) } -> sentinel_for<decltype(std::ranges::__cust_access::_RBegin{}(std::forward<_Tp>(__t)))>; };;
            struct _REnd {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_rend<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().rend()));
                    else if (__adl_rend<_Tp>)
                        return noexcept(__decay_copy(rend(std::declval<_Tp &>())));
                    else {
                        if (noexcept(std::ranges::__cust_access::_Begin{}(std::declval<_Tp &>()))) {
                            using _It = decltype(std::ranges::__cust_access::_Begin{}(std::declval<_Tp &>()));
                            return is_nothrow_copy_constructible_v<_It>;
                        } else
                            return false;
                    }
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]]                 {
                    if (__member_rend<_Tp>)
                        return __t.rend();
                    else if (__adl_rend<_Tp>)
                        return rend(__t);
                    else
                        return std::make_reverse_iterator(std::ranges::__cust_access::_Begin{}(__t));
                }
            };
            struct _CRBegin {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const<_Tp>(__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]]                 {
                    return std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            struct _CREnd {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_REnd{}(__cust_access::__as_const<_Tp>(__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_REnd{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { std::ranges::__cust_access::_REnd{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]]                 {
                    return std::ranges::__cust_access::_REnd{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
            template <typename _Tp> concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(__t.size()) } -> __detail::__is_integer_like; };;
            template <> void size(auto &) = delete
            template <> void size(const auto &) = delete
            template <typename _Tp> concept __adl_size = __class_or_enum<remove_reference_t<_Tp>> && !disable_sized_range<remove_cvref_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(size(__t)) } -> __detail::__is_integer_like; };;
            template <typename _Tp> concept __sentinel_size = requires (_Tp &__t) { requires (!is_unbounded_array_v<remove_reference_t<_Tp>>); { std::ranges::__cust_access::_Begin{}(__t) } -> forward_iterator; { std::ranges::__cust_access::_End{}(__t) } -> sized_sentinel_for<decltype(std::ranges::__cust_access::_Begin{}(__t))>; __detail::__to_unsigned_like(std::ranges::__cust_access::_End{}(__t) - std::ranges::__cust_access::_Begin{}(__t)); };;
            struct _Size {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_size<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().size()));
                    else if (__adl_size<_Tp>)
                        return noexcept(__decay_copy(size(std::declval<_Tp &>())));
                    else if (__sentinel_size<_Tp>)
                        return noexcept(std::ranges::__cust_access::_End{}(std::declval<_Tp &>()) - std::ranges::__cust_access::_Begin{}(std::declval<_Tp &>()));
                }
            public:
                template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]]                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return extent_v<remove_reference_t<_Tp>>;
                    else if (__member_size<_Tp>)
                        return __t.size();
                    else if (__adl_size<_Tp>)
                        return size(__t);
                    else if (__sentinel_size<_Tp>)
                        return __detail::__to_unsigned_like(std::ranges::__cust_access::_End{}(__t) - std::ranges::__cust_access::_Begin{}(__t));
                }
            };
            struct _SSize {
                template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(std::ranges::__cust_access::_Size{}(__t))operator()(_Tp &&__t) const noexcept(noexcept(std::ranges::__cust_access::_Size{}(__t))) [[nodiscard("")]]                 {
                    auto __size = std::ranges::__cust_access::_Size{}(__t);
                    using __size_type = decltype(__size);
                    if (integral<__size_type>) {
                        using __gnu_cxx::__int_traits;
                        if (__int_traits<__size_type>::__digits < __int_traits<ptrdiff_t>::__digits)
                            return static_cast<std::ptrdiff_t>(__size);
                        else
                            return static_cast<make_signed_t<__size_type>>(__size);
                    } else if (__detail::__is_int128<__size_type>)
                        return static_cast<__int128>(__size);
                    else
                        return __detail::__max_diff_type(__size);
                }
            };
            template <typename _Tp> concept __member_empty = requires (_Tp &__t) { bool(__t.empty()); };;
            template <typename _Tp> concept __size0_empty = requires (_Tp &__t) { std::ranges::__cust_access::_Size{}(__t) == 0; };;
            template <typename _Tp> concept __eq_iter_empty = requires (_Tp &__t) { requires (!is_unbounded_array_v<remove_reference_t<_Tp>>); { std::ranges::__cust_access::_Begin{}(__t) } -> forward_iterator; bool(std::ranges::__cust_access::_Begin{}(__t) == std::ranges::__cust_access::_End{}(__t)); };;
            struct _Empty {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_empty<_Tp>)
                        return noexcept(bool(std::declval<_Tp &>().empty()));
                    else if (__size0_empty<_Tp>)
                        return noexcept(std::ranges::__cust_access::_Size{}(std::declval<_Tp &>()) == 0);
                    else
                        return noexcept(bool(std::ranges::__cust_access::_Begin{}(std::declval<_Tp &>()) == std::ranges::__cust_access::_End{}(std::declval<_Tp &>())));
                }
            public:
                template <typename _Tp> constexpr bool operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp &>()) [[nodiscard("")]]                 {
                    if (__member_empty<_Tp>)
                        return bool(__t.empty());
                    else if (__size0_empty<_Tp>)
                        return std::ranges::__cust_access::_Size{}(__t) == 0;
                    else
                        return bool(std::ranges::__cust_access::_Begin{}(__t) == std::ranges::__cust_access::_End{}(__t));
                }
            };
            template <typename _Tp> concept __pointer_to_object = is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;;
            template <typename _Tp> concept __member_data = requires (_Tp &__t) { { __decay_copy(__t.data()) } -> __pointer_to_object; };;
            template <typename _Tp> concept __begin_data = contiguous_iterator<__range_iter_t<_Tp>>;;
            struct _Data {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_data<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().data()));
                    else
                        return noexcept(std::ranges::__cust_access::_Begin{}(std::declval<_Tp &>()));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>()) [[nodiscard("")]]                 {
                    if (__member_data<_Tp>)
                        return __t.data();
                    else
                        return std::to_address(std::ranges::__cust_access::_Begin{}(__t));
                }
            };
            struct _CData {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Data{}(__cust_access::__as_const<_Tp>(__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Data{}(__cust_access::__as_const<_Tp>(__e)))) requires requires { std::ranges::__cust_access::_Data{}(__cust_access::__as_const<_Tp>(__e)); } [[nodiscard("")]]                 {
                    return std::ranges::__cust_access::_Data{}(__cust_access::__as_const<_Tp>(__e));
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_access::_Begin begin{};
            constexpr __cust_access::_End end{};
            constexpr __cust_access::_CBegin cbegin{};
            constexpr __cust_access::_CEnd cend{};
            constexpr __cust_access::_RBegin rbegin{};
            constexpr __cust_access::_REnd rend{};
            constexpr __cust_access::_CRBegin crbegin{};
            constexpr __cust_access::_CREnd crend{};
            constexpr __cust_access::_Size size{};
            constexpr __cust_access::_SSize ssize{};
            constexpr __cust_access::_Empty empty{};
            constexpr __cust_access::_Data data{};
            constexpr __cust_access::_CData cdata{};
        }
        template <typename _Tp> concept range = requires (_Tp &__t) { ranges::begin(__t); ranges::end(__t); };;
        template <typename _Tp> concept borrowed_range = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;;
        template <typename _Tp> using iterator_t = std::__detail::__range_iter_t<_Tp>;
        template <range _Range> using sentinel_t = decltype(ranges::end(std::declval<_Range &>()));
        template <range _Range> using range_difference_t = iter_difference_t<iterator_t<_Range>>;
        template <range _Range> using range_value_t = iter_value_t<iterator_t<_Range>>;
        template <range _Range> using range_reference_t = iter_reference_t<iterator_t<_Range>>;
        template <range _Range> using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Range>>;
        template <typename _Tp> concept sized_range = range<_Tp> && requires (_Tp &__t) { ranges::size(__t); };;
        template <sized_range _Range> using range_size_t = decltype(ranges::size(std::declval<_Range &>()));
        template <typename _Derived> class view_interface;
        namespace __detail {
            template <typename _Tp, typename _Up> void __is_derived_from_view_interface_fn(const _Tp &, const view_interface<_Up> &);
            template <typename _Tp> concept __is_derived_from_view_interface = requires (_Tp __t) { __is_derived_from_view_interface_fn(__t, __t); };;
        }
        struct view_base {
        };
        template <typename _Tp> constexpr bool enable_view = derived_from<_Tp, std::ranges::view_base> || __detail::__is_derived_from_view_interface<_Tp>;
        template <typename _Tp> concept view = range<_Tp> && movable<_Tp> && enable_view<_Tp>;;
        template <typename _Range, typename _Tp> concept output_range = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;;
        template <typename _Tp> concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires (_Tp &__t) { { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>; };;
        template <typename _Tp> concept common_range = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;;
        namespace __detail {
            template <typename _Tp> constexpr bool __is_initializer_list = false;
            constexpr bool __is_initializer_list = true;
        }
        template <typename _Tp> concept viewable_range = range<_Tp> && ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>) || (!view<remove_cvref_t<_Tp>> && (is_lvalue_reference_v<_Tp> || (movable<remove_reference_t<_Tp>> && !__detail::__is_initializer_list<remove_cvref_t<_Tp>>))));;
        struct final __advance_fn {
            template <input_or_output_iterator _It> constexpr void operator()(_It &__it, iter_difference_t<_It> __n) const             {
                if (random_access_iterator<_It>)
                    __it += __n;
                else if (bidirectional_iterator<_It>) {
                    if (__n > 0) {
                        do {
                            ++__it;
                        } while (--__n);
                    } else if (__n < 0) {
                        do {
                            --__it;
                        } while (++__n);
                    }
                } else {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__n >= 0))
                            __builtin_unreachable();
                    } while (false);
                    while (__n-- > 0)
                        ++__it;
                }
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr void operator()(_It &__it, _Sent __bound) const             {
                if (assignable_from<_It &, _Sent>)
                    __it = std::move(__bound);
                else if (sized_sentinel_for<_Sent, _It>)
                    (*this)(__it, __bound - __it);
                else {
                    while (__it != __bound)
                        ++__it;
                }
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> operator()(_It &__it, iter_difference_t<_It> __n, _Sent __bound) const             {
                if (sized_sentinel_for<_Sent, _It>) {
                    const auto __diff = __bound - __it;
                    if (__diff == 0)
                        return __n;
                    else if (__diff > 0 ? __n >= __diff : __n <= __diff) {
                        (*this)(__it, __bound);
                        return __n - __diff;
                    } else if (__n != 0) {
                        do {
                            if (std::__is_constant_evaluated() && !bool(__n < 0 == __diff < 0))
                                __builtin_unreachable();
                        } while (false);
                        (*this)(__it, __n);
                        return 0;
                    } else
                        return 0;
                } else if (__it == __bound || __n == 0)
                    return __n;
                else if (__n > 0) {
                    iter_difference_t<_It> __m = 0;
                    do {
                        ++__it;
                        ++__m;
                    } while (__m != __n && __it != __bound);
                    return __n - __m;
                } else if (bidirectional_iterator<_It> && same_as<_It, _Sent>) {
                    iter_difference_t<_It> __m = 0;
                    do {
                        --__it;
                        --__m;
                    } while (__m != __n && __it != __bound);
                    return __n - __m;
                } else {
                    do {
                        if (std::__is_constant_evaluated() && !bool(__n >= 0))
                            __builtin_unreachable();
                    } while (false);
                    return __n;
                }
            }
            void operator&() const = delete
        };
        constexpr std::ranges::__advance_fn advance{};
        struct final __distance_fn {
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> operator()(_It __first, _Sent __last) const [[nodiscard("")]]             {
                iter_difference_t<_It> __n = 0;
                while (__first != __last)
                    {
                        ++__first;
                        ++__n;
                    }
                return __n;
            }
            template <input_or_output_iterator _It, sized_sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> operator()(const _It &__first, const _Sent &__last) const [[nodiscard("")]]             {
                return __last - __first;
            }
            template <range _Range> constexpr range_difference_t<_Range> operator()(_Range &&__r) const [[nodiscard("")]]             {
                if (sized_range<_Range>)
                    return static_cast<range_difference_t<_Range>>(ranges::size(__r));
                else
                    return (*this)(ranges::begin(__r), ranges::end(__r));
            }
            void operator&() const = delete
        };
        constexpr std::ranges::__distance_fn distance{};
        struct final __next_fn {
            template <input_or_output_iterator _It> constexpr _It operator()(_It __x) const [[nodiscard("")]]             {
                ++__x;
                return __x;
            }
            template <input_or_output_iterator _It> constexpr _It operator()(_It __x, iter_difference_t<_It> __n) const [[nodiscard("")]]             {
                ranges::advance(__x, __n);
                return __x;
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr _It operator()(_It __x, _Sent __bound) const [[nodiscard("")]]             {
                ranges::advance(__x, __bound);
                return __x;
            }
            template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr _It operator()(_It __x, iter_difference_t<_It> __n, _Sent __bound) const [[nodiscard("")]]             {
                ranges::advance(__x, __n, __bound);
                return __x;
            }
            void operator&() const = delete
        };
        constexpr std::ranges::__next_fn next{};
        struct final __prev_fn {
            template <bidirectional_iterator _It> constexpr _It operator()(_It __x) const [[nodiscard("")]]             {
                --__x;
                return __x;
            }
            template <bidirectional_iterator _It> constexpr _It operator()(_It __x, iter_difference_t<_It> __n) const [[nodiscard("")]]             {
                ranges::advance(__x, - __n);
                return __x;
            }
            template <bidirectional_iterator _It> constexpr _It operator()(_It __x, iter_difference_t<_It> __n, _It __bound) const [[nodiscard("")]]             {
                ranges::advance(__x, - __n, __bound);
                return __x;
            }
            void operator&() const = delete
        };
        constexpr std::ranges::__prev_fn prev{};
        struct dangling {
            dangling() noexcept = default
            template <typename ..._Args> constexpr dangling(_Args &&...) noexcept             {
            }
        };
        template <range _Range> using borrowed_iterator_t = __conditional_t<borrowed_range<_Range>, iterator_t<_Range>, std::ranges::dangling>;
    }
}
namespace std {
    constexpr std::size_t __sv_check(std::size_t __size, std::size_t __pos, const char *__s)     {
        if (__pos > __size)
            __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size (which is %zu)"), __s, __pos, __size);
        return __pos;
    }
    constexpr std::size_t __sv_limit(std::size_t __size, std::size_t __pos, std::size_t __off) noexcept     {
        const bool __testoff = __off < __size - __pos;
        return __testoff ? __off : __size - __pos;
    }
    template <typename _CharT, typename _Traits = std::char_traits<_CharT>> class basic_string_view {
        static_assert(!is_array_v<_CharT>);
        static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
        static_assert(is_same_v<_CharT, typename _Traits::char_type>);
    public:
        using traits_type = _Traits;
        using value_type = _CharT;
        using pointer = std::basic_string_view::value_type *;
        using const_pointer = const std::basic_string_view::value_type *;
        using reference = std::basic_string_view::value_type &;
        using const_reference = const std::basic_string_view::value_type &;
        using const_iterator = const std::basic_string_view::value_type *;
        using iterator = std::basic_string_view::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos = std::basic_string_view::size_type(-1);
        constexpr basic_string_view<_CharT, _Traits>() noexcept : _M_len({0}), _M_str({nullptr})         {
        }
        basic_string_view<_CharT, _Traits>(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str) noexcept : _M_len({traits_type::length(__str)}), _M_str({__str}) __attribute__((nonnull()))         {
        }
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view<_CharT, _Traits>(_It __first, _End __last) noexcept(noexcept(__last - __first)basic_string_view<_CharT, _Traits>(_It __first, _End __last) noexcept(noexcept(__last - __first)) : _M_len(__last - __first), _M_str(std::to_address(__first))         {
        }
        basic_string_view<_CharT, _Traits> &operator=(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr std::basic_string_view::const_iterator begin() const noexcept         {
            return this->_M_str;
        }
        constexpr std::basic_string_view::const_iterator end() const noexcept         {
            return this->_M_str + this->_M_len;
        }
        constexpr std::basic_string_view::const_iterator cbegin() const noexcept         {
            return this->_M_str;
        }
        constexpr std::basic_string_view::const_iterator cend() const noexcept         {
            return this->_M_str + this->_M_len;
        }
        constexpr std::basic_string_view::const_reverse_iterator rbegin() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->end());
        }
        constexpr std::basic_string_view::const_reverse_iterator rend() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->begin());
        }
        constexpr std::basic_string_view::const_reverse_iterator crbegin() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->end());
        }
        constexpr std::basic_string_view::const_reverse_iterator crend() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->begin());
        }
        constexpr std::basic_string_view::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept         {
            return (npos - sizeof(std::basic_string_view::size_type) - sizeof(void *)) / sizeof(std::basic_string_view::value_type) / 4;
        }
        constexpr bool empty() const noexcept [[nodiscard("")]]         {
            return this->_M_len == 0;
        }
        constexpr std::basic_string_view::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept         {
            do {
                if (std::__is_constant_evaluated() && !bool(__pos < this->_M_len))
                    __builtin_unreachable();
            } while (false);
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view::const_reference at(std::basic_string_view::size_type __pos) const         {
            if (__pos >= this->_M_len)
                __throw_out_of_range_fmt(("basic_string_view::at: __pos (which is %zu) >= this->size() (which is %zu)"), __pos, this->size());
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view::const_reference front() const noexcept         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
                    __builtin_unreachable();
            } while (false);
            return *this->_M_str;
        }
        constexpr std::basic_string_view::const_reference back() const noexcept         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
                    __builtin_unreachable();
            } while (false);
            return *(this->_M_str + this->_M_len - 1);
        }
        constexpr std::basic_string_view::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept         {
            do {
                if (std::__is_constant_evaluated() && !bool(this->_M_len >= __n))
                    __builtin_unreachable();
            } while (false);
            this->_M_str += __n;
            this->_M_len -= __n;
        }
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept         {
            this->_M_len -= __n;
        }
        constexpr void swap(basic_string_view<_CharT, _Traits> &__sv) noexcept         {
            auto __tmp = *this;
            *this = __sv;
            __sv = __tmp;
        }
        constexpr std::basic_string_view::size_type copy(_CharT *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos = 0) const         {
            ;
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::copy");
            const std::basic_string_view::size_type __rlen = std::min(__n, this->_M_len - __pos);
            traits_type::copy(__str, this->data() + __pos, __rlen);
            return __rlen;
        }
        constexpr basic_string_view<_CharT, _Traits> substr(std::basic_string_view::size_type __pos = 0, std::basic_string_view::size_type __n = npos) const noexcept(falsesubstr(std::basic_string_view::size_type __pos = 0, std::basic_string_view::size_type __n = npos) const noexcept(false)         {
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::substr");
            const std::basic_string_view::size_type __rlen = std::min(__n, this->_M_len - __pos);
            return basic_string_view<_CharT, _Traits>({this->_M_str + __pos, __rlen});
        }
        constexpr int compare(basic_string_view<_CharT, _Traits> __str) const noexcept         {
            const std::basic_string_view::size_type __rlen = std::min(this->_M_len, __str._M_len);
            int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
            if (__ret == 0)
                __ret = _S_compare(this->_M_len, __str._M_len);
            return __ret;
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __str) const         {
            return this->substr(__pos1, __n1).compare(__str);
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const         {
            return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
        }
        constexpr int compare(const _CharT *__str) const noexcept __attribute__((nonnull()))         {
            return this->compare(basic_string_view<_CharT, _Traits>({__str}));
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str) const __attribute__((nonnull()))         {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>({__str}));
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str, std::basic_string_view::size_type __n2) const noexcept(falsecompare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str, std::basic_string_view::size_type __n2) const noexcept(false)         {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>(__str, __n2));
        }
        constexpr bool starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept         {
            return this->substr(0, __x.size()) == __x;
        }
        constexpr bool starts_with(_CharT __x) const noexcept         {
            return !this->empty() && traits_type::eq(this->front(), __x);
        }
        constexpr bool starts_with(const _CharT *__x) const noexcept         {
            return this->starts_with(basic_string_view<_CharT, _Traits>(__x));
        }
        constexpr bool ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept         {
            const auto __len = this->size();
            const auto __xlen = __x.size();
            return __len >= __xlen && traits_type::compare(this->end() - __xlen, __x.data(), __xlen) == 0;
        }
        constexpr bool ends_with(_CharT __x) const noexcept         {
            return !this->empty() && traits_type::eq(this->back(), __x);
        }
        constexpr bool ends_with(const _CharT *__x) const noexcept         {
            return this->ends_with(basic_string_view<_CharT, _Traits>(__x));
        }
        constexpr std::basic_string_view::size_type find(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept;
        constexpr std::basic_string_view::size_type find(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type rfind(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->rfind(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type rfind(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept;
        constexpr std::basic_string_view::size_type rfind(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type rfind(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->rfind(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_first_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find_first_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_first_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find(__c, __pos);
        }
        constexpr std::basic_string_view::size_type find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find_first_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_last_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->find_last_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_last_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->rfind(__c, __pos);
        }
        constexpr std::basic_string_view::size_type find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->find_last_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_first_not_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find_first_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_first_not_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept;
        constexpr std::basic_string_view::size_type find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find_first_not_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_last_not_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->find_last_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_last_not_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept;
        constexpr std::basic_string_view::size_type find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->find_last_not_of(__str, __pos, traits_type::length(__str));
        }
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept         {
            using __limits = __gnu_cxx::__int_traits<int>;
            const std::basic_string_view::difference_type __diff = __n1 - __n2;
            if (__diff > __limits::__max)
                return __limits::__max;
            if (__diff < __limits::__min)
                return __limits::__min;
            return static_cast<int>(__diff);
        }
        std::size_t _M_len;
        const _CharT *_M_str;
    };
template<> class basic_string_view<char, std::char_traits<char>> {
        static_assert(!is_array_v<char>);
        static_assert(is_trivial_v<char> && is_standard_layout_v<char>);
        static_assert(is_same_v<char, typename char_traits<char>::char_type>);
    public:
        using traits_type = std::char_traits<char>;
        using value_type = char;
        using pointer = std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using const_pointer = const std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using reference = std::basic_string_view<char, std::char_traits<char>>::value_type &;
        using const_reference = const std::basic_string_view<char, std::char_traits<char>>::value_type &;
        using const_iterator = const std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using iterator = std::basic_string_view<char, std::char_traits<char>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char, std::char_traits<char>> &) noexcept = default
        constexpr basic_string_view(const char *__str) noexcept : _M_len({traits_type::length(__str)}), _M_str({__str}) __attribute__((nonnull()))         {
        }
        constexpr basic_string_view(const char *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char *, unsigned long>(const char *__first, unsigned long __last);
        std::basic_string_view<char, std::char_traits<char>> &operator=(const std::basic_string_view<char, std::char_traits<char>> &) noexcept = default
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept         {
            do {
                if (std::__is_constant_evaluated() && !bool(__pos < this->_M_len))
                    __builtin_unreachable();
            } while (false);
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char, std::char_traits<char>> &__sv) noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type copy(char *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char, std::char_traits<char>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char, std::char_traits<char>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char, std::char_traits<char>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char, std::char_traits<char>> __x) const noexcept;
        constexpr bool starts_with(char __x) const noexcept;
        constexpr bool starts_with(const char *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char, std::char_traits<char>> __x) const noexcept;
        constexpr bool ends_with(char __x) const noexcept;
        constexpr bool ends_with(const char *__x) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char *_M_str;
    };
template<> class basic_string_view<wchar_t, std::char_traits<wchar_t>> {
        static_assert(!is_array_v<wchar_t>);
        static_assert(is_trivial_v<wchar_t> && is_standard_layout_v<wchar_t>);
        static_assert(is_same_v<wchar_t, typename char_traits<wchar_t>::char_type>);
    public:
        using traits_type = std::char_traits<wchar_t>;
        using value_type = wchar_t;
        using pointer = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using const_pointer = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using reference = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type &;
        using const_reference = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type &;
        using const_iterator = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using iterator = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &) noexcept = default
        constexpr basic_string_view(const wchar_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const wchar_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const wchar_t *, unsigned long>(const wchar_t *__first, unsigned long __last);
        std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &operator=(const std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &) noexcept = default
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &__sv) noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type copy(wchar_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const wchar_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const wchar_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const wchar_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
        constexpr bool starts_with(wchar_t __x) const noexcept;
        constexpr bool starts_with(const wchar_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
        constexpr bool ends_with(wchar_t __x) const noexcept;
        constexpr bool ends_with(const wchar_t *__x) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const wchar_t *_M_str;
    };
template<> class basic_string_view<char8_t, std::char_traits<char8_t>> {
        static_assert(!is_array_v<char8_t>);
        static_assert(is_trivial_v<char8_t> && is_standard_layout_v<char8_t>);
        static_assert(is_same_v<char8_t, typename char_traits<char8_t>::char_type>);
    public:
        using traits_type = std::char_traits<char8_t>;
        using value_type = char8_t;
        using pointer = std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type *;
        using reference = std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type &;
        using const_reference = const std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type *;
        using iterator = std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char8_t, std::char_traits<char8_t>> &) noexcept = default
        constexpr basic_string_view(const char8_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char8_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char8_t *, unsigned long>(const char8_t *__first, unsigned long __last);
        std::basic_string_view<char8_t, std::char_traits<char8_t>> &operator=(const std::basic_string_view<char8_t, std::char_traits<char8_t>> &) noexcept = default
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char8_t, std::char_traits<char8_t>> &__sv) noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type copy(char8_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char8_t, std::char_traits<char8_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char8_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char8_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char8_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
        constexpr bool starts_with(char8_t __x) const noexcept;
        constexpr bool starts_with(const char8_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
        constexpr bool ends_with(char8_t __x) const noexcept;
        constexpr bool ends_with(const char8_t *__x) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char8_t *_M_str;
    };
template<> class basic_string_view<char16_t, std::char_traits<char16_t>> {
        static_assert(!is_array_v<char16_t>);
        static_assert(is_trivial_v<char16_t> && is_standard_layout_v<char16_t>);
        static_assert(is_same_v<char16_t, typename char_traits<char16_t>::char_type>);
    public:
        using traits_type = std::char_traits<char16_t>;
        using value_type = char16_t;
        using pointer = std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using reference = std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type &;
        using const_reference = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using iterator = std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char16_t, std::char_traits<char16_t>> &) noexcept = default
        constexpr basic_string_view(const char16_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char16_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char16_t *, unsigned long>(const char16_t *__first, unsigned long __last);
        std::basic_string_view<char16_t, std::char_traits<char16_t>> &operator=(const std::basic_string_view<char16_t, std::char_traits<char16_t>> &) noexcept = default
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char16_t, std::char_traits<char16_t>> &__sv) noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type copy(char16_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char16_t, std::char_traits<char16_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char16_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char16_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char16_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
        constexpr bool starts_with(char16_t __x) const noexcept;
        constexpr bool starts_with(const char16_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
        constexpr bool ends_with(char16_t __x) const noexcept;
        constexpr bool ends_with(const char16_t *__x) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char16_t *_M_str;
    };
template<> class basic_string_view<char32_t, std::char_traits<char32_t>> {
        static_assert(!is_array_v<char32_t>);
        static_assert(is_trivial_v<char32_t> && is_standard_layout_v<char32_t>);
        static_assert(is_same_v<char32_t, typename char_traits<char32_t>::char_type>);
    public:
        using traits_type = std::char_traits<char32_t>;
        using value_type = char32_t;
        using pointer = std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using reference = std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type &;
        using const_reference = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using iterator = std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char32_t, std::char_traits<char32_t>> &) noexcept = default
        constexpr basic_string_view(const char32_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char32_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char32_t *, unsigned long>(const char32_t *__first, unsigned long __last);
        std::basic_string_view<char32_t, std::char_traits<char32_t>> &operator=(const std::basic_string_view<char32_t, std::char_traits<char32_t>> &) noexcept = default
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char32_t, std::char_traits<char32_t>> &__sv) noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type copy(char32_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char32_t, std::char_traits<char32_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char32_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char32_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char32_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
        constexpr bool starts_with(char32_t __x) const noexcept;
        constexpr bool starts_with(const char32_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
        constexpr bool ends_with(char32_t __x) const noexcept;
        constexpr bool ends_with(const char32_t *__x) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char32_t *_M_str;
    };
    template <contiguous_iterator _It, sized_sentinel_for<_It> _End> basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))     {
        return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
    }
    template <typename _CharT, typename _Traits> constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))     {
        return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, basic_string_view<_CharT, _Traits> __str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    using string_view = basic_string_view<char>;
    using wstring_view = basic_string_view<wchar_t>;
    using u8string_view = basic_string_view<char8_t>;
    using u16string_view = basic_string_view<char16_t>;
    using u32string_view = basic_string_view<char32_t>;
    template <typename _Tp> struct hash;
    template<> struct hash<std::string_view> : public __hash_base<std::size_t, std::string_view> {
        std::size_t operator()(const std::string_view &__str) const noexcept         {
            return std::_Hash_impl::hash(__str.data(), __str.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::string_view>> : std::false_type {
    };
    template<> struct hash<std::wstring_view> : public __hash_base<std::size_t, std::wstring_view> {
        std::size_t operator()(const std::wstring_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::wstring_view>> : std::false_type {
    };
    template<> struct hash<std::u8string_view> : public __hash_base<std::size_t, std::u8string_view> {
        std::size_t operator()(const std::u8string_view &__str) const noexcept         {
            return std::_Hash_impl::hash(__str.data(), __str.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::u8string_view>> : std::false_type {
    };
    template<> struct hash<std::u16string_view> : public __hash_base<std::size_t, std::u16string_view> {
        std::size_t operator()(const std::u16string_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u16string_view>> : std::false_type {
    };
    template<> struct hash<std::u32string_view> : public __hash_base<std::size_t, std::u32string_view> {
        std::size_t operator()(const std::u32string_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u32string_view>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_view_literals {
            inline constexpr basic_string_view<char> operator""sv(const char *__str, std::size_t __len) noexcept             {
                return basic_string_view<char>{__str, __len};
            }
            inline constexpr basic_string_view<wchar_t> operator""sv(const wchar_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<wchar_t>{__str, __len};
            }
            inline constexpr basic_string_view<char8_t> operator""sv(const char8_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char8_t>{__str, __len};
            }
            inline constexpr basic_string_view<char16_t> operator""sv(const char16_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char16_t>{__str, __len};
            }
            inline constexpr basic_string_view<char32_t> operator""sv(const char32_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char32_t>{__str, __len};
            }
        }
    }
    namespace ranges {
        constexpr bool enable_borrowed_range = true;
        constexpr bool enable_view = true;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        if (__n == 0)
            return __pos <= this->_M_len ? __pos : npos;
        if (__pos >= this->_M_len)
            return npos;
        const _CharT __elem0 = __str[0];
        const _CharT *__first = this->_M_str + __pos;
        const _CharT *const __last = this->_M_str + this->_M_len;
        std::basic_string_view::size_type __len = this->_M_len - __pos;
        while (__len >= __n)
            {
                __first = traits_type::find(__first, __len - __n + 1, __elem0);
                if (!__first)
                    return npos;
                if (traits_type::compare(__first, __str, __n) == 0)
                    return __first - this->_M_str;
                __len = __last - ++__first;
            }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept     {
        std::basic_string_view::size_type __ret = npos;
        if (__pos < this->_M_len) {
            const std::basic_string_view::size_type __n = this->_M_len - __pos;
            const _CharT *__p = traits_type::find(this->_M_str + __pos, __n, __c);
            if (__p)
                __ret = __p - this->_M_str;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        if (__n <= this->_M_len) {
            __pos = std::min(std::basic_string_view::size_type(this->_M_len - __n), __pos);
            do {
                if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept     {
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size > 0) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(this->_M_str[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        for (; __n && __pos < this->_M_len; ++__pos) {
            const _CharT *__p = traits_type::find(__str, __n, this->_M_str[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        std::basic_string_view::size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::find(__str, __n, this->_M_str[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept     {
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::eq(this->_M_str[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept     {
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(this->_M_str[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
}
extern "C" {
    typedef float float_t;
    typedef double double_t;
    enum  {
        FP_INT_UPWARD = 0,
        FP_INT_DOWNWARD = 1,
        FP_INT_TOWARDZERO = 2,
        FP_INT_TONEARESTFROMZERO = 3,
        FP_INT_TONEAREST = 4
    };
    extern int __fpclassify(double __value) noexcept(true__fpclassify(double __value) noexcept(true) __attribute__((const));
    extern int __signbit(double __value) noexcept(true__signbit(double __value) noexcept(true) __attribute__((const));
    extern int __isinf(double __value) noexcept(true__isinf(double __value) noexcept(true) __attribute__((const));
    extern int __finite(double __value) noexcept(true__finite(double __value) noexcept(true) __attribute__((const));
    extern int __isnan(double __value) noexcept(true__isnan(double __value) noexcept(true) __attribute__((const));
    extern int __iseqsig(double __x, double __y) noexcept(true__iseqsig(double __x, double __y) noexcept(true);
    extern int __issignaling(double __value) noexcept(true__issignaling(double __value) noexcept(true) __attribute__((const));
    extern double acos(double __x) noexcept(trueacos(double __x) noexcept(true);
    extern double __acos(double __x) noexcept(true__acos(double __x) noexcept(true);
    extern double asin(double __x) noexcept(trueasin(double __x) noexcept(true);
    extern double __asin(double __x) noexcept(true__asin(double __x) noexcept(true);
    extern double atan(double __x) noexcept(trueatan(double __x) noexcept(true);
    extern double __atan(double __x) noexcept(true__atan(double __x) noexcept(true);
    extern double atan2(double __y, double __x) noexcept(trueatan2(double __y, double __x) noexcept(true);
    extern double __atan2(double __y, double __x) noexcept(true__atan2(double __y, double __x) noexcept(true);
    extern double cos(double __x) noexcept(truecos(double __x) noexcept(true);
    extern double __cos(double __x) noexcept(true__cos(double __x) noexcept(true);
    extern double sin(double __x) noexcept(truesin(double __x) noexcept(true);
    extern double __sin(double __x) noexcept(true__sin(double __x) noexcept(true);
    extern double tan(double __x) noexcept(truetan(double __x) noexcept(true);
    extern double __tan(double __x) noexcept(true__tan(double __x) noexcept(true);
    extern double cosh(double __x) noexcept(truecosh(double __x) noexcept(true);
    extern double __cosh(double __x) noexcept(true__cosh(double __x) noexcept(true);
    extern double sinh(double __x) noexcept(truesinh(double __x) noexcept(true);
    extern double __sinh(double __x) noexcept(true__sinh(double __x) noexcept(true);
    extern double tanh(double __x) noexcept(truetanh(double __x) noexcept(true);
    extern double __tanh(double __x) noexcept(true__tanh(double __x) noexcept(true);
    extern void sincos(double __x, double *__sinx, double *__cosx) noexcept(truesincos(double __x, double *__sinx, double *__cosx) noexcept(true);
    extern void __sincos(double __x, double *__sinx, double *__cosx) noexcept(true__sincos(double __x, double *__sinx, double *__cosx) noexcept(true);
    extern double acosh(double __x) noexcept(trueacosh(double __x) noexcept(true);
    extern double __acosh(double __x) noexcept(true__acosh(double __x) noexcept(true);
    extern double asinh(double __x) noexcept(trueasinh(double __x) noexcept(true);
    extern double __asinh(double __x) noexcept(true__asinh(double __x) noexcept(true);
    extern double atanh(double __x) noexcept(trueatanh(double __x) noexcept(true);
    extern double __atanh(double __x) noexcept(true__atanh(double __x) noexcept(true);
    extern double exp(double __x) noexcept(trueexp(double __x) noexcept(true);
    extern double __exp(double __x) noexcept(true__exp(double __x) noexcept(true);
    extern double frexp(double __x, int *__exponent) noexcept(truefrexp(double __x, int *__exponent) noexcept(true);
    extern double __frexp(double __x, int *__exponent) noexcept(true__frexp(double __x, int *__exponent) noexcept(true);
    extern double ldexp(double __x, int __exponent) noexcept(trueldexp(double __x, int __exponent) noexcept(true);
    extern double __ldexp(double __x, int __exponent) noexcept(true__ldexp(double __x, int __exponent) noexcept(true);
    extern double log(double __x) noexcept(truelog(double __x) noexcept(true);
    extern double __log(double __x) noexcept(true__log(double __x) noexcept(true);
    extern double log10(double __x) noexcept(truelog10(double __x) noexcept(true);
    extern double __log10(double __x) noexcept(true__log10(double __x) noexcept(true);
    extern double modf(double __x, double *__iptr) noexcept(truemodf(double __x, double *__iptr) noexcept(true);
    extern double __modf(double __x, double *__iptr) noexcept(true__modf(double __x, double *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern double exp10(double __x) noexcept(trueexp10(double __x) noexcept(true);
    extern double __exp10(double __x) noexcept(true__exp10(double __x) noexcept(true);
    extern double expm1(double __x) noexcept(trueexpm1(double __x) noexcept(true);
    extern double __expm1(double __x) noexcept(true__expm1(double __x) noexcept(true);
    extern double log1p(double __x) noexcept(truelog1p(double __x) noexcept(true);
    extern double __log1p(double __x) noexcept(true__log1p(double __x) noexcept(true);
    extern double logb(double __x) noexcept(truelogb(double __x) noexcept(true);
    extern double __logb(double __x) noexcept(true__logb(double __x) noexcept(true);
    extern double exp2(double __x) noexcept(trueexp2(double __x) noexcept(true);
    extern double __exp2(double __x) noexcept(true__exp2(double __x) noexcept(true);
    extern double log2(double __x) noexcept(truelog2(double __x) noexcept(true);
    extern double __log2(double __x) noexcept(true__log2(double __x) noexcept(true);
    extern double pow(double __x, double __y) noexcept(truepow(double __x, double __y) noexcept(true);
    extern double __pow(double __x, double __y) noexcept(true__pow(double __x, double __y) noexcept(true);
    extern double sqrt(double __x) noexcept(truesqrt(double __x) noexcept(true);
    extern double __sqrt(double __x) noexcept(true__sqrt(double __x) noexcept(true);
    extern double hypot(double __x, double __y) noexcept(truehypot(double __x, double __y) noexcept(true);
    extern double __hypot(double __x, double __y) noexcept(true__hypot(double __x, double __y) noexcept(true);
    extern double cbrt(double __x) noexcept(truecbrt(double __x) noexcept(true);
    extern double __cbrt(double __x) noexcept(true__cbrt(double __x) noexcept(true);
    extern double ceil(double __x) noexcept(trueceil(double __x) noexcept(true) __attribute__((const));
    extern double __ceil(double __x) noexcept(true__ceil(double __x) noexcept(true) __attribute__((const));
    extern double fabs(double __x) noexcept(truefabs(double __x) noexcept(true) __attribute__((const));
    extern double __fabs(double __x) noexcept(true__fabs(double __x) noexcept(true) __attribute__((const));
    extern double floor(double __x) noexcept(truefloor(double __x) noexcept(true) __attribute__((const));
    extern double __floor(double __x) noexcept(true__floor(double __x) noexcept(true) __attribute__((const));
    extern double fmod(double __x, double __y) noexcept(truefmod(double __x, double __y) noexcept(true);
    extern double __fmod(double __x, double __y) noexcept(true__fmod(double __x, double __y) noexcept(true);
    extern int finite(double __value) noexcept(truefinite(double __value) noexcept(true) __attribute__((const));
    extern double drem(double __x, double __y) noexcept(truedrem(double __x, double __y) noexcept(true);
    extern double __drem(double __x, double __y) noexcept(true__drem(double __x, double __y) noexcept(true);
    extern double significand(double __x) noexcept(truesignificand(double __x) noexcept(true);
    extern double __significand(double __x) noexcept(true__significand(double __x) noexcept(true);
    extern double copysign(double __x, double __y) noexcept(truecopysign(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __copysign(double __x, double __y) noexcept(true__copysign(double __x, double __y) noexcept(true) __attribute__((const));
    extern double nan(const char *__tagb) noexcept(truenan(const char *__tagb) noexcept(true);
    extern double __nan(const char *__tagb) noexcept(true__nan(const char *__tagb) noexcept(true);
    extern double j0(double) noexcept(truej0(double) noexcept(true);
    extern double __j0(double) noexcept(true__j0(double) noexcept(true);
    extern double j1(double) noexcept(truej1(double) noexcept(true);
    extern double __j1(double) noexcept(true__j1(double) noexcept(true);
    extern double jn(int, double) noexcept(truejn(int, double) noexcept(true);
    extern double __jn(int, double) noexcept(true__jn(int, double) noexcept(true);
    extern double y0(double) noexcept(truey0(double) noexcept(true);
    extern double __y0(double) noexcept(true__y0(double) noexcept(true);
    extern double y1(double) noexcept(truey1(double) noexcept(true);
    extern double __y1(double) noexcept(true__y1(double) noexcept(true);
    extern double yn(int, double) noexcept(trueyn(int, double) noexcept(true);
    extern double __yn(int, double) noexcept(true__yn(int, double) noexcept(true);
    extern double erf(double) noexcept(trueerf(double) noexcept(true);
    extern double __erf(double) noexcept(true__erf(double) noexcept(true);
    extern double erfc(double) noexcept(trueerfc(double) noexcept(true);
    extern double __erfc(double) noexcept(true__erfc(double) noexcept(true);
    extern double lgamma(double) noexcept(truelgamma(double) noexcept(true);
    extern double __lgamma(double) noexcept(true__lgamma(double) noexcept(true);
    extern double tgamma(double) noexcept(truetgamma(double) noexcept(true);
    extern double __tgamma(double) noexcept(true__tgamma(double) noexcept(true);
    extern double gamma(double) noexcept(truegamma(double) noexcept(true);
    extern double __gamma(double) noexcept(true__gamma(double) noexcept(true);
    extern double lgamma_r(double, int *__signgamp) noexcept(truelgamma_r(double, int *__signgamp) noexcept(true);
    extern double __lgamma_r(double, int *__signgamp) noexcept(true__lgamma_r(double, int *__signgamp) noexcept(true);
    extern double rint(double __x) noexcept(truerint(double __x) noexcept(true);
    extern double __rint(double __x) noexcept(true__rint(double __x) noexcept(true);
    extern double nextafter(double __x, double __y) noexcept(truenextafter(double __x, double __y) noexcept(true);
    extern double __nextafter(double __x, double __y) noexcept(true__nextafter(double __x, double __y) noexcept(true);
    extern double nexttoward(double __x, long double __y) noexcept(truenexttoward(double __x, long double __y) noexcept(true);
    extern double __nexttoward(double __x, long double __y) noexcept(true__nexttoward(double __x, long double __y) noexcept(true);
    extern double nextdown(double __x) noexcept(truenextdown(double __x) noexcept(true);
    extern double __nextdown(double __x) noexcept(true__nextdown(double __x) noexcept(true);
    extern double nextup(double __x) noexcept(truenextup(double __x) noexcept(true);
    extern double __nextup(double __x) noexcept(true__nextup(double __x) noexcept(true);
    extern double remainder(double __x, double __y) noexcept(trueremainder(double __x, double __y) noexcept(true);
    extern double __remainder(double __x, double __y) noexcept(true__remainder(double __x, double __y) noexcept(true);
    extern double scalbn(double __x, int __n) noexcept(truescalbn(double __x, int __n) noexcept(true);
    extern double __scalbn(double __x, int __n) noexcept(true__scalbn(double __x, int __n) noexcept(true);
    extern int ilogb(double __x) noexcept(trueilogb(double __x) noexcept(true);
    extern int __ilogb(double __x) noexcept(true__ilogb(double __x) noexcept(true);
    extern long llogb(double __x) noexcept(truellogb(double __x) noexcept(true);
    extern long __llogb(double __x) noexcept(true__llogb(double __x) noexcept(true);
    extern double scalbln(double __x, long __n) noexcept(truescalbln(double __x, long __n) noexcept(true);
    extern double __scalbln(double __x, long __n) noexcept(true__scalbln(double __x, long __n) noexcept(true);
    extern double nearbyint(double __x) noexcept(truenearbyint(double __x) noexcept(true);
    extern double __nearbyint(double __x) noexcept(true__nearbyint(double __x) noexcept(true);
    extern double round(double __x) noexcept(trueround(double __x) noexcept(true) __attribute__((const));
    extern double __round(double __x) noexcept(true__round(double __x) noexcept(true) __attribute__((const));
    extern double trunc(double __x) noexcept(truetrunc(double __x) noexcept(true) __attribute__((const));
    extern double __trunc(double __x) noexcept(true__trunc(double __x) noexcept(true) __attribute__((const));
    extern double remquo(double __x, double __y, int *__quo) noexcept(trueremquo(double __x, double __y, int *__quo) noexcept(true);
    extern double __remquo(double __x, double __y, int *__quo) noexcept(true__remquo(double __x, double __y, int *__quo) noexcept(true);
    extern long lrint(double __x) noexcept(truelrint(double __x) noexcept(true);
    extern long __lrint(double __x) noexcept(true__lrint(double __x) noexcept(true);
    extern long long llrint(double __x) noexcept(truellrint(double __x) noexcept(true);
    extern long long __llrint(double __x) noexcept(true__llrint(double __x) noexcept(true);
    extern long lround(double __x) noexcept(truelround(double __x) noexcept(true);
    extern long __lround(double __x) noexcept(true__lround(double __x) noexcept(true);
    extern long long llround(double __x) noexcept(truellround(double __x) noexcept(true);
    extern long long __llround(double __x) noexcept(true__llround(double __x) noexcept(true);
    extern double fdim(double __x, double __y) noexcept(truefdim(double __x, double __y) noexcept(true);
    extern double __fdim(double __x, double __y) noexcept(true__fdim(double __x, double __y) noexcept(true);
    extern double fmax(double __x, double __y) noexcept(truefmax(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmax(double __x, double __y) noexcept(true__fmax(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmin(double __x, double __y) noexcept(truefmin(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmin(double __x, double __y) noexcept(true__fmin(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fma(double __x, double __y, double __z) noexcept(truefma(double __x, double __y, double __z) noexcept(true);
    extern double __fma(double __x, double __y, double __z) noexcept(true__fma(double __x, double __y, double __z) noexcept(true);
    extern double roundeven(double __x) noexcept(trueroundeven(double __x) noexcept(true) __attribute__((const));
    extern double __roundeven(double __x) noexcept(true__roundeven(double __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfp(double __x, int __round, unsigned int __width) noexcept(truefromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfp(double __x, int __round, unsigned int __width) noexcept(true__fromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfp(double __x, int __round, unsigned int __width) noexcept(trueufromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfp(double __x, int __round, unsigned int __width) noexcept(true__ufromfp(double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpx(double __x, int __round, unsigned int __width) noexcept(truefromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpx(double __x, int __round, unsigned int __width) noexcept(true__fromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpx(double __x, int __round, unsigned int __width) noexcept(trueufromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpx(double __x, int __round, unsigned int __width) noexcept(true__ufromfpx(double __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalize(double *__cx, const double *__x) noexcept(truecanonicalize(double *__cx, const double *__x) noexcept(true);
    extern double fmaxmag(double __x, double __y) noexcept(truefmaxmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaxmag(double __x, double __y) noexcept(true__fmaxmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminmag(double __x, double __y) noexcept(truefminmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminmag(double __x, double __y) noexcept(true__fminmag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum(double __x, double __y) noexcept(truefmaximum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum(double __x, double __y) noexcept(true__fmaximum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum(double __x, double __y) noexcept(truefminimum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum(double __x, double __y) noexcept(true__fminimum(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum_num(double __x, double __y) noexcept(truefmaximum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum_num(double __x, double __y) noexcept(true__fmaximum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum_num(double __x, double __y) noexcept(truefminimum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum_num(double __x, double __y) noexcept(true__fminimum_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum_mag(double __x, double __y) noexcept(truefmaximum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum_mag(double __x, double __y) noexcept(true__fmaximum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum_mag(double __x, double __y) noexcept(truefminimum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum_mag(double __x, double __y) noexcept(true__fminimum_mag(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fmaximum_mag_num(double __x, double __y) noexcept(truefmaximum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fmaximum_mag_num(double __x, double __y) noexcept(true__fmaximum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double fminimum_mag_num(double __x, double __y) noexcept(truefminimum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern double __fminimum_mag_num(double __x, double __y) noexcept(true__fminimum_mag_num(double __x, double __y) noexcept(true) __attribute__((const));
    extern int totalorder(const double *__x, const double *__y) noexcept(truetotalorder(const double *__x, const double *__y) noexcept(true) __attribute__((pure));
    extern int totalordermag(const double *__x, const double *__y) noexcept(truetotalordermag(const double *__x, const double *__y) noexcept(true) __attribute__((pure));
    extern double getpayload(const double *__x) noexcept(truegetpayload(const double *__x) noexcept(true);
    extern double __getpayload(const double *__x) noexcept(true__getpayload(const double *__x) noexcept(true);
    extern int setpayload(double *__x, double __payload) noexcept(truesetpayload(double *__x, double __payload) noexcept(true);
    extern int setpayloadsig(double *__x, double __payload) noexcept(truesetpayloadsig(double *__x, double __payload) noexcept(true);
    extern double scalb(double __x, double __n) noexcept(truescalb(double __x, double __n) noexcept(true);
    extern double __scalb(double __x, double __n) noexcept(true__scalb(double __x, double __n) noexcept(true);
    extern int __fpclassifyf(float __value) noexcept(true__fpclassifyf(float __value) noexcept(true) __attribute__((const));
    extern int __signbitf(float __value) noexcept(true__signbitf(float __value) noexcept(true) __attribute__((const));
    extern int __isinff(float __value) noexcept(true__isinff(float __value) noexcept(true) __attribute__((const));
    extern int __finitef(float __value) noexcept(true__finitef(float __value) noexcept(true) __attribute__((const));
    extern int __isnanf(float __value) noexcept(true__isnanf(float __value) noexcept(true) __attribute__((const));
    extern int __iseqsigf(float __x, float __y) noexcept(true__iseqsigf(float __x, float __y) noexcept(true);
    extern int __issignalingf(float __value) noexcept(true__issignalingf(float __value) noexcept(true) __attribute__((const));
    extern float acosf(float __x) noexcept(trueacosf(float __x) noexcept(true);
    extern float __acosf(float __x) noexcept(true__acosf(float __x) noexcept(true);
    extern float asinf(float __x) noexcept(trueasinf(float __x) noexcept(true);
    extern float __asinf(float __x) noexcept(true__asinf(float __x) noexcept(true);
    extern float atanf(float __x) noexcept(trueatanf(float __x) noexcept(true);
    extern float __atanf(float __x) noexcept(true__atanf(float __x) noexcept(true);
    extern float atan2f(float __y, float __x) noexcept(trueatan2f(float __y, float __x) noexcept(true);
    extern float __atan2f(float __y, float __x) noexcept(true__atan2f(float __y, float __x) noexcept(true);
    extern float cosf(float __x) noexcept(truecosf(float __x) noexcept(true);
    extern float __cosf(float __x) noexcept(true__cosf(float __x) noexcept(true);
    extern float sinf(float __x) noexcept(truesinf(float __x) noexcept(true);
    extern float __sinf(float __x) noexcept(true__sinf(float __x) noexcept(true);
    extern float tanf(float __x) noexcept(truetanf(float __x) noexcept(true);
    extern float __tanf(float __x) noexcept(true__tanf(float __x) noexcept(true);
    extern float coshf(float __x) noexcept(truecoshf(float __x) noexcept(true);
    extern float __coshf(float __x) noexcept(true__coshf(float __x) noexcept(true);
    extern float sinhf(float __x) noexcept(truesinhf(float __x) noexcept(true);
    extern float __sinhf(float __x) noexcept(true__sinhf(float __x) noexcept(true);
    extern float tanhf(float __x) noexcept(truetanhf(float __x) noexcept(true);
    extern float __tanhf(float __x) noexcept(true__tanhf(float __x) noexcept(true);
    extern void sincosf(float __x, float *__sinx, float *__cosx) noexcept(truesincosf(float __x, float *__sinx, float *__cosx) noexcept(true);
    extern void __sincosf(float __x, float *__sinx, float *__cosx) noexcept(true__sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);
    extern float acoshf(float __x) noexcept(trueacoshf(float __x) noexcept(true);
    extern float __acoshf(float __x) noexcept(true__acoshf(float __x) noexcept(true);
    extern float asinhf(float __x) noexcept(trueasinhf(float __x) noexcept(true);
    extern float __asinhf(float __x) noexcept(true__asinhf(float __x) noexcept(true);
    extern float atanhf(float __x) noexcept(trueatanhf(float __x) noexcept(true);
    extern float __atanhf(float __x) noexcept(true__atanhf(float __x) noexcept(true);
    extern float expf(float __x) noexcept(trueexpf(float __x) noexcept(true);
    extern float __expf(float __x) noexcept(true__expf(float __x) noexcept(true);
    extern float frexpf(float __x, int *__exponent) noexcept(truefrexpf(float __x, int *__exponent) noexcept(true);
    extern float __frexpf(float __x, int *__exponent) noexcept(true__frexpf(float __x, int *__exponent) noexcept(true);
    extern float ldexpf(float __x, int __exponent) noexcept(trueldexpf(float __x, int __exponent) noexcept(true);
    extern float __ldexpf(float __x, int __exponent) noexcept(true__ldexpf(float __x, int __exponent) noexcept(true);
    extern float logf(float __x) noexcept(truelogf(float __x) noexcept(true);
    extern float __logf(float __x) noexcept(true__logf(float __x) noexcept(true);
    extern float log10f(float __x) noexcept(truelog10f(float __x) noexcept(true);
    extern float __log10f(float __x) noexcept(true__log10f(float __x) noexcept(true);
    extern float modff(float __x, float *__iptr) noexcept(truemodff(float __x, float *__iptr) noexcept(true);
    extern float __modff(float __x, float *__iptr) noexcept(true__modff(float __x, float *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern float exp10f(float __x) noexcept(trueexp10f(float __x) noexcept(true);
    extern float __exp10f(float __x) noexcept(true__exp10f(float __x) noexcept(true);
    extern float expm1f(float __x) noexcept(trueexpm1f(float __x) noexcept(true);
    extern float __expm1f(float __x) noexcept(true__expm1f(float __x) noexcept(true);
    extern float log1pf(float __x) noexcept(truelog1pf(float __x) noexcept(true);
    extern float __log1pf(float __x) noexcept(true__log1pf(float __x) noexcept(true);
    extern float logbf(float __x) noexcept(truelogbf(float __x) noexcept(true);
    extern float __logbf(float __x) noexcept(true__logbf(float __x) noexcept(true);
    extern float exp2f(float __x) noexcept(trueexp2f(float __x) noexcept(true);
    extern float __exp2f(float __x) noexcept(true__exp2f(float __x) noexcept(true);
    extern float log2f(float __x) noexcept(truelog2f(float __x) noexcept(true);
    extern float __log2f(float __x) noexcept(true__log2f(float __x) noexcept(true);
    extern float powf(float __x, float __y) noexcept(truepowf(float __x, float __y) noexcept(true);
    extern float __powf(float __x, float __y) noexcept(true__powf(float __x, float __y) noexcept(true);
    extern float sqrtf(float __x) noexcept(truesqrtf(float __x) noexcept(true);
    extern float __sqrtf(float __x) noexcept(true__sqrtf(float __x) noexcept(true);
    extern float hypotf(float __x, float __y) noexcept(truehypotf(float __x, float __y) noexcept(true);
    extern float __hypotf(float __x, float __y) noexcept(true__hypotf(float __x, float __y) noexcept(true);
    extern float cbrtf(float __x) noexcept(truecbrtf(float __x) noexcept(true);
    extern float __cbrtf(float __x) noexcept(true__cbrtf(float __x) noexcept(true);
    extern float ceilf(float __x) noexcept(trueceilf(float __x) noexcept(true) __attribute__((const));
    extern float __ceilf(float __x) noexcept(true__ceilf(float __x) noexcept(true) __attribute__((const));
    extern float fabsf(float __x) noexcept(truefabsf(float __x) noexcept(true) __attribute__((const));
    extern float __fabsf(float __x) noexcept(true__fabsf(float __x) noexcept(true) __attribute__((const));
    extern float floorf(float __x) noexcept(truefloorf(float __x) noexcept(true) __attribute__((const));
    extern float __floorf(float __x) noexcept(true__floorf(float __x) noexcept(true) __attribute__((const));
    extern float fmodf(float __x, float __y) noexcept(truefmodf(float __x, float __y) noexcept(true);
    extern float __fmodf(float __x, float __y) noexcept(true__fmodf(float __x, float __y) noexcept(true);
    extern int isinff(float __value) noexcept(trueisinff(float __value) noexcept(true) __attribute__((const));
    extern int finitef(float __value) noexcept(truefinitef(float __value) noexcept(true) __attribute__((const));
    extern float dremf(float __x, float __y) noexcept(truedremf(float __x, float __y) noexcept(true);
    extern float __dremf(float __x, float __y) noexcept(true__dremf(float __x, float __y) noexcept(true);
    extern float significandf(float __x) noexcept(truesignificandf(float __x) noexcept(true);
    extern float __significandf(float __x) noexcept(true__significandf(float __x) noexcept(true);
    extern float copysignf(float __x, float __y) noexcept(truecopysignf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __copysignf(float __x, float __y) noexcept(true__copysignf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float nanf(const char *__tagb) noexcept(truenanf(const char *__tagb) noexcept(true);
    extern float __nanf(const char *__tagb) noexcept(true__nanf(const char *__tagb) noexcept(true);
    extern int isnanf(float __value) noexcept(trueisnanf(float __value) noexcept(true) __attribute__((const));
    extern float j0f(float) noexcept(truej0f(float) noexcept(true);
    extern float __j0f(float) noexcept(true__j0f(float) noexcept(true);
    extern float j1f(float) noexcept(truej1f(float) noexcept(true);
    extern float __j1f(float) noexcept(true__j1f(float) noexcept(true);
    extern float jnf(int, float) noexcept(truejnf(int, float) noexcept(true);
    extern float __jnf(int, float) noexcept(true__jnf(int, float) noexcept(true);
    extern float y0f(float) noexcept(truey0f(float) noexcept(true);
    extern float __y0f(float) noexcept(true__y0f(float) noexcept(true);
    extern float y1f(float) noexcept(truey1f(float) noexcept(true);
    extern float __y1f(float) noexcept(true__y1f(float) noexcept(true);
    extern float ynf(int, float) noexcept(trueynf(int, float) noexcept(true);
    extern float __ynf(int, float) noexcept(true__ynf(int, float) noexcept(true);
    extern float erff(float) noexcept(trueerff(float) noexcept(true);
    extern float __erff(float) noexcept(true__erff(float) noexcept(true);
    extern float erfcf(float) noexcept(trueerfcf(float) noexcept(true);
    extern float __erfcf(float) noexcept(true__erfcf(float) noexcept(true);
    extern float lgammaf(float) noexcept(truelgammaf(float) noexcept(true);
    extern float __lgammaf(float) noexcept(true__lgammaf(float) noexcept(true);
    extern float tgammaf(float) noexcept(truetgammaf(float) noexcept(true);
    extern float __tgammaf(float) noexcept(true__tgammaf(float) noexcept(true);
    extern float gammaf(float) noexcept(truegammaf(float) noexcept(true);
    extern float __gammaf(float) noexcept(true__gammaf(float) noexcept(true);
    extern float lgammaf_r(float, int *__signgamp) noexcept(truelgammaf_r(float, int *__signgamp) noexcept(true);
    extern float __lgammaf_r(float, int *__signgamp) noexcept(true__lgammaf_r(float, int *__signgamp) noexcept(true);
    extern float rintf(float __x) noexcept(truerintf(float __x) noexcept(true);
    extern float __rintf(float __x) noexcept(true__rintf(float __x) noexcept(true);
    extern float nextafterf(float __x, float __y) noexcept(truenextafterf(float __x, float __y) noexcept(true);
    extern float __nextafterf(float __x, float __y) noexcept(true__nextafterf(float __x, float __y) noexcept(true);
    extern float nexttowardf(float __x, long double __y) noexcept(truenexttowardf(float __x, long double __y) noexcept(true);
    extern float __nexttowardf(float __x, long double __y) noexcept(true__nexttowardf(float __x, long double __y) noexcept(true);
    extern float nextdownf(float __x) noexcept(truenextdownf(float __x) noexcept(true);
    extern float __nextdownf(float __x) noexcept(true__nextdownf(float __x) noexcept(true);
    extern float nextupf(float __x) noexcept(truenextupf(float __x) noexcept(true);
    extern float __nextupf(float __x) noexcept(true__nextupf(float __x) noexcept(true);
    extern float remainderf(float __x, float __y) noexcept(trueremainderf(float __x, float __y) noexcept(true);
    extern float __remainderf(float __x, float __y) noexcept(true__remainderf(float __x, float __y) noexcept(true);
    extern float scalbnf(float __x, int __n) noexcept(truescalbnf(float __x, int __n) noexcept(true);
    extern float __scalbnf(float __x, int __n) noexcept(true__scalbnf(float __x, int __n) noexcept(true);
    extern int ilogbf(float __x) noexcept(trueilogbf(float __x) noexcept(true);
    extern int __ilogbf(float __x) noexcept(true__ilogbf(float __x) noexcept(true);
    extern long llogbf(float __x) noexcept(truellogbf(float __x) noexcept(true);
    extern long __llogbf(float __x) noexcept(true__llogbf(float __x) noexcept(true);
    extern float scalblnf(float __x, long __n) noexcept(truescalblnf(float __x, long __n) noexcept(true);
    extern float __scalblnf(float __x, long __n) noexcept(true__scalblnf(float __x, long __n) noexcept(true);
    extern float nearbyintf(float __x) noexcept(truenearbyintf(float __x) noexcept(true);
    extern float __nearbyintf(float __x) noexcept(true__nearbyintf(float __x) noexcept(true);
    extern float roundf(float __x) noexcept(trueroundf(float __x) noexcept(true) __attribute__((const));
    extern float __roundf(float __x) noexcept(true__roundf(float __x) noexcept(true) __attribute__((const));
    extern float truncf(float __x) noexcept(truetruncf(float __x) noexcept(true) __attribute__((const));
    extern float __truncf(float __x) noexcept(true__truncf(float __x) noexcept(true) __attribute__((const));
    extern float remquof(float __x, float __y, int *__quo) noexcept(trueremquof(float __x, float __y, int *__quo) noexcept(true);
    extern float __remquof(float __x, float __y, int *__quo) noexcept(true__remquof(float __x, float __y, int *__quo) noexcept(true);
    extern long lrintf(float __x) noexcept(truelrintf(float __x) noexcept(true);
    extern long __lrintf(float __x) noexcept(true__lrintf(float __x) noexcept(true);
    extern long long llrintf(float __x) noexcept(truellrintf(float __x) noexcept(true);
    extern long long __llrintf(float __x) noexcept(true__llrintf(float __x) noexcept(true);
    extern long lroundf(float __x) noexcept(truelroundf(float __x) noexcept(true);
    extern long __lroundf(float __x) noexcept(true__lroundf(float __x) noexcept(true);
    extern long long llroundf(float __x) noexcept(truellroundf(float __x) noexcept(true);
    extern long long __llroundf(float __x) noexcept(true__llroundf(float __x) noexcept(true);
    extern float fdimf(float __x, float __y) noexcept(truefdimf(float __x, float __y) noexcept(true);
    extern float __fdimf(float __x, float __y) noexcept(true__fdimf(float __x, float __y) noexcept(true);
    extern float fmaxf(float __x, float __y) noexcept(truefmaxf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaxf(float __x, float __y) noexcept(true__fmaxf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminf(float __x, float __y) noexcept(truefminf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminf(float __x, float __y) noexcept(true__fminf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaf(float __x, float __y, float __z) noexcept(truefmaf(float __x, float __y, float __z) noexcept(true);
    extern float __fmaf(float __x, float __y, float __z) noexcept(true__fmaf(float __x, float __y, float __z) noexcept(true);
    extern float roundevenf(float __x) noexcept(trueroundevenf(float __x) noexcept(true) __attribute__((const));
    extern float __roundevenf(float __x) noexcept(true__roundevenf(float __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf(float __x, int __round, unsigned int __width) noexcept(truefromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf(float __x, int __round, unsigned int __width) noexcept(true__fromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf(float __x, int __round, unsigned int __width) noexcept(trueufromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf(float __x, int __round, unsigned int __width) noexcept(true__ufromfpf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf(float __x, int __round, unsigned int __width) noexcept(truefromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf(float __x, int __round, unsigned int __width) noexcept(true__fromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf(float __x, int __round, unsigned int __width) noexcept(trueufromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf(float __x, int __round, unsigned int __width) noexcept(true__ufromfpxf(float __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef(float *__cx, const float *__x) noexcept(truecanonicalizef(float *__cx, const float *__x) noexcept(true);
    extern float fmaxmagf(float __x, float __y) noexcept(truefmaxmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaxmagf(float __x, float __y) noexcept(true__fmaxmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminmagf(float __x, float __y) noexcept(truefminmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminmagf(float __x, float __y) noexcept(true__fminmagf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximumf(float __x, float __y) noexcept(truefmaximumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximumf(float __x, float __y) noexcept(true__fmaximumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimumf(float __x, float __y) noexcept(truefminimumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimumf(float __x, float __y) noexcept(true__fminimumf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximum_numf(float __x, float __y) noexcept(truefmaximum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximum_numf(float __x, float __y) noexcept(true__fmaximum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimum_numf(float __x, float __y) noexcept(truefminimum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimum_numf(float __x, float __y) noexcept(true__fminimum_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximum_magf(float __x, float __y) noexcept(truefmaximum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximum_magf(float __x, float __y) noexcept(true__fmaximum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimum_magf(float __x, float __y) noexcept(truefminimum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimum_magf(float __x, float __y) noexcept(true__fminimum_magf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fmaximum_mag_numf(float __x, float __y) noexcept(truefmaximum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fmaximum_mag_numf(float __x, float __y) noexcept(true__fmaximum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float fminimum_mag_numf(float __x, float __y) noexcept(truefminimum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern float __fminimum_mag_numf(float __x, float __y) noexcept(true__fminimum_mag_numf(float __x, float __y) noexcept(true) __attribute__((const));
    extern int totalorderf(const float *__x, const float *__y) noexcept(truetotalorderf(const float *__x, const float *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf(const float *__x, const float *__y) noexcept(truetotalordermagf(const float *__x, const float *__y) noexcept(true) __attribute__((pure));
    extern float getpayloadf(const float *__x) noexcept(truegetpayloadf(const float *__x) noexcept(true);
    extern float __getpayloadf(const float *__x) noexcept(true__getpayloadf(const float *__x) noexcept(true);
    extern int setpayloadf(float *__x, float __payload) noexcept(truesetpayloadf(float *__x, float __payload) noexcept(true);
    extern int setpayloadsigf(float *__x, float __payload) noexcept(truesetpayloadsigf(float *__x, float __payload) noexcept(true);
    extern float scalbf(float __x, float __n) noexcept(truescalbf(float __x, float __n) noexcept(true);
    extern float __scalbf(float __x, float __n) noexcept(true__scalbf(float __x, float __n) noexcept(true);
    extern int __fpclassifyl(long double __value) noexcept(true__fpclassifyl(long double __value) noexcept(true) __attribute__((const));
    extern int __signbitl(long double __value) noexcept(true__signbitl(long double __value) noexcept(true) __attribute__((const));
    extern int __isinfl(long double __value) noexcept(true__isinfl(long double __value) noexcept(true) __attribute__((const));
    extern int __finitel(long double __value) noexcept(true__finitel(long double __value) noexcept(true) __attribute__((const));
    extern int __isnanl(long double __value) noexcept(true__isnanl(long double __value) noexcept(true) __attribute__((const));
    extern int __iseqsigl(long double __x, long double __y) noexcept(true__iseqsigl(long double __x, long double __y) noexcept(true);
    extern int __issignalingl(long double __value) noexcept(true__issignalingl(long double __value) noexcept(true) __attribute__((const));
    extern long double acosl(long double __x) noexcept(trueacosl(long double __x) noexcept(true);
    extern long double __acosl(long double __x) noexcept(true__acosl(long double __x) noexcept(true);
    extern long double asinl(long double __x) noexcept(trueasinl(long double __x) noexcept(true);
    extern long double __asinl(long double __x) noexcept(true__asinl(long double __x) noexcept(true);
    extern long double atanl(long double __x) noexcept(trueatanl(long double __x) noexcept(true);
    extern long double __atanl(long double __x) noexcept(true__atanl(long double __x) noexcept(true);
    extern long double atan2l(long double __y, long double __x) noexcept(trueatan2l(long double __y, long double __x) noexcept(true);
    extern long double __atan2l(long double __y, long double __x) noexcept(true__atan2l(long double __y, long double __x) noexcept(true);
    extern long double cosl(long double __x) noexcept(truecosl(long double __x) noexcept(true);
    extern long double __cosl(long double __x) noexcept(true__cosl(long double __x) noexcept(true);
    extern long double sinl(long double __x) noexcept(truesinl(long double __x) noexcept(true);
    extern long double __sinl(long double __x) noexcept(true__sinl(long double __x) noexcept(true);
    extern long double tanl(long double __x) noexcept(truetanl(long double __x) noexcept(true);
    extern long double __tanl(long double __x) noexcept(true__tanl(long double __x) noexcept(true);
    extern long double coshl(long double __x) noexcept(truecoshl(long double __x) noexcept(true);
    extern long double __coshl(long double __x) noexcept(true__coshl(long double __x) noexcept(true);
    extern long double sinhl(long double __x) noexcept(truesinhl(long double __x) noexcept(true);
    extern long double __sinhl(long double __x) noexcept(true__sinhl(long double __x) noexcept(true);
    extern long double tanhl(long double __x) noexcept(truetanhl(long double __x) noexcept(true);
    extern long double __tanhl(long double __x) noexcept(true__tanhl(long double __x) noexcept(true);
    extern void sincosl(long double __x, long double *__sinx, long double *__cosx) noexcept(truesincosl(long double __x, long double *__sinx, long double *__cosx) noexcept(true);
    extern void __sincosl(long double __x, long double *__sinx, long double *__cosx) noexcept(true__sincosl(long double __x, long double *__sinx, long double *__cosx) noexcept(true);
    extern long double acoshl(long double __x) noexcept(trueacoshl(long double __x) noexcept(true);
    extern long double __acoshl(long double __x) noexcept(true__acoshl(long double __x) noexcept(true);
    extern long double asinhl(long double __x) noexcept(trueasinhl(long double __x) noexcept(true);
    extern long double __asinhl(long double __x) noexcept(true__asinhl(long double __x) noexcept(true);
    extern long double atanhl(long double __x) noexcept(trueatanhl(long double __x) noexcept(true);
    extern long double __atanhl(long double __x) noexcept(true__atanhl(long double __x) noexcept(true);
    extern long double expl(long double __x) noexcept(trueexpl(long double __x) noexcept(true);
    extern long double __expl(long double __x) noexcept(true__expl(long double __x) noexcept(true);
    extern long double frexpl(long double __x, int *__exponent) noexcept(truefrexpl(long double __x, int *__exponent) noexcept(true);
    extern long double __frexpl(long double __x, int *__exponent) noexcept(true__frexpl(long double __x, int *__exponent) noexcept(true);
    extern long double ldexpl(long double __x, int __exponent) noexcept(trueldexpl(long double __x, int __exponent) noexcept(true);
    extern long double __ldexpl(long double __x, int __exponent) noexcept(true__ldexpl(long double __x, int __exponent) noexcept(true);
    extern long double logl(long double __x) noexcept(truelogl(long double __x) noexcept(true);
    extern long double __logl(long double __x) noexcept(true__logl(long double __x) noexcept(true);
    extern long double log10l(long double __x) noexcept(truelog10l(long double __x) noexcept(true);
    extern long double __log10l(long double __x) noexcept(true__log10l(long double __x) noexcept(true);
    extern long double modfl(long double __x, long double *__iptr) noexcept(truemodfl(long double __x, long double *__iptr) noexcept(true);
    extern long double __modfl(long double __x, long double *__iptr) noexcept(true__modfl(long double __x, long double *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern long double exp10l(long double __x) noexcept(trueexp10l(long double __x) noexcept(true);
    extern long double __exp10l(long double __x) noexcept(true__exp10l(long double __x) noexcept(true);
    extern long double expm1l(long double __x) noexcept(trueexpm1l(long double __x) noexcept(true);
    extern long double __expm1l(long double __x) noexcept(true__expm1l(long double __x) noexcept(true);
    extern long double log1pl(long double __x) noexcept(truelog1pl(long double __x) noexcept(true);
    extern long double __log1pl(long double __x) noexcept(true__log1pl(long double __x) noexcept(true);
    extern long double logbl(long double __x) noexcept(truelogbl(long double __x) noexcept(true);
    extern long double __logbl(long double __x) noexcept(true__logbl(long double __x) noexcept(true);
    extern long double exp2l(long double __x) noexcept(trueexp2l(long double __x) noexcept(true);
    extern long double __exp2l(long double __x) noexcept(true__exp2l(long double __x) noexcept(true);
    extern long double log2l(long double __x) noexcept(truelog2l(long double __x) noexcept(true);
    extern long double __log2l(long double __x) noexcept(true__log2l(long double __x) noexcept(true);
    extern long double powl(long double __x, long double __y) noexcept(truepowl(long double __x, long double __y) noexcept(true);
    extern long double __powl(long double __x, long double __y) noexcept(true__powl(long double __x, long double __y) noexcept(true);
    extern long double sqrtl(long double __x) noexcept(truesqrtl(long double __x) noexcept(true);
    extern long double __sqrtl(long double __x) noexcept(true__sqrtl(long double __x) noexcept(true);
    extern long double hypotl(long double __x, long double __y) noexcept(truehypotl(long double __x, long double __y) noexcept(true);
    extern long double __hypotl(long double __x, long double __y) noexcept(true__hypotl(long double __x, long double __y) noexcept(true);
    extern long double cbrtl(long double __x) noexcept(truecbrtl(long double __x) noexcept(true);
    extern long double __cbrtl(long double __x) noexcept(true__cbrtl(long double __x) noexcept(true);
    extern long double ceill(long double __x) noexcept(trueceill(long double __x) noexcept(true) __attribute__((const));
    extern long double __ceill(long double __x) noexcept(true__ceill(long double __x) noexcept(true) __attribute__((const));
    extern long double fabsl(long double __x) noexcept(truefabsl(long double __x) noexcept(true) __attribute__((const));
    extern long double __fabsl(long double __x) noexcept(true__fabsl(long double __x) noexcept(true) __attribute__((const));
    extern long double floorl(long double __x) noexcept(truefloorl(long double __x) noexcept(true) __attribute__((const));
    extern long double __floorl(long double __x) noexcept(true__floorl(long double __x) noexcept(true) __attribute__((const));
    extern long double fmodl(long double __x, long double __y) noexcept(truefmodl(long double __x, long double __y) noexcept(true);
    extern long double __fmodl(long double __x, long double __y) noexcept(true__fmodl(long double __x, long double __y) noexcept(true);
    extern int isinfl(long double __value) noexcept(trueisinfl(long double __value) noexcept(true) __attribute__((const));
    extern int finitel(long double __value) noexcept(truefinitel(long double __value) noexcept(true) __attribute__((const));
    extern long double dreml(long double __x, long double __y) noexcept(truedreml(long double __x, long double __y) noexcept(true);
    extern long double __dreml(long double __x, long double __y) noexcept(true__dreml(long double __x, long double __y) noexcept(true);
    extern long double significandl(long double __x) noexcept(truesignificandl(long double __x) noexcept(true);
    extern long double __significandl(long double __x) noexcept(true__significandl(long double __x) noexcept(true);
    extern long double copysignl(long double __x, long double __y) noexcept(truecopysignl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __copysignl(long double __x, long double __y) noexcept(true__copysignl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double nanl(const char *__tagb) noexcept(truenanl(const char *__tagb) noexcept(true);
    extern long double __nanl(const char *__tagb) noexcept(true__nanl(const char *__tagb) noexcept(true);
    extern int isnanl(long double __value) noexcept(trueisnanl(long double __value) noexcept(true) __attribute__((const));
    extern long double j0l(long double) noexcept(truej0l(long double) noexcept(true);
    extern long double __j0l(long double) noexcept(true__j0l(long double) noexcept(true);
    extern long double j1l(long double) noexcept(truej1l(long double) noexcept(true);
    extern long double __j1l(long double) noexcept(true__j1l(long double) noexcept(true);
    extern long double jnl(int, long double) noexcept(truejnl(int, long double) noexcept(true);
    extern long double __jnl(int, long double) noexcept(true__jnl(int, long double) noexcept(true);
    extern long double y0l(long double) noexcept(truey0l(long double) noexcept(true);
    extern long double __y0l(long double) noexcept(true__y0l(long double) noexcept(true);
    extern long double y1l(long double) noexcept(truey1l(long double) noexcept(true);
    extern long double __y1l(long double) noexcept(true__y1l(long double) noexcept(true);
    extern long double ynl(int, long double) noexcept(trueynl(int, long double) noexcept(true);
    extern long double __ynl(int, long double) noexcept(true__ynl(int, long double) noexcept(true);
    extern long double erfl(long double) noexcept(trueerfl(long double) noexcept(true);
    extern long double __erfl(long double) noexcept(true__erfl(long double) noexcept(true);
    extern long double erfcl(long double) noexcept(trueerfcl(long double) noexcept(true);
    extern long double __erfcl(long double) noexcept(true__erfcl(long double) noexcept(true);
    extern long double lgammal(long double) noexcept(truelgammal(long double) noexcept(true);
    extern long double __lgammal(long double) noexcept(true__lgammal(long double) noexcept(true);
    extern long double tgammal(long double) noexcept(truetgammal(long double) noexcept(true);
    extern long double __tgammal(long double) noexcept(true__tgammal(long double) noexcept(true);
    extern long double gammal(long double) noexcept(truegammal(long double) noexcept(true);
    extern long double __gammal(long double) noexcept(true__gammal(long double) noexcept(true);
    extern long double lgammal_r(long double, int *__signgamp) noexcept(truelgammal_r(long double, int *__signgamp) noexcept(true);
    extern long double __lgammal_r(long double, int *__signgamp) noexcept(true__lgammal_r(long double, int *__signgamp) noexcept(true);
    extern long double rintl(long double __x) noexcept(truerintl(long double __x) noexcept(true);
    extern long double __rintl(long double __x) noexcept(true__rintl(long double __x) noexcept(true);
    extern long double nextafterl(long double __x, long double __y) noexcept(truenextafterl(long double __x, long double __y) noexcept(true);
    extern long double __nextafterl(long double __x, long double __y) noexcept(true__nextafterl(long double __x, long double __y) noexcept(true);
    extern long double nexttowardl(long double __x, long double __y) noexcept(truenexttowardl(long double __x, long double __y) noexcept(true);
    extern long double __nexttowardl(long double __x, long double __y) noexcept(true__nexttowardl(long double __x, long double __y) noexcept(true);
    extern long double nextdownl(long double __x) noexcept(truenextdownl(long double __x) noexcept(true);
    extern long double __nextdownl(long double __x) noexcept(true__nextdownl(long double __x) noexcept(true);
    extern long double nextupl(long double __x) noexcept(truenextupl(long double __x) noexcept(true);
    extern long double __nextupl(long double __x) noexcept(true__nextupl(long double __x) noexcept(true);
    extern long double remainderl(long double __x, long double __y) noexcept(trueremainderl(long double __x, long double __y) noexcept(true);
    extern long double __remainderl(long double __x, long double __y) noexcept(true__remainderl(long double __x, long double __y) noexcept(true);
    extern long double scalbnl(long double __x, int __n) noexcept(truescalbnl(long double __x, int __n) noexcept(true);
    extern long double __scalbnl(long double __x, int __n) noexcept(true__scalbnl(long double __x, int __n) noexcept(true);
    extern int ilogbl(long double __x) noexcept(trueilogbl(long double __x) noexcept(true);
    extern int __ilogbl(long double __x) noexcept(true__ilogbl(long double __x) noexcept(true);
    extern long llogbl(long double __x) noexcept(truellogbl(long double __x) noexcept(true);
    extern long __llogbl(long double __x) noexcept(true__llogbl(long double __x) noexcept(true);
    extern long double scalblnl(long double __x, long __n) noexcept(truescalblnl(long double __x, long __n) noexcept(true);
    extern long double __scalblnl(long double __x, long __n) noexcept(true__scalblnl(long double __x, long __n) noexcept(true);
    extern long double nearbyintl(long double __x) noexcept(truenearbyintl(long double __x) noexcept(true);
    extern long double __nearbyintl(long double __x) noexcept(true__nearbyintl(long double __x) noexcept(true);
    extern long double roundl(long double __x) noexcept(trueroundl(long double __x) noexcept(true) __attribute__((const));
    extern long double __roundl(long double __x) noexcept(true__roundl(long double __x) noexcept(true) __attribute__((const));
    extern long double truncl(long double __x) noexcept(truetruncl(long double __x) noexcept(true) __attribute__((const));
    extern long double __truncl(long double __x) noexcept(true__truncl(long double __x) noexcept(true) __attribute__((const));
    extern long double remquol(long double __x, long double __y, int *__quo) noexcept(trueremquol(long double __x, long double __y, int *__quo) noexcept(true);
    extern long double __remquol(long double __x, long double __y, int *__quo) noexcept(true__remquol(long double __x, long double __y, int *__quo) noexcept(true);
    extern long lrintl(long double __x) noexcept(truelrintl(long double __x) noexcept(true);
    extern long __lrintl(long double __x) noexcept(true__lrintl(long double __x) noexcept(true);
    extern long long llrintl(long double __x) noexcept(truellrintl(long double __x) noexcept(true);
    extern long long __llrintl(long double __x) noexcept(true__llrintl(long double __x) noexcept(true);
    extern long lroundl(long double __x) noexcept(truelroundl(long double __x) noexcept(true);
    extern long __lroundl(long double __x) noexcept(true__lroundl(long double __x) noexcept(true);
    extern long long llroundl(long double __x) noexcept(truellroundl(long double __x) noexcept(true);
    extern long long __llroundl(long double __x) noexcept(true__llroundl(long double __x) noexcept(true);
    extern long double fdiml(long double __x, long double __y) noexcept(truefdiml(long double __x, long double __y) noexcept(true);
    extern long double __fdiml(long double __x, long double __y) noexcept(true__fdiml(long double __x, long double __y) noexcept(true);
    extern long double fmaxl(long double __x, long double __y) noexcept(truefmaxl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaxl(long double __x, long double __y) noexcept(true__fmaxl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminl(long double __x, long double __y) noexcept(truefminl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminl(long double __x, long double __y) noexcept(true__fminl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmal(long double __x, long double __y, long double __z) noexcept(truefmal(long double __x, long double __y, long double __z) noexcept(true);
    extern long double __fmal(long double __x, long double __y, long double __z) noexcept(true__fmal(long double __x, long double __y, long double __z) noexcept(true);
    extern long double roundevenl(long double __x) noexcept(trueroundevenl(long double __x) noexcept(true) __attribute__((const));
    extern long double __roundevenl(long double __x) noexcept(true__roundevenl(long double __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpl(long double __x, int __round, unsigned int __width) noexcept(truefromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpl(long double __x, int __round, unsigned int __width) noexcept(true__fromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpl(long double __x, int __round, unsigned int __width) noexcept(trueufromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpl(long double __x, int __round, unsigned int __width) noexcept(true__ufromfpl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxl(long double __x, int __round, unsigned int __width) noexcept(truefromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxl(long double __x, int __round, unsigned int __width) noexcept(true__fromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxl(long double __x, int __round, unsigned int __width) noexcept(trueufromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxl(long double __x, int __round, unsigned int __width) noexcept(true__ufromfpxl(long double __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizel(long double *__cx, const long double *__x) noexcept(truecanonicalizel(long double *__cx, const long double *__x) noexcept(true);
    extern long double fmaxmagl(long double __x, long double __y) noexcept(truefmaxmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaxmagl(long double __x, long double __y) noexcept(true__fmaxmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminmagl(long double __x, long double __y) noexcept(truefminmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminmagl(long double __x, long double __y) noexcept(true__fminmagl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximuml(long double __x, long double __y) noexcept(truefmaximuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximuml(long double __x, long double __y) noexcept(true__fmaximuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimuml(long double __x, long double __y) noexcept(truefminimuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimuml(long double __x, long double __y) noexcept(true__fminimuml(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximum_numl(long double __x, long double __y) noexcept(truefmaximum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximum_numl(long double __x, long double __y) noexcept(true__fmaximum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimum_numl(long double __x, long double __y) noexcept(truefminimum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimum_numl(long double __x, long double __y) noexcept(true__fminimum_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximum_magl(long double __x, long double __y) noexcept(truefmaximum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximum_magl(long double __x, long double __y) noexcept(true__fmaximum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimum_magl(long double __x, long double __y) noexcept(truefminimum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimum_magl(long double __x, long double __y) noexcept(true__fminimum_magl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fmaximum_mag_numl(long double __x, long double __y) noexcept(truefmaximum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fmaximum_mag_numl(long double __x, long double __y) noexcept(true__fmaximum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double fminimum_mag_numl(long double __x, long double __y) noexcept(truefminimum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern long double __fminimum_mag_numl(long double __x, long double __y) noexcept(true__fminimum_mag_numl(long double __x, long double __y) noexcept(true) __attribute__((const));
    extern int totalorderl(const long double *__x, const long double *__y) noexcept(truetotalorderl(const long double *__x, const long double *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagl(const long double *__x, const long double *__y) noexcept(truetotalordermagl(const long double *__x, const long double *__y) noexcept(true) __attribute__((pure));
    extern long double getpayloadl(const long double *__x) noexcept(truegetpayloadl(const long double *__x) noexcept(true);
    extern long double __getpayloadl(const long double *__x) noexcept(true__getpayloadl(const long double *__x) noexcept(true);
    extern int setpayloadl(long double *__x, long double __payload) noexcept(truesetpayloadl(long double *__x, long double __payload) noexcept(true);
    extern int setpayloadsigl(long double *__x, long double __payload) noexcept(truesetpayloadsigl(long double *__x, long double __payload) noexcept(true);
    extern long double scalbl(long double __x, long double __n) noexcept(truescalbl(long double __x, long double __n) noexcept(true);
    extern long double __scalbl(long double __x, long double __n) noexcept(true__scalbl(long double __x, long double __n) noexcept(true);
    extern _Float32 acosf32(_Float32 __x) noexcept(trueacosf32(_Float32 __x) noexcept(true);
    extern _Float32 __acosf32(_Float32 __x) noexcept(true__acosf32(_Float32 __x) noexcept(true);
    extern _Float32 asinf32(_Float32 __x) noexcept(trueasinf32(_Float32 __x) noexcept(true);
    extern _Float32 __asinf32(_Float32 __x) noexcept(true__asinf32(_Float32 __x) noexcept(true);
    extern _Float32 atanf32(_Float32 __x) noexcept(trueatanf32(_Float32 __x) noexcept(true);
    extern _Float32 __atanf32(_Float32 __x) noexcept(true__atanf32(_Float32 __x) noexcept(true);
    extern _Float32 atan2f32(_Float32 __y, _Float32 __x) noexcept(trueatan2f32(_Float32 __y, _Float32 __x) noexcept(true);
    extern _Float32 __atan2f32(_Float32 __y, _Float32 __x) noexcept(true__atan2f32(_Float32 __y, _Float32 __x) noexcept(true);
    extern _Float32 cosf32(_Float32 __x) noexcept(truecosf32(_Float32 __x) noexcept(true);
    extern _Float32 __cosf32(_Float32 __x) noexcept(true__cosf32(_Float32 __x) noexcept(true);
    extern _Float32 sinf32(_Float32 __x) noexcept(truesinf32(_Float32 __x) noexcept(true);
    extern _Float32 __sinf32(_Float32 __x) noexcept(true__sinf32(_Float32 __x) noexcept(true);
    extern _Float32 tanf32(_Float32 __x) noexcept(truetanf32(_Float32 __x) noexcept(true);
    extern _Float32 __tanf32(_Float32 __x) noexcept(true__tanf32(_Float32 __x) noexcept(true);
    extern _Float32 coshf32(_Float32 __x) noexcept(truecoshf32(_Float32 __x) noexcept(true);
    extern _Float32 __coshf32(_Float32 __x) noexcept(true__coshf32(_Float32 __x) noexcept(true);
    extern _Float32 sinhf32(_Float32 __x) noexcept(truesinhf32(_Float32 __x) noexcept(true);
    extern _Float32 __sinhf32(_Float32 __x) noexcept(true__sinhf32(_Float32 __x) noexcept(true);
    extern _Float32 tanhf32(_Float32 __x) noexcept(truetanhf32(_Float32 __x) noexcept(true);
    extern _Float32 __tanhf32(_Float32 __x) noexcept(true__tanhf32(_Float32 __x) noexcept(true);
    extern void sincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept(truesincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept(true);
    extern void __sincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept(true__sincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept(true);
    extern _Float32 acoshf32(_Float32 __x) noexcept(trueacoshf32(_Float32 __x) noexcept(true);
    extern _Float32 __acoshf32(_Float32 __x) noexcept(true__acoshf32(_Float32 __x) noexcept(true);
    extern _Float32 asinhf32(_Float32 __x) noexcept(trueasinhf32(_Float32 __x) noexcept(true);
    extern _Float32 __asinhf32(_Float32 __x) noexcept(true__asinhf32(_Float32 __x) noexcept(true);
    extern _Float32 atanhf32(_Float32 __x) noexcept(trueatanhf32(_Float32 __x) noexcept(true);
    extern _Float32 __atanhf32(_Float32 __x) noexcept(true__atanhf32(_Float32 __x) noexcept(true);
    extern _Float32 expf32(_Float32 __x) noexcept(trueexpf32(_Float32 __x) noexcept(true);
    extern _Float32 __expf32(_Float32 __x) noexcept(true__expf32(_Float32 __x) noexcept(true);
    extern _Float32 frexpf32(_Float32 __x, int *__exponent) noexcept(truefrexpf32(_Float32 __x, int *__exponent) noexcept(true);
    extern _Float32 __frexpf32(_Float32 __x, int *__exponent) noexcept(true__frexpf32(_Float32 __x, int *__exponent) noexcept(true);
    extern _Float32 ldexpf32(_Float32 __x, int __exponent) noexcept(trueldexpf32(_Float32 __x, int __exponent) noexcept(true);
    extern _Float32 __ldexpf32(_Float32 __x, int __exponent) noexcept(true__ldexpf32(_Float32 __x, int __exponent) noexcept(true);
    extern _Float32 logf32(_Float32 __x) noexcept(truelogf32(_Float32 __x) noexcept(true);
    extern _Float32 __logf32(_Float32 __x) noexcept(true__logf32(_Float32 __x) noexcept(true);
    extern _Float32 log10f32(_Float32 __x) noexcept(truelog10f32(_Float32 __x) noexcept(true);
    extern _Float32 __log10f32(_Float32 __x) noexcept(true__log10f32(_Float32 __x) noexcept(true);
    extern _Float32 modff32(_Float32 __x, _Float32 *__iptr) noexcept(truemodff32(_Float32 __x, _Float32 *__iptr) noexcept(true);
    extern _Float32 __modff32(_Float32 __x, _Float32 *__iptr) noexcept(true__modff32(_Float32 __x, _Float32 *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float32 exp10f32(_Float32 __x) noexcept(trueexp10f32(_Float32 __x) noexcept(true);
    extern _Float32 __exp10f32(_Float32 __x) noexcept(true__exp10f32(_Float32 __x) noexcept(true);
    extern _Float32 expm1f32(_Float32 __x) noexcept(trueexpm1f32(_Float32 __x) noexcept(true);
    extern _Float32 __expm1f32(_Float32 __x) noexcept(true__expm1f32(_Float32 __x) noexcept(true);
    extern _Float32 log1pf32(_Float32 __x) noexcept(truelog1pf32(_Float32 __x) noexcept(true);
    extern _Float32 __log1pf32(_Float32 __x) noexcept(true__log1pf32(_Float32 __x) noexcept(true);
    extern _Float32 logbf32(_Float32 __x) noexcept(truelogbf32(_Float32 __x) noexcept(true);
    extern _Float32 __logbf32(_Float32 __x) noexcept(true__logbf32(_Float32 __x) noexcept(true);
    extern _Float32 exp2f32(_Float32 __x) noexcept(trueexp2f32(_Float32 __x) noexcept(true);
    extern _Float32 __exp2f32(_Float32 __x) noexcept(true__exp2f32(_Float32 __x) noexcept(true);
    extern _Float32 log2f32(_Float32 __x) noexcept(truelog2f32(_Float32 __x) noexcept(true);
    extern _Float32 __log2f32(_Float32 __x) noexcept(true__log2f32(_Float32 __x) noexcept(true);
    extern _Float32 powf32(_Float32 __x, _Float32 __y) noexcept(truepowf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __powf32(_Float32 __x, _Float32 __y) noexcept(true__powf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 sqrtf32(_Float32 __x) noexcept(truesqrtf32(_Float32 __x) noexcept(true);
    extern _Float32 __sqrtf32(_Float32 __x) noexcept(true__sqrtf32(_Float32 __x) noexcept(true);
    extern _Float32 hypotf32(_Float32 __x, _Float32 __y) noexcept(truehypotf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __hypotf32(_Float32 __x, _Float32 __y) noexcept(true__hypotf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 cbrtf32(_Float32 __x) noexcept(truecbrtf32(_Float32 __x) noexcept(true);
    extern _Float32 __cbrtf32(_Float32 __x) noexcept(true__cbrtf32(_Float32 __x) noexcept(true);
    extern _Float32 ceilf32(_Float32 __x) noexcept(trueceilf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __ceilf32(_Float32 __x) noexcept(true__ceilf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 fabsf32(_Float32 __x) noexcept(truefabsf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __fabsf32(_Float32 __x) noexcept(true__fabsf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 floorf32(_Float32 __x) noexcept(truefloorf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __floorf32(_Float32 __x) noexcept(true__floorf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 fmodf32(_Float32 __x, _Float32 __y) noexcept(truefmodf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __fmodf32(_Float32 __x, _Float32 __y) noexcept(true__fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 copysignf32(_Float32 __x, _Float32 __y) noexcept(truecopysignf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __copysignf32(_Float32 __x, _Float32 __y) noexcept(true__copysignf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 nanf32(const char *__tagb) noexcept(truenanf32(const char *__tagb) noexcept(true);
    extern _Float32 __nanf32(const char *__tagb) noexcept(true__nanf32(const char *__tagb) noexcept(true);
    extern _Float32 j0f32(_Float32) noexcept(truej0f32(_Float32) noexcept(true);
    extern _Float32 __j0f32(_Float32) noexcept(true__j0f32(_Float32) noexcept(true);
    extern _Float32 j1f32(_Float32) noexcept(truej1f32(_Float32) noexcept(true);
    extern _Float32 __j1f32(_Float32) noexcept(true__j1f32(_Float32) noexcept(true);
    extern _Float32 jnf32(int, _Float32) noexcept(truejnf32(int, _Float32) noexcept(true);
    extern _Float32 __jnf32(int, _Float32) noexcept(true__jnf32(int, _Float32) noexcept(true);
    extern _Float32 y0f32(_Float32) noexcept(truey0f32(_Float32) noexcept(true);
    extern _Float32 __y0f32(_Float32) noexcept(true__y0f32(_Float32) noexcept(true);
    extern _Float32 y1f32(_Float32) noexcept(truey1f32(_Float32) noexcept(true);
    extern _Float32 __y1f32(_Float32) noexcept(true__y1f32(_Float32) noexcept(true);
    extern _Float32 ynf32(int, _Float32) noexcept(trueynf32(int, _Float32) noexcept(true);
    extern _Float32 __ynf32(int, _Float32) noexcept(true__ynf32(int, _Float32) noexcept(true);
    extern _Float32 erff32(_Float32) noexcept(trueerff32(_Float32) noexcept(true);
    extern _Float32 __erff32(_Float32) noexcept(true__erff32(_Float32) noexcept(true);
    extern _Float32 erfcf32(_Float32) noexcept(trueerfcf32(_Float32) noexcept(true);
    extern _Float32 __erfcf32(_Float32) noexcept(true__erfcf32(_Float32) noexcept(true);
    extern _Float32 lgammaf32(_Float32) noexcept(truelgammaf32(_Float32) noexcept(true);
    extern _Float32 __lgammaf32(_Float32) noexcept(true__lgammaf32(_Float32) noexcept(true);
    extern _Float32 tgammaf32(_Float32) noexcept(truetgammaf32(_Float32) noexcept(true);
    extern _Float32 __tgammaf32(_Float32) noexcept(true__tgammaf32(_Float32) noexcept(true);
    extern _Float32 lgammaf32_r(_Float32, int *__signgamp) noexcept(truelgammaf32_r(_Float32, int *__signgamp) noexcept(true);
    extern _Float32 __lgammaf32_r(_Float32, int *__signgamp) noexcept(true__lgammaf32_r(_Float32, int *__signgamp) noexcept(true);
    extern _Float32 rintf32(_Float32 __x) noexcept(truerintf32(_Float32 __x) noexcept(true);
    extern _Float32 __rintf32(_Float32 __x) noexcept(true__rintf32(_Float32 __x) noexcept(true);
    extern _Float32 nextafterf32(_Float32 __x, _Float32 __y) noexcept(truenextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __nextafterf32(_Float32 __x, _Float32 __y) noexcept(true__nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 nextdownf32(_Float32 __x) noexcept(truenextdownf32(_Float32 __x) noexcept(true);
    extern _Float32 __nextdownf32(_Float32 __x) noexcept(true__nextdownf32(_Float32 __x) noexcept(true);
    extern _Float32 nextupf32(_Float32 __x) noexcept(truenextupf32(_Float32 __x) noexcept(true);
    extern _Float32 __nextupf32(_Float32 __x) noexcept(true__nextupf32(_Float32 __x) noexcept(true);
    extern _Float32 remainderf32(_Float32 __x, _Float32 __y) noexcept(trueremainderf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __remainderf32(_Float32 __x, _Float32 __y) noexcept(true__remainderf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 scalbnf32(_Float32 __x, int __n) noexcept(truescalbnf32(_Float32 __x, int __n) noexcept(true);
    extern _Float32 __scalbnf32(_Float32 __x, int __n) noexcept(true__scalbnf32(_Float32 __x, int __n) noexcept(true);
    extern int ilogbf32(_Float32 __x) noexcept(trueilogbf32(_Float32 __x) noexcept(true);
    extern int __ilogbf32(_Float32 __x) noexcept(true__ilogbf32(_Float32 __x) noexcept(true);
    extern long llogbf32(_Float32 __x) noexcept(truellogbf32(_Float32 __x) noexcept(true);
    extern long __llogbf32(_Float32 __x) noexcept(true__llogbf32(_Float32 __x) noexcept(true);
    extern _Float32 scalblnf32(_Float32 __x, long __n) noexcept(truescalblnf32(_Float32 __x, long __n) noexcept(true);
    extern _Float32 __scalblnf32(_Float32 __x, long __n) noexcept(true__scalblnf32(_Float32 __x, long __n) noexcept(true);
    extern _Float32 nearbyintf32(_Float32 __x) noexcept(truenearbyintf32(_Float32 __x) noexcept(true);
    extern _Float32 __nearbyintf32(_Float32 __x) noexcept(true__nearbyintf32(_Float32 __x) noexcept(true);
    extern _Float32 roundf32(_Float32 __x) noexcept(trueroundf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __roundf32(_Float32 __x) noexcept(true__roundf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 truncf32(_Float32 __x) noexcept(truetruncf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __truncf32(_Float32 __x) noexcept(true__truncf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 remquof32(_Float32 __x, _Float32 __y, int *__quo) noexcept(trueremquof32(_Float32 __x, _Float32 __y, int *__quo) noexcept(true);
    extern _Float32 __remquof32(_Float32 __x, _Float32 __y, int *__quo) noexcept(true__remquof32(_Float32 __x, _Float32 __y, int *__quo) noexcept(true);
    extern long lrintf32(_Float32 __x) noexcept(truelrintf32(_Float32 __x) noexcept(true);
    extern long __lrintf32(_Float32 __x) noexcept(true__lrintf32(_Float32 __x) noexcept(true);
    extern long long llrintf32(_Float32 __x) noexcept(truellrintf32(_Float32 __x) noexcept(true);
    extern long long __llrintf32(_Float32 __x) noexcept(true__llrintf32(_Float32 __x) noexcept(true);
    extern long lroundf32(_Float32 __x) noexcept(truelroundf32(_Float32 __x) noexcept(true);
    extern long __lroundf32(_Float32 __x) noexcept(true__lroundf32(_Float32 __x) noexcept(true);
    extern long long llroundf32(_Float32 __x) noexcept(truellroundf32(_Float32 __x) noexcept(true);
    extern long long __llroundf32(_Float32 __x) noexcept(true__llroundf32(_Float32 __x) noexcept(true);
    extern _Float32 fdimf32(_Float32 __x, _Float32 __y) noexcept(truefdimf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 __fdimf32(_Float32 __x, _Float32 __y) noexcept(true__fdimf32(_Float32 __x, _Float32 __y) noexcept(true);
    extern _Float32 fmaxf32(_Float32 __x, _Float32 __y) noexcept(truefmaxf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaxf32(_Float32 __x, _Float32 __y) noexcept(true__fmaxf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminf32(_Float32 __x, _Float32 __y) noexcept(truefminf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminf32(_Float32 __x, _Float32 __y) noexcept(true__fminf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(truefmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true);
    extern _Float32 __fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true__fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true);
    extern _Float32 roundevenf32(_Float32 __x) noexcept(trueroundevenf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern _Float32 __roundevenf32(_Float32 __x) noexcept(true__roundevenf32(_Float32 __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(truefromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true__fromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(trueufromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true__ufromfpf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(truefromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true__fromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(trueufromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true__ufromfpxf32(_Float32 __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef32(_Float32 *__cx, const _Float32 *__x) noexcept(truecanonicalizef32(_Float32 *__cx, const _Float32 *__x) noexcept(true);
    extern _Float32 fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(truefmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true__fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminmagf32(_Float32 __x, _Float32 __y) noexcept(truefminmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminmagf32(_Float32 __x, _Float32 __y) noexcept(true__fminmagf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximumf32(_Float32 __x, _Float32 __y) noexcept(truefmaximumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true__fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimumf32(_Float32 __x, _Float32 __y) noexcept(truefminimumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimumf32(_Float32 __x, _Float32 __y) noexcept(true__fminimumf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(truefmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true__fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(truefminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true__fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(truefmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true__fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(truefminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true__fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(truefmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true__fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(truefminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern _Float32 __fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true__fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true) __attribute__((const));
    extern int totalorderf32(const _Float32 *__x, const _Float32 *__y) noexcept(truetotalorderf32(const _Float32 *__x, const _Float32 *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf32(const _Float32 *__x, const _Float32 *__y) noexcept(truetotalordermagf32(const _Float32 *__x, const _Float32 *__y) noexcept(true) __attribute__((pure));
    extern _Float32 getpayloadf32(const _Float32 *__x) noexcept(truegetpayloadf32(const _Float32 *__x) noexcept(true);
    extern _Float32 __getpayloadf32(const _Float32 *__x) noexcept(true__getpayloadf32(const _Float32 *__x) noexcept(true);
    extern int setpayloadf32(_Float32 *__x, _Float32 __payload) noexcept(truesetpayloadf32(_Float32 *__x, _Float32 __payload) noexcept(true);
    extern int setpayloadsigf32(_Float32 *__x, _Float32 __payload) noexcept(truesetpayloadsigf32(_Float32 *__x, _Float32 __payload) noexcept(true);
    extern _Float64 acosf64(_Float64 __x) noexcept(trueacosf64(_Float64 __x) noexcept(true);
    extern _Float64 __acosf64(_Float64 __x) noexcept(true__acosf64(_Float64 __x) noexcept(true);
    extern _Float64 asinf64(_Float64 __x) noexcept(trueasinf64(_Float64 __x) noexcept(true);
    extern _Float64 __asinf64(_Float64 __x) noexcept(true__asinf64(_Float64 __x) noexcept(true);
    extern _Float64 atanf64(_Float64 __x) noexcept(trueatanf64(_Float64 __x) noexcept(true);
    extern _Float64 __atanf64(_Float64 __x) noexcept(true__atanf64(_Float64 __x) noexcept(true);
    extern _Float64 atan2f64(_Float64 __y, _Float64 __x) noexcept(trueatan2f64(_Float64 __y, _Float64 __x) noexcept(true);
    extern _Float64 __atan2f64(_Float64 __y, _Float64 __x) noexcept(true__atan2f64(_Float64 __y, _Float64 __x) noexcept(true);
    extern _Float64 cosf64(_Float64 __x) noexcept(truecosf64(_Float64 __x) noexcept(true);
    extern _Float64 __cosf64(_Float64 __x) noexcept(true__cosf64(_Float64 __x) noexcept(true);
    extern _Float64 sinf64(_Float64 __x) noexcept(truesinf64(_Float64 __x) noexcept(true);
    extern _Float64 __sinf64(_Float64 __x) noexcept(true__sinf64(_Float64 __x) noexcept(true);
    extern _Float64 tanf64(_Float64 __x) noexcept(truetanf64(_Float64 __x) noexcept(true);
    extern _Float64 __tanf64(_Float64 __x) noexcept(true__tanf64(_Float64 __x) noexcept(true);
    extern _Float64 coshf64(_Float64 __x) noexcept(truecoshf64(_Float64 __x) noexcept(true);
    extern _Float64 __coshf64(_Float64 __x) noexcept(true__coshf64(_Float64 __x) noexcept(true);
    extern _Float64 sinhf64(_Float64 __x) noexcept(truesinhf64(_Float64 __x) noexcept(true);
    extern _Float64 __sinhf64(_Float64 __x) noexcept(true__sinhf64(_Float64 __x) noexcept(true);
    extern _Float64 tanhf64(_Float64 __x) noexcept(truetanhf64(_Float64 __x) noexcept(true);
    extern _Float64 __tanhf64(_Float64 __x) noexcept(true__tanhf64(_Float64 __x) noexcept(true);
    extern void sincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept(truesincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept(true);
    extern void __sincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept(true__sincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept(true);
    extern _Float64 acoshf64(_Float64 __x) noexcept(trueacoshf64(_Float64 __x) noexcept(true);
    extern _Float64 __acoshf64(_Float64 __x) noexcept(true__acoshf64(_Float64 __x) noexcept(true);
    extern _Float64 asinhf64(_Float64 __x) noexcept(trueasinhf64(_Float64 __x) noexcept(true);
    extern _Float64 __asinhf64(_Float64 __x) noexcept(true__asinhf64(_Float64 __x) noexcept(true);
    extern _Float64 atanhf64(_Float64 __x) noexcept(trueatanhf64(_Float64 __x) noexcept(true);
    extern _Float64 __atanhf64(_Float64 __x) noexcept(true__atanhf64(_Float64 __x) noexcept(true);
    extern _Float64 expf64(_Float64 __x) noexcept(trueexpf64(_Float64 __x) noexcept(true);
    extern _Float64 __expf64(_Float64 __x) noexcept(true__expf64(_Float64 __x) noexcept(true);
    extern _Float64 frexpf64(_Float64 __x, int *__exponent) noexcept(truefrexpf64(_Float64 __x, int *__exponent) noexcept(true);
    extern _Float64 __frexpf64(_Float64 __x, int *__exponent) noexcept(true__frexpf64(_Float64 __x, int *__exponent) noexcept(true);
    extern _Float64 ldexpf64(_Float64 __x, int __exponent) noexcept(trueldexpf64(_Float64 __x, int __exponent) noexcept(true);
    extern _Float64 __ldexpf64(_Float64 __x, int __exponent) noexcept(true__ldexpf64(_Float64 __x, int __exponent) noexcept(true);
    extern _Float64 logf64(_Float64 __x) noexcept(truelogf64(_Float64 __x) noexcept(true);
    extern _Float64 __logf64(_Float64 __x) noexcept(true__logf64(_Float64 __x) noexcept(true);
    extern _Float64 log10f64(_Float64 __x) noexcept(truelog10f64(_Float64 __x) noexcept(true);
    extern _Float64 __log10f64(_Float64 __x) noexcept(true__log10f64(_Float64 __x) noexcept(true);
    extern _Float64 modff64(_Float64 __x, _Float64 *__iptr) noexcept(truemodff64(_Float64 __x, _Float64 *__iptr) noexcept(true);
    extern _Float64 __modff64(_Float64 __x, _Float64 *__iptr) noexcept(true__modff64(_Float64 __x, _Float64 *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float64 exp10f64(_Float64 __x) noexcept(trueexp10f64(_Float64 __x) noexcept(true);
    extern _Float64 __exp10f64(_Float64 __x) noexcept(true__exp10f64(_Float64 __x) noexcept(true);
    extern _Float64 expm1f64(_Float64 __x) noexcept(trueexpm1f64(_Float64 __x) noexcept(true);
    extern _Float64 __expm1f64(_Float64 __x) noexcept(true__expm1f64(_Float64 __x) noexcept(true);
    extern _Float64 log1pf64(_Float64 __x) noexcept(truelog1pf64(_Float64 __x) noexcept(true);
    extern _Float64 __log1pf64(_Float64 __x) noexcept(true__log1pf64(_Float64 __x) noexcept(true);
    extern _Float64 logbf64(_Float64 __x) noexcept(truelogbf64(_Float64 __x) noexcept(true);
    extern _Float64 __logbf64(_Float64 __x) noexcept(true__logbf64(_Float64 __x) noexcept(true);
    extern _Float64 exp2f64(_Float64 __x) noexcept(trueexp2f64(_Float64 __x) noexcept(true);
    extern _Float64 __exp2f64(_Float64 __x) noexcept(true__exp2f64(_Float64 __x) noexcept(true);
    extern _Float64 log2f64(_Float64 __x) noexcept(truelog2f64(_Float64 __x) noexcept(true);
    extern _Float64 __log2f64(_Float64 __x) noexcept(true__log2f64(_Float64 __x) noexcept(true);
    extern _Float64 powf64(_Float64 __x, _Float64 __y) noexcept(truepowf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __powf64(_Float64 __x, _Float64 __y) noexcept(true__powf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 sqrtf64(_Float64 __x) noexcept(truesqrtf64(_Float64 __x) noexcept(true);
    extern _Float64 __sqrtf64(_Float64 __x) noexcept(true__sqrtf64(_Float64 __x) noexcept(true);
    extern _Float64 hypotf64(_Float64 __x, _Float64 __y) noexcept(truehypotf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __hypotf64(_Float64 __x, _Float64 __y) noexcept(true__hypotf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 cbrtf64(_Float64 __x) noexcept(truecbrtf64(_Float64 __x) noexcept(true);
    extern _Float64 __cbrtf64(_Float64 __x) noexcept(true__cbrtf64(_Float64 __x) noexcept(true);
    extern _Float64 ceilf64(_Float64 __x) noexcept(trueceilf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __ceilf64(_Float64 __x) noexcept(true__ceilf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 fabsf64(_Float64 __x) noexcept(truefabsf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __fabsf64(_Float64 __x) noexcept(true__fabsf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 floorf64(_Float64 __x) noexcept(truefloorf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __floorf64(_Float64 __x) noexcept(true__floorf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 fmodf64(_Float64 __x, _Float64 __y) noexcept(truefmodf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __fmodf64(_Float64 __x, _Float64 __y) noexcept(true__fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 copysignf64(_Float64 __x, _Float64 __y) noexcept(truecopysignf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __copysignf64(_Float64 __x, _Float64 __y) noexcept(true__copysignf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 nanf64(const char *__tagb) noexcept(truenanf64(const char *__tagb) noexcept(true);
    extern _Float64 __nanf64(const char *__tagb) noexcept(true__nanf64(const char *__tagb) noexcept(true);
    extern _Float64 j0f64(_Float64) noexcept(truej0f64(_Float64) noexcept(true);
    extern _Float64 __j0f64(_Float64) noexcept(true__j0f64(_Float64) noexcept(true);
    extern _Float64 j1f64(_Float64) noexcept(truej1f64(_Float64) noexcept(true);
    extern _Float64 __j1f64(_Float64) noexcept(true__j1f64(_Float64) noexcept(true);
    extern _Float64 jnf64(int, _Float64) noexcept(truejnf64(int, _Float64) noexcept(true);
    extern _Float64 __jnf64(int, _Float64) noexcept(true__jnf64(int, _Float64) noexcept(true);
    extern _Float64 y0f64(_Float64) noexcept(truey0f64(_Float64) noexcept(true);
    extern _Float64 __y0f64(_Float64) noexcept(true__y0f64(_Float64) noexcept(true);
    extern _Float64 y1f64(_Float64) noexcept(truey1f64(_Float64) noexcept(true);
    extern _Float64 __y1f64(_Float64) noexcept(true__y1f64(_Float64) noexcept(true);
    extern _Float64 ynf64(int, _Float64) noexcept(trueynf64(int, _Float64) noexcept(true);
    extern _Float64 __ynf64(int, _Float64) noexcept(true__ynf64(int, _Float64) noexcept(true);
    extern _Float64 erff64(_Float64) noexcept(trueerff64(_Float64) noexcept(true);
    extern _Float64 __erff64(_Float64) noexcept(true__erff64(_Float64) noexcept(true);
    extern _Float64 erfcf64(_Float64) noexcept(trueerfcf64(_Float64) noexcept(true);
    extern _Float64 __erfcf64(_Float64) noexcept(true__erfcf64(_Float64) noexcept(true);
    extern _Float64 lgammaf64(_Float64) noexcept(truelgammaf64(_Float64) noexcept(true);
    extern _Float64 __lgammaf64(_Float64) noexcept(true__lgammaf64(_Float64) noexcept(true);
    extern _Float64 tgammaf64(_Float64) noexcept(truetgammaf64(_Float64) noexcept(true);
    extern _Float64 __tgammaf64(_Float64) noexcept(true__tgammaf64(_Float64) noexcept(true);
    extern _Float64 lgammaf64_r(_Float64, int *__signgamp) noexcept(truelgammaf64_r(_Float64, int *__signgamp) noexcept(true);
    extern _Float64 __lgammaf64_r(_Float64, int *__signgamp) noexcept(true__lgammaf64_r(_Float64, int *__signgamp) noexcept(true);
    extern _Float64 rintf64(_Float64 __x) noexcept(truerintf64(_Float64 __x) noexcept(true);
    extern _Float64 __rintf64(_Float64 __x) noexcept(true__rintf64(_Float64 __x) noexcept(true);
    extern _Float64 nextafterf64(_Float64 __x, _Float64 __y) noexcept(truenextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __nextafterf64(_Float64 __x, _Float64 __y) noexcept(true__nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 nextdownf64(_Float64 __x) noexcept(truenextdownf64(_Float64 __x) noexcept(true);
    extern _Float64 __nextdownf64(_Float64 __x) noexcept(true__nextdownf64(_Float64 __x) noexcept(true);
    extern _Float64 nextupf64(_Float64 __x) noexcept(truenextupf64(_Float64 __x) noexcept(true);
    extern _Float64 __nextupf64(_Float64 __x) noexcept(true__nextupf64(_Float64 __x) noexcept(true);
    extern _Float64 remainderf64(_Float64 __x, _Float64 __y) noexcept(trueremainderf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __remainderf64(_Float64 __x, _Float64 __y) noexcept(true__remainderf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 scalbnf64(_Float64 __x, int __n) noexcept(truescalbnf64(_Float64 __x, int __n) noexcept(true);
    extern _Float64 __scalbnf64(_Float64 __x, int __n) noexcept(true__scalbnf64(_Float64 __x, int __n) noexcept(true);
    extern int ilogbf64(_Float64 __x) noexcept(trueilogbf64(_Float64 __x) noexcept(true);
    extern int __ilogbf64(_Float64 __x) noexcept(true__ilogbf64(_Float64 __x) noexcept(true);
    extern long llogbf64(_Float64 __x) noexcept(truellogbf64(_Float64 __x) noexcept(true);
    extern long __llogbf64(_Float64 __x) noexcept(true__llogbf64(_Float64 __x) noexcept(true);
    extern _Float64 scalblnf64(_Float64 __x, long __n) noexcept(truescalblnf64(_Float64 __x, long __n) noexcept(true);
    extern _Float64 __scalblnf64(_Float64 __x, long __n) noexcept(true__scalblnf64(_Float64 __x, long __n) noexcept(true);
    extern _Float64 nearbyintf64(_Float64 __x) noexcept(truenearbyintf64(_Float64 __x) noexcept(true);
    extern _Float64 __nearbyintf64(_Float64 __x) noexcept(true__nearbyintf64(_Float64 __x) noexcept(true);
    extern _Float64 roundf64(_Float64 __x) noexcept(trueroundf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __roundf64(_Float64 __x) noexcept(true__roundf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 truncf64(_Float64 __x) noexcept(truetruncf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __truncf64(_Float64 __x) noexcept(true__truncf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 remquof64(_Float64 __x, _Float64 __y, int *__quo) noexcept(trueremquof64(_Float64 __x, _Float64 __y, int *__quo) noexcept(true);
    extern _Float64 __remquof64(_Float64 __x, _Float64 __y, int *__quo) noexcept(true__remquof64(_Float64 __x, _Float64 __y, int *__quo) noexcept(true);
    extern long lrintf64(_Float64 __x) noexcept(truelrintf64(_Float64 __x) noexcept(true);
    extern long __lrintf64(_Float64 __x) noexcept(true__lrintf64(_Float64 __x) noexcept(true);
    extern long long llrintf64(_Float64 __x) noexcept(truellrintf64(_Float64 __x) noexcept(true);
    extern long long __llrintf64(_Float64 __x) noexcept(true__llrintf64(_Float64 __x) noexcept(true);
    extern long lroundf64(_Float64 __x) noexcept(truelroundf64(_Float64 __x) noexcept(true);
    extern long __lroundf64(_Float64 __x) noexcept(true__lroundf64(_Float64 __x) noexcept(true);
    extern long long llroundf64(_Float64 __x) noexcept(truellroundf64(_Float64 __x) noexcept(true);
    extern long long __llroundf64(_Float64 __x) noexcept(true__llroundf64(_Float64 __x) noexcept(true);
    extern _Float64 fdimf64(_Float64 __x, _Float64 __y) noexcept(truefdimf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 __fdimf64(_Float64 __x, _Float64 __y) noexcept(true__fdimf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float64 fmaxf64(_Float64 __x, _Float64 __y) noexcept(truefmaxf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaxf64(_Float64 __x, _Float64 __y) noexcept(true__fmaxf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminf64(_Float64 __x, _Float64 __y) noexcept(truefminf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminf64(_Float64 __x, _Float64 __y) noexcept(true__fminf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(truefmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float64 __fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true__fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float64 roundevenf64(_Float64 __x) noexcept(trueroundevenf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern _Float64 __roundevenf64(_Float64 __x) noexcept(true__roundevenf64(_Float64 __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(truefromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true__fromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(trueufromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true__ufromfpf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(truefromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true__fromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(trueufromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true__ufromfpxf64(_Float64 __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef64(_Float64 *__cx, const _Float64 *__x) noexcept(truecanonicalizef64(_Float64 *__cx, const _Float64 *__x) noexcept(true);
    extern _Float64 fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(truefmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true__fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminmagf64(_Float64 __x, _Float64 __y) noexcept(truefminmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminmagf64(_Float64 __x, _Float64 __y) noexcept(true__fminmagf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximumf64(_Float64 __x, _Float64 __y) noexcept(truefmaximumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true__fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimumf64(_Float64 __x, _Float64 __y) noexcept(truefminimumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimumf64(_Float64 __x, _Float64 __y) noexcept(true__fminimumf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(truefmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true__fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(truefminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true__fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(truefmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true__fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(truefminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true__fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(truefmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true__fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(truefminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern _Float64 __fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true__fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true) __attribute__((const));
    extern int totalorderf64(const _Float64 *__x, const _Float64 *__y) noexcept(truetotalorderf64(const _Float64 *__x, const _Float64 *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf64(const _Float64 *__x, const _Float64 *__y) noexcept(truetotalordermagf64(const _Float64 *__x, const _Float64 *__y) noexcept(true) __attribute__((pure));
    extern _Float64 getpayloadf64(const _Float64 *__x) noexcept(truegetpayloadf64(const _Float64 *__x) noexcept(true);
    extern _Float64 __getpayloadf64(const _Float64 *__x) noexcept(true__getpayloadf64(const _Float64 *__x) noexcept(true);
    extern int setpayloadf64(_Float64 *__x, _Float64 __payload) noexcept(truesetpayloadf64(_Float64 *__x, _Float64 __payload) noexcept(true);
    extern int setpayloadsigf64(_Float64 *__x, _Float64 __payload) noexcept(truesetpayloadsigf64(_Float64 *__x, _Float64 __payload) noexcept(true);
    extern _Float32x acosf32x(_Float32x __x) noexcept(trueacosf32x(_Float32x __x) noexcept(true);
    extern _Float32x __acosf32x(_Float32x __x) noexcept(true__acosf32x(_Float32x __x) noexcept(true);
    extern _Float32x asinf32x(_Float32x __x) noexcept(trueasinf32x(_Float32x __x) noexcept(true);
    extern _Float32x __asinf32x(_Float32x __x) noexcept(true__asinf32x(_Float32x __x) noexcept(true);
    extern _Float32x atanf32x(_Float32x __x) noexcept(trueatanf32x(_Float32x __x) noexcept(true);
    extern _Float32x __atanf32x(_Float32x __x) noexcept(true__atanf32x(_Float32x __x) noexcept(true);
    extern _Float32x atan2f32x(_Float32x __y, _Float32x __x) noexcept(trueatan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
    extern _Float32x __atan2f32x(_Float32x __y, _Float32x __x) noexcept(true__atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
    extern _Float32x cosf32x(_Float32x __x) noexcept(truecosf32x(_Float32x __x) noexcept(true);
    extern _Float32x __cosf32x(_Float32x __x) noexcept(true__cosf32x(_Float32x __x) noexcept(true);
    extern _Float32x sinf32x(_Float32x __x) noexcept(truesinf32x(_Float32x __x) noexcept(true);
    extern _Float32x __sinf32x(_Float32x __x) noexcept(true__sinf32x(_Float32x __x) noexcept(true);
    extern _Float32x tanf32x(_Float32x __x) noexcept(truetanf32x(_Float32x __x) noexcept(true);
    extern _Float32x __tanf32x(_Float32x __x) noexcept(true__tanf32x(_Float32x __x) noexcept(true);
    extern _Float32x coshf32x(_Float32x __x) noexcept(truecoshf32x(_Float32x __x) noexcept(true);
    extern _Float32x __coshf32x(_Float32x __x) noexcept(true__coshf32x(_Float32x __x) noexcept(true);
    extern _Float32x sinhf32x(_Float32x __x) noexcept(truesinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __sinhf32x(_Float32x __x) noexcept(true__sinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x tanhf32x(_Float32x __x) noexcept(truetanhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __tanhf32x(_Float32x __x) noexcept(true__tanhf32x(_Float32x __x) noexcept(true);
    extern void sincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept(truesincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept(true);
    extern void __sincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept(true__sincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept(true);
    extern _Float32x acoshf32x(_Float32x __x) noexcept(trueacoshf32x(_Float32x __x) noexcept(true);
    extern _Float32x __acoshf32x(_Float32x __x) noexcept(true__acoshf32x(_Float32x __x) noexcept(true);
    extern _Float32x asinhf32x(_Float32x __x) noexcept(trueasinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __asinhf32x(_Float32x __x) noexcept(true__asinhf32x(_Float32x __x) noexcept(true);
    extern _Float32x atanhf32x(_Float32x __x) noexcept(trueatanhf32x(_Float32x __x) noexcept(true);
    extern _Float32x __atanhf32x(_Float32x __x) noexcept(true__atanhf32x(_Float32x __x) noexcept(true);
    extern _Float32x expf32x(_Float32x __x) noexcept(trueexpf32x(_Float32x __x) noexcept(true);
    extern _Float32x __expf32x(_Float32x __x) noexcept(true__expf32x(_Float32x __x) noexcept(true);
    extern _Float32x frexpf32x(_Float32x __x, int *__exponent) noexcept(truefrexpf32x(_Float32x __x, int *__exponent) noexcept(true);
    extern _Float32x __frexpf32x(_Float32x __x, int *__exponent) noexcept(true__frexpf32x(_Float32x __x, int *__exponent) noexcept(true);
    extern _Float32x ldexpf32x(_Float32x __x, int __exponent) noexcept(trueldexpf32x(_Float32x __x, int __exponent) noexcept(true);
    extern _Float32x __ldexpf32x(_Float32x __x, int __exponent) noexcept(true__ldexpf32x(_Float32x __x, int __exponent) noexcept(true);
    extern _Float32x logf32x(_Float32x __x) noexcept(truelogf32x(_Float32x __x) noexcept(true);
    extern _Float32x __logf32x(_Float32x __x) noexcept(true__logf32x(_Float32x __x) noexcept(true);
    extern _Float32x log10f32x(_Float32x __x) noexcept(truelog10f32x(_Float32x __x) noexcept(true);
    extern _Float32x __log10f32x(_Float32x __x) noexcept(true__log10f32x(_Float32x __x) noexcept(true);
    extern _Float32x modff32x(_Float32x __x, _Float32x *__iptr) noexcept(truemodff32x(_Float32x __x, _Float32x *__iptr) noexcept(true);
    extern _Float32x __modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true__modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float32x exp10f32x(_Float32x __x) noexcept(trueexp10f32x(_Float32x __x) noexcept(true);
    extern _Float32x __exp10f32x(_Float32x __x) noexcept(true__exp10f32x(_Float32x __x) noexcept(true);
    extern _Float32x expm1f32x(_Float32x __x) noexcept(trueexpm1f32x(_Float32x __x) noexcept(true);
    extern _Float32x __expm1f32x(_Float32x __x) noexcept(true__expm1f32x(_Float32x __x) noexcept(true);
    extern _Float32x log1pf32x(_Float32x __x) noexcept(truelog1pf32x(_Float32x __x) noexcept(true);
    extern _Float32x __log1pf32x(_Float32x __x) noexcept(true__log1pf32x(_Float32x __x) noexcept(true);
    extern _Float32x logbf32x(_Float32x __x) noexcept(truelogbf32x(_Float32x __x) noexcept(true);
    extern _Float32x __logbf32x(_Float32x __x) noexcept(true__logbf32x(_Float32x __x) noexcept(true);
    extern _Float32x exp2f32x(_Float32x __x) noexcept(trueexp2f32x(_Float32x __x) noexcept(true);
    extern _Float32x __exp2f32x(_Float32x __x) noexcept(true__exp2f32x(_Float32x __x) noexcept(true);
    extern _Float32x log2f32x(_Float32x __x) noexcept(truelog2f32x(_Float32x __x) noexcept(true);
    extern _Float32x __log2f32x(_Float32x __x) noexcept(true__log2f32x(_Float32x __x) noexcept(true);
    extern _Float32x powf32x(_Float32x __x, _Float32x __y) noexcept(truepowf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __powf32x(_Float32x __x, _Float32x __y) noexcept(true__powf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x sqrtf32x(_Float32x __x) noexcept(truesqrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x __sqrtf32x(_Float32x __x) noexcept(true__sqrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x hypotf32x(_Float32x __x, _Float32x __y) noexcept(truehypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __hypotf32x(_Float32x __x, _Float32x __y) noexcept(true__hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x cbrtf32x(_Float32x __x) noexcept(truecbrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x __cbrtf32x(_Float32x __x) noexcept(true__cbrtf32x(_Float32x __x) noexcept(true);
    extern _Float32x ceilf32x(_Float32x __x) noexcept(trueceilf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __ceilf32x(_Float32x __x) noexcept(true__ceilf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x fabsf32x(_Float32x __x) noexcept(truefabsf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __fabsf32x(_Float32x __x) noexcept(true__fabsf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x floorf32x(_Float32x __x) noexcept(truefloorf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __floorf32x(_Float32x __x) noexcept(true__floorf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x fmodf32x(_Float32x __x, _Float32x __y) noexcept(truefmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __fmodf32x(_Float32x __x, _Float32x __y) noexcept(true__fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x copysignf32x(_Float32x __x, _Float32x __y) noexcept(truecopysignf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __copysignf32x(_Float32x __x, _Float32x __y) noexcept(true__copysignf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x nanf32x(const char *__tagb) noexcept(truenanf32x(const char *__tagb) noexcept(true);
    extern _Float32x __nanf32x(const char *__tagb) noexcept(true__nanf32x(const char *__tagb) noexcept(true);
    extern _Float32x j0f32x(_Float32x) noexcept(truej0f32x(_Float32x) noexcept(true);
    extern _Float32x __j0f32x(_Float32x) noexcept(true__j0f32x(_Float32x) noexcept(true);
    extern _Float32x j1f32x(_Float32x) noexcept(truej1f32x(_Float32x) noexcept(true);
    extern _Float32x __j1f32x(_Float32x) noexcept(true__j1f32x(_Float32x) noexcept(true);
    extern _Float32x jnf32x(int, _Float32x) noexcept(truejnf32x(int, _Float32x) noexcept(true);
    extern _Float32x __jnf32x(int, _Float32x) noexcept(true__jnf32x(int, _Float32x) noexcept(true);
    extern _Float32x y0f32x(_Float32x) noexcept(truey0f32x(_Float32x) noexcept(true);
    extern _Float32x __y0f32x(_Float32x) noexcept(true__y0f32x(_Float32x) noexcept(true);
    extern _Float32x y1f32x(_Float32x) noexcept(truey1f32x(_Float32x) noexcept(true);
    extern _Float32x __y1f32x(_Float32x) noexcept(true__y1f32x(_Float32x) noexcept(true);
    extern _Float32x ynf32x(int, _Float32x) noexcept(trueynf32x(int, _Float32x) noexcept(true);
    extern _Float32x __ynf32x(int, _Float32x) noexcept(true__ynf32x(int, _Float32x) noexcept(true);
    extern _Float32x erff32x(_Float32x) noexcept(trueerff32x(_Float32x) noexcept(true);
    extern _Float32x __erff32x(_Float32x) noexcept(true__erff32x(_Float32x) noexcept(true);
    extern _Float32x erfcf32x(_Float32x) noexcept(trueerfcf32x(_Float32x) noexcept(true);
    extern _Float32x __erfcf32x(_Float32x) noexcept(true__erfcf32x(_Float32x) noexcept(true);
    extern _Float32x lgammaf32x(_Float32x) noexcept(truelgammaf32x(_Float32x) noexcept(true);
    extern _Float32x __lgammaf32x(_Float32x) noexcept(true__lgammaf32x(_Float32x) noexcept(true);
    extern _Float32x tgammaf32x(_Float32x) noexcept(truetgammaf32x(_Float32x) noexcept(true);
    extern _Float32x __tgammaf32x(_Float32x) noexcept(true__tgammaf32x(_Float32x) noexcept(true);
    extern _Float32x lgammaf32x_r(_Float32x, int *__signgamp) noexcept(truelgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
    extern _Float32x __lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true__lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
    extern _Float32x rintf32x(_Float32x __x) noexcept(truerintf32x(_Float32x __x) noexcept(true);
    extern _Float32x __rintf32x(_Float32x __x) noexcept(true__rintf32x(_Float32x __x) noexcept(true);
    extern _Float32x nextafterf32x(_Float32x __x, _Float32x __y) noexcept(truenextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true__nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x nextdownf32x(_Float32x __x) noexcept(truenextdownf32x(_Float32x __x) noexcept(true);
    extern _Float32x __nextdownf32x(_Float32x __x) noexcept(true__nextdownf32x(_Float32x __x) noexcept(true);
    extern _Float32x nextupf32x(_Float32x __x) noexcept(truenextupf32x(_Float32x __x) noexcept(true);
    extern _Float32x __nextupf32x(_Float32x __x) noexcept(true__nextupf32x(_Float32x __x) noexcept(true);
    extern _Float32x remainderf32x(_Float32x __x, _Float32x __y) noexcept(trueremainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __remainderf32x(_Float32x __x, _Float32x __y) noexcept(true__remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x scalbnf32x(_Float32x __x, int __n) noexcept(truescalbnf32x(_Float32x __x, int __n) noexcept(true);
    extern _Float32x __scalbnf32x(_Float32x __x, int __n) noexcept(true__scalbnf32x(_Float32x __x, int __n) noexcept(true);
    extern int ilogbf32x(_Float32x __x) noexcept(trueilogbf32x(_Float32x __x) noexcept(true);
    extern int __ilogbf32x(_Float32x __x) noexcept(true__ilogbf32x(_Float32x __x) noexcept(true);
    extern long llogbf32x(_Float32x __x) noexcept(truellogbf32x(_Float32x __x) noexcept(true);
    extern long __llogbf32x(_Float32x __x) noexcept(true__llogbf32x(_Float32x __x) noexcept(true);
    extern _Float32x scalblnf32x(_Float32x __x, long __n) noexcept(truescalblnf32x(_Float32x __x, long __n) noexcept(true);
    extern _Float32x __scalblnf32x(_Float32x __x, long __n) noexcept(true__scalblnf32x(_Float32x __x, long __n) noexcept(true);
    extern _Float32x nearbyintf32x(_Float32x __x) noexcept(truenearbyintf32x(_Float32x __x) noexcept(true);
    extern _Float32x __nearbyintf32x(_Float32x __x) noexcept(true__nearbyintf32x(_Float32x __x) noexcept(true);
    extern _Float32x roundf32x(_Float32x __x) noexcept(trueroundf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __roundf32x(_Float32x __x) noexcept(true__roundf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x truncf32x(_Float32x __x) noexcept(truetruncf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __truncf32x(_Float32x __x) noexcept(true__truncf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x remquof32x(_Float32x __x, _Float32x __y, int *__quo) noexcept(trueremquof32x(_Float32x __x, _Float32x __y, int *__quo) noexcept(true);
    extern _Float32x __remquof32x(_Float32x __x, _Float32x __y, int *__quo) noexcept(true__remquof32x(_Float32x __x, _Float32x __y, int *__quo) noexcept(true);
    extern long lrintf32x(_Float32x __x) noexcept(truelrintf32x(_Float32x __x) noexcept(true);
    extern long __lrintf32x(_Float32x __x) noexcept(true__lrintf32x(_Float32x __x) noexcept(true);
    extern long long llrintf32x(_Float32x __x) noexcept(truellrintf32x(_Float32x __x) noexcept(true);
    extern long long __llrintf32x(_Float32x __x) noexcept(true__llrintf32x(_Float32x __x) noexcept(true);
    extern long lroundf32x(_Float32x __x) noexcept(truelroundf32x(_Float32x __x) noexcept(true);
    extern long __lroundf32x(_Float32x __x) noexcept(true__lroundf32x(_Float32x __x) noexcept(true);
    extern long long llroundf32x(_Float32x __x) noexcept(truellroundf32x(_Float32x __x) noexcept(true);
    extern long long __llroundf32x(_Float32x __x) noexcept(true__llroundf32x(_Float32x __x) noexcept(true);
    extern _Float32x fdimf32x(_Float32x __x, _Float32x __y) noexcept(truefdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x __fdimf32x(_Float32x __x, _Float32x __y) noexcept(true__fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32x fmaxf32x(_Float32x __x, _Float32x __y) noexcept(truefmaxf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true__fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminf32x(_Float32x __x, _Float32x __y) noexcept(truefminf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminf32x(_Float32x __x, _Float32x __y) noexcept(true__fminf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(truefmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(true);
    extern _Float32x __fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(true__fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(true);
    extern _Float32x roundevenf32x(_Float32x __x) noexcept(trueroundevenf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern _Float32x __roundevenf32x(_Float32x __x) noexcept(true__roundevenf32x(_Float32x __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(truefromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true__fromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(trueufromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true__ufromfpf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(truefromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true__fromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(trueufromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true__ufromfpxf32x(_Float32x __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef32x(_Float32x *__cx, const _Float32x *__x) noexcept(truecanonicalizef32x(_Float32x *__cx, const _Float32x *__x) noexcept(true);
    extern _Float32x fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(truefmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true__fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminmagf32x(_Float32x __x, _Float32x __y) noexcept(truefminmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true__fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(truefmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true__fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimumf32x(_Float32x __x, _Float32x __y) noexcept(truefminimumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true__fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(truefmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true__fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(truefminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true__fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(truefmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true__fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(truefminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true__fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fmaximum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(truefmaximum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fmaximum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true__fmaximum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x fminimum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(truefminimum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern _Float32x __fminimum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true__fminimum_mag_numf32x(_Float32x __x, _Float32x __y) noexcept(true) __attribute__((const));
    extern int totalorderf32x(const _Float32x *__x, const _Float32x *__y) noexcept(truetotalorderf32x(const _Float32x *__x, const _Float32x *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf32x(const _Float32x *__x, const _Float32x *__y) noexcept(truetotalordermagf32x(const _Float32x *__x, const _Float32x *__y) noexcept(true) __attribute__((pure));
    extern _Float32x getpayloadf32x(const _Float32x *__x) noexcept(truegetpayloadf32x(const _Float32x *__x) noexcept(true);
    extern _Float32x __getpayloadf32x(const _Float32x *__x) noexcept(true__getpayloadf32x(const _Float32x *__x) noexcept(true);
    extern int setpayloadf32x(_Float32x *__x, _Float32x __payload) noexcept(truesetpayloadf32x(_Float32x *__x, _Float32x __payload) noexcept(true);
    extern int setpayloadsigf32x(_Float32x *__x, _Float32x __payload) noexcept(truesetpayloadsigf32x(_Float32x *__x, _Float32x __payload) noexcept(true);
    extern _Float64x acosf64x(_Float64x __x) noexcept(trueacosf64x(_Float64x __x) noexcept(true);
    extern _Float64x __acosf64x(_Float64x __x) noexcept(true__acosf64x(_Float64x __x) noexcept(true);
    extern _Float64x asinf64x(_Float64x __x) noexcept(trueasinf64x(_Float64x __x) noexcept(true);
    extern _Float64x __asinf64x(_Float64x __x) noexcept(true__asinf64x(_Float64x __x) noexcept(true);
    extern _Float64x atanf64x(_Float64x __x) noexcept(trueatanf64x(_Float64x __x) noexcept(true);
    extern _Float64x __atanf64x(_Float64x __x) noexcept(true__atanf64x(_Float64x __x) noexcept(true);
    extern _Float64x atan2f64x(_Float64x __y, _Float64x __x) noexcept(trueatan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
    extern _Float64x __atan2f64x(_Float64x __y, _Float64x __x) noexcept(true__atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
    extern _Float64x cosf64x(_Float64x __x) noexcept(truecosf64x(_Float64x __x) noexcept(true);
    extern _Float64x __cosf64x(_Float64x __x) noexcept(true__cosf64x(_Float64x __x) noexcept(true);
    extern _Float64x sinf64x(_Float64x __x) noexcept(truesinf64x(_Float64x __x) noexcept(true);
    extern _Float64x __sinf64x(_Float64x __x) noexcept(true__sinf64x(_Float64x __x) noexcept(true);
    extern _Float64x tanf64x(_Float64x __x) noexcept(truetanf64x(_Float64x __x) noexcept(true);
    extern _Float64x __tanf64x(_Float64x __x) noexcept(true__tanf64x(_Float64x __x) noexcept(true);
    extern _Float64x coshf64x(_Float64x __x) noexcept(truecoshf64x(_Float64x __x) noexcept(true);
    extern _Float64x __coshf64x(_Float64x __x) noexcept(true__coshf64x(_Float64x __x) noexcept(true);
    extern _Float64x sinhf64x(_Float64x __x) noexcept(truesinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __sinhf64x(_Float64x __x) noexcept(true__sinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x tanhf64x(_Float64x __x) noexcept(truetanhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __tanhf64x(_Float64x __x) noexcept(true__tanhf64x(_Float64x __x) noexcept(true);
    extern void sincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept(truesincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept(true);
    extern void __sincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept(true__sincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept(true);
    extern _Float64x acoshf64x(_Float64x __x) noexcept(trueacoshf64x(_Float64x __x) noexcept(true);
    extern _Float64x __acoshf64x(_Float64x __x) noexcept(true__acoshf64x(_Float64x __x) noexcept(true);
    extern _Float64x asinhf64x(_Float64x __x) noexcept(trueasinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __asinhf64x(_Float64x __x) noexcept(true__asinhf64x(_Float64x __x) noexcept(true);
    extern _Float64x atanhf64x(_Float64x __x) noexcept(trueatanhf64x(_Float64x __x) noexcept(true);
    extern _Float64x __atanhf64x(_Float64x __x) noexcept(true__atanhf64x(_Float64x __x) noexcept(true);
    extern _Float64x expf64x(_Float64x __x) noexcept(trueexpf64x(_Float64x __x) noexcept(true);
    extern _Float64x __expf64x(_Float64x __x) noexcept(true__expf64x(_Float64x __x) noexcept(true);
    extern _Float64x frexpf64x(_Float64x __x, int *__exponent) noexcept(truefrexpf64x(_Float64x __x, int *__exponent) noexcept(true);
    extern _Float64x __frexpf64x(_Float64x __x, int *__exponent) noexcept(true__frexpf64x(_Float64x __x, int *__exponent) noexcept(true);
    extern _Float64x ldexpf64x(_Float64x __x, int __exponent) noexcept(trueldexpf64x(_Float64x __x, int __exponent) noexcept(true);
    extern _Float64x __ldexpf64x(_Float64x __x, int __exponent) noexcept(true__ldexpf64x(_Float64x __x, int __exponent) noexcept(true);
    extern _Float64x logf64x(_Float64x __x) noexcept(truelogf64x(_Float64x __x) noexcept(true);
    extern _Float64x __logf64x(_Float64x __x) noexcept(true__logf64x(_Float64x __x) noexcept(true);
    extern _Float64x log10f64x(_Float64x __x) noexcept(truelog10f64x(_Float64x __x) noexcept(true);
    extern _Float64x __log10f64x(_Float64x __x) noexcept(true__log10f64x(_Float64x __x) noexcept(true);
    extern _Float64x modff64x(_Float64x __x, _Float64x *__iptr) noexcept(truemodff64x(_Float64x __x, _Float64x *__iptr) noexcept(true);
    extern _Float64x __modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true__modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true) __attribute__((nonnull(2)));
    extern _Float64x exp10f64x(_Float64x __x) noexcept(trueexp10f64x(_Float64x __x) noexcept(true);
    extern _Float64x __exp10f64x(_Float64x __x) noexcept(true__exp10f64x(_Float64x __x) noexcept(true);
    extern _Float64x expm1f64x(_Float64x __x) noexcept(trueexpm1f64x(_Float64x __x) noexcept(true);
    extern _Float64x __expm1f64x(_Float64x __x) noexcept(true__expm1f64x(_Float64x __x) noexcept(true);
    extern _Float64x log1pf64x(_Float64x __x) noexcept(truelog1pf64x(_Float64x __x) noexcept(true);
    extern _Float64x __log1pf64x(_Float64x __x) noexcept(true__log1pf64x(_Float64x __x) noexcept(true);
    extern _Float64x logbf64x(_Float64x __x) noexcept(truelogbf64x(_Float64x __x) noexcept(true);
    extern _Float64x __logbf64x(_Float64x __x) noexcept(true__logbf64x(_Float64x __x) noexcept(true);
    extern _Float64x exp2f64x(_Float64x __x) noexcept(trueexp2f64x(_Float64x __x) noexcept(true);
    extern _Float64x __exp2f64x(_Float64x __x) noexcept(true__exp2f64x(_Float64x __x) noexcept(true);
    extern _Float64x log2f64x(_Float64x __x) noexcept(truelog2f64x(_Float64x __x) noexcept(true);
    extern _Float64x __log2f64x(_Float64x __x) noexcept(true__log2f64x(_Float64x __x) noexcept(true);
    extern _Float64x powf64x(_Float64x __x, _Float64x __y) noexcept(truepowf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __powf64x(_Float64x __x, _Float64x __y) noexcept(true__powf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x sqrtf64x(_Float64x __x) noexcept(truesqrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x __sqrtf64x(_Float64x __x) noexcept(true__sqrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x hypotf64x(_Float64x __x, _Float64x __y) noexcept(truehypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __hypotf64x(_Float64x __x, _Float64x __y) noexcept(true__hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x cbrtf64x(_Float64x __x) noexcept(truecbrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x __cbrtf64x(_Float64x __x) noexcept(true__cbrtf64x(_Float64x __x) noexcept(true);
    extern _Float64x ceilf64x(_Float64x __x) noexcept(trueceilf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __ceilf64x(_Float64x __x) noexcept(true__ceilf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x fabsf64x(_Float64x __x) noexcept(truefabsf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __fabsf64x(_Float64x __x) noexcept(true__fabsf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x floorf64x(_Float64x __x) noexcept(truefloorf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __floorf64x(_Float64x __x) noexcept(true__floorf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x fmodf64x(_Float64x __x, _Float64x __y) noexcept(truefmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __fmodf64x(_Float64x __x, _Float64x __y) noexcept(true__fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x copysignf64x(_Float64x __x, _Float64x __y) noexcept(truecopysignf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __copysignf64x(_Float64x __x, _Float64x __y) noexcept(true__copysignf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x nanf64x(const char *__tagb) noexcept(truenanf64x(const char *__tagb) noexcept(true);
    extern _Float64x __nanf64x(const char *__tagb) noexcept(true__nanf64x(const char *__tagb) noexcept(true);
    extern _Float64x j0f64x(_Float64x) noexcept(truej0f64x(_Float64x) noexcept(true);
    extern _Float64x __j0f64x(_Float64x) noexcept(true__j0f64x(_Float64x) noexcept(true);
    extern _Float64x j1f64x(_Float64x) noexcept(truej1f64x(_Float64x) noexcept(true);
    extern _Float64x __j1f64x(_Float64x) noexcept(true__j1f64x(_Float64x) noexcept(true);
    extern _Float64x jnf64x(int, _Float64x) noexcept(truejnf64x(int, _Float64x) noexcept(true);
    extern _Float64x __jnf64x(int, _Float64x) noexcept(true__jnf64x(int, _Float64x) noexcept(true);
    extern _Float64x y0f64x(_Float64x) noexcept(truey0f64x(_Float64x) noexcept(true);
    extern _Float64x __y0f64x(_Float64x) noexcept(true__y0f64x(_Float64x) noexcept(true);
    extern _Float64x y1f64x(_Float64x) noexcept(truey1f64x(_Float64x) noexcept(true);
    extern _Float64x __y1f64x(_Float64x) noexcept(true__y1f64x(_Float64x) noexcept(true);
    extern _Float64x ynf64x(int, _Float64x) noexcept(trueynf64x(int, _Float64x) noexcept(true);
    extern _Float64x __ynf64x(int, _Float64x) noexcept(true__ynf64x(int, _Float64x) noexcept(true);
    extern _Float64x erff64x(_Float64x) noexcept(trueerff64x(_Float64x) noexcept(true);
    extern _Float64x __erff64x(_Float64x) noexcept(true__erff64x(_Float64x) noexcept(true);
    extern _Float64x erfcf64x(_Float64x) noexcept(trueerfcf64x(_Float64x) noexcept(true);
    extern _Float64x __erfcf64x(_Float64x) noexcept(true__erfcf64x(_Float64x) noexcept(true);
    extern _Float64x lgammaf64x(_Float64x) noexcept(truelgammaf64x(_Float64x) noexcept(true);
    extern _Float64x __lgammaf64x(_Float64x) noexcept(true__lgammaf64x(_Float64x) noexcept(true);
    extern _Float64x tgammaf64x(_Float64x) noexcept(truetgammaf64x(_Float64x) noexcept(true);
    extern _Float64x __tgammaf64x(_Float64x) noexcept(true__tgammaf64x(_Float64x) noexcept(true);
    extern _Float64x lgammaf64x_r(_Float64x, int *__signgamp) noexcept(truelgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
    extern _Float64x __lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true__lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
    extern _Float64x rintf64x(_Float64x __x) noexcept(truerintf64x(_Float64x __x) noexcept(true);
    extern _Float64x __rintf64x(_Float64x __x) noexcept(true__rintf64x(_Float64x __x) noexcept(true);
    extern _Float64x nextafterf64x(_Float64x __x, _Float64x __y) noexcept(truenextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true__nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x nextdownf64x(_Float64x __x) noexcept(truenextdownf64x(_Float64x __x) noexcept(true);
    extern _Float64x __nextdownf64x(_Float64x __x) noexcept(true__nextdownf64x(_Float64x __x) noexcept(true);
    extern _Float64x nextupf64x(_Float64x __x) noexcept(truenextupf64x(_Float64x __x) noexcept(true);
    extern _Float64x __nextupf64x(_Float64x __x) noexcept(true__nextupf64x(_Float64x __x) noexcept(true);
    extern _Float64x remainderf64x(_Float64x __x, _Float64x __y) noexcept(trueremainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __remainderf64x(_Float64x __x, _Float64x __y) noexcept(true__remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x scalbnf64x(_Float64x __x, int __n) noexcept(truescalbnf64x(_Float64x __x, int __n) noexcept(true);
    extern _Float64x __scalbnf64x(_Float64x __x, int __n) noexcept(true__scalbnf64x(_Float64x __x, int __n) noexcept(true);
    extern int ilogbf64x(_Float64x __x) noexcept(trueilogbf64x(_Float64x __x) noexcept(true);
    extern int __ilogbf64x(_Float64x __x) noexcept(true__ilogbf64x(_Float64x __x) noexcept(true);
    extern long llogbf64x(_Float64x __x) noexcept(truellogbf64x(_Float64x __x) noexcept(true);
    extern long __llogbf64x(_Float64x __x) noexcept(true__llogbf64x(_Float64x __x) noexcept(true);
    extern _Float64x scalblnf64x(_Float64x __x, long __n) noexcept(truescalblnf64x(_Float64x __x, long __n) noexcept(true);
    extern _Float64x __scalblnf64x(_Float64x __x, long __n) noexcept(true__scalblnf64x(_Float64x __x, long __n) noexcept(true);
    extern _Float64x nearbyintf64x(_Float64x __x) noexcept(truenearbyintf64x(_Float64x __x) noexcept(true);
    extern _Float64x __nearbyintf64x(_Float64x __x) noexcept(true__nearbyintf64x(_Float64x __x) noexcept(true);
    extern _Float64x roundf64x(_Float64x __x) noexcept(trueroundf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __roundf64x(_Float64x __x) noexcept(true__roundf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x truncf64x(_Float64x __x) noexcept(truetruncf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __truncf64x(_Float64x __x) noexcept(true__truncf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x remquof64x(_Float64x __x, _Float64x __y, int *__quo) noexcept(trueremquof64x(_Float64x __x, _Float64x __y, int *__quo) noexcept(true);
    extern _Float64x __remquof64x(_Float64x __x, _Float64x __y, int *__quo) noexcept(true__remquof64x(_Float64x __x, _Float64x __y, int *__quo) noexcept(true);
    extern long lrintf64x(_Float64x __x) noexcept(truelrintf64x(_Float64x __x) noexcept(true);
    extern long __lrintf64x(_Float64x __x) noexcept(true__lrintf64x(_Float64x __x) noexcept(true);
    extern long long llrintf64x(_Float64x __x) noexcept(truellrintf64x(_Float64x __x) noexcept(true);
    extern long long __llrintf64x(_Float64x __x) noexcept(true__llrintf64x(_Float64x __x) noexcept(true);
    extern long lroundf64x(_Float64x __x) noexcept(truelroundf64x(_Float64x __x) noexcept(true);
    extern long __lroundf64x(_Float64x __x) noexcept(true__lroundf64x(_Float64x __x) noexcept(true);
    extern long long llroundf64x(_Float64x __x) noexcept(truellroundf64x(_Float64x __x) noexcept(true);
    extern long long __llroundf64x(_Float64x __x) noexcept(true__llroundf64x(_Float64x __x) noexcept(true);
    extern _Float64x fdimf64x(_Float64x __x, _Float64x __y) noexcept(truefdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x __fdimf64x(_Float64x __x, _Float64x __y) noexcept(true__fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64x fmaxf64x(_Float64x __x, _Float64x __y) noexcept(truefmaxf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true__fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminf64x(_Float64x __x, _Float64x __y) noexcept(truefminf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminf64x(_Float64x __x, _Float64x __y) noexcept(true__fminf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(truefmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float64x __fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true__fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float64x roundevenf64x(_Float64x __x) noexcept(trueroundevenf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern _Float64x __roundevenf64x(_Float64x __x) noexcept(true__roundevenf64x(_Float64x __x) noexcept(true) __attribute__((const));
    extern __intmax_t fromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(truefromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true__fromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(trueufromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true__ufromfpf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t fromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(truefromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __intmax_t __fromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true__fromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t ufromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(trueufromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern __uintmax_t __ufromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true__ufromfpxf64x(_Float64x __x, int __round, unsigned int __width) noexcept(true);
    extern int canonicalizef64x(_Float64x *__cx, const _Float64x *__x) noexcept(truecanonicalizef64x(_Float64x *__cx, const _Float64x *__x) noexcept(true);
    extern _Float64x fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(truefmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true__fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminmagf64x(_Float64x __x, _Float64x __y) noexcept(truefminmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true__fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(truefmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true__fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimumf64x(_Float64x __x, _Float64x __y) noexcept(truefminimumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true__fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(truefmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true__fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(truefminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true__fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(truefmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true__fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(truefminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true__fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fmaximum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(truefmaximum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fmaximum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true__fmaximum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x fminimum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(truefminimum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern _Float64x __fminimum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true__fminimum_mag_numf64x(_Float64x __x, _Float64x __y) noexcept(true) __attribute__((const));
    extern int totalorderf64x(const _Float64x *__x, const _Float64x *__y) noexcept(truetotalorderf64x(const _Float64x *__x, const _Float64x *__y) noexcept(true) __attribute__((pure));
    extern int totalordermagf64x(const _Float64x *__x, const _Float64x *__y) noexcept(truetotalordermagf64x(const _Float64x *__x, const _Float64x *__y) noexcept(true) __attribute__((pure));
    extern _Float64x getpayloadf64x(const _Float64x *__x) noexcept(truegetpayloadf64x(const _Float64x *__x) noexcept(true);
    extern _Float64x __getpayloadf64x(const _Float64x *__x) noexcept(true__getpayloadf64x(const _Float64x *__x) noexcept(true);
    extern int setpayloadf64x(_Float64x *__x, _Float64x __payload) noexcept(truesetpayloadf64x(_Float64x *__x, _Float64x __payload) noexcept(true);
    extern int setpayloadsigf64x(_Float64x *__x, _Float64x __payload) noexcept(truesetpayloadsigf64x(_Float64x *__x, _Float64x __payload) noexcept(true);
    extern float fadd(double __x, double __y) noexcept(truefadd(double __x, double __y) noexcept(true);
    extern float fdiv(double __x, double __y) noexcept(truefdiv(double __x, double __y) noexcept(true);
    extern float ffma(double __x, double __y, double __z) noexcept(trueffma(double __x, double __y, double __z) noexcept(true);
    extern float fmul(double __x, double __y) noexcept(truefmul(double __x, double __y) noexcept(true);
    extern float fsqrt(double __x) noexcept(truefsqrt(double __x) noexcept(true);
    extern float fsub(double __x, double __y) noexcept(truefsub(double __x, double __y) noexcept(true);
    extern float faddl(long double __x, long double __y) noexcept(truefaddl(long double __x, long double __y) noexcept(true);
    extern float fdivl(long double __x, long double __y) noexcept(truefdivl(long double __x, long double __y) noexcept(true);
    extern float ffmal(long double __x, long double __y, long double __z) noexcept(trueffmal(long double __x, long double __y, long double __z) noexcept(true);
    extern float fmull(long double __x, long double __y) noexcept(truefmull(long double __x, long double __y) noexcept(true);
    extern float fsqrtl(long double __x) noexcept(truefsqrtl(long double __x) noexcept(true);
    extern float fsubl(long double __x, long double __y) noexcept(truefsubl(long double __x, long double __y) noexcept(true);
    extern double daddl(long double __x, long double __y) noexcept(truedaddl(long double __x, long double __y) noexcept(true);
    extern double ddivl(long double __x, long double __y) noexcept(trueddivl(long double __x, long double __y) noexcept(true);
    extern double dfmal(long double __x, long double __y, long double __z) noexcept(truedfmal(long double __x, long double __y, long double __z) noexcept(true);
    extern double dmull(long double __x, long double __y) noexcept(truedmull(long double __x, long double __y) noexcept(true);
    extern double dsqrtl(long double __x) noexcept(truedsqrtl(long double __x) noexcept(true);
    extern double dsubl(long double __x, long double __y) noexcept(truedsubl(long double __x, long double __y) noexcept(true);
    extern _Float32 f32addf32x(_Float32x __x, _Float32x __y) noexcept(truef32addf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32divf32x(_Float32x __x, _Float32x __y) noexcept(truef32divf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(truef32fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) noexcept(true);
    extern _Float32 f32mulf32x(_Float32x __x, _Float32x __y) noexcept(truef32mulf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32sqrtf32x(_Float32x __x) noexcept(truef32sqrtf32x(_Float32x __x) noexcept(true);
    extern _Float32 f32subf32x(_Float32x __x, _Float32x __y) noexcept(truef32subf32x(_Float32x __x, _Float32x __y) noexcept(true);
    extern _Float32 f32addf64(_Float64 __x, _Float64 __y) noexcept(truef32addf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32divf64(_Float64 __x, _Float64 __y) noexcept(truef32divf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(truef32fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float32 f32mulf64(_Float64 __x, _Float64 __y) noexcept(truef32mulf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32sqrtf64(_Float64 __x) noexcept(truef32sqrtf64(_Float64 __x) noexcept(true);
    extern _Float32 f32subf64(_Float64 __x, _Float64 __y) noexcept(truef32subf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32 f32addf64x(_Float64x __x, _Float64x __y) noexcept(truef32addf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32 f32divf64x(_Float64x __x, _Float64x __y) noexcept(truef32divf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32 f32fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(truef32fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float32 f32mulf64x(_Float64x __x, _Float64x __y) noexcept(truef32mulf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32 f32sqrtf64x(_Float64x __x) noexcept(truef32sqrtf64x(_Float64x __x) noexcept(true);
    extern _Float32 f32subf64x(_Float64x __x, _Float64x __y) noexcept(truef32subf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xaddf64(_Float64 __x, _Float64 __y) noexcept(truef32xaddf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xdivf64(_Float64 __x, _Float64 __y) noexcept(truef32xdivf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xfmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(truef32xfmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
    extern _Float32x f32xmulf64(_Float64 __x, _Float64 __y) noexcept(truef32xmulf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xsqrtf64(_Float64 __x) noexcept(truef32xsqrtf64(_Float64 __x) noexcept(true);
    extern _Float32x f32xsubf64(_Float64 __x, _Float64 __y) noexcept(truef32xsubf64(_Float64 __x, _Float64 __y) noexcept(true);
    extern _Float32x f32xaddf64x(_Float64x __x, _Float64x __y) noexcept(truef32xaddf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xdivf64x(_Float64x __x, _Float64x __y) noexcept(truef32xdivf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xfmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(truef32xfmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float32x f32xmulf64x(_Float64x __x, _Float64x __y) noexcept(truef32xmulf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float32x f32xsqrtf64x(_Float64x __x) noexcept(truef32xsqrtf64x(_Float64x __x) noexcept(true);
    extern _Float32x f32xsubf64x(_Float64x __x, _Float64x __y) noexcept(truef32xsubf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64addf64x(_Float64x __x, _Float64x __y) noexcept(truef64addf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64divf64x(_Float64x __x, _Float64x __y) noexcept(truef64divf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(truef64fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) noexcept(true);
    extern _Float64 f64mulf64x(_Float64x __x, _Float64x __y) noexcept(truef64mulf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern _Float64 f64sqrtf64x(_Float64x __x) noexcept(truef64sqrtf64x(_Float64x __x) noexcept(true);
    extern _Float64 f64subf64x(_Float64x __x, _Float64x __y) noexcept(truef64subf64x(_Float64x __x, _Float64x __y) noexcept(true);
    extern int signgam;
    enum  {
        FP_NAN = 0,
        FP_INFINITE = 1,
        FP_ZERO = 2,
        FP_SUBNORMAL = 3,
        FP_NORMAL = 4
    };
    extern int __iscanonicall(long double __x) noexcept(true__iscanonicall(long double __x) noexcept(true) __attribute__((const));
    extern "C++" {
        inline int iscanonical(float __val)         {
            return ((void)(typeof (__val))(__val) , 1);
        }
        inline int iscanonical(double __val)         {
            return ((void)(typeof (__val))(__val) , 1);
        }
        inline int iscanonical(long double __val)         {
            return __iscanonicall(__val);
        }
    }
    extern "C++" {
        inline int issignaling(float __val)         {
            return __issignalingf(__val);
        }
        inline int issignaling(double __val)         {
            return __issignaling(__val);
        }
        inline int issignaling(long double __val)         {
            return __issignalingl(__val);
        }
    }
    extern "C++" {
        template <class __T> inline bool iszero(__T __val)         {
            return __val == 0;
        }
    }
    extern "C++" {
        template <typename> struct __iseqsig_type;
        template<> struct __iseqsig_type<float> {
            static int __call(float __x, float __y) throw()             {
                return __iseqsigf(__x, __y);
            }
        };
        template<> struct __iseqsig_type<double> {
            static int __call(double __x, double __y) throw()             {
                return __iseqsig(__x, __y);
            }
        };
        template<> struct __iseqsig_type<long double> {
            static int __call(long double __x, long double __y) throw()             {
                return __iseqsigl(__x, __y);
            }
        };
        template <typename _T1, typename _T2> inline int iseqsig(_T1 __x, _T2 __y) throw()         {
            typedef decltype(((__x) + (__y) + 0.F)) _T3;
            return __iseqsig_type<_T3>::__call(__x, __y);
        }
    }
}
typedef unsigned long size_t;
extern "C" {
    typedef enum  {
        P_ALL,
        P_PID,
        P_PGID
    } idtype_t;
    typedef struct {
        int quot;
        int rem;
    } div_t;
    typedef struct {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct {
        long long quot;
        long long rem;
    } lldiv_t;
    extern size_t __ctype_get_mb_cur_max() noexcept(true__ctype_get_mb_cur_max() noexcept(true);
    extern double atof(const char *__nptr) noexcept(trueatof(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern int atoi(const char *__nptr) noexcept(trueatoi(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern long atol(const char *__nptr) noexcept(trueatol(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern long long atoll(const char *__nptr) noexcept(trueatoll(const char *__nptr) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) noexcept(truestrtod(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) noexcept(truestrtof(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) noexcept(truestrtold(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float32 strtof32(const char *__restrict __nptr, char **__restrict __endptr) noexcept(truestrtof32(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float64 strtof64(const char *__restrict __nptr, char **__restrict __endptr) noexcept(truestrtof64(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float32x strtof32x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(truestrtof32x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern _Float64x strtof64x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(truestrtof64x(const char *__restrict __nptr, char **__restrict __endptr) noexcept(true) __attribute__((nonnull(1)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(truestrtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(truestrtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(truestrtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(truestrtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(truestrtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(truestrtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern int strfromd(char *__dest, size_t __size, const char *__format, double __f) noexcept(truestrfromd(char *__dest, size_t __size, const char *__format, double __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf(char *__dest, size_t __size, const char *__format, float __f) noexcept(truestrfromf(char *__dest, size_t __size, const char *__format, float __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfroml(char *__dest, size_t __size, const char *__format, long double __f) noexcept(truestrfroml(char *__dest, size_t __size, const char *__format, long double __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf32(char *__dest, size_t __size, const char *__format, _Float32 __f) noexcept(truestrfromf32(char *__dest, size_t __size, const char *__format, _Float32 __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf64(char *__dest, size_t __size, const char *__format, _Float64 __f) noexcept(truestrfromf64(char *__dest, size_t __size, const char *__format, _Float64 __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf32x(char *__dest, size_t __size, const char *__format, _Float32x __f) noexcept(truestrfromf32x(char *__dest, size_t __size, const char *__format, _Float32x __f) noexcept(true) __attribute__((nonnull(3)));
    extern int strfromf64x(char *__dest, size_t __size, const char *__format, _Float64x __f) noexcept(truestrfromf64x(char *__dest, size_t __size, const char *__format, _Float64x __f) noexcept(true) __attribute__((nonnull(3)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(truestrtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(truestrtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(truestrtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(truestrtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 4)));
    extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(truestrtod_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(truestrtof_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(truestrtold_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float32 strtof32_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(truestrtof32_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float64 strtof64_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(truestrtof64_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float32x strtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(truestrtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern _Float64x strtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(truestrtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) noexcept(true) __attribute__((nonnull(1, 3)));
    extern char *l64a(long __n) noexcept(truel64a(long __n) noexcept(true);
    extern long a64l(const char *__s) noexcept(truea64l(const char *__s) noexcept(true) __attribute__((pure)) __attribute__((nonnull(1)));
    extern "C" {
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __off_t off_t;
        typedef __off64_t off64_t;
        typedef __pid_t pid_t;
        typedef __id_t id_t;
        typedef __ssize_t ssize_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __clock_t clock_t;
        typedef __clockid_t clockid_t;
        typedef __time_t time_t;
        typedef __timer_t timer_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long size_t;
        typedef unsigned long ulong;
        typedef unsigned short ushort;
        typedef unsigned int uint;
        typedef __uint8_t u_int8_t;
        typedef __uint16_t u_int16_t;
        typedef __uint32_t u_int32_t;
        typedef __uint64_t u_int64_t;
        typedef int register_t __attribute__((mode(__word__)));
        static inline __uint16_t __bswap_16(__uint16_t __bsx)         {
            return ((__uint16_t)((((__bsx) >> 8) & 255) | (((__bsx) & 255) << 8)));
        }
        static inline __uint32_t __bswap_32(__uint32_t __bsx)         {
            return ((((__bsx) & 4278190080U) >> 24) | (((__bsx) & 16711680U) >> 8) | (((__bsx) & 65280U) << 8) | (((__bsx) & 255U) << 24));
        }
        static inline __uint64_t __bswap_64(__uint64_t __bsx)         {
            return ((((__bsx) & 18374686479671623680ULL) >> 56) | (((__bsx) & 71776119061217280ULL) >> 40) | (((__bsx) & 280375465082880ULL) >> 24) | (((__bsx) & 1095216660480ULL) >> 8) | (((__bsx) & 4278190080ULL) << 8) | (((__bsx) & 16711680ULL) << 24) | (((__bsx) & 65280ULL) << 40) | (((__bsx) & 255ULL) << 56));
        }
        static inline __uint16_t __uint16_identity(__uint16_t __x)         {
            return __x;
        }
        static inline __uint32_t __uint32_identity(__uint32_t __x)         {
            return __x;
        }
        static inline __uint64_t __uint64_identity(__uint64_t __x)         {
            return __x;
        }
        typedef struct {
            unsigned long __val[16];
        } __sigset_t;
        typedef __sigset_t sigset_t;
        struct timeval {
            __time_t tv_sec;
            __suseconds_t tv_usec;
        };
        struct timespec {
            __time_t tv_sec;
            __syscall_slong_t tv_nsec;
        };
        typedef long __fd_mask;
        typedef struct {
            __fd_mask fds_bits[16];
        } fd_set;
        typedef __fd_mask fd_mask;
        extern "C" {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
        typedef union {
            unsigned long long __value64;
            struct {
                unsigned int __low;
                unsigned int __high;
            } __value32;
        } __atomic_wide_counter;
        typedef struct __pthread_internal_list {
            struct __pthread_internal_list *__prev;
            struct __pthread_internal_list *__next;
        } __pthread_list_t;
        typedef struct __pthread_internal_slist {
            struct __pthread_internal_slist *__next;
        } __pthread_slist_t;
        struct __pthread_mutex_s {
            int __lock;
            unsigned int __count;
            int __owner;
            unsigned int __nusers;
            int __kind;
            short __spins;
            short __elision;
            __pthread_list_t __list;
        };
        struct __pthread_rwlock_arch_t {
            unsigned int __readers;
            unsigned int __writers;
            unsigned int __wrphase_futex;
            unsigned int __writers_futex;
            unsigned int __pad3;
            unsigned int __pad4;
            int __cur_writer;
            int __shared;
            signed char __rwelision;
            unsigned char __pad1[7];
            unsigned long __pad2;
            unsigned int __flags;
        };
        struct __pthread_cond_s {
            __atomic_wide_counter __wseq;
            __atomic_wide_counter __g1_start;
            unsigned int __g_refs[2];
            unsigned int __g_size[2];
            unsigned int __g1_orig_size;
            unsigned int __wrefs;
            unsigned int __g_signals[2];
        };
        typedef unsigned int __tss_t;
        typedef unsigned long __thrd_t;
        typedef struct {
            int __data;
        } __once_flag;
        typedef unsigned long pthread_t;
        typedef union {
            char __size[4];
            int __align;
        } pthread_mutexattr_t;
        typedef union {
            char __size[4];
            int __align;
        } pthread_condattr_t;
        typedef unsigned int pthread_key_t;
        typedef int pthread_once_t;
        union pthread_attr_t {
            char __size[56];
            long __align;
        };
        typedef union pthread_attr_t pthread_attr_t;
        typedef union {
            struct __pthread_mutex_s __data;
            char __size[40];
            long __align;
        } pthread_mutex_t;
        typedef union {
            struct __pthread_cond_s __data;
            char __size[48];
            long long __align;
        } pthread_cond_t;
        typedef union {
            struct __pthread_rwlock_arch_t __data;
            char __size[56];
            long __align;
        } pthread_rwlock_t;
        typedef union {
            char __size[8];
            long __align;
        } pthread_rwlockattr_t;
        typedef volatile int pthread_spinlock_t;
        typedef union {
            char __size[32];
            long __align;
        } pthread_barrier_t;
        typedef union {
            char __size[4];
            int __align;
        } pthread_barrierattr_t;
    }
    extern long random() noexcept(truerandom() noexcept(true);
    extern void srandom(unsigned int __seed) noexcept(truesrandom(unsigned int __seed) noexcept(true);
    extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen) noexcept(trueinitstate(unsigned int __seed, char *__statebuf, size_t __statelen) noexcept(true) __attribute__((nonnull(2)));
    extern char *setstate(char *__statebuf) noexcept(truesetstate(char *__statebuf) noexcept(true) __attribute__((nonnull(1)));
    struct random_data {
        int32_t *fptr;
        int32_t *rptr;
        int32_t *state;
        int rand_type;
        int rand_deg;
        int rand_sep;
        int32_t *end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) noexcept(truerandom_r(struct random_data *__restrict __buf, int32_t *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int srandom_r(unsigned int __seed, struct random_data *__buf) noexcept(truesrandom_r(unsigned int __seed, struct random_data *__buf) noexcept(true) __attribute__((nonnull(2)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) noexcept(trueinitstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) noexcept(true) __attribute__((nonnull(2, 4)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) noexcept(truesetstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int rand() noexcept(truerand() noexcept(true);
    extern void srand(unsigned int __seed) noexcept(truesrand(unsigned int __seed) noexcept(true);
    extern int rand_r(unsigned int *__seed) noexcept(truerand_r(unsigned int *__seed) noexcept(true);
    extern double drand48() noexcept(truedrand48() noexcept(true);
    extern double erand48(unsigned short __xsubi[3]) noexcept(trueerand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern long lrand48() noexcept(truelrand48() noexcept(true);
    extern long nrand48(unsigned short __xsubi[3]) noexcept(truenrand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern long mrand48() noexcept(truemrand48() noexcept(true);
    extern long jrand48(unsigned short __xsubi[3]) noexcept(truejrand48(unsigned short __xsubi[3]) noexcept(true) __attribute__((nonnull(1)));
    extern void srand48(long __seedval) noexcept(truesrand48(long __seedval) noexcept(true);
    extern unsigned short *seed48(unsigned short __seed16v[3]) noexcept(trueseed48(unsigned short __seed16v[3]) noexcept(true) __attribute__((nonnull(1)));
    extern void lcong48(unsigned short __param[7]) noexcept(truelcong48(unsigned short __param[7]) noexcept(true) __attribute__((nonnull(1)));
    struct drand48_data {
        unsigned short __x[3];
        unsigned short __old_x[3];
        unsigned short __c;
        unsigned short __init;
        unsigned long long __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(truedrand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(trueerand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(truelrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(truenrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(truemrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(truejrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int srand48_r(long __seedval, struct drand48_data *__buffer) noexcept(truesrand48_r(long __seedval, struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(2)));
    extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) noexcept(trueseed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer) noexcept(truelcong48_r(unsigned short __param[7], struct drand48_data *__buffer) noexcept(true) __attribute__((nonnull(1, 2)));
    extern void *malloc(size_t __size) noexcept(truemalloc(size_t __size) noexcept(true) __attribute__((malloc));
    extern void *calloc(size_t __nmemb, size_t __size) noexcept(truecalloc(size_t __nmemb, size_t __size) noexcept(true) __attribute__((malloc));
    extern void *realloc(void *__ptr, size_t __size) noexcept(truerealloc(void *__ptr, size_t __size) noexcept(true) __attribute__((warn_unused_result("")));
    extern void free(void *__ptr) noexcept(truefree(void *__ptr) noexcept(true);
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(truereallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(true) __attribute__((warn_unused_result("")));
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(truereallocarray(void *__ptr, size_t __nmemb, size_t __size) noexcept(true);
    typedef unsigned long size_t;
    extern "C" {
        extern void *alloca(size_t __size) noexcept(truealloca(size_t __size) noexcept(true);
    }
    extern void *valloc(size_t __size) noexcept(truevalloc(size_t __size) noexcept(true) __attribute__((malloc));
    extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size) noexcept(trueposix_memalign(void **__memptr, size_t __alignment, size_t __size) noexcept(true) __attribute__((nonnull(1)));
    extern void *aligned_alloc(size_t __alignment, size_t __size) noexcept(truealigned_alloc(size_t __alignment, size_t __size) noexcept(true) __attribute__((malloc)) __attribute__((alloc_align(1)));
    extern void abort() noexcept(trueabort() noexcept(true);
    extern int atexit(void (*__func)()) noexcept(trueatexit(void (*__func)()) noexcept(true) __attribute__((nonnull(1)));
    extern "C++" int at_quick_exit(void (*__func)()) noexcept(trueat_quick_exit(void (*__func)()) noexcept(true) asm("at_quick_exit") __attribute__((nonnull(1)))
    extern int on_exit(void (*__func)(int, void *), void *__arg) noexcept(trueon_exit(void (*__func)(int, void *), void *__arg) noexcept(true) __attribute__((nonnull(1)));
    extern void exit(int __status) noexcept(trueexit(int __status) noexcept(true);
    extern void quick_exit(int __status) noexcept(truequick_exit(int __status) noexcept(true);
    extern void _Exit(int __status) noexcept(true_Exit(int __status) noexcept(true);
    extern char *getenv(const char *__name) noexcept(truegetenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern char *secure_getenv(const char *__name) noexcept(truesecure_getenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern int putenv(char *__string) noexcept(trueputenv(char *__string) noexcept(true) __attribute__((nonnull(1)));
    extern int setenv(const char *__name, const char *__value, int __replace) noexcept(truesetenv(const char *__name, const char *__value, int __replace) noexcept(true) __attribute__((nonnull(2)));
    extern int unsetenv(const char *__name) noexcept(trueunsetenv(const char *__name) noexcept(true) __attribute__((nonnull(1)));
    extern int clearenv() noexcept(trueclearenv() noexcept(true);
    extern char *mktemp(char *__template) noexcept(truemktemp(char *__template) noexcept(true) __attribute__((nonnull(1)));
    extern int mkstemp(char *__template) __attribute__((nonnull(1)));
    extern int mkstemp64(char *__template) __attribute__((nonnull(1)));
    extern int mkstemps(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern int mkstemps64(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern char *mkdtemp(char *__template) noexcept(truemkdtemp(char *__template) noexcept(true) __attribute__((nonnull(1)));
    extern int mkostemp(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemp64(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int system(const char *__command);
    extern char *canonicalize_file_name(const char *__name) noexcept(truecanonicalize_file_name(const char *__name) noexcept(true) __attribute__((nonnull(1))) __attribute__((malloc));
    extern char *realpath(const char *__restrict __name, char *__restrict __resolved) noexcept(truerealpath(const char *__restrict __name, char *__restrict __resolved) noexcept(true);
    typedef int (*__compar_fn_t)(const void *, const void *);
    typedef __compar_fn_t comparison_fn_t;
    typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
    extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 2, 5)));
    extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 4)));
    extern void qsort_r(void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg) __attribute__((nonnull(1, 4)));
    extern int abs(int __x) noexcept(trueabs(int __x) noexcept(true) __attribute__((const));
    extern long labs(long __x) noexcept(truelabs(long __x) noexcept(true) __attribute__((const));
    extern long long llabs(long long __x) noexcept(truellabs(long long __x) noexcept(true) __attribute__((const));
    extern div_t div(int __numer, int __denom) noexcept(truediv(int __numer, int __denom) noexcept(true) __attribute__((const));
    extern ldiv_t ldiv(long __numer, long __denom) noexcept(trueldiv(long __numer, long __denom) noexcept(true) __attribute__((const));
    extern lldiv_t lldiv(long long __numer, long long __denom) noexcept(truelldiv(long long __numer, long long __denom) noexcept(true) __attribute__((const));
    extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(trueecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(truefcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *gcvt(double __value, int __ndigit, char *__buf) noexcept(truegcvt(double __value, int __ndigit, char *__buf) noexcept(true) __attribute__((nonnull(3)));
    extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(trueqecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(trueqfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) noexcept(true) __attribute__((nonnull(3, 4)));
    extern char *qgcvt(long double __value, int __ndigit, char *__buf) noexcept(trueqgcvt(long double __value, int __ndigit, char *__buf) noexcept(true) __attribute__((nonnull(3)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(trueecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(truefcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(trueqecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(trueqfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) noexcept(true) __attribute__((nonnull(3, 4, 5)));
    extern int mblen(const char *__s, size_t __n) noexcept(truemblen(const char *__s, size_t __n) noexcept(true);
    extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) noexcept(truembtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) noexcept(true);
    extern int wctomb(char *__s, wchar_t __wchar) noexcept(truewctomb(char *__s, wchar_t __wchar) noexcept(true);
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) noexcept(truembstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) noexcept(true);
    extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) noexcept(truewcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) noexcept(true);
    extern int rpmatch(const char *__response) noexcept(truerpmatch(const char *__response) noexcept(true) __attribute__((nonnull(1)));
    extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) noexcept(truegetsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) noexcept(true) __attribute__((nonnull(1, 2, 3)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) noexcept(truegrantpt(int __fd) noexcept(true);
    extern int unlockpt(int __fd) noexcept(trueunlockpt(int __fd) noexcept(true);
    extern char *ptsname(int __fd) noexcept(trueptsname(int __fd) noexcept(true);
    extern int ptsname_r(int __fd, char *__buf, size_t __buflen) noexcept(trueptsname_r(int __fd, char *__buf, size_t __buflen) noexcept(true) __attribute__((nonnull(2)));
    extern int getpt();
    extern int getloadavg(double __loadavg[], int __nelem) noexcept(truegetloadavg(double __loadavg[], int __nelem) noexcept(true) __attribute__((nonnull(1)));
}
extern "C++" {
    namespace std {
        using ::abs;
        inline long abs(long __i)         {
            return __builtin_labs(__i);
        }
        inline long long abs(long long __x)         {
            return __builtin_llabs(__x);
        }
        inline constexpr double abs(double __x)         {
            return __builtin_fabs(__x);
        }
        inline constexpr float abs(float __x)         {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double abs(long double __x)         {
            return __builtin_fabsl(__x);
        }
    }
}
extern "C++" {
    namespace std {
        using ::acos;
        inline constexpr float acos(float __x)         {
            return __builtin_acosf(__x);
        }
        inline constexpr long double acos(long double __x)         {
            return __builtin_acosl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x)         {
            return __builtin_acos(__x);
        }
        using ::asin;
        inline constexpr float asin(float __x)         {
            return __builtin_asinf(__x);
        }
        inline constexpr long double asin(long double __x)         {
            return __builtin_asinl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x)         {
            return __builtin_asin(__x);
        }
        using ::atan;
        inline constexpr float atan(float __x)         {
            return __builtin_atanf(__x);
        }
        inline constexpr long double atan(long double __x)         {
            return __builtin_atanl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x)         {
            return __builtin_atan(__x);
        }
        using ::atan2;
        inline constexpr float atan2(float __y, float __x)         {
            return __builtin_atan2f(__y, __x);
        }
        inline constexpr long double atan2(long double __y, long double __x)         {
            return __builtin_atan2l(__y, __x);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return atan2(__type(__y), __type(__x));
        }
        using ::ceil;
        inline constexpr float ceil(float __x)         {
            return __builtin_ceilf(__x);
        }
        inline constexpr long double ceil(long double __x)         {
            return __builtin_ceill(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x)         {
            return __builtin_ceil(__x);
        }
        using ::cos;
        inline constexpr float cos(float __x)         {
            return __builtin_cosf(__x);
        }
        inline constexpr long double cos(long double __x)         {
            return __builtin_cosl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x)         {
            return __builtin_cos(__x);
        }
        using ::cosh;
        inline constexpr float cosh(float __x)         {
            return __builtin_coshf(__x);
        }
        inline constexpr long double cosh(long double __x)         {
            return __builtin_coshl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x)         {
            return __builtin_cosh(__x);
        }
        using ::exp;
        inline constexpr float exp(float __x)         {
            return __builtin_expf(__x);
        }
        inline constexpr long double exp(long double __x)         {
            return __builtin_expl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x)         {
            return __builtin_exp(__x);
        }
        using ::fabs;
        inline constexpr float fabs(float __x)         {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double fabs(long double __x)         {
            return __builtin_fabsl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x)         {
            return __builtin_fabs(__x);
        }
        using ::floor;
        inline constexpr float floor(float __x)         {
            return __builtin_floorf(__x);
        }
        inline constexpr long double floor(long double __x)         {
            return __builtin_floorl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x)         {
            return __builtin_floor(__x);
        }
        using ::fmod;
        inline constexpr float fmod(float __x, float __y)         {
            return __builtin_fmodf(__x, __y);
        }
        inline constexpr long double fmod(long double __x, long double __y)         {
            return __builtin_fmodl(__x, __y);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmod(__type(__x), __type(__y));
        }
        template<> inline constexpr typename __gnu_cxx::__promote_2<float, float>::__type fmod<float, float>(float __x, float __y)        template<> inline constexpr typename __gnu_cxx::__promote_2<long double, long double>::__type fmod<long double, long double>(long double __x, long double __y)        using ::frexp;
        inline float frexp(float __x, int *__exp)         {
            return __builtin_frexpf(__x, __exp);
        }
        inline long double frexp(long double __x, int *__exp)         {
            return __builtin_frexpl(__x, __exp);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp)         {
            return __builtin_frexp(__x, __exp);
        }
        using ::ldexp;
        inline constexpr float ldexp(float __x, int __exp)         {
            return __builtin_ldexpf(__x, __exp);
        }
        inline constexpr long double ldexp(long double __x, int __exp)         {
            return __builtin_ldexpl(__x, __exp);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp)         {
            return __builtin_ldexp(__x, __exp);
        }
        using ::log;
        inline constexpr float log(float __x)         {
            return __builtin_logf(__x);
        }
        inline constexpr long double log(long double __x)         {
            return __builtin_logl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x)         {
            return __builtin_log(__x);
        }
        using ::log10;
        inline constexpr float log10(float __x)         {
            return __builtin_log10f(__x);
        }
        inline constexpr long double log10(long double __x)         {
            return __builtin_log10l(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x)         {
            return __builtin_log10(__x);
        }
        using ::modf;
        inline float modf(float __x, float *__iptr)         {
            return __builtin_modff(__x, __iptr);
        }
        inline long double modf(long double __x, long double *__iptr)         {
            return __builtin_modfl(__x, __iptr);
        }
        using ::pow;
        inline constexpr float pow(float __x, float __y)         {
            return __builtin_powf(__x, __y);
        }
        inline constexpr long double pow(long double __x, long double __y)         {
            return __builtin_powl(__x, __y);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return pow(__type(__x), __type(__y));
        }
        template<> inline constexpr typename __gnu_cxx::__promote_2<float, float>::__type pow<float, float>(float __x, float __y)        template<> inline constexpr typename __gnu_cxx::__promote_2<long double, long double>::__type pow<long double, long double>(long double __x, long double __y)        using ::sin;
        inline constexpr float sin(float __x)         {
            return __builtin_sinf(__x);
        }
        inline constexpr long double sin(long double __x)         {
            return __builtin_sinl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x)         {
            return __builtin_sin(__x);
        }
        using ::sinh;
        inline constexpr float sinh(float __x)         {
            return __builtin_sinhf(__x);
        }
        inline constexpr long double sinh(long double __x)         {
            return __builtin_sinhl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x)         {
            return __builtin_sinh(__x);
        }
        using ::sqrt;
        inline constexpr float sqrt(float __x)         {
            return __builtin_sqrtf(__x);
        }
        inline constexpr long double sqrt(long double __x)         {
            return __builtin_sqrtl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x)         {
            return __builtin_sqrt(__x);
        }
        using ::tan;
        inline constexpr float tan(float __x)         {
            return __builtin_tanf(__x);
        }
        inline constexpr long double tan(long double __x)         {
            return __builtin_tanl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x)         {
            return __builtin_tan(__x);
        }
        using ::tanh;
        inline constexpr float tanh(float __x)         {
            return __builtin_tanhf(__x);
        }
        inline constexpr long double tanh(long double __x)         {
            return __builtin_tanhl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x)         {
            return __builtin_tanh(__x);
        }
        constexpr int fpclassify(float __x)         {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        constexpr int fpclassify(double __x)         {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        constexpr int fpclassify(long double __x)         {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type fpclassify(_Tp __x)         {
            return __x != 0 ? 4 : 2;
        }
        constexpr bool isfinite(float __x)         {
            return __builtin_isfinite(__x);
        }
        constexpr bool isfinite(double __x)         {
            return __builtin_isfinite(__x);
        }
        constexpr bool isfinite(long double __x)         {
            return __builtin_isfinite(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isfinite(_Tp __x)         {
            return true;
        }
        constexpr bool isinf(float __x)         {
            return __builtin_isinf(__x);
        }
        constexpr bool isinf(double __x)         {
            return __builtin_isinf(__x);
        }
        constexpr bool isinf(long double __x)         {
            return __builtin_isinf(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isinf(_Tp __x)         {
            return false;
        }
        constexpr bool isnan(float __x)         {
            return __builtin_isnan(__x);
        }
        constexpr bool isnan(double __x)         {
            return __builtin_isnan(__x);
        }
        constexpr bool isnan(long double __x)         {
            return __builtin_isnan(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnan(_Tp __x)         {
            return false;
        }
        constexpr bool isnormal(float __x)         {
            return __builtin_isnormal(__x);
        }
        constexpr bool isnormal(double __x)         {
            return __builtin_isnormal(__x);
        }
        constexpr bool isnormal(long double __x)         {
            return __builtin_isnormal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnormal(_Tp __x)         {
            return __x != 0 ? true : false;
        }
        constexpr bool signbit(float __x)         {
            return __builtin_signbit(__x);
        }
        constexpr bool signbit(double __x)         {
            return __builtin_signbit(__x);
        }
        constexpr bool signbit(long double __x)         {
            return __builtin_signbit(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type signbit(_Tp __x)         {
            return __x < 0 ? true : false;
        }
        constexpr bool isgreater(float __x, float __y)         {
            return __builtin_isgreater(__x, __y);
        }
        constexpr bool isgreater(double __x, double __y)         {
            return __builtin_isgreater(__x, __y);
        }
        constexpr bool isgreater(long double __x, long double __y)         {
            return __builtin_isgreater(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isgreater(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isgreater(__type(__x), __type(__y));
        }
        constexpr bool isgreaterequal(float __x, float __y)         {
            return __builtin_isgreaterequal(__x, __y);
        }
        constexpr bool isgreaterequal(double __x, double __y)         {
            return __builtin_isgreaterequal(__x, __y);
        }
        constexpr bool isgreaterequal(long double __x, long double __y)         {
            return __builtin_isgreaterequal(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isgreaterequal(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isgreaterequal(__type(__x), __type(__y));
        }
        constexpr bool isless(float __x, float __y)         {
            return __builtin_isless(__x, __y);
        }
        constexpr bool isless(double __x, double __y)         {
            return __builtin_isless(__x, __y);
        }
        constexpr bool isless(long double __x, long double __y)         {
            return __builtin_isless(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isless(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isless(__type(__x), __type(__y));
        }
        constexpr bool islessequal(float __x, float __y)         {
            return __builtin_islessequal(__x, __y);
        }
        constexpr bool islessequal(double __x, double __y)         {
            return __builtin_islessequal(__x, __y);
        }
        constexpr bool islessequal(long double __x, long double __y)         {
            return __builtin_islessequal(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type islessequal(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_islessequal(__type(__x), __type(__y));
        }
        constexpr bool islessgreater(float __x, float __y)         {
            return __builtin_islessgreater(__x, __y);
        }
        constexpr bool islessgreater(double __x, double __y)         {
            return __builtin_islessgreater(__x, __y);
        }
        constexpr bool islessgreater(long double __x, long double __y)         {
            return __builtin_islessgreater(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type islessgreater(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_islessgreater(__type(__x), __type(__y));
        }
        constexpr bool isunordered(float __x, float __y)         {
            return __builtin_isunordered(__x, __y);
        }
        constexpr bool isunordered(double __x, double __y)         {
            return __builtin_isunordered(__x, __y);
        }
        constexpr bool isunordered(long double __x, long double __y)         {
            return __builtin_isunordered(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isunordered(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isunordered(__type(__x), __type(__y));
        }
        using ::double_t;
        using ::float_t;
        using ::acosh;
        using ::acoshf;
        using ::acoshl;
        using ::asinh;
        using ::asinhf;
        using ::asinhl;
        using ::atanh;
        using ::atanhf;
        using ::atanhl;
        using ::cbrt;
        using ::cbrtf;
        using ::cbrtl;
        using ::copysign;
        using ::copysignf;
        using ::copysignl;
        using ::erf;
        using ::erff;
        using ::erfl;
        using ::erfc;
        using ::erfcf;
        using ::erfcl;
        using ::exp2;
        using ::exp2f;
        using ::exp2l;
        using ::expm1;
        using ::expm1f;
        using ::expm1l;
        using ::fdim;
        using ::fdimf;
        using ::fdiml;
        using ::fma;
        using ::fmaf;
        using ::fmal;
        using ::fmax;
        using ::fmaxf;
        using ::fmaxl;
        using ::fmin;
        using ::fminf;
        using ::fminl;
        using ::hypot;
        using ::hypotf;
        using ::hypotl;
        using ::ilogb;
        using ::ilogbf;
        using ::ilogbl;
        using ::lgamma;
        using ::lgammaf;
        using ::lgammal;
        using ::llrint;
        using ::llrintf;
        using ::llrintl;
        using ::llround;
        using ::llroundf;
        using ::llroundl;
        using ::log1p;
        using ::log1pf;
        using ::log1pl;
        using ::log2;
        using ::log2f;
        using ::log2l;
        using ::logb;
        using ::logbf;
        using ::logbl;
        using ::lrint;
        using ::lrintf;
        using ::lrintl;
        using ::lround;
        using ::lroundf;
        using ::lroundl;
        using ::nan;
        using ::nanf;
        using ::nanl;
        using ::nearbyint;
        using ::nearbyintf;
        using ::nearbyintl;
        using ::nextafter;
        using ::nextafterf;
        using ::nextafterl;
        using ::nexttoward;
        using ::nexttowardf;
        using ::nexttowardl;
        using ::remainder;
        using ::remainderf;
        using ::remainderl;
        using ::remquo;
        using ::remquof;
        using ::remquol;
        using ::rint;
        using ::rintf;
        using ::rintl;
        using ::round;
        using ::roundf;
        using ::roundl;
        using ::scalbln;
        using ::scalblnf;
        using ::scalblnl;
        using ::scalbn;
        using ::scalbnf;
        using ::scalbnl;
        using ::tgamma;
        using ::tgammaf;
        using ::tgammal;
        using ::trunc;
        using ::truncf;
        using ::truncl;
        constexpr float acosh(float __x)         {
            return __builtin_acoshf(__x);
        }
        constexpr long double acosh(long double __x)         {
            return __builtin_acoshl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acosh(_Tp __x)         {
            return __builtin_acosh(__x);
        }
        constexpr float asinh(float __x)         {
            return __builtin_asinhf(__x);
        }
        constexpr long double asinh(long double __x)         {
            return __builtin_asinhl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asinh(_Tp __x)         {
            return __builtin_asinh(__x);
        }
        constexpr float atanh(float __x)         {
            return __builtin_atanhf(__x);
        }
        constexpr long double atanh(long double __x)         {
            return __builtin_atanhl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atanh(_Tp __x)         {
            return __builtin_atanh(__x);
        }
        constexpr float cbrt(float __x)         {
            return __builtin_cbrtf(__x);
        }
        constexpr long double cbrt(long double __x)         {
            return __builtin_cbrtl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cbrt(_Tp __x)         {
            return __builtin_cbrt(__x);
        }
        constexpr float copysign(float __x, float __y)         {
            return __builtin_copysignf(__x, __y);
        }
        constexpr long double copysign(long double __x, long double __y)         {
            return __builtin_copysignl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return copysign(__type(__x), __type(__y));
        }
        template<> constexpr typename __gnu_cxx::__promote_2<float, float>::__type copysign<float, float>(float __x, float __y)        template<> constexpr typename __gnu_cxx::__promote_2<long double, long double>::__type copysign<long double, long double>(long double __x, long double __y)        constexpr float erf(float __x)         {
            return __builtin_erff(__x);
        }
        constexpr long double erf(long double __x)         {
            return __builtin_erfl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erf(_Tp __x)         {
            return __builtin_erf(__x);
        }
        constexpr float erfc(float __x)         {
            return __builtin_erfcf(__x);
        }
        constexpr long double erfc(long double __x)         {
            return __builtin_erfcl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erfc(_Tp __x)         {
            return __builtin_erfc(__x);
        }
        constexpr float exp2(float __x)         {
            return __builtin_exp2f(__x);
        }
        constexpr long double exp2(long double __x)         {
            return __builtin_exp2l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp2(_Tp __x)         {
            return __builtin_exp2(__x);
        }
        constexpr float expm1(float __x)         {
            return __builtin_expm1f(__x);
        }
        constexpr long double expm1(long double __x)         {
            return __builtin_expm1l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type expm1(_Tp __x)         {
            return __builtin_expm1(__x);
        }
        constexpr float fdim(float __x, float __y)         {
            return __builtin_fdimf(__x, __y);
        }
        constexpr long double fdim(long double __x, long double __y)         {
            return __builtin_fdiml(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fdim(__type(__x), __type(__y));
        }
        constexpr float fma(float __x, float __y, float __z)         {
            return __builtin_fmaf(__x, __y, __z);
        }
        constexpr long double fma(long double __x, long double __y, long double __z)         {
            return __builtin_fmal(__x, __y, __z);
        }
        template <typename _Tp, typename _Up, typename _Vp> constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(_Tp __x, _Up __y, _Vp __z)         {
            typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
            return fma(__type(__x), __type(__y), __type(__z));
        }
        constexpr float fmax(float __x, float __y)         {
            return __builtin_fmaxf(__x, __y);
        }
        constexpr long double fmax(long double __x, long double __y)         {
            return __builtin_fmaxl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmax(__type(__x), __type(__y));
        }
        constexpr float fmin(float __x, float __y)         {
            return __builtin_fminf(__x, __y);
        }
        constexpr long double fmin(long double __x, long double __y)         {
            return __builtin_fminl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmin(__type(__x), __type(__y));
        }
        constexpr float hypot(float __x, float __y)         {
            return __builtin_hypotf(__x, __y);
        }
        constexpr long double hypot(long double __x, long double __y)         {
            return __builtin_hypotl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return hypot(__type(__x), __type(__y));
        }
        constexpr int ilogb(float __x)         {
            return __builtin_ilogbf(__x);
        }
        constexpr int ilogb(long double __x)         {
            return __builtin_ilogbl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type ilogb(_Tp __x)         {
            return __builtin_ilogb(__x);
        }
        constexpr float lgamma(float __x)         {
            return __builtin_lgammaf(__x);
        }
        constexpr long double lgamma(long double __x)         {
            return __builtin_lgammal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type lgamma(_Tp __x)         {
            return __builtin_lgamma(__x);
        }
        constexpr long long llrint(float __x)         {
            return __builtin_llrintf(__x);
        }
        constexpr long long llrint(long double __x)         {
            return __builtin_llrintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long>::__type llrint(_Tp __x)         {
            return __builtin_llrint(__x);
        }
        constexpr long long llround(float __x)         {
            return __builtin_llroundf(__x);
        }
        constexpr long long llround(long double __x)         {
            return __builtin_llroundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long>::__type llround(_Tp __x)         {
            return __builtin_llround(__x);
        }
        constexpr float log1p(float __x)         {
            return __builtin_log1pf(__x);
        }
        constexpr long double log1p(long double __x)         {
            return __builtin_log1pl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log1p(_Tp __x)         {
            return __builtin_log1p(__x);
        }
        constexpr float log2(float __x)         {
            return __builtin_log2f(__x);
        }
        constexpr long double log2(long double __x)         {
            return __builtin_log2l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log2(_Tp __x)         {
            return __builtin_log2(__x);
        }
        constexpr float logb(float __x)         {
            return __builtin_logbf(__x);
        }
        constexpr long double logb(long double __x)         {
            return __builtin_logbl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type logb(_Tp __x)         {
            return __builtin_logb(__x);
        }
        constexpr long lrint(float __x)         {
            return __builtin_lrintf(__x);
        }
        constexpr long lrint(long double __x)         {
            return __builtin_lrintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type lrint(_Tp __x)         {
            return __builtin_lrint(__x);
        }
        constexpr long lround(float __x)         {
            return __builtin_lroundf(__x);
        }
        constexpr long lround(long double __x)         {
            return __builtin_lroundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type lround(_Tp __x)         {
            return __builtin_lround(__x);
        }
        constexpr float nearbyint(float __x)         {
            return __builtin_nearbyintf(__x);
        }
        constexpr long double nearbyint(long double __x)         {
            return __builtin_nearbyintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nearbyint(_Tp __x)         {
            return __builtin_nearbyint(__x);
        }
        constexpr float nextafter(float __x, float __y)         {
            return __builtin_nextafterf(__x, __y);
        }
        constexpr long double nextafter(long double __x, long double __y)         {
            return __builtin_nextafterl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return nextafter(__type(__x), __type(__y));
        }
        constexpr float nexttoward(float __x, long double __y)         {
            return __builtin_nexttowardf(__x, __y);
        }
        constexpr long double nexttoward(long double __x, long double __y)         {
            return __builtin_nexttowardl(__x, __y);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nexttoward(_Tp __x, long double __y)         {
            return __builtin_nexttoward(__x, __y);
        }
        constexpr float remainder(float __x, float __y)         {
            return __builtin_remainderf(__x, __y);
        }
        constexpr long double remainder(long double __x, long double __y)         {
            return __builtin_remainderl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return remainder(__type(__x), __type(__y));
        }
        inline float remquo(float __x, float __y, int *__pquo)         {
            return __builtin_remquof(__x, __y, __pquo);
        }
        inline long double remquo(long double __x, long double __y, int *__pquo)         {
            return __builtin_remquol(__x, __y, __pquo);
        }
        template <typename _Tp, typename _Up> inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(_Tp __x, _Up __y, int *__pquo)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return remquo(__type(__x), __type(__y), __pquo);
        }
        constexpr float rint(float __x)         {
            return __builtin_rintf(__x);
        }
        constexpr long double rint(long double __x)         {
            return __builtin_rintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type rint(_Tp __x)         {
            return __builtin_rint(__x);
        }
        constexpr float round(float __x)         {
            return __builtin_roundf(__x);
        }
        constexpr long double round(long double __x)         {
            return __builtin_roundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type round(_Tp __x)         {
            return __builtin_round(__x);
        }
        constexpr float scalbln(float __x, long __ex)         {
            return __builtin_scalblnf(__x, __ex);
        }
        constexpr long double scalbln(long double __x, long __ex)         {
            return __builtin_scalblnl(__x, __ex);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbln(_Tp __x, long __ex)         {
            return __builtin_scalbln(__x, __ex);
        }
        constexpr float scalbn(float __x, int __ex)         {
            return __builtin_scalbnf(__x, __ex);
        }
        constexpr long double scalbn(long double __x, int __ex)         {
            return __builtin_scalbnl(__x, __ex);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbn(_Tp __x, int __ex)         {
            return __builtin_scalbn(__x, __ex);
        }
        constexpr float tgamma(float __x)         {
            return __builtin_tgammaf(__x);
        }
        constexpr long double tgamma(long double __x)         {
            return __builtin_tgammal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tgamma(_Tp __x)         {
            return __builtin_tgamma(__x);
        }
        constexpr float trunc(float __x)         {
            return __builtin_truncf(__x);
        }
        constexpr long double trunc(long double __x)         {
            return __builtin_truncl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type trunc(_Tp __x)         {
            return __builtin_trunc(__x);
        }
        template <typename _Tp> inline _Tp __hypot3(_Tp __x, _Tp __y, _Tp __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        template<> inline float __hypot3<float>(float __x, float __y, float __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (float __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        template<> inline double __hypot3<double>(double __x, double __y, double __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (double __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        template<> inline long double __hypot3<long double>(long double __x, long double __y, long double __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (long double __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        inline float hypot(float __x, float __y, float __z)         {
            return std::__hypot3<float>(__x, __y, __z);
        }
        inline double hypot(double __x, double __y, double __z)         {
            return std::__hypot3<double>(__x, __y, __z);
        }
        inline long double hypot(long double __x, long double __y, long double __z)         {
            return std::__hypot3<long double>(__x, __y, __z);
        }
        template <typename _Tp, typename _Up, typename _Vp> __gnu_cxx::__promoted_t<_Tp, _Up, _Vp> hypot(_Tp __x, _Up __y, _Vp __z)         {
            using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
            return std::__hypot3<__type>(__x, __y, __z);
        }
        template <typename _Fp> constexpr _Fp __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept         {
            if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const _Fp __x = __a + __t * (__b - __a);
            return (__t > 1) == (__b > __a) ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        template<> constexpr float __lerp<float>(float __a, float __b, float __t) noexcept         {
            if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const float __x = __a + __t * (__b - __a);
            return (__t > 1) == (__b > __a) ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        template<> constexpr double __lerp<double>(double __a, double __b, double __t) noexcept         {
            if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const double __x = __a + __t * (__b - __a);
            return (__t > 1) == (__b > __a) ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        template<> constexpr long double __lerp<long double>(long double __a, long double __b, long double __t) noexcept         {
            if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const long double __x = __a + __t * (__b - __a);
            return (__t > 1) == (__b > __a) ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        constexpr float lerp(float __a, float __b, float __t) noexcept         {
            return std::__lerp(__a, __b, __t);
        }
        constexpr double lerp(double __a, double __b, double __t) noexcept         {
            return std::__lerp(__a, __b, __t);
        }
        constexpr long double lerp(long double __a, long double __b, long double __t) noexcept         {
            return std::__lerp(__a, __b, __t);
        }
        template <typename _Tp, typename _Up, typename _Vp> constexpr __gnu_cxx::__promoted_t<_Tp, _Up, _Vp> lerp(_Tp __x, _Up __y, _Vp __z) noexcept         {
            using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
            return std::__lerp<__type>(__x, __y, __z);
        }
    }
    namespace std {
        enum float_round_style {
            round_indeterminate = -1,
            round_toward_zero = 0,
            round_to_nearest = 1,
            round_toward_infinity = 2,
            round_toward_neg_infinity = 3
        };
        enum float_denorm_style {
            denorm_indeterminate = -1,
            denorm_absent = 0,
            denorm_present = 1
        };
        struct __numeric_limits_base {
            static constexpr bool is_specialized = false;
            static constexpr int digits = 0;
            static constexpr int digits10 = 0;
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 0;
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = false;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template <typename _Tp> struct numeric_limits : public std::__numeric_limits_base {
            static constexpr _Tp min() noexcept             {
                return _Tp();
            }
            static constexpr _Tp max() noexcept             {
                return _Tp();
            }
            static constexpr _Tp lowest() noexcept             {
                return _Tp();
            }
            static constexpr _Tp epsilon() noexcept             {
                return _Tp();
            }
            static constexpr _Tp round_error() noexcept             {
                return _Tp();
            }
            static constexpr _Tp infinity() noexcept             {
                return _Tp();
            }
            static constexpr _Tp quiet_NaN() noexcept             {
                return _Tp();
            }
            static constexpr _Tp signaling_NaN() noexcept             {
                return _Tp();
            }
            static constexpr _Tp denorm_min() noexcept             {
                return _Tp();
            }
        };
        template <typename _Tp> struct numeric_limits<const _Tp> : public numeric_limits<_Tp> {
        };
        template <typename _Tp> struct numeric_limits<volatile _Tp> : public numeric_limits<_Tp> {
        };
        template <typename _Tp> struct numeric_limits<const volatile _Tp> : public numeric_limits<_Tp> {
        };
        template<> struct numeric_limits<bool> {
            static constexpr bool is_specialized = true;
            static constexpr bool min() noexcept             {
                return false;
            }
            static constexpr bool max() noexcept             {
                return true;
            }
            static constexpr bool lowest() noexcept             {
                return min();
            }
            static constexpr int digits = 1;
            static constexpr int digits10 = 0;
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr bool epsilon() noexcept             {
                return false;
            }
            static constexpr bool round_error() noexcept             {
                return false;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr bool infinity() noexcept             {
                return false;
            }
            static constexpr bool quiet_NaN() noexcept             {
                return false;
            }
            static constexpr bool signaling_NaN() noexcept             {
                return false;
            }
            static constexpr bool denorm_min() noexcept             {
                return false;
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char> {
            static constexpr bool is_specialized = true;
            static constexpr char min() noexcept             {
                return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0);
            }
            static constexpr char max() noexcept             {
                return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0);
            }
            static constexpr char lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char epsilon() noexcept             {
                return 0;
            }
            static constexpr char round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char infinity() noexcept             {
                return char();
            }
            static constexpr char quiet_NaN() noexcept             {
                return char();
            }
            static constexpr char signaling_NaN() noexcept             {
                return char();
            }
            static constexpr char denorm_min() noexcept             {
                return static_cast<char>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<signed char> {
            static constexpr bool is_specialized = true;
            static constexpr signed char min() noexcept             {
                return -127 - 1;
            }
            static constexpr signed char max() noexcept             {
                return 127;
            }
            static constexpr signed char lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
            static constexpr int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr signed char epsilon() noexcept             {
                return 0;
            }
            static constexpr signed char round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr signed char infinity() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr signed char quiet_NaN() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr signed char signaling_NaN() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr signed char denorm_min() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned char> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned char min() noexcept             {
                return 0;
            }
            static constexpr unsigned char max() noexcept             {
                return 127 * 2U + 1;
            }
            static constexpr unsigned char lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned char epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned char round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned char infinity() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr unsigned char quiet_NaN() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr unsigned char signaling_NaN() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr unsigned char denorm_min() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<wchar_t> {
            static constexpr bool is_specialized = true;
            static constexpr wchar_t min() noexcept             {
                return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0);
            }
            static constexpr wchar_t max() noexcept             {
                return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0);
            }
            static constexpr wchar_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((wchar_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr wchar_t epsilon() noexcept             {
                return 0;
            }
            static constexpr wchar_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr wchar_t infinity() noexcept             {
                return wchar_t();
            }
            static constexpr wchar_t quiet_NaN() noexcept             {
                return wchar_t();
            }
            static constexpr wchar_t signaling_NaN() noexcept             {
                return wchar_t();
            }
            static constexpr wchar_t denorm_min() noexcept             {
                return wchar_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char8_t> {
            static constexpr bool is_specialized = true;
            static constexpr char8_t min() noexcept             {
                return (((char8_t)(-1) < 0) ? -(((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0) - 1 : (char8_t)0);
            }
            static constexpr char8_t max() noexcept             {
                return (((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0);
            }
            static constexpr char8_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char8_t) * 8 - ((char8_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char8_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char8_t epsilon() noexcept             {
                return 0;
            }
            static constexpr char8_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char8_t infinity() noexcept             {
                return char8_t();
            }
            static constexpr char8_t quiet_NaN() noexcept             {
                return char8_t();
            }
            static constexpr char8_t signaling_NaN() noexcept             {
                return char8_t();
            }
            static constexpr char8_t denorm_min() noexcept             {
                return char8_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char16_t> {
            static constexpr bool is_specialized = true;
            static constexpr char16_t min() noexcept             {
                return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0);
            }
            static constexpr char16_t max() noexcept             {
                return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0);
            }
            static constexpr char16_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char16_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char16_t epsilon() noexcept             {
                return 0;
            }
            static constexpr char16_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char16_t infinity() noexcept             {
                return char16_t();
            }
            static constexpr char16_t quiet_NaN() noexcept             {
                return char16_t();
            }
            static constexpr char16_t signaling_NaN() noexcept             {
                return char16_t();
            }
            static constexpr char16_t denorm_min() noexcept             {
                return char16_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char32_t> {
            static constexpr bool is_specialized = true;
            static constexpr char32_t min() noexcept             {
                return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0);
            }
            static constexpr char32_t max() noexcept             {
                return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0);
            }
            static constexpr char32_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char32_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char32_t epsilon() noexcept             {
                return 0;
            }
            static constexpr char32_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char32_t infinity() noexcept             {
                return char32_t();
            }
            static constexpr char32_t quiet_NaN() noexcept             {
                return char32_t();
            }
            static constexpr char32_t signaling_NaN() noexcept             {
                return char32_t();
            }
            static constexpr char32_t denorm_min() noexcept             {
                return char32_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<short> {
            static constexpr bool is_specialized = true;
            static constexpr short min() noexcept             {
                return -32767 - 1;
            }
            static constexpr short max() noexcept             {
                return 32767;
            }
            static constexpr short lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
            static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr short epsilon() noexcept             {
                return 0;
            }
            static constexpr short round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr short infinity() noexcept             {
                return short();
            }
            static constexpr short quiet_NaN() noexcept             {
                return short();
            }
            static constexpr short signaling_NaN() noexcept             {
                return short();
            }
            static constexpr short denorm_min() noexcept             {
                return short();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned short> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned short min() noexcept             {
                return 0;
            }
            static constexpr unsigned short max() noexcept             {
                return 32767 * 2U + 1;
            }
            static constexpr unsigned short lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned short epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned short round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned short infinity() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr unsigned short quiet_NaN() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr unsigned short signaling_NaN() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr unsigned short denorm_min() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<int> {
            static constexpr bool is_specialized = true;
            static constexpr int min() noexcept             {
                return -2147483647 - 1;
            }
            static constexpr int max() noexcept             {
                return 2147483647;
            }
            static constexpr int lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
            static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr int epsilon() noexcept             {
                return 0;
            }
            static constexpr int round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr int infinity() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr int quiet_NaN() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr int signaling_NaN() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr int denorm_min() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned int> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned int min() noexcept             {
                return 0;
            }
            static constexpr unsigned int max() noexcept             {
                return 2147483647 * 2U + 1;
            }
            static constexpr unsigned int lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned int epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned int round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned int infinity() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr unsigned int quiet_NaN() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr unsigned int signaling_NaN() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr unsigned int denorm_min() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<long> {
            static constexpr bool is_specialized = true;
            static constexpr long min() noexcept             {
                return -9223372036854775807L - 1;
            }
            static constexpr long max() noexcept             {
                return 9223372036854775807L;
            }
            static constexpr long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr long epsilon() noexcept             {
                return 0;
            }
            static constexpr long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr long infinity() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr long quiet_NaN() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr long signaling_NaN() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr long denorm_min() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned long> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned long min() noexcept             {
                return 0;
            }
            static constexpr unsigned long max() noexcept             {
                return 9223372036854775807L * 2UL + 1;
            }
            static constexpr unsigned long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned long epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned long infinity() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr unsigned long quiet_NaN() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr unsigned long signaling_NaN() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr unsigned long denorm_min() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<long long> {
            static constexpr bool is_specialized = true;
            static constexpr long long min() noexcept             {
                return -9223372036854775807LL - 1;
            }
            static constexpr long long max() noexcept             {
                return 9223372036854775807LL;
            }
            static constexpr long long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr long long epsilon() noexcept             {
                return 0;
            }
            static constexpr long long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr long long infinity() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr long long quiet_NaN() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr long long signaling_NaN() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr long long denorm_min() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned long long> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned long long min() noexcept             {
                return 0;
            }
            static constexpr unsigned long long max() noexcept             {
                return 9223372036854775807LL * 2ULL + 1;
            }
            static constexpr unsigned long long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned long long epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned long long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned long long infinity() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr unsigned long long quiet_NaN() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr unsigned long long signaling_NaN() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr unsigned long long denorm_min() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<__int128> {
            static constexpr bool is_specialized = true;
            static constexpr __int128 min() noexcept             {
                return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0);
            }
            static constexpr __int128 max() noexcept             {
                return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0);
            }
            static constexpr int digits = 128 - 1;
            static constexpr int digits10 = (128 - 1) * 643L / 2136;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr __int128 epsilon() noexcept             {
                return 0;
            }
            static constexpr __int128 round_error() noexcept             {
                return 0;
            }
            static constexpr __int128 lowest() noexcept             {
                return min();
            }
            static constexpr int max_digits10 = 0;
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr __int128 infinity() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr __int128 quiet_NaN() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr __int128 signaling_NaN() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr __int128 denorm_min() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned __int128> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned __int128 min() noexcept             {
                return 0;
            }
            static constexpr unsigned __int128 max() noexcept             {
                return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0);
            }
            static constexpr unsigned __int128 lowest() noexcept             {
                return min();
            }
            static constexpr int max_digits10 = 0;
            static constexpr int digits = 128;
            static constexpr int digits10 = 128 * 643L / 2136;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned __int128 epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned __int128 round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned __int128 infinity() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr unsigned __int128 quiet_NaN() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr unsigned __int128 signaling_NaN() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr unsigned __int128 denorm_min() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<float> {
            static constexpr bool is_specialized = true;
            static constexpr float min() noexcept             {
                return 1.17549435E-38F;
            }
            static constexpr float max() noexcept             {
                return 3.40282347E+38F;
            }
            static constexpr float lowest() noexcept             {
                return -3.40282347E+38F;
            }
            static constexpr int digits = 24;
            static constexpr int digits10 = 6;
            static constexpr int max_digits10 = (2 + (24) * 643L / 2136);
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 2;
            static constexpr float epsilon() noexcept             {
                return 1.1920929E-7F;
            }
            static constexpr float round_error() noexcept             {
                return 0.5F;
            }
            static constexpr int min_exponent = (-125);
            static constexpr int min_exponent10 = (-37);
            static constexpr int max_exponent = 128;
            static constexpr int max_exponent10 = 38;
            static constexpr bool has_infinity = 1;
            static constexpr bool has_quiet_NaN = 1;
            static constexpr bool has_signaling_NaN = has_quiet_NaN;
            static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr float infinity() noexcept             {
                return __builtin_huge_valf();
            }
            static constexpr float quiet_NaN() noexcept             {
                return __builtin_nanf("");
            }
            static constexpr float signaling_NaN() noexcept             {
                return __builtin_nansf("");
            }
            static constexpr float denorm_min() noexcept             {
                return 1.40129846E-45F;
            }
            static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_to_nearest;
        };
        template<> struct numeric_limits<double> {
            static constexpr bool is_specialized = true;
            static constexpr double min() noexcept             {
                return 2.2250738585072014E-308;
            }
            static constexpr double max() noexcept             {
                return 1.7976931348623157E+308;
            }
            static constexpr double lowest() noexcept             {
                return -1.7976931348623157E+308;
            }
            static constexpr int digits = 53;
            static constexpr int digits10 = 15;
            static constexpr int max_digits10 = (2 + (53) * 643L / 2136);
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 2;
            static constexpr double epsilon() noexcept             {
                return 2.2204460492503131E-16;
            }
            static constexpr double round_error() noexcept             {
                return 0.5;
            }
            static constexpr int min_exponent = (-1021);
            static constexpr int min_exponent10 = (-307);
            static constexpr int max_exponent = 1024;
            static constexpr int max_exponent10 = 308;
            static constexpr bool has_infinity = 1;
            static constexpr bool has_quiet_NaN = 1;
            static constexpr bool has_signaling_NaN = has_quiet_NaN;
            static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr double infinity() noexcept             {
                return __builtin_huge_val();
            }
            static constexpr double quiet_NaN() noexcept             {
                return __builtin_nan("");
            }
            static constexpr double signaling_NaN() noexcept             {
                return __builtin_nans("");
            }
            static constexpr double denorm_min() noexcept             {
                return 4.9406564584124654E-324;
            }
            static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_to_nearest;
        };
        template<> struct numeric_limits<long double> {
            static constexpr bool is_specialized = true;
            static constexpr long double min() noexcept             {
                return 3.36210314311209350626E-4932L;
            }
            static constexpr long double max() noexcept             {
                return 1.18973149535723176502E+4932L;
            }
            static constexpr long double lowest() noexcept             {
                return -1.18973149535723176502E+4932L;
            }
            static constexpr int digits = 64;
            static constexpr int digits10 = 18;
            static constexpr int max_digits10 = (2 + (64) * 643L / 2136);
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 2;
            static constexpr long double epsilon() noexcept             {
                return 1.08420217248550443401E-19L;
            }
            static constexpr long double round_error() noexcept             {
                return 0.5L;
            }
            static constexpr int min_exponent = (-16381);
            static constexpr int min_exponent10 = (-4931);
            static constexpr int max_exponent = 16384;
            static constexpr int max_exponent10 = 4932;
            static constexpr bool has_infinity = 1;
            static constexpr bool has_quiet_NaN = 1;
            static constexpr bool has_signaling_NaN = has_quiet_NaN;
            static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr long double infinity() noexcept             {
                return __builtin_huge_vall();
            }
            static constexpr long double quiet_NaN() noexcept             {
                return __builtin_nanl("");
            }
            static constexpr long double signaling_NaN() noexcept             {
                return __builtin_nansl("");
            }
            static constexpr long double denorm_min() noexcept             {
                return 3.64519953188247460253E-4951L;
            }
            static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_to_nearest;
        };
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> struct __floating_point_constant {
                static const _Tp __value;
            };
            template <typename _Tp> struct __numeric_constants {
                static _Tp __pi() throw()                 {
                    return static_cast<_Tp>(3.14159265358979323851L);
                }
                static _Tp __pi_2() throw()                 {
                    return static_cast<_Tp>(1.57079632679489661926L);
                }
                static _Tp __pi_3() throw()                 {
                    return static_cast<_Tp>(1.04719755119659774613L);
                }
                static _Tp __pi_4() throw()                 {
                    return static_cast<_Tp>(0.785398163397448309628L);
                }
                static _Tp __1_pi() throw()                 {
                    return static_cast<_Tp>(0.318309886183790671538L);
                }
                static _Tp __2_sqrtpi() throw()                 {
                    return static_cast<_Tp>(1.12837916709551257385L);
                }
                static _Tp __sqrt2() throw()                 {
                    return static_cast<_Tp>(1.41421356237309504876L);
                }
                static _Tp __sqrt3() throw()                 {
                    return static_cast<_Tp>(1.73205080756887729357L);
                }
                static _Tp __sqrtpio2() throw()                 {
                    return static_cast<_Tp>(1.25331413731550025124L);
                }
                static _Tp __sqrt1_2() throw()                 {
                    return static_cast<_Tp>(0.707106781186547524382L);
                }
                static _Tp __lnpi() throw()                 {
                    return static_cast<_Tp>(1.14472988584940017418L);
                }
                static _Tp __gamma_e() throw()                 {
                    return static_cast<_Tp>(0.577215664901532860616L);
                }
                static _Tp __euler() throw()                 {
                    return static_cast<_Tp>(2.71828182845904523543L);
                }
            };
template<> struct __numeric_constants<float> {
                static float __pi() throw()                 {
                    return static_cast<float>(3.14159265358979323851L);
                }
                static float __pi_2() throw()                 {
                    return static_cast<float>(1.57079632679489661926L);
                }
                static float __pi_3() throw();
                static float __pi_4() throw()                 {
                    return static_cast<float>(0.785398163397448309628L);
                }
                static float __1_pi() throw();
                static float __2_sqrtpi() throw();
                static float __sqrt2() throw();
                static float __sqrt3() throw();
                static float __sqrtpio2() throw()                 {
                    return static_cast<float>(1.25331413731550025124L);
                }
                static float __sqrt1_2() throw();
                static float __lnpi() throw()                 {
                    return static_cast<float>(1.14472988584940017418L);
                }
                static float __gamma_e() throw()                 {
                    return static_cast<float>(0.577215664901532860616L);
                }
                static float __euler() throw();
            };
template<> struct __numeric_constants<long double> {
                static long double __pi() throw()                 {
                    return static_cast<long double>(3.14159265358979323851L);
                }
                static long double __pi_2() throw()                 {
                    return static_cast<long double>(1.57079632679489661926L);
                }
                static long double __pi_3() throw();
                static long double __pi_4() throw()                 {
                    return static_cast<long double>(0.785398163397448309628L);
                }
                static long double __1_pi() throw();
                static long double __2_sqrtpi() throw();
                static long double __sqrt2() throw();
                static long double __sqrt3() throw();
                static long double __sqrtpio2() throw()                 {
                    return static_cast<long double>(1.25331413731550025124L);
                }
                static long double __sqrt1_2() throw();
                static long double __lnpi() throw()                 {
                    return static_cast<long double>(1.14472988584940017418L);
                }
                static long double __gamma_e() throw()                 {
                    return static_cast<long double>(0.577215664901532860616L);
                }
                static long double __euler() throw();
            };
            template <typename _Tp> inline bool __isnan(_Tp __x)             {
                return std::isnan(__x);
            }
            template<> inline bool __isnan<float>(float __x)             {
                return std::isnan(__x);
            }
            template<> inline bool __isnan<long double>(long double __x)             {
                return std::isnan(__x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __bernoulli_series(unsigned int __n)             {
                static const _Tp __num[28] = {_Tp(1UL), - _Tp(1UL) / _Tp(2UL), _Tp(1UL) / _Tp(6UL), _Tp(0UL), - _Tp(1UL) / _Tp(30UL), _Tp(0UL), _Tp(1UL) / _Tp(42UL), _Tp(0UL), - _Tp(1UL) / _Tp(30UL), _Tp(0UL), _Tp(5UL) / _Tp(66UL), _Tp(0UL), - _Tp(691UL) / _Tp(2730UL), _Tp(0UL), _Tp(7UL) / _Tp(6UL), _Tp(0UL), - _Tp(3617UL) / _Tp(510UL), _Tp(0UL), _Tp(43867UL) / _Tp(798UL), _Tp(0UL), - _Tp(174611) / _Tp(330UL), _Tp(0UL), _Tp(854513UL) / _Tp(138UL), _Tp(0UL), - _Tp(236364091UL) / _Tp(2730UL), _Tp(0UL), _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)};
                if (__n == 0)
                    return _Tp(1);
                if (__n == 1)
                    return - _Tp(1) / _Tp(2);
                if (__n % 2 == 1)
                    return _Tp(0);
                if (__n < 28)
                    return __num[__n];
                _Tp __fact = _Tp(1);
                if ((__n / 2) % 2 == 0)
                    __fact *= _Tp(-1);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
                __fact *= _Tp(2);
                _Tp __sum = _Tp(0);
                for (unsigned int __i = 1; __i < 1000; ++__i) {
                    _Tp __term = std::pow(_Tp(__i), - _Tp(__n));
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term;
                }
                return __fact * __sum;
            }
            template <typename _Tp> inline _Tp __bernoulli(int __n)             {
                return __bernoulli_series<_Tp>(__n);
            }
            template <typename _Tp> _Tp __log_gamma_bernoulli(_Tp __x)             {
                _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x + _Tp(0.5L) * std::log(_Tp(2) * __numeric_constants<_Tp>::__pi());
                const _Tp __xx = __x * __x;
                _Tp __help = _Tp(1) / __x;
                for (unsigned int __i = 1; __i < 20; ++__i) {
                    const _Tp __2i = _Tp(2 * __i);
                    __help /= __2i * (__2i - _Tp(1)) * __xx;
                    __lg += __bernoulli<_Tp>(2 * __i) * __help;
                }
                return __lg;
            }
            template <typename _Tp> _Tp __log_gamma_lanczos(_Tp __x)             {
                const _Tp __xm1 = __x - _Tp(1);
                static const _Tp __lanczos_cheb_7[9] = {_Tp(0.999999999999809932257L), _Tp(676.520368121885098567L), _Tp(-1259.13921672240287042L), _Tp(771.323428777653078869L), _Tp(-176.615029162140599064L), _Tp(12.5073432786869048142L), _Tp(-0.138571095265720116896L), _Tp(9.98436957801957085945E-6L), _Tp(1.5056327351493115584E-7L)};
                static const _Tp __LOGROOT2PI = _Tp(0.918938533204672741803L);
                _Tp __sum = __lanczos_cheb_7[0];
                for (unsigned int __k = 1; __k < 9; ++__k)
                    __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);
                const _Tp __term1 = (__xm1 + _Tp(0.5L)) * std::log((__xm1 + _Tp(7.5L)) / __numeric_constants<_Tp>::__euler());
                const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
                const _Tp __result = __term1 + (__term2 - _Tp(7));
                return __result;
            }
            template <typename _Tp> _Tp __log_gamma(_Tp __x)             {
                if (__x > _Tp(0.5L))
                    return __log_gamma_lanczos(__x);
                else {
                    const _Tp __sin_fact = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
                    if (__sin_fact == _Tp(0))
                        std::__throw_domain_error(("Argument is nonpositive integer in __log_gamma"));
                    return __numeric_constants<_Tp>::__lnpi() - std::log(__sin_fact) - __log_gamma_lanczos(_Tp(1) - __x);
                }
            }
            template <typename _Tp> _Tp __log_gamma_sign(_Tp __x)             {
                if (__x > _Tp(0))
                    return _Tp(1);
                else {
                    const _Tp __sin_fact = std::sin(__numeric_constants<_Tp>::__pi() * __x);
                    if (__sin_fact > _Tp(0))
                        return (1);
                    else if (__sin_fact < _Tp(0))
                        return - _Tp(1);
                    else
                        return _Tp(0);
                }
            }
            template <typename _Tp> _Tp __log_bincoef(unsigned int __n, unsigned int __k)             {
                static const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                _Tp __coeff = ::std::lgamma(_Tp(1 + __n)) - ::std::lgamma(_Tp(1 + __k)) - ::std::lgamma(_Tp(1 + __n - __k));
            }
            template <typename _Tp> _Tp __bincoef(unsigned int __n, unsigned int __k)             {
                static const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
                if (__log_coeff > __max_bincoeff)
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return std::exp(__log_coeff);
            }
            template <typename _Tp> inline _Tp __gamma(_Tp __x)             {
                return std::exp(__log_gamma(__x));
            }
            template <typename _Tp> _Tp __psi_series(_Tp __x)             {
                _Tp __sum = - __numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
                const unsigned int __max_iter = 100000;
                for (unsigned int __k = 1; __k < __max_iter; ++__k) {
                    const _Tp __term = __x / (__k * (__k + __x));
                    __sum += __term;
                    if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
                        break;
                }
                return __sum;
            }
            template <typename _Tp> _Tp __psi_asymp(_Tp __x)             {
                _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
                const _Tp __xx = __x * __x;
                _Tp __xp = __xx;
                const unsigned int __max_iter = 100;
                for (unsigned int __k = 1; __k < __max_iter; ++__k) {
                    const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
                    __sum -= __term;
                    if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __xp *= __xx;
                }
                return __sum;
            }
            template <typename _Tp> _Tp __psi(_Tp __x)             {
                const int __n = static_cast<int>(__x + 0.5L);
                const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
                if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x < _Tp(0)) {
                    const _Tp __pi = __numeric_constants<_Tp>::__pi();
                    return __psi(_Tp(1) - __x) - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
                } else if (__x > _Tp(100))
                    return __psi_asymp(__x);
                else
                    return __psi_series(__x);
            }
            template <typename _Tp> _Tp __psi(unsigned int __n, _Tp __x)             {
                if (__x <= _Tp(0))
                    std::__throw_domain_error(("Argument out of range in __psi"));
                else if (__n == 0)
                    return __psi(__x);
                else {
                    const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);
                    const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));
                    _Tp __result = std::exp(__ln_nfact) * __hzeta;
                    if (__n % 2 == 1)
                        __result = - __result;
                    return __result;
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> void __gamma_temme(_Tp __mu, _Tp &__gam1, _Tp &__gam2, _Tp &__gampl, _Tp &__gammi)             {
                __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
                __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);
                if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
                    __gam1 = - _Tp(__numeric_constants<_Tp>::__gamma_e());
                else
                    __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);
                __gam2 = (__gammi + __gampl) / (_Tp(2));
                return;
            }
            template<> void __gamma_temme<float>(float __mu, float &__gam1, float &__gam2, float &__gampl, float &__gammi)             {
                __gampl = float(1) / ::std::tgamma(float(1) + __mu);
                __gammi = float(1) / ::std::tgamma(float(1) - __mu);
                if (std::abs(__mu) < std::numeric_limits<float>::epsilon())
                    __gam1 = -float(__numeric_constants<float>::__gamma_e());
                else
                    __gam1 = (__gammi - __gampl) / (float(2) * __mu);
                __gam2 = (__gammi + __gampl) / (float(2));
                return;
            }
            template<> void __gamma_temme<long double>(long double __mu, long double &__gam1, long double &__gam2, long double &__gampl, long double &__gammi)             {
                __gampl = long double(1) / ::std::tgamma(long double(1) + __mu);
                __gammi = long double(1) / ::std::tgamma(long double(1) - __mu);
                if (std::abs(__mu) < std::numeric_limits<long double>::epsilon())
                    __gam1 = -long double(__numeric_constants<long double>::__gamma_e());
                else
                    __gam1 = (__gammi - __gampl) / (long double(2) * __mu);
                __gam2 = (__gammi + __gampl) / (long double(2));
                return;
            }
            template <typename _Tp> void __bessel_jn(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu, _Tp &__Jpnu, _Tp &__Npnu)             {
                if (__x == _Tp(0)) {
                    if (__nu == _Tp(0)) {
                        __Jnu = _Tp(1);
                        __Jpnu = _Tp(0);
                    } else if (__nu == _Tp(1)) {
                        __Jnu = _Tp(0);
                        __Jpnu = _Tp(0.5L);
                    } else {
                        __Jnu = _Tp(0);
                        __Jpnu = _Tp(0);
                    }
                    __Nnu = - std::numeric_limits<_Tp>::infinity();
                    __Npnu = std::numeric_limits<_Tp>::infinity();
                    return;
                }
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
                const int __max_iter = 15000;
                const _Tp __x_min = _Tp(2);
                const int __nl = (__x < __x_min ? static_cast<int>(__nu + _Tp(0.5L)) : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));
                const _Tp __mu = __nu - __nl;
                const _Tp __mu2 = __mu * __mu;
                const _Tp __xi = _Tp(1) / __x;
                const _Tp __xi2 = _Tp(2) * __xi;
                _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
                int __isign = 1;
                _Tp __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                _Tp __b = __xi2 * __nu;
                _Tp __d = _Tp(0);
                _Tp __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = __b - __d;
                    if (std::abs(__d) < __fp_min)
                        __d = __fp_min;
                    __c = __b - _Tp(1) / __c;
                    if (std::abs(__c) < __fp_min)
                        __c = __fp_min;
                    __d = _Tp(1) / __d;
                    const _Tp __del = __c * __d;
                    __h *= __del;
                    if (__d < _Tp(0))
                        __isign = -__isign;
                    if (std::abs(__del - _Tp(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_jn; try asymptotic expansion."));
                _Tp __Jnul = __isign * __fp_min;
                _Tp __Jpnul = __h * __Jnul;
                _Tp __Jnul1 = __Jnul;
                _Tp __Jpnu1 = __Jpnul;
                _Tp __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
                    __fact -= __xi;
                    __Jpnul = __fact * __Jnutemp - __Jnul;
                    __Jnul = __Jnutemp;
                }
                if (__Jnul == _Tp(0))
                    __Jnul = __eps;
                _Tp __f = __Jpnul / __Jnul;
                _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
                if (__x < __x_min) {
                    const _Tp __x2 = __x / _Tp(2);
                    const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
                    _Tp __fact = (std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
                    _Tp __d = - std::log(__x2);
                    _Tp __e = __mu * __d;
                    _Tp __fact2 = (std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
                    _Tp __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi()) * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    __e = std::exp(__e);
                    _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
                    _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
                    const _Tp __pimu2 = __pimu / _Tp(2);
                    _Tp __fact3 = (std::abs(__pimu2) < __eps ? _Tp(1) : std::sin(__pimu2) / __pimu2);
                    _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
                    _Tp __c = _Tp(1);
                    __d = - __x2 * __x2;
                    _Tp __sum = __ff + __r * __q;
                    _Tp __sum1 = __p;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / _Tp(__i);
                        __p /= _Tp(__i) - __mu;
                        __q /= _Tp(__i) + __mu;
                        const _Tp __del = __c * (__ff + __r * __q);
                        __sum += __del;
                        const _Tp __del1 = __c * __p - __i * __del;
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel y series failed to converge in __bessel_jn."));
                    __Nmu = - __sum;
                    __Nnu1 = - __sum1 * __xi2;
                    __Npmu = __mu * __xi * __Nmu - __Nnu1;
                    __Jmu = __w / (__Npmu - __f * __Nmu);
                } else {
                    _Tp __a = _Tp(0.25L) - __mu2;
                    _Tp __q = _Tp(1);
                    _Tp __p = - __xi / _Tp(2);
                    _Tp __br = _Tp(2) * __x;
                    _Tp __bi = _Tp(2);
                    _Tp __fact = __a * __xi / (__p * __p + __q * __q);
                    _Tp __cr = __br + __q * __fact;
                    _Tp __ci = __bi + __p * __fact;
                    _Tp __den = __br * __br + __bi * __bi;
                    _Tp __dr = __br / __den;
                    _Tp __di = - __bi / __den;
                    _Tp __dlr = __cr * __dr - __ci * __di;
                    _Tp __dli = __cr * __di + __ci * __dr;
                    _Tp __temp = __p * __dlr - __q * __dli;
                    __q = __p * __dli + __q * __dlr;
                    __p = __temp;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a += _Tp(2 * (__i - 1));
                        __bi += _Tp(2);
                        __dr = __a * __dr + __br;
                        __di = __a * __di + __bi;
                        if (std::abs(__dr) + std::abs(__di) < __fp_min)
                            __dr = __fp_min;
                        __fact = __a / (__cr * __cr + __ci * __ci);
                        __cr = __br + __cr * __fact;
                        __ci = __bi - __ci * __fact;
                        if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                            __cr = __fp_min;
                        __den = __dr * __dr + __di * __di;
                        __dr /= __den;
                        __di /= - __den;
                        __dlr = __cr * __dr - __ci * __di;
                        __dli = __cr * __di + __ci * __dr;
                        __temp = __p * __dlr - __q * __dli;
                        __q = __p * __dli + __q * __dlr;
                        __p = __temp;
                        if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Lentz's method failed in __bessel_jn."));
                    const _Tp __gam = (__p - __f) / __q;
                    __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));
                    __Jmu = ::std::copysign(__Jmu, __Jnul);
                    __Nmu = __gam * __Jmu;
                    __Npmu = (__p + __q / __gam) * __Nmu;
                    __Nnu1 = __mu * __xi * __Nmu - __Npmu;
                }
                __fact = __Jmu / __Jnul;
                __Jnu = __fact * __Jnul1;
                __Jpnu = __fact * __Jpnu1;
                for (__i = 1; __i <= __nl; ++__i) {
                    const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
                    __Nmu = __Nnu1;
                    __Nnu1 = __Nnutemp;
                }
                __Nnu = __Nmu;
                __Npnu = __nu * __xi * __Nmu - __Nnu1;
                return;
            }
            template<> void __bessel_jn<float>(float __nu, float __x, float &__Jnu, float &__Nnu, float &__Jpnu, float &__Npnu)             {
                if (__x == float(0)) {
                    if (__nu == float(0)) {
                        __Jnu = float(1);
                        __Jpnu = float(0);
                    } else if (__nu == float(1)) {
                        __Jnu = float(0);
                        __Jpnu = float(0.5L);
                    } else {
                        __Jnu = float(0);
                        __Jpnu = float(0);
                    }
                    __Nnu = -std::numeric_limits<float>::infinity();
                    __Npnu = std::numeric_limits<float>::infinity();
                    return;
                }
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __fp_min = std::sqrt(std::numeric_limits<float>::min());
                const int __max_iter = 15000;
                const float __x_min = float(2);
                const int __nl = (__x < __x_min ? static_cast<int>(__nu + float(0.5L)) : std::max(0, static_cast<int>(__nu - __x + float(1.5L))));
                const float __mu = __nu - __nl;
                const float __mu2 = __mu * __mu;
                const float __xi = float(1) / __x;
                const float __xi2 = float(2) * __xi;
                float __w = __xi2 / __numeric_constants<float>::__pi();
                int __isign = 1;
                float __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                float __b = __xi2 * __nu;
                float __d = float(0);
                float __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = __b - __d;
                    if (std::abs(__d) < __fp_min)
                        __d = __fp_min;
                    __c = __b - float(1) / __c;
                    if (std::abs(__c) < __fp_min)
                        __c = __fp_min;
                    __d = float(1) / __d;
                    const float __del = __c * __d;
                    __h *= __del;
                    if (__d < float(0))
                        __isign = -__isign;
                    if (std::abs(__del - float(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_jn; try asymptotic expansion."));
                float __Jnul = __isign * __fp_min;
                float __Jpnul = __h * __Jnul;
                float __Jnul1 = __Jnul;
                float __Jpnu1 = __Jpnul;
                float __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const float __Jnutemp = __fact * __Jnul + __Jpnul;
                    __fact -= __xi;
                    __Jpnul = __fact * __Jnutemp - __Jnul;
                    __Jnul = __Jnutemp;
                }
                if (__Jnul == float(0))
                    __Jnul = __eps;
                float __f = __Jpnul / __Jnul;
                float __Nmu, __Nnu1, __Npmu, __Jmu;
                if (__x < __x_min) {
                    const float __x2 = __x / float(2);
                    const float __pimu = __numeric_constants<float>::__pi() * __mu;
                    float __fact = (std::abs(__pimu) < __eps ? float(1) : __pimu / std::sin(__pimu));
                    float __d = -std::log(__x2);
                    float __e = __mu * __d;
                    float __fact2 = (std::abs(__e) < __eps ? float(1) : std::sinh(__e) / __e);
                    float __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    float __ff = (float(2) / __numeric_constants<float>::__pi()) * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    __e = std::exp(__e);
                    float __p = __e / (__numeric_constants<float>::__pi() * __gampl);
                    float __q = float(1) / (__e * __numeric_constants<float>::__pi() * __gammi);
                    const float __pimu2 = __pimu / float(2);
                    float __fact3 = (std::abs(__pimu2) < __eps ? float(1) : std::sin(__pimu2) / __pimu2);
                    float __r = __numeric_constants<float>::__pi() * __pimu2 * __fact3 * __fact3;
                    float __c = float(1);
                    __d = -__x2 * __x2;
                    float __sum = __ff + __r * __q;
                    float __sum1 = __p;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / float(__i);
                        __p /= float(__i) - __mu;
                        __q /= float(__i) + __mu;
                        const float __del = __c * (__ff + __r * __q);
                        __sum += __del;
                        const float __del1 = __c * __p - __i * __del;
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * (float(1) + std::abs(__sum)))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel y series failed to converge in __bessel_jn."));
                    __Nmu = -__sum;
                    __Nnu1 = -__sum1 * __xi2;
                    __Npmu = __mu * __xi * __Nmu - __Nnu1;
                    __Jmu = __w / (__Npmu - __f * __Nmu);
                } else {
                    float __a = float(0.25L) - __mu2;
                    float __q = float(1);
                    float __p = -__xi / float(2);
                    float __br = float(2) * __x;
                    float __bi = float(2);
                    float __fact = __a * __xi / (__p * __p + __q * __q);
                    float __cr = __br + __q * __fact;
                    float __ci = __bi + __p * __fact;
                    float __den = __br * __br + __bi * __bi;
                    float __dr = __br / __den;
                    float __di = -__bi / __den;
                    float __dlr = __cr * __dr - __ci * __di;
                    float __dli = __cr * __di + __ci * __dr;
                    float __temp = __p * __dlr - __q * __dli;
                    __q = __p * __dli + __q * __dlr;
                    __p = __temp;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a += float(2 * (__i - 1));
                        __bi += float(2);
                        __dr = __a * __dr + __br;
                        __di = __a * __di + __bi;
                        if (std::abs(__dr) + std::abs(__di) < __fp_min)
                            __dr = __fp_min;
                        __fact = __a / (__cr * __cr + __ci * __ci);
                        __cr = __br + __cr * __fact;
                        __ci = __bi - __ci * __fact;
                        if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                            __cr = __fp_min;
                        __den = __dr * __dr + __di * __di;
                        __dr /= __den;
                        __di /= -__den;
                        __dlr = __cr * __dr - __ci * __di;
                        __dli = __cr * __di + __ci * __dr;
                        __temp = __p * __dlr - __q * __dli;
                        __q = __p * __dli + __q * __dlr;
                        __p = __temp;
                        if (std::abs(__dlr - float(1)) + std::abs(__dli) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Lentz's method failed in __bessel_jn."));
                    const float __gam = (__p - __f) / __q;
                    __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));
                    __Jmu = ::std::copysign(__Jmu, __Jnul);
                    __Nmu = __gam * __Jmu;
                    __Npmu = (__p + __q / __gam) * __Nmu;
                    __Nnu1 = __mu * __xi * __Nmu - __Npmu;
                }
                __fact = __Jmu / __Jnul;
                __Jnu = __fact * __Jnul1;
                __Jpnu = __fact * __Jpnu1;
                for (__i = 1; __i <= __nl; ++__i) {
                    const float __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
                    __Nmu = __Nnu1;
                    __Nnu1 = __Nnutemp;
                }
                __Nnu = __Nmu;
                __Npnu = __nu * __xi * __Nmu - __Nnu1;
                return;
            }
            template<> void __bessel_jn<long double>(long double __nu, long double __x, long double &__Jnu, long double &__Nnu, long double &__Jpnu, long double &__Npnu)             {
                if (__x == long double(0)) {
                    if (__nu == long double(0)) {
                        __Jnu = long double(1);
                        __Jpnu = long double(0);
                    } else if (__nu == long double(1)) {
                        __Jnu = long double(0);
                        __Jpnu = long double(0.5L);
                    } else {
                        __Jnu = long double(0);
                        __Jpnu = long double(0);
                    }
                    __Nnu = -std::numeric_limits<long double>::infinity();
                    __Npnu = std::numeric_limits<long double>::infinity();
                    return;
                }
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __fp_min = std::sqrt(std::numeric_limits<long double>::min());
                const int __max_iter = 15000;
                const long double __x_min = long double(2);
                const int __nl = (__x < __x_min ? static_cast<int>(__nu + long double(0.5L)) : std::max(0, static_cast<int>(__nu - __x + long double(1.5L))));
                const long double __mu = __nu - __nl;
                const long double __mu2 = __mu * __mu;
                const long double __xi = long double(1) / __x;
                const long double __xi2 = long double(2) * __xi;
                long double __w = __xi2 / __numeric_constants<long double>::__pi();
                int __isign = 1;
                long double __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                long double __b = __xi2 * __nu;
                long double __d = long double(0);
                long double __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = __b - __d;
                    if (std::abs(__d) < __fp_min)
                        __d = __fp_min;
                    __c = __b - long double(1) / __c;
                    if (std::abs(__c) < __fp_min)
                        __c = __fp_min;
                    __d = long double(1) / __d;
                    const long double __del = __c * __d;
                    __h *= __del;
                    if (__d < long double(0))
                        __isign = -__isign;
                    if (std::abs(__del - long double(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_jn; try asymptotic expansion."));
                long double __Jnul = __isign * __fp_min;
                long double __Jpnul = __h * __Jnul;
                long double __Jnul1 = __Jnul;
                long double __Jpnu1 = __Jpnul;
                long double __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const long double __Jnutemp = __fact * __Jnul + __Jpnul;
                    __fact -= __xi;
                    __Jpnul = __fact * __Jnutemp - __Jnul;
                    __Jnul = __Jnutemp;
                }
                if (__Jnul == long double(0))
                    __Jnul = __eps;
                long double __f = __Jpnul / __Jnul;
                long double __Nmu, __Nnu1, __Npmu, __Jmu;
                if (__x < __x_min) {
                    const long double __x2 = __x / long double(2);
                    const long double __pimu = __numeric_constants<long double>::__pi() * __mu;
                    long double __fact = (std::abs(__pimu) < __eps ? long double(1) : __pimu / std::sin(__pimu));
                    long double __d = -std::log(__x2);
                    long double __e = __mu * __d;
                    long double __fact2 = (std::abs(__e) < __eps ? long double(1) : std::sinh(__e) / __e);
                    long double __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    long double __ff = (long double(2) / __numeric_constants<long double>::__pi()) * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    __e = std::exp(__e);
                    long double __p = __e / (__numeric_constants<long double>::__pi() * __gampl);
                    long double __q = long double(1) / (__e * __numeric_constants<long double>::__pi() * __gammi);
                    const long double __pimu2 = __pimu / long double(2);
                    long double __fact3 = (std::abs(__pimu2) < __eps ? long double(1) : std::sin(__pimu2) / __pimu2);
                    long double __r = __numeric_constants<long double>::__pi() * __pimu2 * __fact3 * __fact3;
                    long double __c = long double(1);
                    __d = -__x2 * __x2;
                    long double __sum = __ff + __r * __q;
                    long double __sum1 = __p;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / long double(__i);
                        __p /= long double(__i) - __mu;
                        __q /= long double(__i) + __mu;
                        const long double __del = __c * (__ff + __r * __q);
                        __sum += __del;
                        const long double __del1 = __c * __p - __i * __del;
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * (long double(1) + std::abs(__sum)))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel y series failed to converge in __bessel_jn."));
                    __Nmu = -__sum;
                    __Nnu1 = -__sum1 * __xi2;
                    __Npmu = __mu * __xi * __Nmu - __Nnu1;
                    __Jmu = __w / (__Npmu - __f * __Nmu);
                } else {
                    long double __a = long double(0.25L) - __mu2;
                    long double __q = long double(1);
                    long double __p = -__xi / long double(2);
                    long double __br = long double(2) * __x;
                    long double __bi = long double(2);
                    long double __fact = __a * __xi / (__p * __p + __q * __q);
                    long double __cr = __br + __q * __fact;
                    long double __ci = __bi + __p * __fact;
                    long double __den = __br * __br + __bi * __bi;
                    long double __dr = __br / __den;
                    long double __di = -__bi / __den;
                    long double __dlr = __cr * __dr - __ci * __di;
                    long double __dli = __cr * __di + __ci * __dr;
                    long double __temp = __p * __dlr - __q * __dli;
                    __q = __p * __dli + __q * __dlr;
                    __p = __temp;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a += long double(2 * (__i - 1));
                        __bi += long double(2);
                        __dr = __a * __dr + __br;
                        __di = __a * __di + __bi;
                        if (std::abs(__dr) + std::abs(__di) < __fp_min)
                            __dr = __fp_min;
                        __fact = __a / (__cr * __cr + __ci * __ci);
                        __cr = __br + __cr * __fact;
                        __ci = __bi - __ci * __fact;
                        if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                            __cr = __fp_min;
                        __den = __dr * __dr + __di * __di;
                        __dr /= __den;
                        __di /= -__den;
                        __dlr = __cr * __dr - __ci * __di;
                        __dli = __cr * __di + __ci * __dr;
                        __temp = __p * __dlr - __q * __dli;
                        __q = __p * __dli + __q * __dlr;
                        __p = __temp;
                        if (std::abs(__dlr - long double(1)) + std::abs(__dli) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Lentz's method failed in __bessel_jn."));
                    const long double __gam = (__p - __f) / __q;
                    __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));
                    __Jmu = ::std::copysign(__Jmu, __Jnul);
                    __Nmu = __gam * __Jmu;
                    __Npmu = (__p + __q / __gam) * __Nmu;
                    __Nnu1 = __mu * __xi * __Nmu - __Npmu;
                }
                __fact = __Jmu / __Jnul;
                __Jnu = __fact * __Jnul1;
                __Jpnu = __fact * __Jpnu1;
                for (__i = 1; __i <= __nl; ++__i) {
                    const long double __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
                    __Nmu = __Nnu1;
                    __Nnu1 = __Nnutemp;
                }
                __Nnu = __Nmu;
                __Npnu = __nu * __xi * __Nmu - __Nnu1;
                return;
            }
            template <typename _Tp> void __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu)             {
                const _Tp __mu = _Tp(4) * __nu * __nu;
                const _Tp __8x = _Tp(8) * __x;
                _Tp __P = _Tp(0);
                _Tp __Q = _Tp(0);
                _Tp __k = _Tp(0);
                _Tp __term = _Tp(1);
                int __epsP = 0;
                int __epsQ = 0;
                _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                do {
                    __term *= (__k == 0 ? _Tp(1) : - (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));
                    __epsP = std::abs(__term) < __eps * std::abs(__P);
                    __P += __term;
                    __k++;
                    __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
                    __epsQ = std::abs(__term) < __eps * std::abs(__Q);
                    __Q += __term;
                    if (__epsP && __epsQ && __k > (__nu / 2.))
                        break;
                    __k++;
                } while (__k < 1000);
                const _Tp __chi = __x - (__nu + _Tp(0.5L)) * __numeric_constants<_Tp>::__pi_2();
                const _Tp __c = std::cos(__chi);
                const _Tp __s = std::sin(__chi);
                const _Tp __coef = std::sqrt(_Tp(2) / (__numeric_constants<_Tp>::__pi() * __x));
                __Jnu = __coef * (__c * __P - __s * __Q);
                __Nnu = __coef * (__s * __P + __c * __Q);
                return;
            }
            template<> void __cyl_bessel_jn_asymp<float>(float __nu, float __x, float &__Jnu, float &__Nnu)             {
                const float __mu = float(4) * __nu * __nu;
                const float __8x = float(8) * __x;
                float __P = float(0);
                float __Q = float(0);
                float __k = float(0);
                float __term = float(1);
                int __epsP = 0;
                int __epsQ = 0;
                float __eps = std::numeric_limits<float>::epsilon();
                do {
                    __term *= (__k == 0 ? float(1) : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));
                    __epsP = std::abs(__term) < __eps * std::abs(__P);
                    __P += __term;
                    __k++;
                    __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
                    __epsQ = std::abs(__term) < __eps * std::abs(__Q);
                    __Q += __term;
                    if (__epsP && __epsQ && __k > (__nu / 2.))
                        break;
                    __k++;
                } while (__k < 1000);
                const float __chi = __x - (__nu + float(0.5L)) * __numeric_constants<float>::__pi_2();
                const float __c = std::cos(__chi);
                const float __s = std::sin(__chi);
                const float __coef = std::sqrt(float(2) / (__numeric_constants<float>::__pi() * __x));
                __Jnu = __coef * (__c * __P - __s * __Q);
                __Nnu = __coef * (__s * __P + __c * __Q);
                return;
            }
            template<> void __cyl_bessel_jn_asymp<long double>(long double __nu, long double __x, long double &__Jnu, long double &__Nnu)             {
                const long double __mu = long double(4) * __nu * __nu;
                const long double __8x = long double(8) * __x;
                long double __P = long double(0);
                long double __Q = long double(0);
                long double __k = long double(0);
                long double __term = long double(1);
                int __epsP = 0;
                int __epsQ = 0;
                long double __eps = std::numeric_limits<long double>::epsilon();
                do {
                    __term *= (__k == 0 ? long double(1) : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));
                    __epsP = std::abs(__term) < __eps * std::abs(__P);
                    __P += __term;
                    __k++;
                    __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
                    __epsQ = std::abs(__term) < __eps * std::abs(__Q);
                    __Q += __term;
                    if (__epsP && __epsQ && __k > (__nu / 2.))
                        break;
                    __k++;
                } while (__k < 1000);
                const long double __chi = __x - (__nu + long double(0.5L)) * __numeric_constants<long double>::__pi_2();
                const long double __c = std::cos(__chi);
                const long double __s = std::sin(__chi);
                const long double __coef = std::sqrt(long double(2) / (__numeric_constants<long double>::__pi() * __x));
                __Jnu = __coef * (__c * __P - __s * __Q);
                __Nnu = __coef * (__s * __P + __c * __Q);
                return;
            }
            template <typename _Tp> _Tp __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn, unsigned int __max_iter)             {
                if (__x == _Tp(0))
                    return __nu == _Tp(0) ? _Tp(1) : _Tp(0);
                const _Tp __x2 = __x / _Tp(2);
                _Tp __fact = __nu * std::log(__x2);
                __fact -= ::std::lgamma(__nu + _Tp(1));
                __fact = std::exp(__fact);
                const _Tp __xx4 = __sgn * __x2 * __x2;
                _Tp __Jn = _Tp(1);
                _Tp __term = _Tp(1);
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
                    __Jn += __term;
                    if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
                        break;
                }
                return __fact * __Jn;
            }
            template<> float __cyl_bessel_ij_series<float>(float __nu, float __x, float __sgn, unsigned int __max_iter)             {
                if (__x == float(0))
                    return __nu == float(0) ? float(1) : float(0);
                const float __x2 = __x / float(2);
                float __fact = __nu * std::log(__x2);
                __fact -= ::std::lgamma(__nu + float(1));
                __fact = std::exp(__fact);
                const float __xx4 = __sgn * __x2 * __x2;
                float __Jn = float(1);
                float __term = float(1);
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __xx4 / (float(__i) * (__nu + float(__i)));
                    __Jn += __term;
                    if (std::abs(__term / __Jn) < std::numeric_limits<float>::epsilon())
                        break;
                }
                return __fact * __Jn;
            }
            template<> long double __cyl_bessel_ij_series<long double>(long double __nu, long double __x, long double __sgn, unsigned int __max_iter)             {
                if (__x == long double(0))
                    return __nu == long double(0) ? long double(1) : long double(0);
                const long double __x2 = __x / long double(2);
                long double __fact = __nu * std::log(__x2);
                __fact -= ::std::lgamma(__nu + long double(1));
                __fact = std::exp(__fact);
                const long double __xx4 = __sgn * __x2 * __x2;
                long double __Jn = long double(1);
                long double __term = long double(1);
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __xx4 / (long double(__i) * (__nu + long double(__i)));
                    __Jn += __term;
                    if (std::abs(__term / __Jn) < std::numeric_limits<long double>::epsilon())
                        break;
                }
                return __fact * __Jn;
            }
            template <typename _Tp> _Tp __cyl_bessel_j(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_j."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
                    return __cyl_bessel_ij_series(__nu, __x, - _Tp(1), 200);
                else if (__x > _Tp(1000)) {
                    _Tp __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __J_nu;
                } else {
                    _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __J_nu;
                }
            }
            template<> float __cyl_bessel_j<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_j."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x * __x < float(10) * (__nu + float(1)))
                    return __cyl_bessel_ij_series(__nu, __x, -float(1), 200);
                else if (__x > float(1000)) {
                    float __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __J_nu;
                } else {
                    float __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __J_nu;
                }
            }
            template<> long double __cyl_bessel_j<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_j."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x * __x < long double(10) * (__nu + long double(1)))
                    return __cyl_bessel_ij_series(__nu, __x, -long double(1), 200);
                else if (__x > long double(1000)) {
                    long double __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __J_nu;
                } else {
                    long double __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __J_nu;
                }
            }
            template <typename _Tp> _Tp __cyl_neumann_n(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_neumann_n."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x > _Tp(1000)) {
                    _Tp __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __N_nu;
                } else {
                    _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __N_nu;
                }
            }
            template<> float __cyl_neumann_n<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_neumann_n."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x > float(1000)) {
                    float __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __N_nu;
                } else {
                    float __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __N_nu;
                }
            }
            template<> long double __cyl_neumann_n<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_neumann_n."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x > long double(1000)) {
                    long double __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __N_nu;
                } else {
                    long double __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __N_nu;
                }
            }
            template <typename _Tp> void __sph_bessel_jn(unsigned int __n, _Tp __x, _Tp &__j_n, _Tp &__n_n, _Tp &__jp_n, _Tp &__np_n)             {
                const _Tp __nu = _Tp(__n) + _Tp(0.5L);
                _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
                __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);
                __j_n = __factor * __J_nu;
                __n_n = __factor * __N_nu;
                __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
                __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);
                return;
            }
            template<> void __sph_bessel_jn<float>(unsigned int __n, float __x, float &__j_n, float &__n_n, float &__jp_n, float &__np_n)             {
                const float __nu = float(__n) + float(0.5L);
                float __J_nu, __N_nu, __Jp_nu, __Np_nu;
                __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                const float __factor = __numeric_constants<float>::__sqrtpio2() / std::sqrt(__x);
                __j_n = __factor * __J_nu;
                __n_n = __factor * __N_nu;
                __jp_n = __factor * __Jp_nu - __j_n / (float(2) * __x);
                __np_n = __factor * __Np_nu - __n_n / (float(2) * __x);
                return;
            }
            template<> void __sph_bessel_jn<long double>(unsigned int __n, long double __x, long double &__j_n, long double &__n_n, long double &__jp_n, long double &__np_n)             {
                const long double __nu = long double(__n) + long double(0.5L);
                long double __J_nu, __N_nu, __Jp_nu, __Np_nu;
                __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                const long double __factor = __numeric_constants<long double>::__sqrtpio2() / std::sqrt(__x);
                __j_n = __factor * __J_nu;
                __n_n = __factor * __N_nu;
                __jp_n = __factor * __Jp_nu - __j_n / (long double(2) * __x);
                __np_n = __factor * __Np_nu - __n_n / (long double(2) * __x);
                return;
            }
            template <typename _Tp> _Tp __sph_bessel(unsigned int __n, _Tp __x)             {
                if (__x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __sph_bessel."));
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x == _Tp(0)) {
                    if (__n == 0)
                        return _Tp(1);
                    else
                        return _Tp(0);
                } else {
                    _Tp __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __j_n;
                }
            }
            template<> float __sph_bessel<float>(unsigned int __n, float __x)             {
                if (__x < float(0))
                    std::__throw_domain_error(("Bad argument in __sph_bessel."));
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x == float(0)) {
                    if (__n == 0)
                        return float(1);
                    else
                        return float(0);
                } else {
                    float __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __j_n;
                }
            }
            template<> long double __sph_bessel<long double>(unsigned int __n, long double __x)             {
                if (__x < long double(0))
                    std::__throw_domain_error(("Bad argument in __sph_bessel."));
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x == long double(0)) {
                    if (__n == 0)
                        return long double(1);
                    else
                        return long double(0);
                } else {
                    long double __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __j_n;
                }
            }
            template <typename _Tp> _Tp __sph_neumann(unsigned int __n, _Tp __x)             {
                if (__x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __sph_neumann."));
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x == _Tp(0))
                    return - std::numeric_limits<_Tp>::infinity();
                else {
                    _Tp __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __n_n;
                }
            }
            template<> float __sph_neumann<float>(unsigned int __n, float __x)             {
                if (__x < float(0))
                    std::__throw_domain_error(("Bad argument in __sph_neumann."));
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x == float(0))
                    return -std::numeric_limits<float>::infinity();
                else {
                    float __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __n_n;
                }
            }
            template<> long double __sph_neumann<long double>(unsigned int __n, long double __x)             {
                if (__x < long double(0))
                    std::__throw_domain_error(("Bad argument in __sph_neumann."));
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x == long double(0))
                    return -std::numeric_limits<long double>::infinity();
                else {
                    long double __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __n_n;
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __beta_gamma(_Tp __x, _Tp __y)             {
                _Tp __bet;
                if (__x > __y) {
                    __bet = ::std::tgamma(__x) / ::std::tgamma(__x + __y);
                    __bet *= ::std::tgamma(__y);
                } else {
                    __bet = ::std::tgamma(__y) / ::std::tgamma(__x + __y);
                    __bet *= ::std::tgamma(__x);
                }
                return __bet;
            }
            template <typename _Tp> _Tp __beta_lgamma(_Tp __x, _Tp __y)             {
                _Tp __bet = ::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);
                __bet = std::exp(__bet);
                return __bet;
            }
            template<> float __beta_lgamma<float>(float __x, float __y)             {
                float __bet = ::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);
                __bet = std::exp(__bet);
                return __bet;
            }
            template<> long double __beta_lgamma<long double>(long double __x, long double __y)             {
                long double __bet = ::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);
                __bet = std::exp(__bet);
                return __bet;
            }
            template <typename _Tp> _Tp __beta_product(_Tp __x, _Tp __y)             {
                _Tp __bet = (__x + __y) / (__x * __y);
                unsigned int __max_iter = 1000000;
                for (unsigned int __k = 1; __k < __max_iter; ++__k) {
                    _Tp __term = (_Tp(1) + (__x + __y) / __k) / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
                    __bet *= __term;
                }
                return __bet;
            }
            template <typename _Tp> inline _Tp __beta(_Tp __x, _Tp __y)             {
                if (__isnan(__x) || __isnan(__y))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __beta_lgamma(__x, __y);
            }
            template<> inline float __beta<float>(float __x, float __y)             {
                if (__isnan(__x) || __isnan(__y))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __beta_lgamma(__x, __y);
            }
            template<> inline long double __beta<long double>(long double __x, long double __y)             {
                if (__isnan(__x) || __isnan(__y))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __beta_lgamma(__x, __y);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __ellint_rf(_Tp __x, _Tp __y, _Tp __z)             {
                const _Tp __min = std::numeric_limits<_Tp>::min();
                const _Tp __lolim = _Tp(5) * __min;
                if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rf."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rf"));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(1) / _Tp(24);
                    const _Tp __c2 = _Tp(1) / _Tp(10);
                    const _Tp __c3 = _Tp(3) / _Tp(44);
                    const _Tp __c4 = _Tp(1) / _Tp(14);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    _Tp __zn = __z;
                    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                    const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
                    _Tp __mu;
                    _Tp __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn) / _Tp(3);
                        __xndev = 2 - (__mu + __xn) / __mu;
                        __yndev = 2 - (__mu + __yn) / __mu;
                        __zndev = 2 - (__mu + __zn) / __mu;
                        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        const _Tp __xnroot = std::sqrt(__xn);
                        const _Tp __ynroot = std::sqrt(__yn);
                        const _Tp __znroot = std::sqrt(__zn);
                        const _Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
                    const _Tp __e3 = __xndev * __yndev * __zndev;
                    const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;
                    return __s / std::sqrt(__mu);
                }
            }
            template<> float __ellint_rf<float>(float __x, float __y, float __z)             {
                const float __min = std::numeric_limits<float>::min();
                const float __lolim = float(5) * __min;
                if (__x < float(0) || __y < float(0) || __z < float(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rf."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rf"));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(1) / float(24);
                    const float __c2 = float(1) / float(10);
                    const float __c3 = float(3) / float(44);
                    const float __c4 = float(1) / float(14);
                    float __xn = __x;
                    float __yn = __y;
                    float __zn = __z;
                    const float __eps = std::numeric_limits<float>::epsilon();
                    const float __errtol = std::pow(__eps, float(1) / float(6));
                    float __mu;
                    float __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn) / float(3);
                        __xndev = 2 - (__mu + __xn) / __mu;
                        __yndev = 2 - (__mu + __yn) / __mu;
                        __zndev = 2 - (__mu + __zn) / __mu;
                        float __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        const float __xnroot = std::sqrt(__xn);
                        const float __ynroot = std::sqrt(__yn);
                        const float __znroot = std::sqrt(__zn);
                        const float __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    const float __e2 = __xndev * __yndev - __zndev * __zndev;
                    const float __e3 = __xndev * __yndev * __zndev;
                    const float __s = float(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;
                    return __s / std::sqrt(__mu);
                }
            }
            template<> long double __ellint_rf<long double>(long double __x, long double __y, long double __z)             {
                const long double __min = std::numeric_limits<long double>::min();
                const long double __lolim = long double(5) * __min;
                if (__x < long double(0) || __y < long double(0) || __z < long double(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rf."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rf"));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(1) / long double(24);
                    const long double __c2 = long double(1) / long double(10);
                    const long double __c3 = long double(3) / long double(44);
                    const long double __c4 = long double(1) / long double(14);
                    long double __xn = __x;
                    long double __yn = __y;
                    long double __zn = __z;
                    const long double __eps = std::numeric_limits<long double>::epsilon();
                    const long double __errtol = std::pow(__eps, long double(1) / long double(6));
                    long double __mu;
                    long double __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn) / long double(3);
                        __xndev = 2 - (__mu + __xn) / __mu;
                        __yndev = 2 - (__mu + __yn) / __mu;
                        __zndev = 2 - (__mu + __zn) / __mu;
                        long double __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        const long double __xnroot = std::sqrt(__xn);
                        const long double __ynroot = std::sqrt(__yn);
                        const long double __znroot = std::sqrt(__zn);
                        const long double __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    const long double __e2 = __xndev * __yndev - __zndev * __zndev;
                    const long double __e3 = __xndev * __yndev * __zndev;
                    const long double __s = long double(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;
                    return __s / std::sqrt(__mu);
                }
            }
            template <typename _Tp> _Tp __comp_ellint_1_series(_Tp __k)             {
                const _Tp __kk = __k * __k;
                _Tp __term = __kk / _Tp(4);
                _Tp __sum = _Tp(1) + __term;
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 2; __i < __max_iter; ++__i) {
                    __term *= (2 * __i - 1) * __kk / (2 * __i);
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term;
                }
                return __numeric_constants<_Tp>::__pi_2() * __sum;
            }
            template <typename _Tp> _Tp __comp_ellint_1(_Tp __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) >= _Tp(1))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
            }
            template<> float __comp_ellint_1<float>(float __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) >= float(1))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __ellint_rf(float(0), float(1) - __k * __k, float(1));
            }
            template<> long double __comp_ellint_1<long double>(long double __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) >= long double(1))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __ellint_rf(long double(0), long double(1) - __k * __k, long double(1));
            }
            template <typename _Tp> _Tp __ellint_1(_Tp __k, _Tp __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __ellint_1."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
                    const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();
                    const _Tp __s = std::sin(__phi_red);
                    const _Tp __c = std::cos(__phi_red);
                    const _Tp __F = __s * __ellint_rf(__c * __c, _Tp(1) - __k * __k * __s * __s, _Tp(1));
                    if (__n == 0)
                        return __F;
                    else
                        return __F + _Tp(2) * __n * __comp_ellint_1(__k);
                }
            }
            template<> float __ellint_1<float>(float __k, float __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __ellint_1."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<float>::__pi() + float(0.5L));
                    const float __phi_red = __phi - __n * __numeric_constants<float>::__pi();
                    const float __s = std::sin(__phi_red);
                    const float __c = std::cos(__phi_red);
                    const float __F = __s * __ellint_rf(__c * __c, float(1) - __k * __k * __s * __s, float(1));
                    if (__n == 0)
                        return __F;
                    else
                        return __F + float(2) * __n * __comp_ellint_1(__k);
                }
            }
            template<> long double __ellint_1<long double>(long double __k, long double __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __ellint_1."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<long double>::__pi() + long double(0.5L));
                    const long double __phi_red = __phi - __n * __numeric_constants<long double>::__pi();
                    const long double __s = std::sin(__phi_red);
                    const long double __c = std::cos(__phi_red);
                    const long double __F = __s * __ellint_rf(__c * __c, long double(1) - __k * __k * __s * __s, long double(1));
                    if (__n == 0)
                        return __F;
                    else
                        return __F + long double(2) * __n * __comp_ellint_1(__k);
                }
            }
            template <typename _Tp> _Tp __comp_ellint_2_series(_Tp __k)             {
                const _Tp __kk = __k * __k;
                _Tp __term = __kk;
                _Tp __sum = __term;
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 2; __i < __max_iter; ++__i) {
                    const _Tp __i2m = 2 * __i - 1;
                    const _Tp __i2 = 2 * __i;
                    __term *= __i2m * __i2m * __kk / (__i2 * __i2);
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term / __i2m;
                }
                return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
            }
            template <typename _Tp> _Tp __ellint_rd(_Tp __x, _Tp __y, _Tp __z)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
                const _Tp __max = std::numeric_limits<_Tp>::max();
                const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));
                if (__x < _Tp(0) || __y < _Tp(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rd."));
                else if (__x + __y < __lolim || __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rd."));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(3) / _Tp(14);
                    const _Tp __c2 = _Tp(1) / _Tp(6);
                    const _Tp __c3 = _Tp(9) / _Tp(22);
                    const _Tp __c4 = _Tp(3) / _Tp(26);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    _Tp __zn = __z;
                    _Tp __sigma = _Tp(0);
                    _Tp __power4 = _Tp(1);
                    _Tp __mu;
                    _Tp __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        _Tp __xnroot = std::sqrt(__xn);
                        _Tp __ynroot = std::sqrt(__yn);
                        _Tp __znroot = std::sqrt(__zn);
                        _Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __sigma += __power4 / (__znroot * (__zn + __lambda));
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    _Tp __ea = __xndev * __yndev;
                    _Tp __eb = __zndev * __zndev;
                    _Tp __ec = __ea - __eb;
                    _Tp __ed = __ea - _Tp(6) * __eb;
                    _Tp __ef = __ed + __ec + __ec;
                    _Tp __s1 = __ed * (- __c1 + __c3 * __ed / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef / _Tp(2));
                    _Tp __s2 = __zndev * (__c2 * __ef + __zndev * (- __c3 * __ec - __zndev * __c4 - __ea));
                    return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
                }
            }
            template<> float __ellint_rd<float>(float __x, float __y, float __z)             {
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __errtol = std::pow(__eps / float(8), float(1) / float(6));
                const float __max = std::numeric_limits<float>::max();
                const float __lolim = float(2) / std::pow(__max, float(2) / float(3));
                if (__x < float(0) || __y < float(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rd."));
                else if (__x + __y < __lolim || __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rd."));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(3) / float(14);
                    const float __c2 = float(1) / float(6);
                    const float __c3 = float(9) / float(22);
                    const float __c4 = float(3) / float(26);
                    float __xn = __x;
                    float __yn = __y;
                    float __zn = __z;
                    float __sigma = float(0);
                    float __power4 = float(1);
                    float __mu;
                    float __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + float(3) * __zn) / float(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        float __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        float __xnroot = std::sqrt(__xn);
                        float __ynroot = std::sqrt(__yn);
                        float __znroot = std::sqrt(__zn);
                        float __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __sigma += __power4 / (__znroot * (__zn + __lambda));
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    float __ea = __xndev * __yndev;
                    float __eb = __zndev * __zndev;
                    float __ec = __ea - __eb;
                    float __ed = __ea - float(6) * __eb;
                    float __ef = __ed + __ec + __ec;
                    float __s1 = __ed * (-__c1 + __c3 * __ed / float(3) - float(3) * __c4 * __zndev * __ef / float(2));
                    float __s2 = __zndev * (__c2 * __ef + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));
                    return float(3) * __sigma + __power4 * (float(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
                }
            }
            template<> long double __ellint_rd<long double>(long double __x, long double __y, long double __z)             {
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __errtol = std::pow(__eps / long double(8), long double(1) / long double(6));
                const long double __max = std::numeric_limits<long double>::max();
                const long double __lolim = long double(2) / std::pow(__max, long double(2) / long double(3));
                if (__x < long double(0) || __y < long double(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rd."));
                else if (__x + __y < __lolim || __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rd."));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(3) / long double(14);
                    const long double __c2 = long double(1) / long double(6);
                    const long double __c3 = long double(9) / long double(22);
                    const long double __c4 = long double(3) / long double(26);
                    long double __xn = __x;
                    long double __yn = __y;
                    long double __zn = __z;
                    long double __sigma = long double(0);
                    long double __power4 = long double(1);
                    long double __mu;
                    long double __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + long double(3) * __zn) / long double(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        long double __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        long double __xnroot = std::sqrt(__xn);
                        long double __ynroot = std::sqrt(__yn);
                        long double __znroot = std::sqrt(__zn);
                        long double __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __sigma += __power4 / (__znroot * (__zn + __lambda));
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    long double __ea = __xndev * __yndev;
                    long double __eb = __zndev * __zndev;
                    long double __ec = __ea - __eb;
                    long double __ed = __ea - long double(6) * __eb;
                    long double __ef = __ed + __ec + __ec;
                    long double __s1 = __ed * (-__c1 + __c3 * __ed / long double(3) - long double(3) * __c4 * __zndev * __ef / long double(2));
                    long double __s2 = __zndev * (__c2 * __ef + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));
                    return long double(3) * __sigma + __power4 * (long double(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
                }
            }
            template <typename _Tp> _Tp __comp_ellint_2(_Tp __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) == 1)
                    return _Tp(1);
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
                else {
                    const _Tp __kk = __k * __k;
                    return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
                }
            }
            template<> float __comp_ellint_2<float>(float __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) == 1)
                    return float(1);
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
                else {
                    const float __kk = __k * __k;
                    return __ellint_rf(float(0), float(1) - __kk, float(1)) - __kk * __ellint_rd(float(0), float(1) - __kk, float(1)) / float(3);
                }
            }
            template<> long double __comp_ellint_2<long double>(long double __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) == 1)
                    return long double(1);
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
                else {
                    const long double __kk = __k * __k;
                    return __ellint_rf(long double(0), long double(1) - __kk, long double(1)) - __kk * __ellint_rd(long double(0), long double(1) - __kk, long double(1)) / long double(3);
                }
            }
            template <typename _Tp> _Tp __ellint_2(_Tp __k, _Tp __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __ellint_2."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
                    const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();
                    const _Tp __kk = __k * __k;
                    const _Tp __s = std::sin(__phi_red);
                    const _Tp __ss = __s * __s;
                    const _Tp __sss = __ss * __s;
                    const _Tp __c = std::cos(__phi_red);
                    const _Tp __cc = __c * __c;
                    const _Tp __E = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) - __kk * __sss * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1)) / _Tp(3);
                    if (__n == 0)
                        return __E;
                    else
                        return __E + _Tp(2) * __n * __comp_ellint_2(__k);
                }
            }
            template<> float __ellint_2<float>(float __k, float __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __ellint_2."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<float>::__pi() + float(0.5L));
                    const float __phi_red = __phi - __n * __numeric_constants<float>::__pi();
                    const float __kk = __k * __k;
                    const float __s = std::sin(__phi_red);
                    const float __ss = __s * __s;
                    const float __sss = __ss * __s;
                    const float __c = std::cos(__phi_red);
                    const float __cc = __c * __c;
                    const float __E = __s * __ellint_rf(__cc, float(1) - __kk * __ss, float(1)) - __kk * __sss * __ellint_rd(__cc, float(1) - __kk * __ss, float(1)) / float(3);
                    if (__n == 0)
                        return __E;
                    else
                        return __E + float(2) * __n * __comp_ellint_2(__k);
                }
            }
            template<> long double __ellint_2<long double>(long double __k, long double __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __ellint_2."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<long double>::__pi() + long double(0.5L));
                    const long double __phi_red = __phi - __n * __numeric_constants<long double>::__pi();
                    const long double __kk = __k * __k;
                    const long double __s = std::sin(__phi_red);
                    const long double __ss = __s * __s;
                    const long double __sss = __ss * __s;
                    const long double __c = std::cos(__phi_red);
                    const long double __cc = __c * __c;
                    const long double __E = __s * __ellint_rf(__cc, long double(1) - __kk * __ss, long double(1)) - __kk * __sss * __ellint_rd(__cc, long double(1) - __kk * __ss, long double(1)) / long double(3);
                    if (__n == 0)
                        return __E;
                    else
                        return __E + long double(2) * __n * __comp_ellint_2(__k);
                }
            }
            template <typename _Tp> _Tp __ellint_rc(_Tp __x, _Tp __y)             {
                const _Tp __min = std::numeric_limits<_Tp>::min();
                const _Tp __lolim = _Tp(5) * __min;
                if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
                    std::__throw_domain_error(("Argument less than zero in __ellint_rc."));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(1) / _Tp(7);
                    const _Tp __c2 = _Tp(9) / _Tp(22);
                    const _Tp __c3 = _Tp(3) / _Tp(10);
                    const _Tp __c4 = _Tp(3) / _Tp(8);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                    const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
                    _Tp __mu;
                    _Tp __sn;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
                        __sn = (__yn + __mu) / __mu - _Tp(2);
                        if (std::abs(__sn) < __errtol)
                            break;
                        const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                    }
                    _Tp __s = __sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));
                    return (_Tp(1) + __s) / std::sqrt(__mu);
                }
            }
            template<> float __ellint_rc<float>(float __x, float __y)             {
                const float __min = std::numeric_limits<float>::min();
                const float __lolim = float(5) * __min;
                if (__x < float(0) || __y < float(0) || __x + __y < __lolim)
                    std::__throw_domain_error(("Argument less than zero in __ellint_rc."));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(1) / float(7);
                    const float __c2 = float(9) / float(22);
                    const float __c3 = float(3) / float(10);
                    const float __c4 = float(3) / float(8);
                    float __xn = __x;
                    float __yn = __y;
                    const float __eps = std::numeric_limits<float>::epsilon();
                    const float __errtol = std::pow(__eps / float(30), float(1) / float(6));
                    float __mu;
                    float __sn;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + float(2) * __yn) / float(3);
                        __sn = (__yn + __mu) / __mu - float(2);
                        if (std::abs(__sn) < __errtol)
                            break;
                        const float __lambda = float(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                    }
                    float __s = __sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));
                    return (float(1) + __s) / std::sqrt(__mu);
                }
            }
            template<> long double __ellint_rc<long double>(long double __x, long double __y)             {
                const long double __min = std::numeric_limits<long double>::min();
                const long double __lolim = long double(5) * __min;
                if (__x < long double(0) || __y < long double(0) || __x + __y < __lolim)
                    std::__throw_domain_error(("Argument less than zero in __ellint_rc."));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(1) / long double(7);
                    const long double __c2 = long double(9) / long double(22);
                    const long double __c3 = long double(3) / long double(10);
                    const long double __c4 = long double(3) / long double(8);
                    long double __xn = __x;
                    long double __yn = __y;
                    const long double __eps = std::numeric_limits<long double>::epsilon();
                    const long double __errtol = std::pow(__eps / long double(30), long double(1) / long double(6));
                    long double __mu;
                    long double __sn;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + long double(2) * __yn) / long double(3);
                        __sn = (__yn + __mu) / __mu - long double(2);
                        if (std::abs(__sn) < __errtol)
                            break;
                        const long double __lambda = long double(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                    }
                    long double __s = __sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));
                    return (long double(1) + __s) / std::sqrt(__mu);
                }
            }
            template <typename _Tp> _Tp __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)             {
                const _Tp __min = std::numeric_limits<_Tp>::min();
                const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1) / _Tp(3));
                if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rj."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim || __p < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rj"));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(3) / _Tp(14);
                    const _Tp __c2 = _Tp(1) / _Tp(3);
                    const _Tp __c3 = _Tp(3) / _Tp(22);
                    const _Tp __c4 = _Tp(3) / _Tp(26);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    _Tp __zn = __z;
                    _Tp __pn = __p;
                    _Tp __sigma = _Tp(0);
                    _Tp __power4 = _Tp(1);
                    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                    const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
                    _Tp __mu;
                    _Tp __xndev, __yndev, __zndev, __pndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        __pndev = (__mu - __pn) / __mu;
                        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        __epsilon = std::max(__epsilon, std::abs(__pndev));
                        if (__epsilon < __errtol)
                            break;
                        const _Tp __xnroot = std::sqrt(__xn);
                        const _Tp __ynroot = std::sqrt(__yn);
                        const _Tp __znroot = std::sqrt(__zn);
                        const _Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot) + __xnroot * __ynroot * __znroot;
                        const _Tp __alpha2 = __alpha1 * __alpha1;
                        const _Tp __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
                        __sigma += __power4 * __ellint_rc(__alpha2, __beta);
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                        __pn = __c0 * (__pn + __lambda);
                    }
                    _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
                    _Tp __eb = __xndev * __yndev * __zndev;
                    _Tp __ec = __pndev * __pndev;
                    _Tp __e2 = __ea - _Tp(3) * __ec;
                    _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
                    _Tp __s1 = _Tp(1) + __e2 * (- __c1 + _Tp(3) * __c3 * __e2 / _Tp(4) - _Tp(3) * __c4 * __e3 / _Tp(2));
                    _Tp __s2 = __eb * (__c2 / _Tp(2) + __pndev * (- __c3 - __c3 + __pndev * __c4));
                    _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;
                    return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
                }
            }
            template<> float __ellint_rj<float>(float __x, float __y, float __z, float __p)             {
                const float __min = std::numeric_limits<float>::min();
                const float __lolim = std::pow(float(5) * __min, float(1) / float(3));
                if (__x < float(0) || __y < float(0) || __z < float(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rj."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim || __p < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rj"));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(3) / float(14);
                    const float __c2 = float(1) / float(3);
                    const float __c3 = float(3) / float(22);
                    const float __c4 = float(3) / float(26);
                    float __xn = __x;
                    float __yn = __y;
                    float __zn = __z;
                    float __pn = __p;
                    float __sigma = float(0);
                    float __power4 = float(1);
                    const float __eps = std::numeric_limits<float>::epsilon();
                    const float __errtol = std::pow(__eps / float(8), float(1) / float(6));
                    float __mu;
                    float __xndev, __yndev, __zndev, __pndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn + float(2) * __pn) / float(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        __pndev = (__mu - __pn) / __mu;
                        float __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        __epsilon = std::max(__epsilon, std::abs(__pndev));
                        if (__epsilon < __errtol)
                            break;
                        const float __xnroot = std::sqrt(__xn);
                        const float __ynroot = std::sqrt(__yn);
                        const float __znroot = std::sqrt(__zn);
                        const float __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        const float __alpha1 = __pn * (__xnroot + __ynroot + __znroot) + __xnroot * __ynroot * __znroot;
                        const float __alpha2 = __alpha1 * __alpha1;
                        const float __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
                        __sigma += __power4 * __ellint_rc(__alpha2, __beta);
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                        __pn = __c0 * (__pn + __lambda);
                    }
                    float __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
                    float __eb = __xndev * __yndev * __zndev;
                    float __ec = __pndev * __pndev;
                    float __e2 = __ea - float(3) * __ec;
                    float __e3 = __eb + float(2) * __pndev * (__ea - __ec);
                    float __s1 = float(1) + __e2 * (-__c1 + float(3) * __c3 * __e2 / float(4) - float(3) * __c4 * __e3 / float(2));
                    float __s2 = __eb * (__c2 / float(2) + __pndev * (-__c3 - __c3 + __pndev * __c4));
                    float __s3 = __pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;
                    return float(3) * __sigma + __power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
                }
            }
            template<> long double __ellint_rj<long double>(long double __x, long double __y, long double __z, long double __p)             {
                const long double __min = std::numeric_limits<long double>::min();
                const long double __lolim = std::pow(long double(5) * __min, long double(1) / long double(3));
                if (__x < long double(0) || __y < long double(0) || __z < long double(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rj."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim || __p < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rj"));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(3) / long double(14);
                    const long double __c2 = long double(1) / long double(3);
                    const long double __c3 = long double(3) / long double(22);
                    const long double __c4 = long double(3) / long double(26);
                    long double __xn = __x;
                    long double __yn = __y;
                    long double __zn = __z;
                    long double __pn = __p;
                    long double __sigma = long double(0);
                    long double __power4 = long double(1);
                    const long double __eps = std::numeric_limits<long double>::epsilon();
                    const long double __errtol = std::pow(__eps / long double(8), long double(1) / long double(6));
                    long double __mu;
                    long double __xndev, __yndev, __zndev, __pndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn + long double(2) * __pn) / long double(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        __pndev = (__mu - __pn) / __mu;
                        long double __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        __epsilon = std::max(__epsilon, std::abs(__pndev));
                        if (__epsilon < __errtol)
                            break;
                        const long double __xnroot = std::sqrt(__xn);
                        const long double __ynroot = std::sqrt(__yn);
                        const long double __znroot = std::sqrt(__zn);
                        const long double __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        const long double __alpha1 = __pn * (__xnroot + __ynroot + __znroot) + __xnroot * __ynroot * __znroot;
                        const long double __alpha2 = __alpha1 * __alpha1;
                        const long double __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
                        __sigma += __power4 * __ellint_rc(__alpha2, __beta);
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                        __pn = __c0 * (__pn + __lambda);
                    }
                    long double __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
                    long double __eb = __xndev * __yndev * __zndev;
                    long double __ec = __pndev * __pndev;
                    long double __e2 = __ea - long double(3) * __ec;
                    long double __e3 = __eb + long double(2) * __pndev * (__ea - __ec);
                    long double __s1 = long double(1) + __e2 * (-__c1 + long double(3) * __c3 * __e2 / long double(4) - long double(3) * __c4 * __e3 / long double(2));
                    long double __s2 = __eb * (__c2 / long double(2) + __pndev * (-__c3 - __c3 + __pndev * __c4));
                    long double __s3 = __pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;
                    return long double(3) * __sigma + __power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
                }
            }
            template <typename _Tp> _Tp __comp_ellint_3(_Tp __k, _Tp __nu)             {
                if (__isnan(__k) || __isnan(__nu))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__nu == _Tp(1))
                    return std::numeric_limits<_Tp>::infinity();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
                else {
                    const _Tp __kk = __k * __k;
                    return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) + __nu * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu) / _Tp(3);
                }
            }
            template<> float __comp_ellint_3<float>(float __k, float __nu)             {
                if (__isnan(__k) || __isnan(__nu))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__nu == float(1))
                    return std::numeric_limits<float>::infinity();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
                else {
                    const float __kk = __k * __k;
                    return __ellint_rf(float(0), float(1) - __kk, float(1)) + __nu * __ellint_rj(float(0), float(1) - __kk, float(1), float(1) - __nu) / float(3);
                }
            }
            template<> long double __comp_ellint_3<long double>(long double __k, long double __nu)             {
                if (__isnan(__k) || __isnan(__nu))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__nu == long double(1))
                    return std::numeric_limits<long double>::infinity();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
                else {
                    const long double __kk = __k * __k;
                    return __ellint_rf(long double(0), long double(1) - __kk, long double(1)) + __nu * __ellint_rj(long double(0), long double(1) - __kk, long double(1), long double(1) - __nu) / long double(3);
                }
            }
            template <typename _Tp> _Tp __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)             {
                if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __ellint_3."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
                    const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();
                    const _Tp __kk = __k * __k;
                    const _Tp __s = std::sin(__phi_red);
                    const _Tp __ss = __s * __s;
                    const _Tp __sss = __ss * __s;
                    const _Tp __c = std::cos(__phi_red);
                    const _Tp __cc = __c * __c;
                    const _Tp __Pi = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) + __nu * __sss * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1), _Tp(1) - __nu * __ss) / _Tp(3);
                    if (__n == 0)
                        return __Pi;
                    else
                        return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
                }
            }
            template<> float __ellint_3<float>(float __k, float __nu, float __phi)             {
                if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __ellint_3."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<float>::__pi() + float(0.5L));
                    const float __phi_red = __phi - __n * __numeric_constants<float>::__pi();
                    const float __kk = __k * __k;
                    const float __s = std::sin(__phi_red);
                    const float __ss = __s * __s;
                    const float __sss = __ss * __s;
                    const float __c = std::cos(__phi_red);
                    const float __cc = __c * __c;
                    const float __Pi = __s * __ellint_rf(__cc, float(1) - __kk * __ss, float(1)) + __nu * __sss * __ellint_rj(__cc, float(1) - __kk * __ss, float(1), float(1) - __nu * __ss) / float(3);
                    if (__n == 0)
                        return __Pi;
                    else
                        return __Pi + float(2) * __n * __comp_ellint_3(__k, __nu);
                }
            }
            template<> long double __ellint_3<long double>(long double __k, long double __nu, long double __phi)             {
                if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __ellint_3."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<long double>::__pi() + long double(0.5L));
                    const long double __phi_red = __phi - __n * __numeric_constants<long double>::__pi();
                    const long double __kk = __k * __k;
                    const long double __s = std::sin(__phi_red);
                    const long double __ss = __s * __s;
                    const long double __sss = __ss * __s;
                    const long double __c = std::cos(__phi_red);
                    const long double __cc = __c * __c;
                    const long double __Pi = __s * __ellint_rf(__cc, long double(1) - __kk * __ss, long double(1)) + __nu * __sss * __ellint_rj(__cc, long double(1) - __kk * __ss, long double(1), long double(1) - __nu * __ss) / long double(3);
                    if (__n == 0)
                        return __Pi;
                    else
                        return __Pi + long double(2) * __n * __comp_ellint_3(__k, __nu);
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __expint_E1(_Tp);
            template <typename _Tp> _Tp __expint_E1_series(_Tp __x)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                _Tp __term = _Tp(1);
                _Tp __esum = _Tp(0);
                _Tp __osum = _Tp(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= - __x / __i;
                    if (std::abs(__term) < __eps)
                        break;
                    if (__term >= _Tp(0))
                        __esum += __term / __i;
                    else
                        __osum += __term / __i;
                }
                return - __esum - __osum - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
            }
            template<> float __expint_E1_series<float>(float __x)             {
                const float __eps = std::numeric_limits<float>::epsilon();
                float __term = float(1);
                float __esum = float(0);
                float __osum = float(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= -__x / __i;
                    if (std::abs(__term) < __eps)
                        break;
                    if (__term >= float(0))
                        __esum += __term / __i;
                    else
                        __osum += __term / __i;
                }
                return -__esum - __osum - __numeric_constants<float>::__gamma_e() - std::log(__x);
            }
            template<> long double __expint_E1_series<long double>(long double __x)             {
                const long double __eps = std::numeric_limits<long double>::epsilon();
                long double __term = long double(1);
                long double __esum = long double(0);
                long double __osum = long double(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= -__x / __i;
                    if (std::abs(__term) < __eps)
                        break;
                    if (__term >= long double(0))
                        __esum += __term / __i;
                    else
                        __osum += __term / __i;
                }
                return -__esum - __osum - __numeric_constants<long double>::__gamma_e() - std::log(__x);
            }
            template <typename _Tp> _Tp __expint_E1_asymp(_Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __esum = _Tp(1);
                _Tp __osum = _Tp(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    _Tp __prev = __term;
                    __term *= -__i / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    if (__term >= _Tp(0))
                        __esum += __term;
                    else
                        __osum += __term;
                }
                return std::exp(- __x) * (__esum + __osum) / __x;
            }
            template<> float __expint_E1_asymp<float>(float __x)             {
                float __term = float(1);
                float __esum = float(1);
                float __osum = float(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    float __prev = __term;
                    __term *= -__i / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    if (__term >= float(0))
                        __esum += __term;
                    else
                        __osum += __term;
                }
                return std::exp(-__x) * (__esum + __osum) / __x;
            }
            template<> long double __expint_E1_asymp<long double>(long double __x)             {
                long double __term = long double(1);
                long double __esum = long double(1);
                long double __osum = long double(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    long double __prev = __term;
                    __term *= -__i / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    if (__term >= long double(0))
                        __esum += __term;
                    else
                        __osum += __term;
                }
                return std::exp(-__x) * (__esum + __osum) / __x;
            }
            template <typename _Tp> _Tp __expint_En_series(unsigned int __n, _Tp __x)             {
                const unsigned int __max_iter = 1000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const int __nm1 = __n - 1;
                _Tp __ans = (__nm1 != 0 ? _Tp(1) / __nm1 : - std::log(__x) - __numeric_constants<_Tp>::__gamma_e());
                _Tp __fact = _Tp(1);
                for (int __i = 1; __i <= __max_iter; ++__i) {
                    __fact *= - __x / _Tp(__i);
                    _Tp __del;
                    if (__i != __nm1)
                        __del = - __fact / _Tp(__i - __nm1);
                    else {
                        _Tp __psi = - __numeric_constants<_Tp>::gamma_e();
                        for (int __ii = 1; __ii <= __nm1; ++__ii)
                            __psi += _Tp(1) / _Tp(__ii);
                        __del = __fact * (__psi - std::log(__x));
                    }
                    __ans += __del;
                    if (std::abs(__del) < __eps * std::abs(__ans))
                        return __ans;
                }
                std::__throw_runtime_error(("Series summation failed in __expint_En_series."));
            }
            template <typename _Tp> _Tp __expint_En_cont_frac(unsigned int __n, _Tp __x)             {
                const unsigned int __max_iter = 1000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __fp_min = std::numeric_limits<_Tp>::min();
                const int __nm1 = __n - 1;
                _Tp __b = __x + _Tp(__n);
                _Tp __c = _Tp(1) / __fp_min;
                _Tp __d = _Tp(1) / __b;
                _Tp __h = __d;
                for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
                    _Tp __a = - _Tp(__i * (__nm1 + __i));
                    __b += _Tp(2);
                    __d = _Tp(1) / (__a * __d + __b);
                    __c = __b + __a / __c;
                    const _Tp __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - _Tp(1)) < __eps) {
                        const _Tp __ans = __h * std::exp(- __x);
                        return __ans;
                    }
                }
                std::__throw_runtime_error(("Continued fraction failed in __expint_En_cont_frac."));
            }
            template<> float __expint_En_cont_frac<float>(unsigned int __n, float __x)             {
                const unsigned int __max_iter = 1000;
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __fp_min = std::numeric_limits<float>::min();
                const int __nm1 = __n - 1;
                float __b = __x + float(__n);
                float __c = float(1) / __fp_min;
                float __d = float(1) / __b;
                float __h = __d;
                for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
                    float __a = -float(__i * (__nm1 + __i));
                    __b += float(2);
                    __d = float(1) / (__a * __d + __b);
                    __c = __b + __a / __c;
                    const float __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - float(1)) < __eps) {
                        const float __ans = __h * std::exp(-__x);
                        return __ans;
                    }
                }
                std::__throw_runtime_error(("Continued fraction failed in __expint_En_cont_frac."));
            }
            template<> long double __expint_En_cont_frac<long double>(unsigned int __n, long double __x)             {
                const unsigned int __max_iter = 1000;
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __fp_min = std::numeric_limits<long double>::min();
                const int __nm1 = __n - 1;
                long double __b = __x + long double(__n);
                long double __c = long double(1) / __fp_min;
                long double __d = long double(1) / __b;
                long double __h = __d;
                for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
                    long double __a = -long double(__i * (__nm1 + __i));
                    __b += long double(2);
                    __d = long double(1) / (__a * __d + __b);
                    __c = __b + __a / __c;
                    const long double __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - long double(1)) < __eps) {
                        const long double __ans = __h * std::exp(-__x);
                        return __ans;
                    }
                }
                std::__throw_runtime_error(("Continued fraction failed in __expint_En_cont_frac."));
            }
            template <typename _Tp> _Tp __expint_En_recursion(unsigned int __n, _Tp __x)             {
                _Tp __En;
                _Tp __E1 = __expint_E1(__x);
                if (__x < _Tp(__n)) {
                    __En = __E1;
                    for (unsigned int __j = 2; __j < __n; ++__j)
                        __En = (std::exp(- __x) - __x * __En) / _Tp(__j - 1);
                } else {
                    __En = _Tp(1);
                    const int __N = __n + 20;
                    _Tp __save = _Tp(0);
                    for (int __j = __N; __j > 0; --__j) {
                        __En = (std::exp(- __x) - __j * __En) / __x;
                        if (__j == __n)
                            __save = __En;
                    }
                    _Tp __norm = __En / __E1;
                    __En /= __norm;
                }
                return __En;
            }
            template <typename _Tp> _Tp __expint_Ei_series(_Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __x / __i;
                    __sum += __term / __i;
                    if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
                        break;
                }
                return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
            }
            template<> float __expint_Ei_series<float>(float __x)             {
                float __term = float(1);
                float __sum = float(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __x / __i;
                    __sum += __term / __i;
                    if (__term < std::numeric_limits<float>::epsilon() * __sum)
                        break;
                }
                return __numeric_constants<float>::__gamma_e() + __sum + std::log(__x);
            }
            template<> long double __expint_Ei_series<long double>(long double __x)             {
                long double __term = long double(1);
                long double __sum = long double(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __x / __i;
                    __sum += __term / __i;
                    if (__term < std::numeric_limits<long double>::epsilon() * __sum)
                        break;
                }
                return __numeric_constants<long double>::__gamma_e() + __sum + std::log(__x);
            }
            template <typename _Tp> _Tp __expint_Ei_asymp(_Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(1);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    _Tp __prev = __term;
                    __term *= __i / __x;
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    if (__term >= __prev)
                        break;
                    __sum += __term;
                }
                return std::exp(__x) * __sum / __x;
            }
            template<> float __expint_Ei_asymp<float>(float __x)             {
                float __term = float(1);
                float __sum = float(1);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    float __prev = __term;
                    __term *= __i / __x;
                    if (__term < std::numeric_limits<float>::epsilon())
                        break;
                    if (__term >= __prev)
                        break;
                    __sum += __term;
                }
                return std::exp(__x) * __sum / __x;
            }
            template<> long double __expint_Ei_asymp<long double>(long double __x)             {
                long double __term = long double(1);
                long double __sum = long double(1);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    long double __prev = __term;
                    __term *= __i / __x;
                    if (__term < std::numeric_limits<long double>::epsilon())
                        break;
                    if (__term >= __prev)
                        break;
                    __sum += __term;
                }
                return std::exp(__x) * __sum / __x;
            }
            template <typename _Tp> _Tp __expint_Ei(_Tp __x)             {
                if (__x < _Tp(0))
                    return - __expint_E1(- __x);
                else if (__x < - std::log(std::numeric_limits<_Tp>::epsilon()))
                    return __expint_Ei_series(__x);
                else
                    return __expint_Ei_asymp(__x);
            }
            template<> float __expint_Ei<float>(float __x)             {
                if (__x < float(0))
                    return -__expint_E1(-__x);
                else if (__x < -std::log(std::numeric_limits<float>::epsilon()))
                    return __expint_Ei_series(__x);
                else
                    return __expint_Ei_asymp(__x);
            }
            template<> long double __expint_Ei<long double>(long double __x)             {
                if (__x < long double(0))
                    return -__expint_E1(-__x);
                else if (__x < -std::log(std::numeric_limits<long double>::epsilon()))
                    return __expint_Ei_series(__x);
                else
                    return __expint_Ei_asymp(__x);
            }
            template <typename _Tp> _Tp __expint_E1(_Tp __x)             {
                if (__x < _Tp(0))
                    return - __expint_Ei(- __x);
                else if (__x < _Tp(1))
                    return __expint_E1_series(__x);
                else if (__x < _Tp(100))
                    return __expint_En_cont_frac(1, __x);
                else
                    return __expint_E1_asymp(__x);
            }
            template<> float __expint_E1<float>(float __x)             {
                if (__x < float(0))
                    return -__expint_Ei(-__x);
                else if (__x < float(1))
                    return __expint_E1_series(__x);
                else if (__x < float(100))
                    return __expint_En_cont_frac(1, __x);
                else
                    return __expint_E1_asymp(__x);
            }
            template<> long double __expint_E1<long double>(long double __x)             {
                if (__x < long double(0))
                    return -__expint_Ei(-__x);
                else if (__x < long double(1))
                    return __expint_E1_series(__x);
                else if (__x < long double(100))
                    return __expint_En_cont_frac(1, __x);
                else
                    return __expint_E1_asymp(__x);
            }
            template <typename _Tp> _Tp __expint_asymp(unsigned int __n, _Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(1);
                for (unsigned int __i = 1; __i <= __n; ++__i) {
                    _Tp __prev = __term;
                    __term *= -(__n - __i + 1) / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    __sum += __term;
                }
                return std::exp(- __x) * __sum / __x;
            }
            template <typename _Tp> _Tp __expint_large_n(unsigned int __n, _Tp __x)             {
                const _Tp __xpn = __x + __n;
                const _Tp __xpn2 = __xpn * __xpn;
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(1);
                for (unsigned int __i = 1; __i <= __n; ++__i) {
                    _Tp __prev = __term;
                    __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
                    if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term;
                }
                return std::exp(- __x) * __sum / __xpn;
            }
            template <typename _Tp> _Tp __expint(unsigned int __n, _Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__n <= 1 && __x == _Tp(0))
                    return std::numeric_limits<_Tp>::infinity();
                else {
                    _Tp __E0 = std::exp(__x) / __x;
                    if (__n == 0)
                        return __E0;
                    _Tp __E1 = __expint_E1(__x);
                    if (__n == 1)
                        return __E1;
                    if (__x == _Tp(0))
                        return _Tp(1) / static_cast<_Tp>(__n - 1);
                    _Tp __En = __expint_En_recursion(__n, __x);
                    return __En;
                }
            }
            template <typename _Tp> inline _Tp __expint(_Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __expint_Ei(__x);
            }
            template<> inline float __expint<float>(float __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __expint_Ei(__x);
            }
            template<> inline long double __expint<long double>(long double __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __expint_Ei(__x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                _Tp __term = _Tp(1);
                _Tp __Fac = _Tp(1);
                const unsigned int __max_iter = 100000;
                unsigned int __i;
                for (__i = 0; __i < __max_iter; ++__i) {
                    __term *= (__a + _Tp(__i)) * __x / ((__c + _Tp(__i)) * _Tp(1 + __i));
                    if (std::abs(__term) < __eps) {
                        break;
                    }
                    __Fac += __term;
                }
                if (__i == __max_iter)
                    std::__throw_runtime_error(("Series failed to converge in __conf_hyperg_series."));
                return __Fac;
            }
            template <typename _Tp> _Tp __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)             {
                const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.159999999999999999997L));
                const int __nmax = 20000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __x = - __xin;
                const _Tp __x3 = __x * __x * __x;
                const _Tp __t0 = __a / __c;
                const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
                const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
                _Tp __F = _Tp(1);
                _Tp __prec;
                _Tp __Bnm3 = _Tp(1);
                _Tp __Bnm2 = _Tp(1) + __t1 * __x;
                _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);
                _Tp __Anm3 = _Tp(1);
                _Tp __Anm2 = __Bnm2 - __t0 * __x;
                _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;
                int __n = 3;
                while (1)
                    {
                        _Tp __npam1 = _Tp(__n - 1) + __a;
                        _Tp __npcm1 = _Tp(__n - 1) + __c;
                        _Tp __npam2 = _Tp(__n - 2) + __a;
                        _Tp __npcm2 = _Tp(__n - 2) + __c;
                        _Tp __tnm1 = _Tp(2 * __n - 1);
                        _Tp __tnm3 = _Tp(2 * __n - 3);
                        _Tp __tnm5 = _Tp(2 * __n - 5);
                        _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
                        _Tp __F2 = (_Tp(__n) + __a) * __npam1 / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
                        _Tp __F3 = - __npam2 * __npam1 * (_Tp(__n - 2) - __a) / (_Tp(8) * __tnm3 * __tnm3 * __tnm5 * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
                        _Tp __E = - __npam1 * (_Tp(__n - 1) - __c) / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);
                        _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
                        _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
                        _Tp __r = __An / __Bn;
                        __prec = std::abs((__F - __r) / __F);
                        __F = __r;
                        if (__prec < __eps || __n > __nmax)
                            break;
                        if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
                            __An /= __big;
                            __Bn /= __big;
                            __Anm1 /= __big;
                            __Bnm1 /= __big;
                            __Anm2 /= __big;
                            __Bnm2 /= __big;
                            __Anm3 /= __big;
                            __Bnm3 /= __big;
                        } else if (std::abs(__An) < _Tp(1) / __big || std::abs(__Bn) < _Tp(1) / __big) {
                            __An *= __big;
                            __Bn *= __big;
                            __Anm1 *= __big;
                            __Bnm1 *= __big;
                            __Anm2 *= __big;
                            __Bnm2 *= __big;
                            __Anm3 *= __big;
                            __Bnm3 *= __big;
                        }
                        ++__n;
                        __Bnm3 = __Bnm2;
                        __Bnm2 = __Bnm1;
                        __Bnm1 = __Bn;
                        __Anm3 = __Anm2;
                        __Anm2 = __Anm1;
                        __Anm1 = __An;
                    }
                if (__n >= __nmax)
                    std::__throw_runtime_error(("Iteration failed to converge in __conf_hyperg_luke."));
                return __F;
            }
            template <typename _Tp> _Tp __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)             {
                const _Tp __c_nint = ::std::nearbyint(__c);
                if (__isnan(__a) || __isnan(__c) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__c_nint == __c && __c_nint <= 0)
                    return std::numeric_limits<_Tp>::infinity();
                else if (__a == _Tp(0))
                    return _Tp(1);
                else if (__c == __a)
                    return std::exp(__x);
                else if (__x < _Tp(0))
                    return __conf_hyperg_luke(__a, __c, __x);
                else
                    return __conf_hyperg_series(__a, __c, __x);
            }
            template <typename _Tp> _Tp __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                _Tp __term = _Tp(1);
                _Tp __Fabc = _Tp(1);
                const unsigned int __max_iter = 100000;
                unsigned int __i;
                for (__i = 0; __i < __max_iter; ++__i) {
                    __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x / ((__c + _Tp(__i)) * _Tp(1 + __i));
                    if (std::abs(__term) < __eps) {
                        break;
                    }
                    __Fabc += __term;
                }
                if (__i == __max_iter)
                    std::__throw_runtime_error(("Series failed to converge in __hyperg_series."));
                return __Fabc;
            }
            template <typename _Tp> _Tp __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)             {
                const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.159999999999999999997L));
                const int __nmax = 20000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __x = - __xin;
                const _Tp __x3 = __x * __x * __x;
                const _Tp __t0 = __a * __b / __c;
                const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
                const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
                _Tp __F = _Tp(1);
                _Tp __Bnm3 = _Tp(1);
                _Tp __Bnm2 = _Tp(1) + __t1 * __x;
                _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);
                _Tp __Anm3 = _Tp(1);
                _Tp __Anm2 = __Bnm2 - __t0 * __x;
                _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;
                int __n = 3;
                while (1)
                    {
                        const _Tp __npam1 = _Tp(__n - 1) + __a;
                        const _Tp __npbm1 = _Tp(__n - 1) + __b;
                        const _Tp __npcm1 = _Tp(__n - 1) + __c;
                        const _Tp __npam2 = _Tp(__n - 2) + __a;
                        const _Tp __npbm2 = _Tp(__n - 2) + __b;
                        const _Tp __npcm2 = _Tp(__n - 2) + __c;
                        const _Tp __tnm1 = _Tp(2 * __n - 1);
                        const _Tp __tnm3 = _Tp(2 * __n - 3);
                        const _Tp __tnm5 = _Tp(2 * __n - 5);
                        const _Tp __n2 = __n * __n;
                        const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n + _Tp(2) - __a * __b - _Tp(2) * (__a + __b)) / (_Tp(2) * __tnm3 * __npcm1);
                        const _Tp __F2 = - (_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n + _Tp(2) - __a * __b) * __npam1 * __npbm1 / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
                        const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1 * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b)) / (_Tp(8) * __tnm3 * __tnm3 * __tnm5 * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
                        const _Tp __E = - __npam1 * __npbm1 * (_Tp(__n - 1) - __c) / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);
                        _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
                        _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
                        const _Tp __r = __An / __Bn;
                        const _Tp __prec = std::abs((__F - __r) / __F);
                        __F = __r;
                        if (__prec < __eps || __n > __nmax)
                            break;
                        if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
                            __An /= __big;
                            __Bn /= __big;
                            __Anm1 /= __big;
                            __Bnm1 /= __big;
                            __Anm2 /= __big;
                            __Bnm2 /= __big;
                            __Anm3 /= __big;
                            __Bnm3 /= __big;
                        } else if (std::abs(__An) < _Tp(1) / __big || std::abs(__Bn) < _Tp(1) / __big) {
                            __An *= __big;
                            __Bn *= __big;
                            __Anm1 *= __big;
                            __Bnm1 *= __big;
                            __Anm2 *= __big;
                            __Bnm2 *= __big;
                            __Anm3 *= __big;
                            __Bnm3 *= __big;
                        }
                        ++__n;
                        __Bnm3 = __Bnm2;
                        __Bnm2 = __Bnm1;
                        __Bnm1 = __Bn;
                        __Anm3 = __Anm2;
                        __Anm2 = __Anm1;
                        __Anm1 = __An;
                    }
                if (__n >= __nmax)
                    std::__throw_runtime_error(("Iteration failed to converge in __hyperg_luke."));
                return __F;
            }
            template <typename _Tp> _Tp __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)             {
                const _Tp __d = __c - __a - __b;
                const int __intd = std::floor(__d + _Tp(0.5L));
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __toler = _Tp(1000) * __eps;
                const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
                const bool __d_integer = (std::abs(__d - __intd) < __toler);
                if (__d_integer) {
                    const _Tp __ln_omx = std::log(_Tp(1) - __x);
                    const _Tp __ad = std::abs(__d);
                    _Tp __F1, __F2;
                    _Tp __d1, __d2;
                    if (__d >= _Tp(0)) {
                        __d1 = __d;
                        __d2 = _Tp(0);
                    } else {
                        __d1 = _Tp(0);
                        __d2 = __d;
                    }
                    const _Tp __lng_c = __log_gamma(__c);
                    if (__ad < __eps) {
                        __F1 = _Tp(0);
                    } else {
                        bool __ok_d1 = true;
                        _Tp __lng_ad, __lng_ad1, __lng_bd1;
                        try {
                            __lng_ad = __log_gamma(__ad);
                            __lng_ad1 = __log_gamma(__a + __d1);
                            __lng_bd1 = __log_gamma(__b + __d1);
                        } catch (...) {
                            __ok_d1 = false;
                        }
                        if (__ok_d1) {
                            _Tp __sum1 = _Tp(1);
                            _Tp __term = _Tp(1);
                            _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx - __lng_ad1 - __lng_bd1;
                            for (int __i = 1; __i < __ad; ++__i) {
                                const int __j = __i - 1;
                                __term *= (__a + __d2 + __j) * (__b + __d2 + __j) / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                                __sum1 += __term;
                            }
                            if (__ln_pre1 > __log_max)
                                std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_luke."));
                            else
                                __F1 = std::exp(__ln_pre1) * __sum1;
                        } else {
                            __F1 = _Tp(0);
                        }
                    }
                    bool __ok_d2 = true;
                    _Tp __lng_ad2, __lng_bd2;
                    try {
                        __lng_ad2 = __log_gamma(__a + __d2);
                        __lng_bd2 = __log_gamma(__b + __d2);
                    } catch (...) {
                        __ok_d2 = false;
                    }
                    if (__ok_d2) {
                        const int __maxiter = 2000;
                        const _Tp __psi_1 = - __numeric_constants<_Tp>::__gamma_e();
                        const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
                        const _Tp __psi_apd1 = __psi(__a + __d1);
                        const _Tp __psi_bpd1 = __psi(__b + __d1);
                        _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1 - __psi_bpd1 - __ln_omx;
                        _Tp __fact = _Tp(1);
                        _Tp __sum2 = __psi_term;
                        _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx - __lng_ad2 - __lng_bd2;
                        int __j;
                        for (__j = 1; __j < __maxiter; ++__j) {
                            const _Tp __term1 = _Tp(1) / _Tp(__j) + _Tp(1) / (__ad + __j);
                            const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1)) + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                            __psi_term += __term1 - __term2;
                            __fact *= (__a + __d1 + _Tp(__j - 1)) * (__b + __d1 + _Tp(__j - 1)) / ((__ad + __j) * __j) * (_Tp(1) - __x);
                            const _Tp __delta = __fact * __psi_term;
                            __sum2 += __delta;
                            if (std::abs(__delta) < __eps * std::abs(__sum2))
                                break;
                        }
                        if (__j == __maxiter)
                            std::__throw_runtime_error(("Sum F2 failed to converge in __hyperg_reflect"));
                        if (__sum2 == _Tp(0))
                            __F2 = _Tp(0);
                        else
                            __F2 = std::exp(__ln_pre2) * __sum2;
                    } else {
                        __F2 = _Tp(0);
                    }
                    const _Tp __sgn_2 = (__intd % 2 == 1 ? - _Tp(1) : _Tp(1));
                    const _Tp __F = __F1 + __sgn_2 * __F2;
                    return __F;
                } else {
                    bool __ok1 = true;
                    _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
                    _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
                    try {
                        __sgn_g1ca = __log_gamma_sign(__c - __a);
                        __ln_g1ca = __log_gamma(__c - __a);
                        __sgn_g1cb = __log_gamma_sign(__c - __b);
                        __ln_g1cb = __log_gamma(__c - __b);
                    } catch (...) {
                        __ok1 = false;
                    }
                    bool __ok2 = true;
                    _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
                    _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
                    try {
                        __sgn_g2a = __log_gamma_sign(__a);
                        __ln_g2a = __log_gamma(__a);
                        __sgn_g2b = __log_gamma_sign(__b);
                        __ln_g2b = __log_gamma(__b);
                    } catch (...) {
                        __ok2 = false;
                    }
                    const _Tp __sgn_gc = __log_gamma_sign(__c);
                    const _Tp __ln_gc = __log_gamma(__c);
                    const _Tp __sgn_gd = __log_gamma_sign(__d);
                    const _Tp __ln_gd = __log_gamma(__d);
                    const _Tp __sgn_gmd = __log_gamma_sign(- __d);
                    const _Tp __ln_gmd = __log_gamma(- __d);
                    const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
                    const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;
                    _Tp __pre1, __pre2;
                    if (__ok1 && __ok2) {
                        _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
                        _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b + __d * std::log(_Tp(1) - __x);
                        if (__ln_pre1 < __log_max && __ln_pre2 < __log_max) {
                            __pre1 = std::exp(__ln_pre1);
                            __pre2 = std::exp(__ln_pre2);
                            __pre1 *= __sgn1;
                            __pre2 *= __sgn2;
                        } else {
                            std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_reflect"));
                        }
                    } else if (__ok1 && !__ok2) {
                        _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
                        if (__ln_pre1 < __log_max) {
                            __pre1 = std::exp(__ln_pre1);
                            __pre1 *= __sgn1;
                            __pre2 = _Tp(0);
                        } else {
                            std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_reflect"));
                        }
                    } else if (!__ok1 && __ok2) {
                        _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b + __d * std::log(_Tp(1) - __x);
                        if (__ln_pre2 < __log_max) {
                            __pre1 = _Tp(0);
                            __pre2 = std::exp(__ln_pre2);
                            __pre2 *= __sgn2;
                        } else {
                            std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_reflect"));
                        }
                    } else {
                        __pre1 = _Tp(0);
                        __pre2 = _Tp(0);
                        std::__throw_runtime_error(("Underflow of gamma functions in __hyperg_reflect"));
                    }
                    const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d, _Tp(1) - __x);
                    const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d, _Tp(1) - __x);
                    const _Tp __F = __pre1 * __F1 + __pre2 * __F2;
                    return __F;
                }
            }
            template <typename _Tp> _Tp __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)             {
                const _Tp __a_nint = ::std::nearbyint(__a);
                const _Tp __b_nint = ::std::nearbyint(__b);
                const _Tp __c_nint = ::std::nearbyint(__c);
                const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
                if (std::abs(__x) >= _Tp(1))
                    std::__throw_domain_error(("Argument outside unit circle in __hyperg."));
                else if (__isnan(__a) || __isnan(__b) || __isnan(__c) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__c_nint == __c && __c_nint <= _Tp(0))
                    return std::numeric_limits<_Tp>::infinity();
                else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
                    return std::pow(_Tp(1) - __x, __c - __a - __b);
                else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0) && __x >= _Tp(0) && __x < _Tp(0.995000000000000000004L))
                    return __hyperg_series(__a, __b, __c, __x);
                else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10)) {
                    if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
                        return __hyperg_series(__a_nint, __b, __c, __x);
                    else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
                        return __hyperg_series(__a, __b_nint, __c, __x);
                    else if (__x < - _Tp(0.25L))
                        return __hyperg_luke(__a, __b, __c, __x);
                    else if (__x < _Tp(0.5L))
                        return __hyperg_series(__a, __b, __c, __x);
                    else if (std::abs(__c) > _Tp(10))
                        return __hyperg_series(__a, __b, __c, __x);
                    else
                        return __hyperg_reflect(__a, __b, __c, __x);
                } else
                    return __hyperg_luke(__a, __b, __c, __x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __poly_legendre_p(unsigned int __l, _Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x == + _Tp(1))
                    return + _Tp(1);
                else if (__x == - _Tp(1))
                    return (__l % 2 == 1 ? - _Tp(1) : + _Tp(1));
                else {
                    _Tp __p_lm2 = _Tp(1);
                    if (__l == 0)
                        return __p_lm2;
                    _Tp __p_lm1 = __x;
                    if (__l == 1)
                        return __p_lm1;
                    _Tp __p_l = 0;
                    for (unsigned int __ll = 2; __ll <= __l; ++__ll) {
                        __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2 - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
                        __p_lm2 = __p_lm1;
                        __p_lm1 = __p_l;
                    }
                    return __p_l;
                }
            }
            template<> float __poly_legendre_p<float>(unsigned int __l, float __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x == +float(1))
                    return +float(1);
                else if (__x == -float(1))
                    return (__l % 2 == 1 ? -float(1) : +float(1));
                else {
                    float __p_lm2 = float(1);
                    if (__l == 0)
                        return __p_lm2;
                    float __p_lm1 = __x;
                    if (__l == 1)
                        return __p_lm1;
                    float __p_l = 0;
                    for (unsigned int __ll = 2; __ll <= __l; ++__ll) {
                        __p_l = float(2) * __x * __p_lm1 - __p_lm2 - (__x * __p_lm1 - __p_lm2) / float(__ll);
                        __p_lm2 = __p_lm1;
                        __p_lm1 = __p_l;
                    }
                    return __p_l;
                }
            }
            template<> long double __poly_legendre_p<long double>(unsigned int __l, long double __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x == +long double(1))
                    return +long double(1);
                else if (__x == -long double(1))
                    return (__l % 2 == 1 ? -long double(1) : +long double(1));
                else {
                    long double __p_lm2 = long double(1);
                    if (__l == 0)
                        return __p_lm2;
                    long double __p_lm1 = __x;
                    if (__l == 1)
                        return __p_lm1;
                    long double __p_l = 0;
                    for (unsigned int __ll = 2; __ll <= __l; ++__ll) {
                        __p_l = long double(2) * __x * __p_lm1 - __p_lm2 - (__x * __p_lm1 - __p_lm2) / long double(__ll);
                        __p_lm2 = __p_lm1;
                        __p_lm1 = __p_l;
                    }
                    return __p_l;
                }
            }
            template <typename _Tp> _Tp __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x, _Tp __phase = _Tp(+1))             {
                if (__m > __l)
                    return _Tp(0);
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__m == 0)
                    return __poly_legendre_p(__l, __x);
                else {
                    _Tp __p_mm = _Tp(1);
                    if (__m > 0) {
                        _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
                        _Tp __fact = _Tp(1);
                        for (unsigned int __i = 1; __i <= __m; ++__i) {
                            __p_mm *= __phase * __fact * __root;
                            __fact += _Tp(2);
                        }
                    }
                    if (__l == __m)
                        return __p_mm;
                    _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
                    if (__l == __m + 1)
                        return __p_mp1m;
                    _Tp __p_lm2m = __p_mm;
                    _Tp __P_lm1m = __p_mp1m;
                    _Tp __p_lm = _Tp(0);
                    for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
                        __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
                        __p_lm2m = __P_lm1m;
                        __P_lm1m = __p_lm;
                    }
                    return __p_lm;
                }
            }
            template<> float __assoc_legendre_p<float>(unsigned int __l, unsigned int __m, float __x, float __phase = float(+1))             {
                if (__m > __l)
                    return float(0);
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__m == 0)
                    return __poly_legendre_p(__l, __x);
                else {
                    float __p_mm = float(1);
                    if (__m > 0) {
                        float __root = std::sqrt(float(1) - __x) * std::sqrt(float(1) + __x);
                        float __fact = float(1);
                        for (unsigned int __i = 1; __i <= __m; ++__i) {
                            __p_mm *= __phase * __fact * __root;
                            __fact += float(2);
                        }
                    }
                    if (__l == __m)
                        return __p_mm;
                    float __p_mp1m = float(2 * __m + 1) * __x * __p_mm;
                    if (__l == __m + 1)
                        return __p_mp1m;
                    float __p_lm2m = __p_mm;
                    float __P_lm1m = __p_mp1m;
                    float __p_lm = float(0);
                    for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
                        __p_lm = (float(2 * __j - 1) * __x * __P_lm1m - float(__j + __m - 1) * __p_lm2m) / float(__j - __m);
                        __p_lm2m = __P_lm1m;
                        __P_lm1m = __p_lm;
                    }
                    return __p_lm;
                }
            }
            template<> long double __assoc_legendre_p<long double>(unsigned int __l, unsigned int __m, long double __x, long double __phase = long double(+1))             {
                if (__m > __l)
                    return long double(0);
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__m == 0)
                    return __poly_legendre_p(__l, __x);
                else {
                    long double __p_mm = long double(1);
                    if (__m > 0) {
                        long double __root = std::sqrt(long double(1) - __x) * std::sqrt(long double(1) + __x);
                        long double __fact = long double(1);
                        for (unsigned int __i = 1; __i <= __m; ++__i) {
                            __p_mm *= __phase * __fact * __root;
                            __fact += long double(2);
                        }
                    }
                    if (__l == __m)
                        return __p_mm;
                    long double __p_mp1m = long double(2 * __m + 1) * __x * __p_mm;
                    if (__l == __m + 1)
                        return __p_mp1m;
                    long double __p_lm2m = __p_mm;
                    long double __P_lm1m = __p_mp1m;
                    long double __p_lm = long double(0);
                    for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
                        __p_lm = (long double(2 * __j - 1) * __x * __P_lm1m - long double(__j + __m - 1) * __p_lm2m) / long double(__j - __m);
                        __p_lm2m = __P_lm1m;
                        __P_lm1m = __p_lm;
                    }
                    return __p_lm;
                }
            }
            template <typename _Tp> _Tp __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)             {
                if (__isnan(__theta))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                const _Tp __x = std::cos(__theta);
                if (__m > __l)
                    return _Tp(0);
                else if (__m == 0) {
                    _Tp __P = __poly_legendre_p(__l, __x);
                    _Tp __fact = std::sqrt(_Tp(2 * __l + 1) / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
                    __P *= __fact;
                    return __P;
                } else if (__x == _Tp(1) || __x == - _Tp(1)) {
                    return _Tp(0);
                } else {
                    const _Tp __sgn = (__m % 2 == 1 ? - _Tp(1) : _Tp(1));
                    const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));
                    const _Tp __lncirc = ::std::log1p(- __x * __x);
                    const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L))) - ::std::lgamma(_Tp(__m));
                    const _Tp __lnpre_val = - _Tp(0.25L) * __numeric_constants<_Tp>::__lnpi() + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
                    const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m) / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
                    _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
                    _Tp __y_mp1m = __y_mp1m_factor * __y_mm;
                    if (__l == __m)
                        return __y_mm;
                    else if (__l == __m + 1)
                        return __y_mp1m;
                    else {
                        _Tp __y_lm = _Tp(0);
                        for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll) {
                            const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                            const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                            const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1) * _Tp(2 * __ll - 1));
                            const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1) / _Tp(2 * __ll - 3));
                            __y_lm = (__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                            __y_mm = __y_mp1m;
                            __y_mp1m = __y_lm;
                        }
                        return __y_lm;
                    }
                }
            }
            template<> float __sph_legendre<float>(unsigned int __l, unsigned int __m, float __theta)             {
                if (__isnan(__theta))
                    return std::numeric_limits<float>::quiet_NaN();
                const float __x = std::cos(__theta);
                if (__m > __l)
                    return float(0);
                else if (__m == 0) {
                    float __P = __poly_legendre_p(__l, __x);
                    float __fact = std::sqrt(float(2 * __l + 1) / (float(4) * __numeric_constants<float>::__pi()));
                    __P *= __fact;
                    return __P;
                } else if (__x == float(1) || __x == -float(1)) {
                    return float(0);
                } else {
                    const float __sgn = (__m % 2 == 1 ? -float(1) : float(1));
                    const float __y_mp1m_factor = __x * std::sqrt(float(2 * __m + 3));
                    const float __lncirc = ::std::log1p(-__x * __x);
                    const float __lnpoch = ::std::lgamma(float(__m + float(0.5L))) - ::std::lgamma(float(__m));
                    const float __lnpre_val = -float(0.25L) * __numeric_constants<float>::__lnpi() + float(0.5L) * (__lnpoch + __m * __lncirc);
                    const float __sr = std::sqrt((float(2) + float(1) / __m) / (float(4) * __numeric_constants<float>::__pi()));
                    float __y_mm = __sgn * __sr * std::exp(__lnpre_val);
                    float __y_mp1m = __y_mp1m_factor * __y_mm;
                    if (__l == __m)
                        return __y_mm;
                    else if (__l == __m + 1)
                        return __y_mp1m;
                    else {
                        float __y_lm = float(0);
                        for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll) {
                            const float __rat1 = float(__ll - __m) / float(__ll + __m);
                            const float __rat2 = float(__ll - __m - 1) / float(__ll + __m - 1);
                            const float __fact1 = std::sqrt(__rat1 * float(2 * __ll + 1) * float(2 * __ll - 1));
                            const float __fact2 = std::sqrt(__rat1 * __rat2 * float(2 * __ll + 1) / float(2 * __ll - 3));
                            __y_lm = (__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) / float(__ll - __m);
                            __y_mm = __y_mp1m;
                            __y_mp1m = __y_lm;
                        }
                        return __y_lm;
                    }
                }
            }
            template<> long double __sph_legendre<long double>(unsigned int __l, unsigned int __m, long double __theta)             {
                if (__isnan(__theta))
                    return std::numeric_limits<long double>::quiet_NaN();
                const long double __x = std::cos(__theta);
                if (__m > __l)
                    return long double(0);
                else if (__m == 0) {
                    long double __P = __poly_legendre_p(__l, __x);
                    long double __fact = std::sqrt(long double(2 * __l + 1) / (long double(4) * __numeric_constants<long double>::__pi()));
                    __P *= __fact;
                    return __P;
                } else if (__x == long double(1) || __x == -long double(1)) {
                    return long double(0);
                } else {
                    const long double __sgn = (__m % 2 == 1 ? -long double(1) : long double(1));
                    const long double __y_mp1m_factor = __x * std::sqrt(long double(2 * __m + 3));
                    const long double __lncirc = ::std::log1p(-__x * __x);
                    const long double __lnpoch = ::std::lgamma(long double(__m + long double(0.5L))) - ::std::lgamma(long double(__m));
                    const long double __lnpre_val = -long double(0.25L) * __numeric_constants<long double>::__lnpi() + long double(0.5L) * (__lnpoch + __m * __lncirc);
                    const long double __sr = std::sqrt((long double(2) + long double(1) / __m) / (long double(4) * __numeric_constants<long double>::__pi()));
                    long double __y_mm = __sgn * __sr * std::exp(__lnpre_val);
                    long double __y_mp1m = __y_mp1m_factor * __y_mm;
                    if (__l == __m)
                        return __y_mm;
                    else if (__l == __m + 1)
                        return __y_mp1m;
                    else {
                        long double __y_lm = long double(0);
                        for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll) {
                            const long double __rat1 = long double(__ll - __m) / long double(__ll + __m);
                            const long double __rat2 = long double(__ll - __m - 1) / long double(__ll + __m - 1);
                            const long double __fact1 = std::sqrt(__rat1 * long double(2 * __ll + 1) * long double(2 * __ll - 1));
                            const long double __fact2 = std::sqrt(__rat1 * __rat2 * long double(2 * __ll + 1) / long double(2 * __ll - 3));
                            __y_lm = (__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) / long double(__ll - __m);
                            __y_mm = __y_mp1m;
                            __y_mp1m = __y_lm;
                        }
                        return __y_lm;
                    }
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> void __bessel_ik(_Tp __nu, _Tp __x, _Tp &__Inu, _Tp &__Knu, _Tp &__Ipnu, _Tp &__Kpnu)             {
                if (__x == _Tp(0)) {
                    if (__nu == _Tp(0)) {
                        __Inu = _Tp(1);
                        __Ipnu = _Tp(0);
                    } else if (__nu == _Tp(1)) {
                        __Inu = _Tp(0);
                        __Ipnu = _Tp(0.5L);
                    } else {
                        __Inu = _Tp(0);
                        __Ipnu = _Tp(0);
                    }
                    __Knu = std::numeric_limits<_Tp>::infinity();
                    __Kpnu = - std::numeric_limits<_Tp>::infinity();
                    return;
                }
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
                const int __max_iter = 15000;
                const _Tp __x_min = _Tp(2);
                const int __nl = static_cast<int>(__nu + _Tp(0.5L));
                const _Tp __mu = __nu - __nl;
                const _Tp __mu2 = __mu * __mu;
                const _Tp __xi = _Tp(1) / __x;
                const _Tp __xi2 = _Tp(2) * __xi;
                _Tp __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                _Tp __b = __xi2 * __nu;
                _Tp __d = _Tp(0);
                _Tp __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = _Tp(1) / (__b + __d);
                    __c = __b + _Tp(1) / __c;
                    const _Tp __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - _Tp(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_ik; try asymptotic expansion."));
                _Tp __Inul = __fp_min;
                _Tp __Ipnul = __h * __Inul;
                _Tp __Inul1 = __Inul;
                _Tp __Ipnu1 = __Ipnul;
                _Tp __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const _Tp __Inutemp = __fact * __Inul + __Ipnul;
                    __fact -= __xi;
                    __Ipnul = __fact * __Inutemp + __Inul;
                    __Inul = __Inutemp;
                }
                _Tp __f = __Ipnul / __Inul;
                _Tp __Kmu, __Knu1;
                if (__x < __x_min) {
                    const _Tp __x2 = __x / _Tp(2);
                    const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
                    const _Tp __fact = (std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
                    _Tp __d = - std::log(__x2);
                    _Tp __e = __mu * __d;
                    const _Tp __fact2 = (std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
                    _Tp __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    _Tp __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    _Tp __sum = __ff;
                    __e = std::exp(__e);
                    _Tp __p = __e / (_Tp(2) * __gampl);
                    _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
                    _Tp __c = _Tp(1);
                    __d = __x2 * __x2;
                    _Tp __sum1 = __p;
                    int __i;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / __i;
                        __p /= __i - __mu;
                        __q /= __i + __mu;
                        const _Tp __del = __c * __ff;
                        __sum += __del;
                        const _Tp __del1 = __c * (__p - __i * __ff);
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * std::abs(__sum))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel k series failed to converge in __bessel_ik."));
                    __Kmu = __sum;
                    __Knu1 = __sum1 * __xi2;
                } else {
                    _Tp __b = _Tp(2) * (_Tp(1) + __x);
                    _Tp __d = _Tp(1) / __b;
                    _Tp __delh = __d;
                    _Tp __h = __delh;
                    _Tp __q1 = _Tp(0);
                    _Tp __q2 = _Tp(1);
                    _Tp __a1 = _Tp(0.25L) - __mu2;
                    _Tp __q = __c = __a1;
                    _Tp __a = - __a1;
                    _Tp __s = _Tp(1) + __q * __delh;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a -= 2 * (__i - 1);
                        __c = - __a * __c / __i;
                        const _Tp __qnew = (__q1 - __b * __q2) / __a;
                        __q1 = __q2;
                        __q2 = __qnew;
                        __q += __c * __qnew;
                        __b += _Tp(2);
                        __d = _Tp(1) / (__b + __a * __d);
                        __delh = (__b * __d - _Tp(1)) * __delh;
                        __h += __delh;
                        const _Tp __dels = __q * __delh;
                        __s += __dels;
                        if (std::abs(__dels / __s) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Steed's method failed in __bessel_ik."));
                    __h = __a1 * __h;
                    __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x)) * std::exp(- __x) / __s;
                    __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
                }
                _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
                _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
                __Inu = __Inumu * __Inul1 / __Inul;
                __Ipnu = __Inumu * __Ipnu1 / __Inul;
                for (__i = 1; __i <= __nl; ++__i) {
                    const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
                    __Kmu = __Knu1;
                    __Knu1 = __Knutemp;
                }
                __Knu = __Kmu;
                __Kpnu = __nu * __xi * __Kmu - __Knu1;
                return;
            }
            template<> void __bessel_ik<float>(float __nu, float __x, float &__Inu, float &__Knu, float &__Ipnu, float &__Kpnu)             {
                if (__x == float(0)) {
                    if (__nu == float(0)) {
                        __Inu = float(1);
                        __Ipnu = float(0);
                    } else if (__nu == float(1)) {
                        __Inu = float(0);
                        __Ipnu = float(0.5L);
                    } else {
                        __Inu = float(0);
                        __Ipnu = float(0);
                    }
                    __Knu = std::numeric_limits<float>::infinity();
                    __Kpnu = -std::numeric_limits<float>::infinity();
                    return;
                }
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __fp_min = float(10) * std::numeric_limits<float>::epsilon();
                const int __max_iter = 15000;
                const float __x_min = float(2);
                const int __nl = static_cast<int>(__nu + float(0.5L));
                const float __mu = __nu - __nl;
                const float __mu2 = __mu * __mu;
                const float __xi = float(1) / __x;
                const float __xi2 = float(2) * __xi;
                float __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                float __b = __xi2 * __nu;
                float __d = float(0);
                float __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = float(1) / (__b + __d);
                    __c = __b + float(1) / __c;
                    const float __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - float(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_ik; try asymptotic expansion."));
                float __Inul = __fp_min;
                float __Ipnul = __h * __Inul;
                float __Inul1 = __Inul;
                float __Ipnu1 = __Ipnul;
                float __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const float __Inutemp = __fact * __Inul + __Ipnul;
                    __fact -= __xi;
                    __Ipnul = __fact * __Inutemp + __Inul;
                    __Inul = __Inutemp;
                }
                float __f = __Ipnul / __Inul;
                float __Kmu, __Knu1;
                if (__x < __x_min) {
                    const float __x2 = __x / float(2);
                    const float __pimu = __numeric_constants<float>::__pi() * __mu;
                    const float __fact = (std::abs(__pimu) < __eps ? float(1) : __pimu / std::sin(__pimu));
                    float __d = -std::log(__x2);
                    float __e = __mu * __d;
                    const float __fact2 = (std::abs(__e) < __eps ? float(1) : std::sinh(__e) / __e);
                    float __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    float __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    float __sum = __ff;
                    __e = std::exp(__e);
                    float __p = __e / (float(2) * __gampl);
                    float __q = float(1) / (float(2) * __e * __gammi);
                    float __c = float(1);
                    __d = __x2 * __x2;
                    float __sum1 = __p;
                    int __i;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / __i;
                        __p /= __i - __mu;
                        __q /= __i + __mu;
                        const float __del = __c * __ff;
                        __sum += __del;
                        const float __del1 = __c * (__p - __i * __ff);
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * std::abs(__sum))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel k series failed to converge in __bessel_ik."));
                    __Kmu = __sum;
                    __Knu1 = __sum1 * __xi2;
                } else {
                    float __b = float(2) * (float(1) + __x);
                    float __d = float(1) / __b;
                    float __delh = __d;
                    float __h = __delh;
                    float __q1 = float(0);
                    float __q2 = float(1);
                    float __a1 = float(0.25L) - __mu2;
                    float __q = __c = __a1;
                    float __a = -__a1;
                    float __s = float(1) + __q * __delh;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a -= 2 * (__i - 1);
                        __c = -__a * __c / __i;
                        const float __qnew = (__q1 - __b * __q2) / __a;
                        __q1 = __q2;
                        __q2 = __qnew;
                        __q += __c * __qnew;
                        __b += float(2);
                        __d = float(1) / (__b + __a * __d);
                        __delh = (__b * __d - float(1)) * __delh;
                        __h += __delh;
                        const float __dels = __q * __delh;
                        __s += __dels;
                        if (std::abs(__dels / __s) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Steed's method failed in __bessel_ik."));
                    __h = __a1 * __h;
                    __Kmu = std::sqrt(__numeric_constants<float>::__pi() / (float(2) * __x)) * std::exp(-__x) / __s;
                    __Knu1 = __Kmu * (__mu + __x + float(0.5L) - __h) * __xi;
                }
                float __Kpmu = __mu * __xi * __Kmu - __Knu1;
                float __Inumu = __xi / (__f * __Kmu - __Kpmu);
                __Inu = __Inumu * __Inul1 / __Inul;
                __Ipnu = __Inumu * __Ipnu1 / __Inul;
                for (__i = 1; __i <= __nl; ++__i) {
                    const float __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
                    __Kmu = __Knu1;
                    __Knu1 = __Knutemp;
                }
                __Knu = __Kmu;
                __Kpnu = __nu * __xi * __Kmu - __Knu1;
                return;
            }
            template<> void __bessel_ik<long double>(long double __nu, long double __x, long double &__Inu, long double &__Knu, long double &__Ipnu, long double &__Kpnu)             {
                if (__x == long double(0)) {
                    if (__nu == long double(0)) {
                        __Inu = long double(1);
                        __Ipnu = long double(0);
                    } else if (__nu == long double(1)) {
                        __Inu = long double(0);
                        __Ipnu = long double(0.5L);
                    } else {
                        __Inu = long double(0);
                        __Ipnu = long double(0);
                    }
                    __Knu = std::numeric_limits<long double>::infinity();
                    __Kpnu = -std::numeric_limits<long double>::infinity();
                    return;
                }
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __fp_min = long double(10) * std::numeric_limits<long double>::epsilon();
                const int __max_iter = 15000;
                const long double __x_min = long double(2);
                const int __nl = static_cast<int>(__nu + long double(0.5L));
                const long double __mu = __nu - __nl;
                const long double __mu2 = __mu * __mu;
                const long double __xi = long double(1) / __x;
                const long double __xi2 = long double(2) * __xi;
                long double __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                long double __b = __xi2 * __nu;
                long double __d = long double(0);
                long double __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = long double(1) / (__b + __d);
                    __c = __b + long double(1) / __c;
                    const long double __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - long double(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_ik; try asymptotic expansion."));
                long double __Inul = __fp_min;
                long double __Ipnul = __h * __Inul;
                long double __Inul1 = __Inul;
                long double __Ipnu1 = __Ipnul;
                long double __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const long double __Inutemp = __fact * __Inul + __Ipnul;
                    __fact -= __xi;
                    __Ipnul = __fact * __Inutemp + __Inul;
                    __Inul = __Inutemp;
                }
                long double __f = __Ipnul / __Inul;
                long double __Kmu, __Knu1;
                if (__x < __x_min) {
                    const long double __x2 = __x / long double(2);
                    const long double __pimu = __numeric_constants<long double>::__pi() * __mu;
                    const long double __fact = (std::abs(__pimu) < __eps ? long double(1) : __pimu / std::sin(__pimu));
                    long double __d = -std::log(__x2);
                    long double __e = __mu * __d;
                    const long double __fact2 = (std::abs(__e) < __eps ? long double(1) : std::sinh(__e) / __e);
                    long double __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    long double __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    long double __sum = __ff;
                    __e = std::exp(__e);
                    long double __p = __e / (long double(2) * __gampl);
                    long double __q = long double(1) / (long double(2) * __e * __gammi);
                    long double __c = long double(1);
                    __d = __x2 * __x2;
                    long double __sum1 = __p;
                    int __i;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / __i;
                        __p /= __i - __mu;
                        __q /= __i + __mu;
                        const long double __del = __c * __ff;
                        __sum += __del;
                        const long double __del1 = __c * (__p - __i * __ff);
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * std::abs(__sum))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel k series failed to converge in __bessel_ik."));
                    __Kmu = __sum;
                    __Knu1 = __sum1 * __xi2;
                } else {
                    long double __b = long double(2) * (long double(1) + __x);
                    long double __d = long double(1) / __b;
                    long double __delh = __d;
                    long double __h = __delh;
                    long double __q1 = long double(0);
                    long double __q2 = long double(1);
                    long double __a1 = long double(0.25L) - __mu2;
                    long double __q = __c = __a1;
                    long double __a = -__a1;
                    long double __s = long double(1) + __q * __delh;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a -= 2 * (__i - 1);
                        __c = -__a * __c / __i;
                        const long double __qnew = (__q1 - __b * __q2) / __a;
                        __q1 = __q2;
                        __q2 = __qnew;
                        __q += __c * __qnew;
                        __b += long double(2);
                        __d = long double(1) / (__b + __a * __d);
                        __delh = (__b * __d - long double(1)) * __delh;
                        __h += __delh;
                        const long double __dels = __q * __delh;
                        __s += __dels;
                        if (std::abs(__dels / __s) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Steed's method failed in __bessel_ik."));
                    __h = __a1 * __h;
                    __Kmu = std::sqrt(__numeric_constants<long double>::__pi() / (long double(2) * __x)) * std::exp(-__x) / __s;
                    __Knu1 = __Kmu * (__mu + __x + long double(0.5L) - __h) * __xi;
                }
                long double __Kpmu = __mu * __xi * __Kmu - __Knu1;
                long double __Inumu = __xi / (__f * __Kmu - __Kpmu);
                __Inu = __Inumu * __Inul1 / __Inul;
                __Ipnu = __Inumu * __Ipnu1 / __Inul;
                for (__i = 1; __i <= __nl; ++__i) {
                    const long double __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
                    __Kmu = __Knu1;
                    __Knu1 = __Knutemp;
                }
                __Knu = __Kmu;
                __Kpnu = __nu * __xi * __Kmu - __Knu1;
                return;
            }
            template <typename _Tp> _Tp __cyl_bessel_i(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_i."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
                    return __cyl_bessel_ij_series(__nu, __x, + _Tp(1), 200);
                else {
                    _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __I_nu;
                }
            }
            template<> float __cyl_bessel_i<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_i."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x * __x < float(10) * (__nu + float(1)))
                    return __cyl_bessel_ij_series(__nu, __x, +float(1), 200);
                else {
                    float __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __I_nu;
                }
            }
            template<> long double __cyl_bessel_i<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_i."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x * __x < long double(10) * (__nu + long double(1)))
                    return __cyl_bessel_ij_series(__nu, __x, +long double(1), 200);
                else {
                    long double __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __I_nu;
                }
            }
            template <typename _Tp> _Tp __cyl_bessel_k(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_k."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else {
                    _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __K_nu;
                }
            }
            template<> float __cyl_bessel_k<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_k."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else {
                    float __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __K_nu;
                }
            }
            template<> long double __cyl_bessel_k<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_k."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else {
                    long double __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __K_nu;
                }
            }
            template <typename _Tp> void __sph_bessel_ik(unsigned int __n, _Tp __x, _Tp &__i_n, _Tp &__k_n, _Tp &__ip_n, _Tp &__kp_n)             {
                const _Tp __nu = _Tp(__n) + _Tp(0.5L);
                _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
                __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);
                __i_n = __factor * __I_nu;
                __k_n = __factor * __K_nu;
                __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
                __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);
                return;
            }
            template <typename _Tp> void __airy(_Tp __x, _Tp &__Ai, _Tp &__Bi, _Tp &__Aip, _Tp &__Bip)             {
                const _Tp __absx = std::abs(__x);
                const _Tp __rootx = std::sqrt(__absx);
                const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
                const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();
                if (__isnan(__x))
                    __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
                else if (__z == _S_inf) {
                    __Aip = __Ai = _Tp(0);
                    __Bip = __Bi = _S_inf;
                } else if (__z == - _S_inf)
                    __Bip = __Aip = __Bi = __Ai = _Tp(0);
                else if (__x > _Tp(0)) {
                    _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
                    __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    __Ai = __rootx * __K_nu / (__numeric_constants<_Tp>::__sqrt3() * __numeric_constants<_Tp>::__pi());
                    __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi() + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());
                    __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    __Aip = - __x * __K_nu / (__numeric_constants<_Tp>::__sqrt3() * __numeric_constants<_Tp>::__pi());
                    __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi() + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());
                } else if (__x < _Tp(0)) {
                    _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;
                    __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    __Ai = __rootx * (__J_nu - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
                    __Bi = - __rootx * (__N_nu + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
                    __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3() + __J_nu) / _Tp(2);
                    __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3() - __N_nu) / _Tp(2);
                } else {
                    __Ai = _Tp(0.355028053887817239255L);
                    __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();
                    __Aip = - _Tp(0.258819403792806798393L);
                    __Bip = - __Aip * __numeric_constants<_Tp>::__sqrt3();
                }
                return;
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __poly_hermite_recursion(unsigned int __n, _Tp __x)             {
                _Tp __H_0 = 1;
                if (__n == 0)
                    return __H_0;
                _Tp __H_1 = 2 * __x;
                if (__n == 1)
                    return __H_1;
                _Tp __H_n, __H_nm1, __H_nm2;
                unsigned int __i;
                for (__H_nm2 = __H_0 , __H_nm1 = __H_1 , __i = 2; __i <= __n; ++__i) {
                    __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
                    __H_nm2 = __H_nm1;
                    __H_nm1 = __H_n;
                }
                return __H_n;
            }
            template<> float __poly_hermite_recursion<float>(unsigned int __n, float __x)             {
                float __H_0 = 1;
                if (__n == 0)
                    return __H_0;
                float __H_1 = 2 * __x;
                if (__n == 1)
                    return __H_1;
                float __H_n, __H_nm1, __H_nm2;
                unsigned int __i;
                for (__H_nm2 = __H_0 , __H_nm1 = __H_1 , __i = 2; __i <= __n; ++__i) {
                    __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
                    __H_nm2 = __H_nm1;
                    __H_nm1 = __H_n;
                }
                return __H_n;
            }
            template<> long double __poly_hermite_recursion<long double>(unsigned int __n, long double __x)             {
                long double __H_0 = 1;
                if (__n == 0)
                    return __H_0;
                long double __H_1 = 2 * __x;
                if (__n == 1)
                    return __H_1;
                long double __H_n, __H_nm1, __H_nm2;
                unsigned int __i;
                for (__H_nm2 = __H_0 , __H_nm1 = __H_1 , __i = 2; __i <= __n; ++__i) {
                    __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
                    __H_nm2 = __H_nm1;
                    __H_nm1 = __H_n;
                }
                return __H_n;
            }
            template <typename _Tp> inline _Tp __poly_hermite(unsigned int __n, _Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __poly_hermite_recursion(__n, __x);
            }
            template<> inline float __poly_hermite<float>(unsigned int __n, float __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __poly_hermite_recursion(__n, __x);
            }
            template<> inline long double __poly_hermite<long double>(unsigned int __n, long double __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __poly_hermite_recursion(__n, __x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre_large_n(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                const _Tp __a = - _Tp(__n);
                const _Tp __b = _Tp(__alpha1) + _Tp(1);
                const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
                const _Tp __cos2th = __x / __eta;
                const _Tp __sin2th = _Tp(1) - __cos2th;
                const _Tp __th = std::acos(std::sqrt(__cos2th));
                const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2() * __numeric_constants<_Tp>::__pi_2() * __eta * __eta * __cos2th * __sin2th;
                const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
                const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));
                _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b) * std::log(_Tp(0.25L) * __x * __eta);
                _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
                _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x + __pre_term1 - __pre_term2;
                _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
                _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta * (_Tp(2) * __th - std::sin(_Tp(2) * __th)) + __numeric_constants<_Tp>::__pi_4());
                _Tp __ser = __ser_term1 + __ser_term2;
                return std::exp(__lnpre) * __ser;
            }
            template<> float __poly_laguerre_large_n<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                const float __a = -float(__n);
                const float __b = float(__alpha1) + float(1);
                const float __eta = float(2) * __b - float(4) * __a;
                const float __cos2th = __x / __eta;
                const float __sin2th = float(1) - __cos2th;
                const float __th = std::acos(std::sqrt(__cos2th));
                const float __pre_h = __numeric_constants<float>::__pi_2() * __numeric_constants<float>::__pi_2() * __eta * __eta * __cos2th * __sin2th;
                const float __lg_b = ::std::lgamma(float(__n) + __b);
                const float __lnfact = ::std::lgamma(float(__n + 1));
                float __pre_term1 = float(0.5L) * (float(1) - __b) * std::log(float(0.25L) * __x * __eta);
                float __pre_term2 = float(0.25L) * std::log(__pre_h);
                float __lnpre = __lg_b - __lnfact + float(0.5L) * __x + __pre_term1 - __pre_term2;
                float __ser_term1 = std::sin(__a * __numeric_constants<float>::__pi());
                float __ser_term2 = std::sin(float(0.25L) * __eta * (float(2) * __th - std::sin(float(2) * __th)) + __numeric_constants<float>::__pi_4());
                float __ser = __ser_term1 + __ser_term2;
                return std::exp(__lnpre) * __ser;
            }
            template<> long double __poly_laguerre_large_n<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                const long double __a = -long double(__n);
                const long double __b = long double(__alpha1) + long double(1);
                const long double __eta = long double(2) * __b - long double(4) * __a;
                const long double __cos2th = __x / __eta;
                const long double __sin2th = long double(1) - __cos2th;
                const long double __th = std::acos(std::sqrt(__cos2th));
                const long double __pre_h = __numeric_constants<long double>::__pi_2() * __numeric_constants<long double>::__pi_2() * __eta * __eta * __cos2th * __sin2th;
                const long double __lg_b = ::std::lgamma(long double(__n) + __b);
                const long double __lnfact = ::std::lgamma(long double(__n + 1));
                long double __pre_term1 = long double(0.5L) * (long double(1) - __b) * std::log(long double(0.25L) * __x * __eta);
                long double __pre_term2 = long double(0.25L) * std::log(__pre_h);
                long double __lnpre = __lg_b - __lnfact + long double(0.5L) * __x + __pre_term1 - __pre_term2;
                long double __ser_term1 = std::sin(__a * __numeric_constants<long double>::__pi());
                long double __ser_term2 = std::sin(long double(0.25L) * __eta * (long double(2) * __th - std::sin(long double(2) * __th)) + __numeric_constants<long double>::__pi_4());
                long double __ser = __ser_term1 + __ser_term2;
                return std::exp(__lnpre) * __ser;
            }
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                const _Tp __b = _Tp(__alpha1) + _Tp(1);
                const _Tp __mx = - __x;
                const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1) : ((__n % 2 == 1) ? - _Tp(1) : _Tp(1)));
                _Tp __tc = _Tp(1);
                const _Tp __ax = std::abs(__x);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __tc *= (__ax / __k);
                _Tp __term = __tc * __tc_sgn;
                _Tp __sum = __term;
                for (int __k = int(__n) - 1; __k >= 0; --__k) {
                    __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k)) * _Tp(__k + 1) / __mx;
                    __sum += __term;
                }
                return __sum;
            }
            template<> float __poly_laguerre_hyperg<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                const float __b = float(__alpha1) + float(1);
                const float __mx = -__x;
                const float __tc_sgn = (__x < float(0) ? float(1) : ((__n % 2 == 1) ? -float(1) : float(1)));
                float __tc = float(1);
                const float __ax = std::abs(__x);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __tc *= (__ax / __k);
                float __term = __tc * __tc_sgn;
                float __sum = __term;
                for (int __k = int(__n) - 1; __k >= 0; --__k) {
                    __term *= ((__b + float(__k)) / float(int(__n) - __k)) * float(__k + 1) / __mx;
                    __sum += __term;
                }
                return __sum;
            }
            template<> long double __poly_laguerre_hyperg<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                const long double __b = long double(__alpha1) + long double(1);
                const long double __mx = -__x;
                const long double __tc_sgn = (__x < long double(0) ? long double(1) : ((__n % 2 == 1) ? -long double(1) : long double(1)));
                long double __tc = long double(1);
                const long double __ax = std::abs(__x);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __tc *= (__ax / __k);
                long double __term = __tc * __tc_sgn;
                long double __sum = __term;
                for (int __k = int(__n) - 1; __k >= 0; --__k) {
                    __term *= ((__b + long double(__k)) / long double(int(__n) - __k)) * long double(__k + 1) / __mx;
                    __sum += __term;
                }
                return __sum;
            }
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                _Tp __l_0 = _Tp(1);
                if (__n == 0)
                    return __l_0;
                _Tp __l_1 = - __x + _Tp(1) + _Tp(__alpha1);
                if (__n == 1)
                    return __l_1;
                _Tp __l_n2 = __l_0;
                _Tp __l_n1 = __l_1;
                _Tp __l_n = _Tp(0);
                for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
                    __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x) * __l_n1 / _Tp(__nn) - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
                    __l_n2 = __l_n1;
                    __l_n1 = __l_n;
                }
                return __l_n;
            }
            template<> float __poly_laguerre_recursion<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                float __l_0 = float(1);
                if (__n == 0)
                    return __l_0;
                float __l_1 = -__x + float(1) + float(__alpha1);
                if (__n == 1)
                    return __l_1;
                float __l_n2 = __l_0;
                float __l_n1 = __l_1;
                float __l_n = float(0);
                for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
                    __l_n = (float(2 * __nn - 1) + float(__alpha1) - __x) * __l_n1 / float(__nn) - (float(__nn - 1) + float(__alpha1)) * __l_n2 / float(__nn);
                    __l_n2 = __l_n1;
                    __l_n1 = __l_n;
                }
                return __l_n;
            }
            template<> long double __poly_laguerre_recursion<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                long double __l_0 = long double(1);
                if (__n == 0)
                    return __l_0;
                long double __l_1 = -__x + long double(1) + long double(__alpha1);
                if (__n == 1)
                    return __l_1;
                long double __l_n2 = __l_0;
                long double __l_n1 = __l_1;
                long double __l_n = long double(0);
                for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
                    __l_n = (long double(2 * __nn - 1) + long double(__alpha1) - __x) * __l_n1 / long double(__nn) - (long double(__nn - 1) + long double(__alpha1)) * __l_n2 / long double(__nn);
                    __l_n2 = __l_n1;
                    __l_n1 = __l_n;
                }
                return __l_n;
            }
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                if (__x < _Tp(0))
                    std::__throw_domain_error(("Negative argument in __poly_laguerre."));
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__n == 0)
                    return _Tp(1);
                else if (__n == 1)
                    return _Tp(1) + _Tp(__alpha1) - __x;
                else if (__x == _Tp(0)) {
                    _Tp __prod = _Tp(__alpha1) + _Tp(1);
                    for (unsigned int __k = 2; __k <= __n; ++__k)
                        __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
                    return __prod;
                } else if (__n > 10000000 && _Tp(__alpha1) > - _Tp(1) && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
                    return __poly_laguerre_large_n(__n, __alpha1, __x);
                else if (_Tp(__alpha1) >= _Tp(0) || (__x > _Tp(0) && _Tp(__alpha1) < - _Tp(__n + 1)))
                    return __poly_laguerre_recursion(__n, __alpha1, __x);
                else
                    return __poly_laguerre_hyperg(__n, __alpha1, __x);
            }
            template<> float __poly_laguerre<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                if (__x < float(0))
                    std::__throw_domain_error(("Negative argument in __poly_laguerre."));
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__n == 0)
                    return float(1);
                else if (__n == 1)
                    return float(1) + float(__alpha1) - __x;
                else if (__x == float(0)) {
                    float __prod = float(__alpha1) + float(1);
                    for (unsigned int __k = 2; __k <= __n; ++__k)
                        __prod *= (float(__alpha1) + float(__k)) / float(__k);
                    return __prod;
                } else if (__n > 10000000 && float(__alpha1) > -float(1) && __x < float(2) * (float(__alpha1) + float(1)) + float(4 * __n))
                    return __poly_laguerre_large_n(__n, __alpha1, __x);
                else if (float(__alpha1) >= float(0) || (__x > float(0) && float(__alpha1) < -float(__n + 1)))
                    return __poly_laguerre_recursion(__n, __alpha1, __x);
                else
                    return __poly_laguerre_hyperg(__n, __alpha1, __x);
            }
            template<> long double __poly_laguerre<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                if (__x < long double(0))
                    std::__throw_domain_error(("Negative argument in __poly_laguerre."));
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__n == 0)
                    return long double(1);
                else if (__n == 1)
                    return long double(1) + long double(__alpha1) - __x;
                else if (__x == long double(0)) {
                    long double __prod = long double(__alpha1) + long double(1);
                    for (unsigned int __k = 2; __k <= __n; ++__k)
                        __prod *= (long double(__alpha1) + long double(__k)) / long double(__k);
                    return __prod;
                } else if (__n > 10000000 && long double(__alpha1) > -long double(1) && __x < long double(2) * (long double(__alpha1) + long double(1)) + long double(4 * __n))
                    return __poly_laguerre_large_n(__n, __alpha1, __x);
                else if (long double(__alpha1) >= long double(0) || (__x > long double(0) && long double(__alpha1) < -long double(__n + 1)))
                    return __poly_laguerre_recursion(__n, __alpha1, __x);
                else
                    return __poly_laguerre_hyperg(__n, __alpha1, __x);
            }
            template <typename _Tp> inline _Tp __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)             {
                return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x);
            }
            template<> inline float __assoc_laguerre<float>(unsigned int __n, unsigned int __m, float __x)             {
                return __poly_laguerre<unsigned int, float>(__n, __m, __x);
            }
            template<> inline long double __assoc_laguerre<long double>(unsigned int __n, unsigned int __m, long double __x)             {
                return __poly_laguerre<unsigned int, long double>(__n, __m, __x);
            }
            template <typename _Tp> inline _Tp __laguerre(unsigned int __n, _Tp __x)             {
                return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x);
            }
            template<> inline float __laguerre<float>(unsigned int __n, float __x)             {
                return __poly_laguerre<unsigned int, float>(__n, 0, __x);
            }
            template<> inline long double __laguerre<long double>(unsigned int __n, long double __x)             {
                return __poly_laguerre<unsigned int, long double>(__n, 0, __x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __riemann_zeta_sum(_Tp __s)             {
                if (__s < _Tp(1))
                    std::__throw_domain_error(("Bad argument in zeta sum."));
                const unsigned int max_iter = 10000;
                _Tp __zeta = _Tp(0);
                for (unsigned int __k = 1; __k < max_iter; ++__k) {
                    _Tp __term = std::pow(static_cast<_Tp>(__k), - __s);
                    if (__term < std::numeric_limits<_Tp>::epsilon()) {
                        break;
                    }
                    __zeta += __term;
                }
                return __zeta;
            }
            template<> float __riemann_zeta_sum<float>(float __s)             {
                if (__s < float(1))
                    std::__throw_domain_error(("Bad argument in zeta sum."));
                const unsigned int max_iter = 10000;
                float __zeta = float(0);
                for (unsigned int __k = 1; __k < max_iter; ++__k) {
                    float __term = std::pow(static_cast<float>(__k), -__s);
                    if (__term < std::numeric_limits<float>::epsilon()) {
                        break;
                    }
                    __zeta += __term;
                }
                return __zeta;
            }
            template<> long double __riemann_zeta_sum<long double>(long double __s)             {
                if (__s < long double(1))
                    std::__throw_domain_error(("Bad argument in zeta sum."));
                const unsigned int max_iter = 10000;
                long double __zeta = long double(0);
                for (unsigned int __k = 1; __k < max_iter; ++__k) {
                    long double __term = std::pow(static_cast<long double>(__k), -__s);
                    if (__term < std::numeric_limits<long double>::epsilon()) {
                        break;
                    }
                    __zeta += __term;
                }
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta_alt(_Tp __s)             {
                _Tp __sgn = _Tp(1);
                _Tp __zeta = _Tp(0);
                for (unsigned int __i = 1; __i < 10000000; ++__i) {
                    _Tp __term = __sgn / std::pow(__i, __s);
                    if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __zeta += __term;
                    __sgn *= _Tp(-1);
                }
                __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta_glob(_Tp __s)             {
                _Tp __zeta = _Tp(0);
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                if (__s < _Tp(0)) {
                    if (::std::fmod(__s, _Tp(2)) == _Tp(0))
                        return _Tp(0);
                    else {
                        _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
                        __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) * std::sin(__numeric_constants<_Tp>::__pi_2() * __s) * std::exp(::std::lgamma(_Tp(1) - __s)) / __numeric_constants<_Tp>::__pi();
                        return __zeta;
                    }
                }
                _Tp __num = _Tp(0.5L);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    _Tp __sgn = _Tp(1);
                    _Tp __term = _Tp(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) - ::std::lgamma(_Tp(1 + __j)) - ::std::lgamma(_Tp(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), - __s);
                        __sgn *= _Tp(-1);
                    }
                    if (__punt)
                        break;
                    __term *= __num;
                    __zeta += __term;
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __num *= _Tp(0.5L);
                }
                __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);
                return __zeta;
            }
            template<> float __riemann_zeta_glob<float>(float __s)             {
                float __zeta = float(0);
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __max_bincoeff = std::numeric_limits<float>::max_exponent10 * std::log(float(10)) - float(1);
                if (__s < float(0)) {
                    if (::std::fmod(__s, float(2)) == float(0))
                        return float(0);
                    else {
                        float __zeta = __riemann_zeta_glob(float(1) - __s);
                        __zeta *= std::pow(float(2) * __numeric_constants<float>::__pi(), __s) * std::sin(__numeric_constants<float>::__pi_2() * __s) * std::exp(::std::lgamma(float(1) - __s)) / __numeric_constants<float>::__pi();
                        return __zeta;
                    }
                }
                float __num = float(0.5L);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    float __sgn = float(1);
                    float __term = float(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        float __bincoeff = ::std::lgamma(float(1 + __i)) - ::std::lgamma(float(1 + __j)) - ::std::lgamma(float(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(float(1 + __j), -__s);
                        __sgn *= float(-1);
                    }
                    if (__punt)
                        break;
                    __term *= __num;
                    __zeta += __term;
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __num *= float(0.5L);
                }
                __zeta /= float(1) - std::pow(float(2), float(1) - __s);
                return __zeta;
            }
            template<> long double __riemann_zeta_glob<long double>(long double __s)             {
                long double __zeta = long double(0);
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __max_bincoeff = std::numeric_limits<long double>::max_exponent10 * std::log(long double(10)) - long double(1);
                if (__s < long double(0)) {
                    if (::std::fmod(__s, long double(2)) == long double(0))
                        return long double(0);
                    else {
                        long double __zeta = __riemann_zeta_glob(long double(1) - __s);
                        __zeta *= std::pow(long double(2) * __numeric_constants<long double>::__pi(), __s) * std::sin(__numeric_constants<long double>::__pi_2() * __s) * std::exp(::std::lgamma(long double(1) - __s)) / __numeric_constants<long double>::__pi();
                        return __zeta;
                    }
                }
                long double __num = long double(0.5L);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    long double __sgn = long double(1);
                    long double __term = long double(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        long double __bincoeff = ::std::lgamma(long double(1 + __i)) - ::std::lgamma(long double(1 + __j)) - ::std::lgamma(long double(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(long double(1 + __j), -__s);
                        __sgn *= long double(-1);
                    }
                    if (__punt)
                        break;
                    __term *= __num;
                    __zeta += __term;
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __num *= long double(0.5L);
                }
                __zeta /= long double(1) - std::pow(long double(2), long double(1) - __s);
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta_product(_Tp __s)             {
                static const _Tp __prime[] = {_Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19), _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47), _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79), _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)};
                static const unsigned int __num_primes = sizeof (__prime) / sizeof(_Tp);
                _Tp __zeta = _Tp(1);
                for (unsigned int __i = 0; __i < __num_primes; ++__i) {
                    const _Tp __fact = _Tp(1) - std::pow(__prime[__i], - __s);
                    __zeta *= __fact;
                    if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
                        break;
                }
                __zeta = _Tp(1) / __zeta;
                return __zeta;
            }
            template<> float __riemann_zeta_product<float>(float __s)             {
                static const float __prime[] = {float(2), float(3), float(5), float(7), float(11), float(13), float(17), float(19), float(23), float(29), float(31), float(37), float(41), float(43), float(47), float(53), float(59), float(61), float(67), float(71), float(73), float(79), float(83), float(89), float(97), float(101), float(103), float(107), float(109)};
                static const unsigned int __num_primes = sizeof (__prime) / sizeof(float);
                float __zeta = float(1);
                for (unsigned int __i = 0; __i < __num_primes; ++__i) {
                    const float __fact = float(1) - std::pow(__prime[__i], -__s);
                    __zeta *= __fact;
                    if (float(1) - __fact < std::numeric_limits<float>::epsilon())
                        break;
                }
                __zeta = float(1) / __zeta;
                return __zeta;
            }
            template<> long double __riemann_zeta_product<long double>(long double __s)             {
                static const long double __prime[] = {long double(2), long double(3), long double(5), long double(7), long double(11), long double(13), long double(17), long double(19), long double(23), long double(29), long double(31), long double(37), long double(41), long double(43), long double(47), long double(53), long double(59), long double(61), long double(67), long double(71), long double(73), long double(79), long double(83), long double(89), long double(97), long double(101), long double(103), long double(107), long double(109)};
                static const unsigned int __num_primes = sizeof (__prime) / sizeof(long double);
                long double __zeta = long double(1);
                for (unsigned int __i = 0; __i < __num_primes; ++__i) {
                    const long double __fact = long double(1) - std::pow(__prime[__i], -__s);
                    __zeta *= __fact;
                    if (long double(1) - __fact < std::numeric_limits<long double>::epsilon())
                        break;
                }
                __zeta = long double(1) / __zeta;
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta(_Tp __s)             {
                if (__isnan(__s))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__s == _Tp(1))
                    return std::numeric_limits<_Tp>::infinity();
                else if (__s < - _Tp(19)) {
                    _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
                    __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) * std::sin(__numeric_constants<_Tp>::__pi_2() * __s) * std::exp(::std::lgamma(_Tp(1) - __s)) / __numeric_constants<_Tp>::__pi();
                    return __zeta;
                } else if (__s < _Tp(20)) {
                    bool __glob = true;
                    if (__glob)
                        return __riemann_zeta_glob(__s);
                    else {
                        if (__s > _Tp(1))
                            return __riemann_zeta_sum(__s);
                        else {
                            _Tp __zeta = std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) * std::sin(__numeric_constants<_Tp>::__pi_2() * __s) * ::std::tgamma(_Tp(1) - __s) * __riemann_zeta_sum(_Tp(1) - __s);
                            return __zeta;
                        }
                    }
                } else
                    return __riemann_zeta_product(__s);
            }
            template<> float __riemann_zeta<float>(float __s)             {
                if (__isnan(__s))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__s == float(1))
                    return std::numeric_limits<float>::infinity();
                else if (__s < -float(19)) {
                    float __zeta = __riemann_zeta_product(float(1) - __s);
                    __zeta *= std::pow(float(2) * __numeric_constants<float>::__pi(), __s) * std::sin(__numeric_constants<float>::__pi_2() * __s) * std::exp(::std::lgamma(float(1) - __s)) / __numeric_constants<float>::__pi();
                    return __zeta;
                } else if (__s < float(20)) {
                    bool __glob = true;
                    if (__glob)
                        return __riemann_zeta_glob(__s);
                    else {
                        if (__s > float(1))
                            return __riemann_zeta_sum(__s);
                        else {
                            float __zeta = std::pow(float(2) * __numeric_constants<float>::__pi(), __s) * std::sin(__numeric_constants<float>::__pi_2() * __s) * ::std::tgamma(float(1) - __s) * __riemann_zeta_sum(float(1) - __s);
                            return __zeta;
                        }
                    }
                } else
                    return __riemann_zeta_product(__s);
            }
            template<> long double __riemann_zeta<long double>(long double __s)             {
                if (__isnan(__s))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__s == long double(1))
                    return std::numeric_limits<long double>::infinity();
                else if (__s < -long double(19)) {
                    long double __zeta = __riemann_zeta_product(long double(1) - __s);
                    __zeta *= std::pow(long double(2) * __numeric_constants<long double>::__pi(), __s) * std::sin(__numeric_constants<long double>::__pi_2() * __s) * std::exp(::std::lgamma(long double(1) - __s)) / __numeric_constants<long double>::__pi();
                    return __zeta;
                } else if (__s < long double(20)) {
                    bool __glob = true;
                    if (__glob)
                        return __riemann_zeta_glob(__s);
                    else {
                        if (__s > long double(1))
                            return __riemann_zeta_sum(__s);
                        else {
                            long double __zeta = std::pow(long double(2) * __numeric_constants<long double>::__pi(), __s) * std::sin(__numeric_constants<long double>::__pi_2() * __s) * ::std::tgamma(long double(1) - __s) * __riemann_zeta_sum(long double(1) - __s);
                            return __zeta;
                        }
                    }
                } else
                    return __riemann_zeta_product(__s);
            }
            template <typename _Tp> _Tp __hurwitz_zeta_glob(_Tp __a, _Tp __s)             {
                _Tp __zeta = _Tp(0);
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    _Tp __sgn = _Tp(1);
                    _Tp __term = _Tp(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) - ::std::lgamma(_Tp(1 + __j)) - ::std::lgamma(_Tp(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), - __s);
                        __sgn *= _Tp(-1);
                    }
                    if (__punt)
                        break;
                    __term /= _Tp(__i + 1);
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __zeta += __term;
                }
                __zeta /= __s - _Tp(1);
                return __zeta;
            }
            template <typename _Tp> inline _Tp __hurwitz_zeta(_Tp __a, _Tp __s)             {
                return __hurwitz_zeta_glob(__a, __s);
            }
        }
    }
    namespace std {
        inline float assoc_laguerref(unsigned int __n, unsigned int __m, float __x)         {
            return __detail::__assoc_laguerre<float>(__n, __m, __x);
        }
        inline long double assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)         {
            return __detail::__assoc_laguerre<long double>(__n, __m, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__assoc_laguerre<__type>(__n, __m, __x);
        }
        inline float assoc_legendref(unsigned int __l, unsigned int __m, float __x)         {
            return __detail::__assoc_legendre_p<float>(__l, __m, __x);
        }
        inline long double assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)         {
            return __detail::__assoc_legendre_p<long double>(__l, __m, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
        }
        inline float betaf(float __a, float __b)         {
            return __detail::__beta<float>(__a, __b);
        }
        inline long double betal(long double __a, long double __b)         {
            return __detail::__beta<long double>(__a, __b);
        }
        template <typename _Tpa, typename _Tpb> inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type beta(_Tpa __a, _Tpb __b)         {
            typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
            return __detail::__beta<__type>(__a, __b);
        }
        inline float comp_ellint_1f(float __k)         {
            return __detail::__comp_ellint_1<float>(__k);
        }
        inline long double comp_ellint_1l(long double __k)         {
            return __detail::__comp_ellint_1<long double>(__k);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_1(_Tp __k)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__comp_ellint_1<__type>(__k);
        }
        inline float comp_ellint_2f(float __k)         {
            return __detail::__comp_ellint_2<float>(__k);
        }
        inline long double comp_ellint_2l(long double __k)         {
            return __detail::__comp_ellint_2<long double>(__k);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_2(_Tp __k)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__comp_ellint_2<__type>(__k);
        }
        inline float comp_ellint_3f(float __k, float __nu)         {
            return __detail::__comp_ellint_3<float>(__k, __nu);
        }
        inline long double comp_ellint_3l(long double __k, long double __nu)         {
            return __detail::__comp_ellint_3<long double>(__k, __nu);
        }
        template <typename _Tp, typename _Tpn> inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type comp_ellint_3(_Tp __k, _Tpn __nu)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
            return __detail::__comp_ellint_3<__type>(__k, __nu);
        }
        inline float cyl_bessel_if(float __nu, float __x)         {
            return __detail::__cyl_bessel_i<float>(__nu, __x);
        }
        inline long double cyl_bessel_il(long double __nu, long double __x)         {
            return __detail::__cyl_bessel_i<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_i(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_bessel_i<__type>(__nu, __x);
        }
        inline float cyl_bessel_jf(float __nu, float __x)         {
            return __detail::__cyl_bessel_j<float>(__nu, __x);
        }
        inline long double cyl_bessel_jl(long double __nu, long double __x)         {
            return __detail::__cyl_bessel_j<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_j(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_bessel_j<__type>(__nu, __x);
        }
        inline float cyl_bessel_kf(float __nu, float __x)         {
            return __detail::__cyl_bessel_k<float>(__nu, __x);
        }
        inline long double cyl_bessel_kl(long double __nu, long double __x)         {
            return __detail::__cyl_bessel_k<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_k(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_bessel_k<__type>(__nu, __x);
        }
        inline float cyl_neumannf(float __nu, float __x)         {
            return __detail::__cyl_neumann_n<float>(__nu, __x);
        }
        inline long double cyl_neumannl(long double __nu, long double __x)         {
            return __detail::__cyl_neumann_n<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_neumann(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_neumann_n<__type>(__nu, __x);
        }
        inline float ellint_1f(float __k, float __phi)         {
            return __detail::__ellint_1<float>(__k, __phi);
        }
        inline long double ellint_1l(long double __k, long double __phi)         {
            return __detail::__ellint_1<long double>(__k, __phi);
        }
        template <typename _Tp, typename _Tpp> inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_1(_Tp __k, _Tpp __phi)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
            return __detail::__ellint_1<__type>(__k, __phi);
        }
        inline float ellint_2f(float __k, float __phi)         {
            return __detail::__ellint_2<float>(__k, __phi);
        }
        inline long double ellint_2l(long double __k, long double __phi)         {
            return __detail::__ellint_2<long double>(__k, __phi);
        }
        template <typename _Tp, typename _Tpp> inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_2(_Tp __k, _Tpp __phi)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
            return __detail::__ellint_2<__type>(__k, __phi);
        }
        inline float ellint_3f(float __k, float __nu, float __phi)         {
            return __detail::__ellint_3<float>(__k, __nu, __phi);
        }
        inline long double ellint_3l(long double __k, long double __nu, long double __phi)         {
            return __detail::__ellint_3<long double>(__k, __nu, __phi);
        }
        template <typename _Tp, typename _Tpn, typename _Tpp> inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)         {
            typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
            return __detail::__ellint_3<__type>(__k, __nu, __phi);
        }
        inline float expintf(float __x)         {
            return __detail::__expint<float>(__x);
        }
        inline long double expintl(long double __x)         {
            return __detail::__expint<long double>(__x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type expint(_Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__expint<__type>(__x);
        }
        inline float hermitef(unsigned int __n, float __x)         {
            return __detail::__poly_hermite<float>(__n, __x);
        }
        inline long double hermitel(unsigned int __n, long double __x)         {
            return __detail::__poly_hermite<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type hermite(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__poly_hermite<__type>(__n, __x);
        }
        inline float laguerref(unsigned int __n, float __x)         {
            return __detail::__laguerre<float>(__n, __x);
        }
        inline long double laguerrel(unsigned int __n, long double __x)         {
            return __detail::__laguerre<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type laguerre(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__laguerre<__type>(__n, __x);
        }
        inline float legendref(unsigned int __l, float __x)         {
            return __detail::__poly_legendre_p<float>(__l, __x);
        }
        inline long double legendrel(unsigned int __l, long double __x)         {
            return __detail::__poly_legendre_p<long double>(__l, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type legendre(unsigned int __l, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__poly_legendre_p<__type>(__l, __x);
        }
        inline float riemann_zetaf(float __s)         {
            return __detail::__riemann_zeta<float>(__s);
        }
        inline long double riemann_zetal(long double __s)         {
            return __detail::__riemann_zeta<long double>(__s);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type riemann_zeta(_Tp __s)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__riemann_zeta<__type>(__s);
        }
        inline float sph_besself(unsigned int __n, float __x)         {
            return __detail::__sph_bessel<float>(__n, __x);
        }
        inline long double sph_bessell(unsigned int __n, long double __x)         {
            return __detail::__sph_bessel<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type sph_bessel(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__sph_bessel<__type>(__n, __x);
        }
        inline float sph_legendref(unsigned int __l, unsigned int __m, float __theta)         {
            return __detail::__sph_legendre<float>(__l, __m, __theta);
        }
        inline long double sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)         {
            return __detail::__sph_legendre<long double>(__l, __m, __theta);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__sph_legendre<__type>(__l, __m, __theta);
        }
        inline float sph_neumannf(unsigned int __n, float __x)         {
            return __detail::__sph_neumann<float>(__n, __x);
        }
        inline long double sph_neumannl(unsigned int __n, long double __x)         {
            return __detail::__sph_neumann<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type sph_neumann(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__sph_neumann<__type>(__n, __x);
        }
    }
}
constexpr int _pow(int base, int exp, int result = 1) {
    return exp < 1 ? result : _pow(base * base, exp / 2, (exp % 2) ? result * base : result);
}
constexpr int _log(int b, int n) {
    return n < b ? 0 : _log(b, n / b) + 1;
}
template <typename A, typename B> constexpr bool is_same_type = std::is_same<A, B>::value;
template <typename Lambda, size_t Index, size_t end_of_list> constexpr auto tokenize_list(Lambda str_lambda) {
    using curr = decltype(tokenize<Lambda, Index + 1>(str_lambda));
    return make_list(curr({}));
}
template<> constexpr list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> tokenize_list<(lambda at main.cpp:26:11), 0, 16>((lambda at main.cpp:26:11) str_lambda) {
    using curr = decltype(tokenize<(lambda at main.cpp:26:11), 0UL + 1>(str_lambda));
    return make_list(curr{});
}
template<> constexpr list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> tokenize_list<(lambda at main.cpp:26:11), 5, 16>((lambda at main.cpp:26:11) str_lambda) {
    using curr = decltype(tokenize<(lambda at main.cpp:26:11), 5UL + 1>(str_lambda));
    return make_list(curr{});
}
template<> constexpr list<token_list<plus, integer<2>, integer<2>>> tokenize_list<(lambda at main.cpp:26:11), 10, 16>((lambda at main.cpp:26:11) str_lambda) {
    using curr = decltype(tokenize<(lambda at main.cpp:26:11), 10UL + 1>(str_lambda));
    return make_list(curr{});
}
template <typename ...Types> struct token_list {
    static constexpr auto append(token_list<>) -> token_list<Types...>;
    template <typename A> static constexpr auto append(A) -> token_list<Types..., A>;
    template <typename A> static constexpr auto append(token_list<A>)     {
        return decltype(append(A({})))({});
    }
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>)     {
        using curr = decltype(token_list<Types...>::append(A({})));
        return decltype(curr::append(token_list<B, Args...>({})))({});
    }
};
template<> struct token_list<<>> {
    static constexpr auto append(token_list<>) -> token_list<>;
    template <typename A> static constexpr auto append(A) -> token_list<A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<2>, A>;
    template<> static constexpr auto append<token_list<token_list<>>>(token_list<token_list<>>) -> token_list<integer<2>, token_list<token_list<>>>;
    template<> static constexpr auto append<token_list<>>(token_list<>) -> token_list<integer<2>, token_list<>>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<integer<2>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<integer<2>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<2>> append<token_list<>>(token_list<token_list<>>)     {
        return decltype(append(token_list<>{})){};
    }
;
    template<> static constexpr token_list<integer<2>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<integer<2>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<2>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<2>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus>> {
    static constexpr auto append(token_list<>) -> token_list<plus>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>, integer<2>>>>(token_list<token_list<integer<2>, integer<2>>>) -> token_list<plus, token_list<token_list<integer<2>, integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>, integer<2>>>(token_list<integer<2>, integer<2>>) -> token_list<plus, token_list<integer<2>, integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<plus, integer<2>>;
    template<> static constexpr auto append<token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<plus, token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> token_list<plus, token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<integer<3>>(integer<3>) -> token_list<plus, integer<3>>;
    template<> static constexpr auto append<token_list<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(token_list<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>) -> token_list<plus, token_list<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> token_list<plus, token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<plus, integer<2>, integer<2>> append<token_list<integer<2>, integer<2>>>(token_list<token_list<integer<2>, integer<2>>>)     {
        return decltype(append(token_list<integer<2>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<integer<2>>(token_list<integer<2>>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<integer<3>>(token_list<integer<3>>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<plus, integer<2>, integer<2>> append<integer<2>, integer<2>, <>>(token_list<integer<2>, integer<2>>)     {
        using curr = decltype(token_list<plus>::append(integer<2>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, <integer<2>>>(token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<plus>::append(integer<3>{}));
        return decltype(curr::append(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, <integer<2>>>(token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<plus>::append(integer<3>{}));
        return decltype(curr::append(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>{})){};
    }
;
};
template<> struct token_list<<token_list<integer<2>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<2>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<2>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<2>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<plus, integer<2>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<plus, integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<plus, integer<2>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<2>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<2>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<2>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, A>;
    template<> static constexpr auto append<token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<integer<3>, token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> token_list<integer<3>, token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(list<token_list<plus, integer<2>, integer<2>>>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template<> static constexpr auto append<token_list<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(token_list<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>) -> token_list<integer<3>, token_list<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> token_list<integer<3>, token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<list<token_list<plus, integer<2>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<integer<3>>::append(list<token_list<plus, integer<2>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<integer<3>>::append(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
};
template<> struct token_list<<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<plus, integer<2>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<3>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, A>;
    template<> static constexpr auto append<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> token_list<plus, integer<3>, token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(list<token_list<plus, integer<2>, integer<2>>>) -> token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template<> static constexpr auto append<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> token_list<plus, integer<3>, token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>>);
    template<> static constexpr auto append<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<list<token_list<plus, integer<2>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<plus, integer<3>>::append(list<token_list<plus, integer<2>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<plus, integer<3>>::append(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
};
template<> struct token_list<<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template <typename T, typename ...Rest> constexpr auto make_token_list(T, Rest ...) -> decltype(token_list<T>::append(token_list<Rest...>({})));
template<> constexpr auto make_token_list<integer<2>, <token_list<>>>(integer<2>, token_list<>) -> decltype(token_list<integer<2>>::append(token_list<token_list<>>{}));
template<> constexpr auto make_token_list<integer<2>, <token_list<integer<2>>>>(integer<2>, token_list<integer<2>>) -> decltype(token_list<integer<2>>::append(token_list<token_list<integer<2>>>{}));
template<> constexpr auto make_token_list<plus, <token_list<integer<2>, integer<2>>>>(plus, token_list<integer<2>, integer<2>>) -> decltype(token_list<plus>::append(token_list<token_list<integer<2>, integer<2>>>{}));
template<> constexpr auto make_token_list<list<token_list<plus, integer<2>, integer<2>>>, <token_list<integer<2>>>>(list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>) -> decltype(token_list<list<token_list<plus, integer<2>, integer<2>>>>::append(token_list<token_list<integer<2>>>{}));
template<> constexpr auto make_token_list<integer<3>, <token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(integer<3>, token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> decltype(token_list<integer<3>>::append(token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<plus, <token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(plus, token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> decltype(token_list<plus>::append(token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, <token_list<integer<2>>>>(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>) -> decltype(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>::append(token_list<token_list<integer<2>>>{}));
template<> constexpr auto make_token_list<integer<3>, <token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(integer<3>, token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> decltype(token_list<integer<3>>::append(token_list<token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<plus, <token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(plus, token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> decltype(token_list<plus>::append(token_list<token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, <token_list<integer<2>>>>(list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, token_list<integer<2>>) -> decltype(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>::append(token_list<token_list<integer<2>>>{}));
constexpr auto make_token_list() -> token_list<>;
template <typename ...Types> using make_token_list_t = decltype(make_token_list(Types({})...));
template <typename ...Types> using token_list_t = decltype(make_token_list());
template <typename ...Types> struct c_list {
    static constexpr auto append(c_list<>) -> c_list<Types...>;
    template <typename A> static constexpr auto append(A) -> c_list<Types..., A>;
    template <typename A> static constexpr auto append(c_list<A>)     {
        return decltype(append(A({})))({});
    }
    template <typename A, typename B, typename ...Args> static constexpr auto append(c_list<A, B, Args...>)     {
        using curr = decltype(c_list<Types...>::append(A({})));
        return decltype(curr::append(c_list<B, Args...>({})))({});
    }
};
template<> struct c_list<<>> {
    static constexpr auto append(c_list<>) -> c_list<>;
    template <typename A> static constexpr auto append(A) -> c_list<A>;
    template <typename A> static constexpr auto append(c_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(c_list<A, B, Args...>);
};
template <typename T, typename ...Rest> constexpr auto make_c_list(T, Rest ...) -> decltype(c_list<T>::append(c_list<Rest...>({})));
constexpr auto make_c_list() -> c_list<>;
template <typename ...Types> struct list {
    static constexpr auto append(list<>) -> list<Types...>;
    template <typename A> static constexpr auto append(A) -> list<Types..., A>;
    template <typename A> static constexpr auto append(list<A>)     {
        return decltype(append(A({})))({});
    }
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>)     {
        using curr = decltype(list<Types...>::append(A({})));
        return decltype(curr::append(list<B, Args...>({})))({});
    }
};
template<> struct list<<>> {
    static constexpr auto append(list<>) -> list<>;
    template <typename A> static constexpr auto append(A) -> list<A>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template<> struct list<<token_list<plus, integer<2>, integer<2>>>> {
    static constexpr auto append(list<>) -> list<token_list<plus, integer<2>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> list<token_list<plus, integer<2>, integer<2>>, A>;
    template<> static constexpr auto append<list<>>(list<>) -> list<token_list<plus, integer<2>, integer<2>>, list<>>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template<> struct list<<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(list<>) -> list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, A>;
    template<> static constexpr auto append<list<>>(list<>) -> list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, list<>>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template<> struct list<<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(list<>) -> list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, A>;
    template<> static constexpr auto append<list<>>(list<>) -> list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, list<>>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template <typename T, typename ...Rest> constexpr auto make_list(T, Rest ...) -> decltype(list<T>::append(list<Rest...>({})));
template<> constexpr auto make_list<token_list<plus, integer<2>, integer<2>>, <>>(token_list<plus, integer<2>, integer<2>>) -> decltype(list<token_list<plus, integer<2>, integer<2>>>::append(list<>{}));
template<> constexpr auto make_list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, <>>(token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> decltype(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>::append(list<>{}));
template<> constexpr auto make_list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, <>>(token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> decltype(list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>::append(list<>{}));
constexpr auto make_list() -> list<>;
struct list_start {
};
struct list_end {
};
struct double_quote {
};
struct quote {
};
struct plus {
};
struct minus {
};
struct mul {
};
struct div_ {
};
struct term {
};
struct whitespace {
};
struct non_integer {
};
struct non_character {
};
template <auto Value> struct c {
};
template <int Value> struct special_character {
};
template <int Value> struct integer {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((Value * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<Value>;
};
template<> struct integer<3> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((3 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<3>;
};
template<> struct integer<2> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((2 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<2>;
};
template<> struct integer<4> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((4 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<4>;
};
template<> struct integer<9> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((9 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<9>;
};
template <int C> constexpr auto deduce_token_type() {
    if (C == '(') {
        return list_start{};
    } else if (C >= '0' && C <= '9') {
        return integer<C - '0'>({});
    } else if (C == ')') {
        return list_end{};
    } else if (C >= 'a' && C <= 'z') {
        return c<C>({});
    } else if (C >= 'A' && C <= 'Z') {
        return c<C>({});
    } else if (C == '"') {
        return double_quote{};
    } else if (C == '\'') {
        return quote{};
    } else if (C == '+') {
        return plus{};
    } else if (C == '-') {
        return minus{};
    } else if (C == '*') {
        return mul{};
    } else if (C == '/') {
        return div_{};
    } else if (C == ' ') {
        return whitespace{};
    }
}
template<> constexpr list_start deduce_token_type<40>() {
    if (40 == '(') {
        return list_start{};
    }
}
template<> constexpr plus deduce_token_type<43>() {
    if (43 == '(')
        ;
    else if (43 >= '0' && 43 <= '9')
        ;
    else if (43 == ')')
        ;
    else if (43 >= 'a' && 43 <= 'z')
        ;
    else if (43 >= 'A' && 43 <= 'Z')
        ;
    else if (43 == '"')
        ;
    else if (43 == '\'')
        ;
    else if (43 == '+') {
        return plus{};
    }
}
template<> constexpr whitespace deduce_token_type<32>() {
    if (32 == '(')
        ;
    else if (32 >= '0' && 32 <= '9')
        ;
    else if (32 == ')')
        ;
    else if (32 >= 'a' && 32 <= 'z')
        ;
    else if (32 >= 'A' && 32 <= 'Z')
        ;
    else if (32 == '"')
        ;
    else if (32 == '\'')
        ;
    else if (32 == '+')
        ;
    else if (32 == '-')
        ;
    else if (32 == '*')
        ;
    else if (32 == '/')
        ;
    else if (32 == ' ') {
        return whitespace{};
    }
}
template<> constexpr integer<3> deduce_token_type<51>() {
    if (51 == '(')
        ;
    else if (51 >= '0' && 51 <= '9') {
        return integer<51 - '0'>{};
    }
}
template<> constexpr integer<2> deduce_token_type<50>() {
    if (50 == '(')
        ;
    else if (50 >= '0' && 50 <= '9') {
        return integer<50 - '0'>{};
    }
}
template<> constexpr list_end deduce_token_type<41>() {
    if (41 == '(')
        ;
    else if (41 >= '0' && 41 <= '9')
        ;
    else if (41 == ')') {
        return list_end{};
    }
}
template <typename Test, template <int ...> class Type> struct is_templated_int_collection : std::false_type {
};
template<> struct is_templated_int_collection<plus, integer> : std::false_type {
};
template<> struct is_templated_int_collection<plus, c> : std::false_type {
};
template<> struct is_templated_int_collection<whitespace, integer> : std::false_type {
};
template<> struct is_templated_int_collection<whitespace, c> : std::false_type {
};
template<> struct is_templated_int_collection<integer<3>, integer> : std::true_type {
};
template<> struct is_templated_int_collection<integer<2>, integer> : std::true_type {
};
template<> struct is_templated_int_collection<list_end, integer> : std::false_type {
};
template <template <int ...> class Type, int ...Args> struct is_templated_int_collection<Type<Args...>, Type> : std::true_type {
};
template <typename T> constexpr bool is_integer_v = is_templated_int_collection<T, integer>::value;
template <typename T> constexpr bool is_char_v = is_templated_int_collection<T, c>::value;
template <int Index, typename Lambda> constexpr auto find_first_non_integer(Lambda lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[Index]>());
    if (!is_integer_v<type>) {
        return Index;
    } else {
        return find_first_non_integer<Index + 1>(lambda);
    }
}
template<> constexpr int find_first_non_integer<4, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[4]>());
    if (!is_integer_v<type>) {
        return 4;
    }
}
template<> constexpr int find_first_non_integer<9, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[9]>());
    if (!is_integer_v<type>) {
        return 9;
    }
}
template<> constexpr int find_first_non_integer<14, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[14]>());
    if (!is_integer_v<type>) {
        return 14;
    }
}
template<> constexpr int find_first_non_integer<16, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[16]>());
    if (!is_integer_v<type>) {
        return 16;
    }
}
template<> constexpr int find_first_non_integer<19, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[19]>());
    if (!is_integer_v<type>) {
        return 19;
    }
}
template <int Start, int End, typename Lambda> constexpr auto make_integer(Lambda str_lambda) {
    constexpr auto str = str_lambda();
    if (Start < End) {
        constexpr auto value = str[Start] - '0';
        return integer<value>::merge(make_integer<Start + 1, End>(str_lambda));
    } else {
        return non_integer{};
    }
}
template<> constexpr integer<3> make_integer<3, 4, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (3 < 4) {
        constexpr auto value = str[3] - '0';
        return integer<value>::merge(make_integer<3 + 1, 4>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<4, 4, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (4 < 4)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<3> make_integer<8, 9, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (8 < 9) {
        constexpr auto value = str[8] - '0';
        return integer<value>::merge(make_integer<8 + 1, 9>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<9, 9, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (9 < 9)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<2> make_integer<13, 14, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (13 < 14) {
        constexpr auto value = str[13] - '0';
        return integer<value>::merge(make_integer<13 + 1, 14>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<14, 14, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (14 < 14)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<2> make_integer<15, 16, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (15 < 16) {
        constexpr auto value = str[15] - '0';
        return integer<value>::merge(make_integer<15 + 1, 16>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<16, 16, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (16 < 16)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<2> make_integer<18, 19, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (18 < 19) {
        constexpr auto value = str[18] - '0';
        return integer<value>::merge(make_integer<18 + 1, 19>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<19, 19, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (19 < 19)
        ;
    else {
        return non_integer{};
    }
}
template <typename Lambda, size_t Index = 0, size_t end_of_char_list> constexpr auto tokenize_char_list(Lambda str_lambda) {
    constexpr auto str = str_lambda();
    if (Index < end_of_char_list) {
        using curr = decltype(deduce_token_type<str[Index]>());
        using second = decltype(tokenize_char_list<Lambda, Index + 1, end_of_char_list>(str_lambda));
        return make_c_list(curr({}), second({}));
    } else {
        return make_c_list();
    }
}
template <int Index, typename Lambda> constexpr auto find_end_of_list(Lambda lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[Index]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<Index + 1>(lambda);
    } else {
        return Index;
    }
}
template<> constexpr int find_end_of_list<0, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[0]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<0 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<1, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[1]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<1 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<2, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[2]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<2 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<3, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[3]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<3 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<4, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[4]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<4 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<5, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[5]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<5 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<6, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[6]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<6 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<7, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[7]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<7 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<8, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[8]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<8 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<9, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[9]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<9 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<10, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[10]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<10 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<11, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[11]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<11 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<12, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[12]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<12 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<13, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[13]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<13 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<14, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[14]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<14 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<15, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[15]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<15 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<16, (lambda at main.cpp:26:11)>((lambda at main.cpp:26:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[16]>());
    if (!is_same_type<type, list_end>)
        ;
    else {
        return 16;
    }
}
template <typename Lambda, int Index = 0> constexpr auto define_atom(Lambda lambda) {
    constexpr auto str = lambda();
    if (Index < str.size()) {
        using curr = decltype(deduce_token_type<str[Index]>());
        using second = decltype(define_atom<Lambda, Index + 1>(lambda));
        return make_c_list(curr({}), second({}));
    } else {
        return make_c_list();
    }
}
template <typename Lambda, size_t Index = 0> constexpr auto tokenize(Lambda str_lambda) {
    constexpr auto str = str_lambda();
    if (Index < str.size()) {
        using curr = decltype(deduce_token_type<str[Index]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<Index>(str_lambda);
            using list = decltype(tokenize_list<Lambda, Index, end_of_list>(str_lambda));
            using second = decltype(tokenize<Lambda, end_of_list + 1>(str_lambda));
            return make_token_list(list({}), second({}));
        } else if (is_same_type<curr, list_end>) {
            return make_token_list();
        } else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<Index + 1>(str_lambda);
            using integer_type = decltype(make_integer<Index, first_non_integer>(str_lambda));
            using second = decltype(tokenize<Lambda, first_non_integer>(str_lambda));
            return make_token_list(integer_type({}), second({}));
        } else if (is_char_v<curr>) {
            constexpr auto end_of_char_list = find_end_of_char_list<Index>(str_lambda);
            if (end_of_char_list > 0) {
                using char_list = decltype(tokenize_char_list<Lambda, Index, end_of_char_list>(str_lambda));
                using second = decltype(tokenize<Lambda, end_of_char_list>(str_lambda));
                return make_token_list(char_list({}), second({}));
            } else {
                using second = decltype(tokenize<Lambda, Index + 1>(str_lambda));
                return make_token_list(curr({}), second({}));
            }
        } else if (is_same_type<curr, whitespace>) {
            return tokenize<Lambda, Index + 1>(str_lambda);
        } else {
            using next = decltype(tokenize<Lambda, Index + 1>(str_lambda));
            return make_token_list(curr({}), next({}));
        }
    } else {
        return make_token_list();
    }
}
template<> constexpr token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 0>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (0UL < str.size()) {
        using curr = decltype(deduce_token_type<str[0UL]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<0UL>(str_lambda);
            using list = decltype(tokenize_list<(lambda at main.cpp:26:11), 0UL, end_of_list>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), end_of_list + 1>(str_lambda));
            return make_token_list(list{}, second{});
        }
    }
}
template<> constexpr token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 1>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (1UL < str.size()) {
        using curr = decltype(deduce_token_type<str[1UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>)
            ;
        else {
            using next = decltype(tokenize<(lambda at main.cpp:26:11), 1UL + 1>(str_lambda));
            return make_token_list(curr{}, next{});
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 2>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (2UL < str.size()) {
        using curr = decltype(deduce_token_type<str[2UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:26:11), 2UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 3>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (3UL < str.size()) {
        using curr = decltype(deduce_token_type<str[3UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<3UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<3UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 4>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (4UL < str.size()) {
        using curr = decltype(deduce_token_type<str[4UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:26:11), 4UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 5>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (5UL < str.size()) {
        using curr = decltype(deduce_token_type<str[5UL]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<5UL>(str_lambda);
            using list = decltype(tokenize_list<(lambda at main.cpp:26:11), 5UL, end_of_list>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), end_of_list + 1>(str_lambda));
            return make_token_list(list{}, second{});
        }
    }
}
template<> constexpr token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 6>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (6UL < str.size()) {
        using curr = decltype(deduce_token_type<str[6UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>)
            ;
        else {
            using next = decltype(tokenize<(lambda at main.cpp:26:11), 6UL + 1>(str_lambda));
            return make_token_list(curr{}, next{});
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 7>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (7UL < str.size()) {
        using curr = decltype(deduce_token_type<str[7UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:26:11), 7UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 8>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (8UL < str.size()) {
        using curr = decltype(deduce_token_type<str[8UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<8UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<8UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 9>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (9UL < str.size()) {
        using curr = decltype(deduce_token_type<str[9UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:26:11), 9UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:26:11), 10>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (10UL < str.size()) {
        using curr = decltype(deduce_token_type<str[10UL]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<10UL>(str_lambda);
            using list = decltype(tokenize_list<(lambda at main.cpp:26:11), 10UL, end_of_list>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), end_of_list + 1>(str_lambda));
            return make_token_list(list{}, second{});
        }
    }
}
template<> constexpr token_list<plus, integer<2>, integer<2>> tokenize<(lambda at main.cpp:26:11), 11>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (11UL < str.size()) {
        using curr = decltype(deduce_token_type<str[11UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>)
            ;
        else {
            using next = decltype(tokenize<(lambda at main.cpp:26:11), 11UL + 1>(str_lambda));
            return make_token_list(curr{}, next{});
        }
    }
}
template<> constexpr token_list<integer<2>, integer<2>> tokenize<(lambda at main.cpp:26:11), 12>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (12UL < str.size()) {
        using curr = decltype(deduce_token_type<str[12UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:26:11), 12UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<2>, integer<2>> tokenize<(lambda at main.cpp:26:11), 13>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (13UL < str.size()) {
        using curr = decltype(deduce_token_type<str[13UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<13UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<13UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:26:11), 14>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (14UL < str.size()) {
        using curr = decltype(deduce_token_type<str[14UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:26:11), 14UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:26:11), 15>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (15UL < str.size()) {
        using curr = decltype(deduce_token_type<str[15UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<15UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<15UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<> tokenize<(lambda at main.cpp:26:11), 16>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (16UL < str.size()) {
        using curr = decltype(deduce_token_type<str[16UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>) {
            return make_token_list();
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:26:11), 17>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (17UL < str.size()) {
        using curr = decltype(deduce_token_type<str[17UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:26:11), 17UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:26:11), 18>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (18UL < str.size()) {
        using curr = decltype(deduce_token_type<str[18UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<18UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<18UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:26:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<> tokenize<(lambda at main.cpp:26:11), 19>((lambda at main.cpp:26:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (19UL < str.size()) {
        using curr = decltype(deduce_token_type<str[19UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>) {
            return make_token_list();
        }
    }
}
template <int A, typename ...Rest> constexpr auto e_add(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A + e_add(r...);
    else
        return A;
}
template<> constexpr int e_add<3, <list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> r, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 3 + e_add(r, r);
}
template<> constexpr int e_add<3, <list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(integer<3>, list<token_list<plus, integer<2>, integer<2>>> r, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 3 + e_add(r, r);
}
template<> constexpr int e_add<2, <integer<2>>>(integer<2>, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 2 + e_add(r);
}
template<> constexpr int e_add<2, <>>(integer<2>) {
    if (sizeof...(Rest) > 0)
        ;
    else
        return 2;
}
template<> constexpr int e_add<4, <integer<2>>>(integer<4>, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 4 + e_add(r);
}
template<> constexpr int e_add<9, <integer<2>>>(integer<9>, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 9 + e_add(r);
}
template <typename ...Args, typename ...Rest> constexpr auto e_add(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_add(integer<x>({}), Rest({})...);
}
template<> constexpr int e_add<<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, <integer<2>>>(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> l, integer<2>) {
    constexpr auto x = handle_prefix(l);
    return e_add(integer<x>{}, integer<2>{});
}
template<> constexpr int e_add<<token_list<plus, integer<2>, integer<2>>>, <integer<2>>>(list<token_list<plus, integer<2>, integer<2>>> l, integer<2>) {
    constexpr auto x = handle_prefix(l);
    return e_add(integer<x>{}, integer<2>{});
}
template <int A, typename ...Rest> constexpr auto e_sub(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A - e_sub(r...);
    else
        return A;
}
template <typename ...Args, typename ...Rest> constexpr auto e_sub(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_sub(integer<x>({}), Rest({})...);
}
template <int A, typename ...Rest> constexpr auto e_mul(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A * e_mul(r...);
    else
        return A;
}
template <typename ...Args, typename ...Rest> constexpr auto e_mul(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_mul(integer<x>({}), Rest({})...);
}
template <int A, typename ...Rest> constexpr auto e_div(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A / e_div(r...);
    else
        return A;
}
template <typename ...Args, typename ...Rest> constexpr auto e_div(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_div(integer<x>({}), Rest({})...);
}
template <typename A, typename ...Rest> constexpr auto handle_prefix(list<token_list<A, Rest...>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<A, plus>) {
            return e_add(Rest({})...);
        } else if (is_same_type<A, minus>) {
            return e_sub(Rest({})...);
        } else if (is_same_type<A, mul>) {
            return e_mul(Rest({})...);
        } else if (is_same_type<A, div_>) {
            return e_div(Rest({})...);
        }
    }
}
template<> constexpr int handle_prefix<plus, <integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<plus, plus>) {
            return e_add(integer<3>{}, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}, integer<2>{});
        }
    }
}
template<> constexpr int handle_prefix<plus, <integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<plus, plus>) {
            return e_add(integer<3>{}, list<token_list<plus, integer<2>, integer<2>>>{}, integer<2>{});
        }
    }
}
template<> constexpr int handle_prefix<plus, <integer<2>, integer<2>>>(list<token_list<plus, integer<2>, integer<2>>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<plus, plus>) {
            return e_add(integer<2>{}, integer<2>{});
        }
    }
}
;
extern "C++" {
    namespace std {
        class bad_exception : public std::exception {
        public:
            bad_exception() noexcept : std::exception()             {
            }
            virtual ~bad_exception() noexcept;
            virtual const char *what() const noexcept;
        };
        typedef void (*terminate_handler)();
        std::terminate_handler set_terminate(std::terminate_handler) noexcept;
        std::terminate_handler get_terminate() noexcept;
        void terminate() noexcept;
        typedef void (*unexpected_handler)() __attribute__((deprecated("")));
        std::unexpected_handler set_unexpected(std::unexpected_handler) noexcept __attribute__((deprecated("")));
        std::unexpected_handler get_unexpected() noexcept __attribute__((deprecated("")));
        void unexpected() __attribute__((deprecated("")));
        bool uncaught_exception() noexcept __attribute__((deprecated("use 'std::uncaught_exceptions()' instead"))) __attribute__((pure));
        int uncaught_exceptions() noexcept __attribute__((pure));
    }
    namespace __gnu_cxx {
        void __verbose_terminate_handler();
    }
}
typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef unsigned long rsize_t;
typedef struct {
    long long __clang_max_align_nonce1 __attribute__((aligned(__alignof(long long))));
    long double __clang_max_align_nonce2 __attribute__((aligned(__alignof(long double))));
} max_align_t;
namespace std {
    class type_info;
}
namespace __cxxabiv1 {
    struct __cxa_refcounted_exception;
    extern "C" {
        void *__cxa_allocate_exception(size_t) noexcept;
        void __cxa_free_exception(void *) noexcept;
        __cxxabiv1::__cxa_refcounted_exception *__cxa_init_primary_exception(void *object, std::type_info *tinfo, void (*dest)(void *)) noexcept;
    }
}
extern "C++" {
    namespace __cxxabiv1 {
        class __class_type_info;
    }
    namespace std {
        class type_info {
        public:
            virtual ~type_info() noexcept;
            const char *name() const noexcept             {
                return this->__name[0] == '*' ? this->__name + 1 : this->__name;
            }
            bool before(const std::type_info &__arg) const noexcept;
            bool operator==(const std::type_info &__arg) const noexcept;
            std::size_t hash_code() const noexcept             {
                return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast<std::size_t>(3339675911UL));
            }
            virtual bool __is_pointer_p() const;
            virtual bool __is_function_p() const;
            virtual bool __do_catch(const std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
            virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target, void **__obj_ptr) const;
        protected:
            const char *__name;
            explicit type_info(const char *__n) : __name(__n)             {
            }
        private:
            std::type_info &operator=(const std::type_info &) = delete
            type_info(const std::type_info &) = delete
        };
        inline bool type_info::before(const std::type_info &__arg) const noexcept         {
            if (this->__name[0] != '*' || __arg.__name[0] != '*')
                return __builtin_strcmp(this->__name, __arg.__name) < 0;
            return this->__name < __arg.__name;
        }
        inline bool type_info::operator==(const std::type_info &__arg) const noexcept         {
            if (std::__is_constant_evaluated())
                return this == &__arg;
            if (this->__name == __arg.__name)
                return true;
            return this->__name[0] != '*' && __builtin_strcmp(this->__name, __arg.name()) == 0;
        }
        class bad_cast : public std::exception {
        public:
            bad_cast() noexcept : std::exception()             {
            }
            virtual ~bad_cast() noexcept;
            virtual const char *what() const noexcept;
        };
        class bad_typeid : public std::exception {
        public:
            bad_typeid() noexcept : std::exception()             {
            }
            virtual ~bad_typeid() noexcept;
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class type_info;
        namespace __exception_ptr {
            class exception_ptr;
        }
        using __exception_ptr::exception_ptr;
        std::__exception_ptr::exception_ptr current_exception() noexcept;
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex) noexcept;
        void rethrow_exception(std::__exception_ptr::exception_ptr);
        namespace __exception_ptr {
            using std::rethrow_exception;
            class exception_ptr {
                void *_M_exception_object;
                explicit exception_ptr(void *__e) noexcept;
                void _M_addref() noexcept;
                void _M_release() noexcept;
                void *_M_get() const noexcept __attribute__((pure));
                friend std::__exception_ptr::exception_ptr std::current_exception() noexcept;
                friend void std::rethrow_exception(std::__exception_ptr::exception_ptr);
                friend template <typename _Ex> std::__exception_ptr::exception_ptr std::make_exception_ptr(_Ex) noexcept;
            public:
                exception_ptr() noexcept;
                exception_ptr(const std::__exception_ptr::exception_ptr &) noexcept;
                exception_ptr(std::nullptr_t) noexcept : _M_exception_object(nullptr)                 {
                }
                exception_ptr(std::__exception_ptr::exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object)                 {
                    __o._M_exception_object = nullptr;
                }
                std::__exception_ptr::exception_ptr &operator=(const std::__exception_ptr::exception_ptr &) noexcept;
                std::__exception_ptr::exception_ptr &operator=(std::__exception_ptr::exception_ptr &&__o) noexcept                 {
                    std::__exception_ptr::exception_ptr(static_cast<std::__exception_ptr::exception_ptr &&>(__o)).swap(*this);
                    return *this;
                }
                ~exception_ptr() noexcept;
                void swap(std::__exception_ptr::exception_ptr &) noexcept;
                explicit operator bool() const noexcept                 {
                    return this->_M_exception_object;
                }
                friend bool operator==(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept = default;
                const class std::type_info *__cxa_exception_type() const noexcept __attribute__((pure));
            };
            inline exception_ptr::exception_ptr() noexcept : _M_exception_object(0)             {
            }
            inline exception_ptr::exception_ptr(const std::__exception_ptr::exception_ptr &__other) noexcept : _M_exception_object(__other._M_exception_object)             {
                if (this->_M_exception_object)
                    this->_M_addref();
            }
            inline exception_ptr::~exception_ptr() noexcept             {
                if (this->_M_exception_object)
                    this->_M_release();
            }
            inline std::__exception_ptr::exception_ptr &exception_ptr::operator=(const std::__exception_ptr::exception_ptr &__other) noexcept             {
                std::__exception_ptr::exception_ptr(__other).swap(*this);
                return *this;
            }
            inline void exception_ptr::swap(std::__exception_ptr::exception_ptr &__other) noexcept             {
                void *__tmp = this->_M_exception_object;
                this->_M_exception_object = __other._M_exception_object;
                __other._M_exception_object = __tmp;
            }
            inline void swap(std::__exception_ptr::exception_ptr &__lhs, std::__exception_ptr::exception_ptr &__rhs)             {
                __lhs.swap(__rhs);
            }
            template <typename _Ex> inline void __dest_thunk(void *__x)             {
                static_cast<_Ex *>(__x)->~_Ex();
            }
        }
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept         {
            using _Ex2 = typename decay<_Ex>::type;
            void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
            (void)__cxxabiv1::__cxa_init_primary_exception(__e, const_cast<std::type_info *>(&typeid(_Ex)), __exception_ptr::__dest_thunk<_Ex2>);
            try {
                ::new (__e) _Ex2((__ex));
                return std::__exception_ptr::exception_ptr(__e);
            } catch (...) {
                __cxxabiv1::__cxa_free_exception(__e);
                return current_exception();
            }
        }
    }
}
extern "C++" {
    namespace std {
        class nested_exception {
            std::__exception_ptr::exception_ptr _M_ptr;
        public:
            nested_exception() noexcept : _M_ptr(current_exception())             {
            }
            nested_exception(const std::nested_exception &) noexcept = default
            std::nested_exception &operator=(const std::nested_exception &) noexcept = default
            virtual ~nested_exception() noexcept;
            void rethrow_nested() const [[noreturn]]             {
                if (this->_M_ptr)
                    rethrow_exception(this->_M_ptr);
                std::terminate();
            }
            std::__exception_ptr::exception_ptr nested_ptr() const noexcept             {
                return this->_M_ptr;
            }
        };
        template <typename _Except> struct _Nested_exception : public _Except, public std::nested_exception {
            explicit _Nested_exception<_Except>(const _Except &__ex) : _Except(__ex)             {
            }
            explicit _Nested_exception<_Except>(_Except &&__ex) : _Except(static_cast<_Except &&>(__ex))             {
            }
        };
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::true_type) [[noreturn]]         {
            using _Up = typename remove_reference<_Tp>::type;
            throw _Nested_exception<_Up>({std::forward<_Tp>(__t)});
        }
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::false_type) [[noreturn]]         {
            throw std::forward<_Tp>(__t);
        }
        template <typename _Tp> inline void throw_with_nested(_Tp &&__t) [[noreturn]]         {
            using _Up = typename decay<_Tp>::type;
            using _CopyConstructible = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
            static_assert(_CopyConstructible::value, "throw_with_nested argument must be CopyConstructible");
            using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>, __not_<is_base_of<std::nested_exception, _Up>>>;
            std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest({}));
        }
        template <typename _Tp> using __rethrow_if_nested_cond = typename enable_if<__and_<is_polymorphic<_Tp>, __or_<__not_<is_base_of<nested_exception, _Tp>>, is_convertible<_Tp *, nested_exception *>>>::value>::type;
        template <typename _Ex> inline __rethrow_if_nested_cond<_Ex> __rethrow_if_nested_impl(const _Ex *__ptr)         {
            if (auto __ne_ptr = dynamic_cast<const std::nested_exception *>(__ptr))
                __ne_ptr->rethrow_nested();
        }
        inline void __rethrow_if_nested_impl(const void *)         {
        }
        template <typename _Ex> inline void rethrow_if_nested(const _Ex &__ex)         {
            std::__rethrow_if_nested_impl(std::__addressof(__ex));
        }
    }
}
extern "C" {
    struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        char int_p_cs_precedes;
        char int_p_sep_by_space;
        char int_n_cs_precedes;
        char int_n_sep_by_space;
        char int_p_sign_posn;
        char int_n_sign_posn;
    };
    extern char *setlocale(int __category, const char *__locale) noexcept(truesetlocale(int __category, const char *__locale) noexcept(true);
    extern struct lconv *localeconv() noexcept(truelocaleconv() noexcept(true);
    extern locale_t newlocale(int __category_mask, const char *__locale, locale_t __base) noexcept(truenewlocale(int __category_mask, const char *__locale, locale_t __base) noexcept(true);
    extern locale_t duplocale(locale_t __dataset) noexcept(trueduplocale(locale_t __dataset) noexcept(true);
    extern void freelocale(locale_t __dataset) noexcept(truefreelocale(locale_t __dataset) noexcept(true);
    extern locale_t uselocale(locale_t __dataset) noexcept(trueuselocale(locale_t __dataset) noexcept(true);
}
namespace std {
    using ::lconv;
    using ::setlocale;
    using ::localeconv;
}
namespace __gnu_cxx {
    extern "C" locale_t __uselocale(locale_t) noexcept(true__uselocale(locale_t) noexcept(true)
}
namespace std {
    typedef __locale_t __c_locale;
    inline int __convert_from_v(const std::__c_locale &__cloc __attribute__((unused)), char *__out, const int __size __attribute__((unused)), const char *__fmt, ...)     {
        std::__c_locale __old = __gnu_cxx::__uselocale(__cloc);
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
        __builtin_va_end(__args);
        __gnu_cxx::__uselocale(__old);
        return __ret;
    }
}
extern "C" {
    enum  {
        _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
        _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
        _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
        _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
        _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
        _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
        _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
        _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
        _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
        _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
        _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
        _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
    };
    extern const unsigned short **__ctype_b_loc() noexcept(true__ctype_b_loc() noexcept(true) __attribute__((const));
    extern const __int32_t **__ctype_tolower_loc() noexcept(true__ctype_tolower_loc() noexcept(true) __attribute__((const));
    extern const __int32_t **__ctype_toupper_loc() noexcept(true__ctype_toupper_loc() noexcept(true) __attribute__((const));
    extern int isalnum(int) noexcept(trueisalnum(int) noexcept(true);
    extern int isalpha(int) noexcept(trueisalpha(int) noexcept(true);
    extern int iscntrl(int) noexcept(trueiscntrl(int) noexcept(true);
    extern int isdigit(int) noexcept(trueisdigit(int) noexcept(true);
    extern int islower(int) noexcept(trueislower(int) noexcept(true);
    extern int isgraph(int) noexcept(trueisgraph(int) noexcept(true);
    extern int isprint(int) noexcept(trueisprint(int) noexcept(true);
    extern int ispunct(int) noexcept(trueispunct(int) noexcept(true);
    extern int isspace(int) noexcept(trueisspace(int) noexcept(true);
    extern int isupper(int) noexcept(trueisupper(int) noexcept(true);
    extern int isxdigit(int) noexcept(trueisxdigit(int) noexcept(true);
    extern int tolower(int __c) noexcept(truetolower(int __c) noexcept(true);
    extern int toupper(int __c) noexcept(truetoupper(int __c) noexcept(true);
    extern int isblank(int) noexcept(trueisblank(int) noexcept(true);
    extern int isctype(int __c, int __mask) noexcept(trueisctype(int __c, int __mask) noexcept(true);
    extern int isascii(int __c) noexcept(trueisascii(int __c) noexcept(true);
    extern int toascii(int __c) noexcept(truetoascii(int __c) noexcept(true);
    extern int _toupper(int) noexcept(true_toupper(int) noexcept(true);
    extern int _tolower(int) noexcept(true_tolower(int) noexcept(true);
    extern int isalnum_l(int, locale_t) noexcept(trueisalnum_l(int, locale_t) noexcept(true);
    extern int isalpha_l(int, locale_t) noexcept(trueisalpha_l(int, locale_t) noexcept(true);
    extern int iscntrl_l(int, locale_t) noexcept(trueiscntrl_l(int, locale_t) noexcept(true);
    extern int isdigit_l(int, locale_t) noexcept(trueisdigit_l(int, locale_t) noexcept(true);
    extern int islower_l(int, locale_t) noexcept(trueislower_l(int, locale_t) noexcept(true);
    extern int isgraph_l(int, locale_t) noexcept(trueisgraph_l(int, locale_t) noexcept(true);
    extern int isprint_l(int, locale_t) noexcept(trueisprint_l(int, locale_t) noexcept(true);
    extern int ispunct_l(int, locale_t) noexcept(trueispunct_l(int, locale_t) noexcept(true);
    extern int isspace_l(int, locale_t) noexcept(trueisspace_l(int, locale_t) noexcept(true);
    extern int isupper_l(int, locale_t) noexcept(trueisupper_l(int, locale_t) noexcept(true);
    extern int isxdigit_l(int, locale_t) noexcept(trueisxdigit_l(int, locale_t) noexcept(true);
    extern int isblank_l(int, locale_t) noexcept(trueisblank_l(int, locale_t) noexcept(true);
    extern int __tolower_l(int __c, locale_t __l) noexcept(true__tolower_l(int __c, locale_t __l) noexcept(true);
    extern int tolower_l(int __c, locale_t __l) noexcept(truetolower_l(int __c, locale_t __l) noexcept(true);
    extern int __toupper_l(int __c, locale_t __l) noexcept(true__toupper_l(int __c, locale_t __l) noexcept(true);
    extern int toupper_l(int __c, locale_t __l) noexcept(truetoupper_l(int __c, locale_t __l) noexcept(true);
}
namespace std {
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;
}
namespace std {
    using ::isblank;
}
namespace std {
    class locale;
    template <typename _Facet> bool has_facet(const std::locale &) throw();
    template <typename _Facet> const _Facet &use_facet(const std::locale &);
    template <typename _CharT> bool isspace(_CharT, const std::locale &);
    template <typename _CharT> bool isprint(_CharT, const std::locale &);
    template <typename _CharT> bool iscntrl(_CharT, const std::locale &);
    template <typename _CharT> bool isupper(_CharT, const std::locale &);
    template <typename _CharT> bool islower(_CharT, const std::locale &);
    template <typename _CharT> bool isalpha(_CharT, const std::locale &);
    template <typename _CharT> bool isdigit(_CharT, const std::locale &);
    template <typename _CharT> bool ispunct(_CharT, const std::locale &);
    template <typename _CharT> bool isxdigit(_CharT, const std::locale &);
    template <typename _CharT> bool isalnum(_CharT, const std::locale &);
    template <typename _CharT> bool isgraph(_CharT, const std::locale &);
    template <typename _CharT> bool isblank(_CharT, const std::locale &);
    template <typename _CharT> _CharT toupper(_CharT, const std::locale &);
    template <typename _CharT> _CharT tolower(_CharT, const std::locale &);
    struct ctype_base;
    template <typename _CharT> class ctype;
    template<> class ctype<char>;
    template<> class ctype<wchar_t>;
    template <typename _CharT> class ctype_byname;
    class codecvt_base;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt;
    template<> class codecvt<char, char, mbstate_t>;
    template<> class codecvt<wchar_t, char, mbstate_t>;
    template<> class codecvt<char16_t, char, mbstate_t>;
    template<> class codecvt<char32_t, char, mbstate_t>;
    template<> class codecvt<char16_t, char8_t, mbstate_t>;
    template<> class codecvt<char32_t, char8_t, mbstate_t>;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt_byname;
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put;
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct;
        template <typename _CharT> class numpunct_byname;
    }
    inline namespace __cxx11 {
        template <typename _CharT> class collate;
        template <typename _CharT> class collate_byname;
    }
    class time_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get;
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get_byname;
    }
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put_byname;
    class money_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class money_get;
        template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class money_put;
    }
    inline namespace __cxx11 {
        template <typename _CharT, bool _Intl = false> class moneypunct;
        template <typename _CharT, bool _Intl = false> class moneypunct_byname;
    }
    struct messages_base;
    inline namespace __cxx11 {
        template <typename _CharT> class messages;
        template <typename _CharT> class messages_byname;
    }
}
typedef unsigned long size_t;
struct sched_param {
    int sched_priority;
};
extern "C" {
    extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) noexcept(trueclone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) noexcept(true);
    extern int unshare(int __flags) noexcept(trueunshare(int __flags) noexcept(true);
    extern int sched_getcpu() noexcept(truesched_getcpu() noexcept(true);
    extern int getcpu(unsigned int *, unsigned int *) noexcept(truegetcpu(unsigned int *, unsigned int *) noexcept(true);
    extern int setns(int __fd, int __nstype) noexcept(truesetns(int __fd, int __nstype) noexcept(true);
}
typedef unsigned long __cpu_mask;
typedef struct {
    __cpu_mask __bits[16];
} cpu_set_t;
extern "C" {
    extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp) noexcept(true__sched_cpucount(size_t __setsize, const cpu_set_t *__setp) noexcept(true);
    extern cpu_set_t *__sched_cpualloc(size_t __count) noexcept(true__sched_cpualloc(size_t __count) noexcept(true);
    extern void __sched_cpufree(cpu_set_t *__set) noexcept(true__sched_cpufree(cpu_set_t *__set) noexcept(true);
}
extern "C" {
    extern int sched_setparam(__pid_t __pid, const struct sched_param *__param) noexcept(truesched_setparam(__pid_t __pid, const struct sched_param *__param) noexcept(true);
    extern int sched_getparam(__pid_t __pid, struct sched_param *__param) noexcept(truesched_getparam(__pid_t __pid, struct sched_param *__param) noexcept(true);
    extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param) noexcept(truesched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param) noexcept(true);
    extern int sched_getscheduler(__pid_t __pid) noexcept(truesched_getscheduler(__pid_t __pid) noexcept(true);
    extern int sched_yield() noexcept(truesched_yield() noexcept(true);
    extern int sched_get_priority_max(int __algorithm) noexcept(truesched_get_priority_max(int __algorithm) noexcept(true);
    extern int sched_get_priority_min(int __algorithm) noexcept(truesched_get_priority_min(int __algorithm) noexcept(true);
    extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t) noexcept(truesched_rr_get_interval(__pid_t __pid, struct timespec *__t) noexcept(true);
    extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(truesched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true);
    extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(truesched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true);
}
typedef unsigned long size_t;
struct timex {
    unsigned int modes;
    __syscall_slong_t offset;
    __syscall_slong_t freq;
    __syscall_slong_t maxerror;
    __syscall_slong_t esterror;
    int status;
    __syscall_slong_t constant;
    __syscall_slong_t precision;
    __syscall_slong_t tolerance;
    struct timeval time;
    __syscall_slong_t tick;
    __syscall_slong_t ppsfreq;
    __syscall_slong_t jitter;
    int shift;
    __syscall_slong_t stabil;
    __syscall_slong_t jitcnt;
    __syscall_slong_t calcnt;
    __syscall_slong_t errcnt;
    __syscall_slong_t stbcnt;
    int tai;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
};
extern "C" {
    extern int clock_adjtime(__clockid_t __clock_id, struct timex *__utx) noexcept(trueclock_adjtime(__clockid_t __clock_id, struct timex *__utx) noexcept(true);
}
struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    const char *tm_zone;
};
struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};
struct sigevent;
extern "C" {
    extern clock_t clock() noexcept(trueclock() noexcept(true);
    extern time_t time(time_t *__timer) noexcept(truetime(time_t *__timer) noexcept(true);
    extern double difftime(time_t __time1, time_t __time0) noexcept(truedifftime(time_t __time1, time_t __time0) noexcept(true) __attribute__((const));
    extern time_t mktime(struct tm *__tp) noexcept(truemktime(struct tm *__tp) noexcept(true);
    extern size_t strftime(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp) noexcept(truestrftime(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp) noexcept(true);
    extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp) noexcept(truestrptime(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp) noexcept(true);
    extern size_t strftime_l(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(truestrftime_l(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) noexcept(true);
    extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp, locale_t __loc) noexcept(truestrptime_l(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp, locale_t __loc) noexcept(true);
    extern struct tm *gmtime(const time_t *__timer) noexcept(truegmtime(const time_t *__timer) noexcept(true);
    extern struct tm *localtime(const time_t *__timer) noexcept(truelocaltime(const time_t *__timer) noexcept(true);
    extern struct tm *gmtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(truegmtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(true);
    extern struct tm *localtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(truelocaltime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) noexcept(true);
    extern char *asctime(const struct tm *__tp) noexcept(trueasctime(const struct tm *__tp) noexcept(true);
    extern char *ctime(const time_t *__timer) noexcept(truectime(const time_t *__timer) noexcept(true);
    extern char *asctime_r(const struct tm *__restrict __tp, char *__restrict __buf) noexcept(trueasctime_r(const struct tm *__restrict __tp, char *__restrict __buf) noexcept(true);
    extern char *ctime_r(const time_t *__restrict __timer, char *__restrict __buf) noexcept(truectime_r(const time_t *__restrict __timer, char *__restrict __buf) noexcept(true);
    extern char *__tzname[2];
    extern int __daylight;
    extern long __timezone;
    extern char *tzname[2];
    extern void tzset() noexcept(truetzset() noexcept(true);
    extern int daylight;
    extern long timezone;
    extern time_t timegm(struct tm *__tp) noexcept(truetimegm(struct tm *__tp) noexcept(true);
    extern time_t timelocal(struct tm *__tp) noexcept(truetimelocal(struct tm *__tp) noexcept(true);
    extern int dysize(int __year) noexcept(truedysize(int __year) noexcept(true) __attribute__((const));
    extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining);
    extern int clock_getres(clockid_t __clock_id, struct timespec *__res) noexcept(trueclock_getres(clockid_t __clock_id, struct timespec *__res) noexcept(true);
    extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp) noexcept(trueclock_gettime(clockid_t __clock_id, struct timespec *__tp) noexcept(true);
    extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp) noexcept(trueclock_settime(clockid_t __clock_id, const struct timespec *__tp) noexcept(true);
    extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem);
    extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id) noexcept(trueclock_getcpuclockid(pid_t __pid, clockid_t *__clock_id) noexcept(true);
    extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) noexcept(truetimer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) noexcept(true);
    extern int timer_delete(timer_t __timerid) noexcept(truetimer_delete(timer_t __timerid) noexcept(true);
    extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) noexcept(truetimer_settime(timer_t __timerid, int __flags, const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) noexcept(true);
    extern int timer_gettime(timer_t __timerid, struct itimerspec *__value) noexcept(truetimer_gettime(timer_t __timerid, struct itimerspec *__value) noexcept(true);
    extern int timer_getoverrun(timer_t __timerid) noexcept(truetimer_getoverrun(timer_t __timerid) noexcept(true);
    extern int timespec_get(struct timespec *__ts, int __base) noexcept(truetimespec_get(struct timespec *__ts, int __base) noexcept(true) __attribute__((nonnull(1)));
    extern int timespec_getres(struct timespec *__ts, int __base) noexcept(truetimespec_getres(struct timespec *__ts, int __base) noexcept(true);
    extern int getdate_err;
    extern struct tm *getdate(const char *__string);
    extern int getdate_r(const char *__restrict __string, struct tm *__restrict __resbufp);
}
typedef long __jmp_buf[8];
struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
};
extern "C" {
    extern long __sysconf(int __name) noexcept(true__sysconf(int __name) noexcept(true);
}
enum  {
    PTHREAD_CREATE_JOINABLE,
    PTHREAD_CREATE_DETACHED
};
enum  {
    PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP,
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum  {
    PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_ROBUST,
    PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};
enum  {
    PTHREAD_PRIO_NONE,
    PTHREAD_PRIO_INHERIT,
    PTHREAD_PRIO_PROTECT
};
enum  {
    PTHREAD_RWLOCK_PREFER_READER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum  {
    PTHREAD_INHERIT_SCHED,
    PTHREAD_EXPLICIT_SCHED
};
enum  {
    PTHREAD_SCOPE_SYSTEM,
    PTHREAD_SCOPE_PROCESS
};
enum  {
    PTHREAD_PROCESS_PRIVATE,
    PTHREAD_PROCESS_SHARED
};
struct _pthread_cleanup_buffer {
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
enum  {
    PTHREAD_CANCEL_ENABLE,
    PTHREAD_CANCEL_DISABLE
};
enum  {
    PTHREAD_CANCEL_DEFERRED,
    PTHREAD_CANCEL_ASYNCHRONOUS
};
extern "C" {
    extern int pthread_create(pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) noexcept(truepthread_create(pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) noexcept(true) __attribute__((nonnull(1, 3)));
    extern void pthread_exit(void *__retval);
    extern int pthread_join(pthread_t __th, void **__thread_return);
    extern int pthread_tryjoin_np(pthread_t __th, void **__thread_return) noexcept(truepthread_tryjoin_np(pthread_t __th, void **__thread_return) noexcept(true);
    extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return, const struct timespec *__abstime);
    extern int pthread_clockjoin_np(pthread_t __th, void **__thread_return, clockid_t __clockid, const struct timespec *__abstime);
    extern int pthread_detach(pthread_t __th) noexcept(truepthread_detach(pthread_t __th) noexcept(true);
    extern pthread_t pthread_self() noexcept(truepthread_self() noexcept(true) __attribute__((const));
    extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) noexcept(truepthread_equal(pthread_t __thread1, pthread_t __thread2) noexcept(true) __attribute__((const));
    extern int pthread_attr_init(pthread_attr_t *__attr) noexcept(truepthread_attr_init(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_destroy(pthread_attr_t *__attr) noexcept(truepthread_attr_destroy(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate) noexcept(truepthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate) noexcept(truepthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize) noexcept(truepthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize) noexcept(truepthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) noexcept(truepthread_attr_getschedparam(const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedparam(pthread_attr_t *__restrict __attr, const struct sched_param *__restrict __param) noexcept(truepthread_attr_setschedparam(pthread_attr_t *__restrict __attr, const struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr, int *__restrict __policy) noexcept(truepthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr, int *__restrict __policy) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy) noexcept(truepthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr, int *__restrict __inherit) noexcept(truepthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr, int *__restrict __inherit) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit) noexcept(truepthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getscope(const pthread_attr_t *__restrict __attr, int *__restrict __scope) noexcept(truepthread_attr_getscope(const pthread_attr_t *__restrict __attr, int *__restrict __scope) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope) noexcept(truepthread_attr_setscope(pthread_attr_t *__attr, int __scope) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) noexcept(truepthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) noexcept(true) __attribute__((nonnull(1, 2))) __attribute__((deprecated("")));
    extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr) noexcept(truepthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr) noexcept(true) __attribute__((nonnull(1))) __attribute__((deprecated("")));
    extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) noexcept(truepthread_attr_getstacksize(const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize) noexcept(truepthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_getstack(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, size_t *__restrict __stacksize) noexcept(truepthread_attr_getstack(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, size_t *__restrict __stacksize) noexcept(true) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize) noexcept(truepthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(truepthread_attr_setaffinity_np(pthread_attr_t *__attr, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(truepthread_attr_getaffinity_np(const pthread_attr_t *__attr, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_getattr_default_np(pthread_attr_t *__attr) noexcept(truepthread_getattr_default_np(pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr, const __sigset_t *sigmask);
    extern int pthread_attr_getsigmask_np(const pthread_attr_t *__attr, __sigset_t *sigmask);
    extern int pthread_setattr_default_np(const pthread_attr_t *__attr) noexcept(truepthread_setattr_default_np(const pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_getattr_np(pthread_t __th, pthread_attr_t *__attr) noexcept(truepthread_getattr_np(pthread_t __th, pthread_attr_t *__attr) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param) noexcept(truepthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) noexcept(truepthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) noexcept(true) __attribute__((nonnull(2, 3)));
    extern int pthread_setschedprio(pthread_t __target_thread, int __prio) noexcept(truepthread_setschedprio(pthread_t __target_thread, int __prio) noexcept(true);
    extern int pthread_getname_np(pthread_t __target_thread, char *__buf, size_t __buflen) noexcept(truepthread_getname_np(pthread_t __target_thread, char *__buf, size_t __buflen) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_setname_np(pthread_t __target_thread, const char *__name) noexcept(truepthread_setname_np(pthread_t __target_thread, const char *__name) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_getconcurrency() noexcept(truepthread_getconcurrency() noexcept(true);
    extern int pthread_setconcurrency(int __level) noexcept(truepthread_setconcurrency(int __level) noexcept(true);
    extern int pthread_yield() noexcept(truepthread_yield() noexcept(true);
    extern int pthread_yield() noexcept(truepthread_yield() noexcept(true) asm("sched_yield") __attribute__((deprecated("pthread_yield is deprecated, use sched_yield instead")));
    extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(truepthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(truepthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t *__cpuset) noexcept(true) __attribute__((nonnull(3)));
    extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((nonnull(1, 2)));
    extern int pthread_setcancelstate(int __state, int *__oldstate);
    extern int pthread_setcanceltype(int __type, int *__oldtype);
    extern int pthread_cancel(pthread_t __th);
    extern void pthread_testcancel();
    struct __cancel_jmp_buf_tag {
        __jmp_buf __cancel_jmp_buf;
        int __mask_was_saved;
    };
    typedef struct {
        struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
        void *__pad[4];
    } __pthread_unwind_buf_t __attribute__((aligned));
    struct __pthread_cleanup_frame {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    };
    class __pthread_cleanup_class {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    public:
        __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)         {
        }
        ~__pthread_cleanup_class() noexcept         {
            if (this->__do_it)
                this->__cancel_routine(this->__cancel_arg);
        }
        void __setdoit(int __newval)         {
            this->__do_it = __newval;
        }
        void __defer()         {
            pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &this->__cancel_type);
        }
        void __restore() const         {
            pthread_setcanceltype(this->__cancel_type, 0);
        }
    };
    extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask) noexcept(true__sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask) noexcept(true);
    extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) noexcept(truepthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) noexcept(truepthread_mutex_destroy(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) noexcept(truepthread_mutex_trylock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_lock(pthread_mutex_t *__mutex) noexcept(truepthread_mutex_lock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) noexcept(truepthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_clocklock(pthread_mutex_t *__restrict __mutex, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(truepthread_mutex_clocklock(pthread_mutex_t *__restrict __mutex, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) noexcept(truepthread_mutex_unlock(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) noexcept(truepthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) noexcept(truepthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) noexcept(truepthread_mutex_consistent(pthread_mutex_t *__mutex) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutex_consistent_np(pthread_mutex_t *) noexcept(truepthread_mutex_consistent_np(pthread_mutex_t *) noexcept(true) asm("pthread_mutex_consistent") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")));
    extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) noexcept(truepthread_mutexattr_init(pthread_mutexattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) noexcept(truepthread_mutexattr_destroy(pthread_mutexattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) noexcept(truepthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared) noexcept(truepthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) noexcept(truepthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind) noexcept(truepthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) noexcept(truepthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol) noexcept(truepthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) noexcept(truepthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling) noexcept(truepthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness) noexcept(truepthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_getrobust_np(pthread_mutexattr_t *, int *) noexcept(truepthread_mutexattr_getrobust_np(pthread_mutexattr_t *, int *) noexcept(true) asm("pthread_mutexattr_getrobust") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")));
    extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness) noexcept(truepthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *, int) noexcept(truepthread_mutexattr_setrobust_np(pthread_mutexattr_t *, int) noexcept(true) asm("pthread_mutexattr_setrobust") __attribute__((nonnull(1))) __attribute__((deprecated("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")));
    extern int pthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) noexcept(truepthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) noexcept(truepthread_rwlock_destroy(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) noexcept(truepthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) noexcept(truepthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(truepthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(truepthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) noexcept(truepthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) noexcept(truepthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(truepthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(truepthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) noexcept(true) __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) noexcept(truepthread_rwlock_unlock(pthread_rwlock_t *__rwlock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) noexcept(truepthread_rwlockattr_init(pthread_rwlockattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) noexcept(truepthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) noexcept(truepthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared) noexcept(truepthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) noexcept(truepthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref) noexcept(truepthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_init(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) noexcept(truepthread_cond_init(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_destroy(pthread_cond_t *__cond) noexcept(truepthread_cond_destroy(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_signal(pthread_cond_t *__cond) noexcept(truepthread_cond_signal(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_broadcast(pthread_cond_t *__cond) noexcept(truepthread_cond_broadcast(pthread_cond_t *__cond) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __attribute__((nonnull(1, 2)));
    extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_cond_clockwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, __clockid_t __clock_id, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 4)));
    extern int pthread_condattr_init(pthread_condattr_t *__attr) noexcept(truepthread_condattr_init(pthread_condattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_destroy(pthread_condattr_t *__attr) noexcept(truepthread_condattr_destroy(pthread_condattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) noexcept(truepthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared) noexcept(truepthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) noexcept(truepthread_condattr_getclock(const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id) noexcept(truepthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared) noexcept(truepthread_spin_init(pthread_spinlock_t *__lock, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_destroy(pthread_spinlock_t *__lock) noexcept(truepthread_spin_destroy(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_lock(pthread_spinlock_t *__lock) noexcept(truepthread_spin_lock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_trylock(pthread_spinlock_t *__lock) noexcept(truepthread_spin_trylock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_spin_unlock(pthread_spinlock_t *__lock) noexcept(truepthread_spin_unlock(pthread_spinlock_t *__lock) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) noexcept(truepthread_barrier_init(pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) noexcept(truepthread_barrier_destroy(pthread_barrier_t *__barrier) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrier_wait(pthread_barrier_t *__barrier) noexcept(truepthread_barrier_wait(pthread_barrier_t *__barrier) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr) noexcept(truepthread_barrierattr_init(pthread_barrierattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) noexcept(truepthread_barrierattr_destroy(pthread_barrierattr_t *__attr) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) noexcept(truepthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) noexcept(true) __attribute__((nonnull(1, 2)));
    extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared) noexcept(truepthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *)) noexcept(truepthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *)) noexcept(true) __attribute__((nonnull(1)));
    extern int pthread_key_delete(pthread_key_t __key) noexcept(truepthread_key_delete(pthread_key_t __key) noexcept(true);
    extern void *pthread_getspecific(pthread_key_t __key) noexcept(truepthread_getspecific(pthread_key_t __key) noexcept(true);
    extern int pthread_setspecific(pthread_key_t __key, const void *__pointer) noexcept(truepthread_setspecific(pthread_key_t __key, const void *__pointer) noexcept(true);
    extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id) noexcept(truepthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id) noexcept(true) __attribute__((nonnull(2)));
    extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) noexcept(truepthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) noexcept(true);
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static inline int __gthread_active_p() {
    return 1;
}
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *__args) {
    return pthread_create(__threadid, __null, __func, __args);
}
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) {
    return pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(__gthread_t __threadid) {
    return pthread_detach(__threadid);
}
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) {
    return pthread_equal(__t1, __t2);
}
static inline __gthread_t __gthread_self() {
    return pthread_self();
}
static inline int __gthread_yield() {
    return sched_yield();
}
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)()) {
    if (__gthread_active_p())
        return pthread_once(__once, __func);
    else
        return -1;
}
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) {
    return pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(__gthread_key_t __key) {
    return pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(__gthread_key_t __key) {
    return pthread_getspecific(__key);
}
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) {
    return pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        pthread_mutex_init(__mutex, __null);
}
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_destroy(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_lock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_trylock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    if (__gthread_active_p())
        return pthread_mutex_timedlock(__mutex, __abs_timeout);
    else
        return 0;
}
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return pthread_mutex_unlock(__mutex);
    else
        return 0;
}
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) {
    return pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) {
    return pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) {
    return pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *__mutex) {
    return __gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) {
    return pthread_cond_destroy(__cond);
}
typedef int _Atomic_word;
extern "C" {
    extern char __libc_single_threaded;
}
namespace __gnu_cxx {
    inline bool __is_single_threaded() noexcept __attribute__((always_inline))     {
        return ::__libc_single_threaded;
    }
    inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        return __atomic_fetch_add(__mem, __val, 4);
    }
    inline void __atomic_add(volatile _Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        __atomic_fetch_add(__mem, __val, 4);
    }
    inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        _Atomic_word __result = *__mem;
        *__mem += __val;
        return __result;
    }
    inline void __atomic_add_single(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        *__mem += __val;
    }
    inline _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        if (__is_single_threaded())
            return __exchange_and_add_single(__mem, __val);
        else
            return __exchange_and_add(__mem, __val);
    }
    inline void __atomic_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((always_inline))     {
        if (__is_single_threaded())
            __atomic_add_single(__mem, __val);
        else
            __atomic_add(__mem, __val);
    }
}
namespace std {
    template <typename _Tp> class __new_allocator {
    public:
        typedef _Tp value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator<_Tp>() noexcept         {
        }
        constexpr __new_allocator<_Tp>(const __new_allocator<_Tp> &) noexcept         {
        }
        template <typename _Tp1> constexpr __new_allocator<_Tp>(const __new_allocator<_Tp1> &) noexcept         {
        }
        _Tp *allocate(std::__new_allocator::size_type __n, const void * = static_cast<const void *>(0)) [[nodiscard("")]]         {
            static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(_Tp)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(_Tp) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(_Tp));
                return static_cast<_Tp *>(__builtin_operator_new(__n * sizeof(_Tp), __al));
            }
            return static_cast<_Tp *>(__builtin_operator_new(__n * sizeof(_Tp)));
        }
        void deallocate(_Tp *__p, std::__new_allocator::size_type __n __attribute__((unused)))         {
            if (alignof(_Tp) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(_Tp)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const __new_allocator<_Tp> &, const __new_allocator<_Up> &) noexcept         {
            return true;
        }
;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(_Tp);
        }
    };
template<> class __new_allocator<char> {
    public:
        typedef char value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept         {
        }
        constexpr __new_allocator(const std::__new_allocator<char> &) noexcept         {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> constexpr __new_allocator<char>(const __new_allocator<char> &) noexcept;
        char *allocate(std::__new_allocator::size_type __n, const void *) [[nodiscard("")]]         {
            static_assert(sizeof(char) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(char)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(char) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(char));
                return static_cast<char *>(__builtin_operator_new(__n * sizeof(char), __al));
            }
            return static_cast<char *>(__builtin_operator_new(__n * sizeof(char)));
        }
        void deallocate(char *__p, std::__new_allocator::size_type __n __attribute__((unused)))         {
            if (alignof(char) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const std::__new_allocator<char> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(char);
        }
    };
template<> class __new_allocator<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept         {
        }
        constexpr __new_allocator(const std::__new_allocator<wchar_t> &) noexcept         {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> constexpr __new_allocator<wchar_t>(const __new_allocator<wchar_t> &) noexcept;
        wchar_t *allocate(std::__new_allocator::size_type __n, const void *) [[nodiscard("")]]         {
            static_assert(sizeof(wchar_t) != 0, "cannot allocate incomplete types");
            if (__builtin_expect(__n > this->_M_max_size(), false)) {
                if (__n > (std::size_t(-1) / sizeof(wchar_t)))
                    std::__throw_bad_array_new_length();
                std::__throw_bad_alloc();
            }
            if (alignof(wchar_t) > 16UL) {
                std::align_val_t __al = std::align_val_t(alignof(wchar_t));
                return static_cast<wchar_t *>(__builtin_operator_new(__n * sizeof(wchar_t), __al));
            }
            return static_cast<wchar_t *>(__builtin_operator_new(__n * sizeof(wchar_t)));
        }
        void deallocate(wchar_t *__p, std::__new_allocator::size_type __n __attribute__((unused)))         {
            if (alignof(wchar_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(wchar_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const std::__new_allocator<wchar_t> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(wchar_t);
        }
    };
template<> class __new_allocator<char8_t> {
    public:
        typedef char8_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept         {
        }
        constexpr __new_allocator(const std::__new_allocator<char8_t> &) noexcept         {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> constexpr __new_allocator<char8_t>(const __new_allocator<char8_t> &) noexcept;
        char8_t *allocate(std::__new_allocator::size_type __n, const void *) [[nodiscard("")]];
        void deallocate(char8_t *__p, std::__new_allocator::size_type __n __attribute__((unused)))         {
            if (alignof(char8_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char8_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const std::__new_allocator<char8_t> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept;
    };
template<> class __new_allocator<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept         {
        }
        constexpr __new_allocator(const std::__new_allocator<char16_t> &) noexcept         {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> constexpr __new_allocator<char16_t>(const __new_allocator<char16_t> &) noexcept;
        char16_t *allocate(std::__new_allocator::size_type __n, const void *) [[nodiscard("")]];
        void deallocate(char16_t *__p, std::__new_allocator::size_type __n __attribute__((unused)))         {
            if (alignof(char16_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char16_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const std::__new_allocator<char16_t> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept;
    };
template<> class __new_allocator<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef std::true_type propagate_on_container_move_assignment;
        constexpr __new_allocator() noexcept         {
        }
        constexpr __new_allocator(const std::__new_allocator<char32_t> &) noexcept         {
        }
        template <typename _Tp1> constexpr __new_allocator(const __new_allocator<_Tp1> &) noexcept;
        template<> constexpr __new_allocator<char32_t>(const __new_allocator<char32_t> &) noexcept;
        char32_t *allocate(std::__new_allocator::size_type __n, const void *) [[nodiscard("")]];
        void deallocate(char32_t *__p, std::__new_allocator::size_type __n __attribute__((unused)))         {
            if (alignof(char32_t) > 16UL) {
                __builtin_operator_delete((__p), std::align_val_t(alignof(char32_t)));
                return;
            }
            __builtin_operator_delete((__p));
        }
        friend template <typename _Up> constexpr bool operator==(const std::__new_allocator<char32_t> &, const __new_allocator<_Up> &) noexcept;
    private:
        constexpr std::__new_allocator::size_type _M_max_size() const noexcept;
    };
}
namespace std {
    template <typename _Tp> using __allocator_base = __new_allocator<_Tp>;
}
namespace std {
    template<> class allocator<void> {
    public:
        typedef void value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        allocator() = default
        ~allocator<void>() = default
        template <typename _Up> constexpr allocator(const allocator<_Up> &) noexcept         {
        }
        template<> constexpr allocator<void>(const allocator<void> &) noexcept    };
    template <typename _Tp> class allocator : public __allocator_base<_Tp> {
    public:
        typedef _Tp value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator<type-parameter-0-0>() noexcept         {
        }
        constexpr allocator<type-parameter-0-0>(const allocator<type-parameter-0-0> &__a) noexcept : __allocator_base<_Tp>(__a)         {
        }
        allocator<type-parameter-0-0> &operator=(const allocator<type-parameter-0-0> &) = default
        template <typename _Tp1> constexpr allocator<type-parameter-0-0>(const allocator<_Tp1> &) noexcept         {
        }
        constexpr ~allocator<type-parameter-0-0>() noexcept         {
        }
        constexpr _Tp *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(_Tp), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<_Tp *>(::operator new(__n));
            }
            return __allocator_base<_Tp>::allocate(__n, 0);
        }
        constexpr void deallocate(_Tp *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            __allocator_base<_Tp>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept         {
            return true;
        }
;
    };
template<> class allocator<char8_t> : public __allocator_base<char8_t> {
    public:
        typedef char8_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<char8_t>()         {
        }
        constexpr allocator(const std::allocator<char8_t> &__a) noexcept : __allocator_base<char8_t>(__a)         {
        }
        std::allocator<char8_t> &operator=(const std::allocator<char8_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<char8_t>(const allocator<char8_t> &) noexcept;
        constexpr ~allocator<char8_t>() noexcept         {
        }
        constexpr char8_t *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]];
        constexpr void deallocate(char8_t *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char8_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<char8_t> &, const std::allocator<char8_t> &) noexcept;
    };
template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef char16_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<char16_t>()         {
        }
        constexpr allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a)         {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<char16_t>(const allocator<char16_t> &) noexcept;
        constexpr ~allocator<char16_t>() noexcept         {
        }
        constexpr char16_t *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]];
        constexpr void deallocate(char16_t *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char16_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    };
template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef char32_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<char32_t>()         {
        }
        constexpr allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a)         {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<char32_t>(const allocator<char32_t> &) noexcept;
        constexpr ~allocator<char32_t>() noexcept         {
        }
        constexpr char32_t *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]];
        constexpr void deallocate(char32_t *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char32_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    };
    template <typename _T1, typename _T2> inline constexpr bool operator==(const allocator<_T1> &, const allocator<_T2> &) noexcept     {
        return true;
    }
    template <typename _Tp> class allocator<const _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template <typename _Tp> class allocator<volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<volatile type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template <typename _Tp> class allocator<const volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const volatile type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template<> class allocator<char> : public __allocator_base<char> {
    public:
        typedef char value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<char>()         {
        }
        constexpr allocator(const std::allocator<char> &__a) noexcept : __allocator_base<char>(__a)         {
        }
        std::allocator<char> &operator=(const std::allocator<char> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<char>(const allocator<char> &) noexcept;
        constexpr ~allocator<char>() noexcept         {
        }
        constexpr char *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(char), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<char *>(::operator new(__n));
            }
            return this->__allocator_base<char>::allocate(__n, 0);
        }
        constexpr void deallocate(char *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<char>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<char> &, const std::allocator<char> &) noexcept;
    };
    template<> class allocator<wchar_t> : public __allocator_base<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        using propagate_on_container_move_assignment = std::true_type;
        using is_always_equal __attribute__((deprecated("use 'std::allocator_traits::is_always_equal' instead"))) = std::true_type;
        constexpr allocator() noexcept : __allocator_base<wchar_t>()         {
        }
        constexpr allocator(const std::allocator<wchar_t> &__a) noexcept : __allocator_base<wchar_t>(__a)         {
        }
        std::allocator<wchar_t> &operator=(const std::allocator<wchar_t> &) = default
        template <typename _Tp1> constexpr allocator(const allocator<_Tp1> &) noexcept;
        template<> constexpr allocator<wchar_t>(const allocator<wchar_t> &) noexcept;
        constexpr ~allocator<wchar_t>() noexcept         {
        }
        constexpr wchar_t *allocate(std::size_t __n) [[nodiscard("")]] [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                if (__builtin_mul_overflow(__n, sizeof(wchar_t), &__n))
                    std::__throw_bad_array_new_length();
                return static_cast<wchar_t *>(::operator new(__n));
            }
            return this->__allocator_base<wchar_t>::allocate(__n, 0);
        }
        constexpr void deallocate(wchar_t *__p, std::size_t __n) [[gnu::always_inline]]         {
            if (std::__is_constant_evaluated()) {
                ::operator delete(__p);
                return;
            }
            this->__allocator_base<wchar_t>::deallocate(__p, __n);
        }
        friend constexpr bool operator==(const std::allocator<wchar_t> &, const std::allocator<wchar_t> &) noexcept;
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
        static void _S_do_it(_Alloc &, _Alloc &) noexcept         {
        }
    };
    template <typename _Alloc> struct __alloc_swap<_Alloc, false> {
        static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept         {
            if (__one != __two)
                swap(__one, __two);
        }
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_neq {
        static bool _S_do_it(const _Alloc &, const _Alloc &)         {
            return false;
        }
    };
    template <typename _Alloc> struct __alloc_neq<_Alloc, false> {
        static bool _S_do_it(const _Alloc &__one, const _Alloc &__two)         {
            return __one != __two;
        }
    };
    template <typename _Tp, bool = __or_<is_copy_constructible<typename _Tp::value_type>, is_nothrow_move_constructible<typename _Tp::value_type>>::value> struct __shrink_to_fit_aux {
        static bool _S_do_it(_Tp &) noexcept         {
            return false;
        }
    };
    template <typename _Tp> struct __shrink_to_fit_aux<_Tp, true> {
        static constexpr bool _S_do_it(_Tp &__c) noexcept         {
            try {
                _Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c);
                return true;
            } catch (...) {
                return false;
            }
        }
    };
}
namespace std {
    template <typename _Arg, typename _Result> struct __attribute__((deprecated(""))) unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <typename _Arg1, typename _Arg2, typename _Result> struct __attribute__((deprecated(""))) binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
template<> struct __attribute__((deprecated(""))) __attribute__((deprecated(""))) binary_function<const volatile void *, const volatile void *, bool> {
        typedef const volatile void *first_argument_type;
        typedef const volatile void *second_argument_type;
        typedef bool result_type;
    };
template<> struct __attribute__((deprecated(""))) __attribute__((deprecated(""))) binary_function<const char *, const char *, bool> {
        typedef const char *first_argument_type;
        typedef const char *second_argument_type;
        typedef bool result_type;
    };
    struct __is_transparent;
    template <typename _Tp = void> struct plus;
    template <typename _Tp = void> struct minus;
    template <typename _Tp = void> struct multiplies;
    template <typename _Tp = void> struct divides;
    template <typename _Tp = void> struct modulus;
    template <typename _Tp = void> struct negate;
    template <typename _Tp = void> struct plus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x + __y;
        }
    };
    template <typename _Tp = void> struct minus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x - __y;
        }
    };
    template <typename _Tp = void> struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x * __y;
        }
    };
    template <typename _Tp = void> struct divides : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x / __y;
        }
    };
    template <typename _Tp = void> struct modulus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x % __y;
        }
    };
    template <typename _Tp = void> struct negate : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const         {
            return - __x;
        }
    };
    template<> struct plus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct minus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct multiplies<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct divides<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct modulus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct negate<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))) -> decltype(- std::forward<_Tp>(__t))         {
            return - std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct equal_to;
    template <typename _Tp = void> struct not_equal_to;
    template <typename _Tp = void> struct greater
template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less
template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    }
template<> struct less<const char *> : public binary_function<const char *, const char *, bool> {
        constexpr bool operator()(const char *__x, const char *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal
template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal
template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x == __y;
        }
    };
    template <typename _Tp = void> struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x != __y;
        }
    };
    template <typename _Tp = void> struct greater : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x > __y;
        }
    };
template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x < __y;
        }
    };
template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
template<> struct less<const char *> : public binary_function<const char *, const char *, bool> {
        constexpr bool operator()(const char *__x, const char *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x >= __y;
        }
    };
template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x <= __y;
        }
    };
template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (std::__is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template<> struct equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct not_equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct greater<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return greater<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return greater<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return less<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return less<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct greater_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return greater_equal<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return greater_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template<> struct less_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return less_equal<common_type_t<_Tp *, _Up *>>({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return less_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *>>;
    };
    template <typename _Tp = void> struct logical_and;
    template <typename _Tp = void> struct logical_or;
    template <typename _Tp = void> struct logical_not;
    template <typename _Tp = void> struct logical_and : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x && __y;
        }
    };
    template <typename _Tp = void> struct logical_or : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x || __y;
        }
    };
    template <typename _Tp = void> struct logical_not : public unary_function<_Tp, bool> {
        constexpr bool operator()(const _Tp &__x) const         {
            return !__x;
        }
    };
    template<> struct logical_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))) -> decltype(!std::forward<_Tp>(__t))         {
            return !std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct bit_and;
    template <typename _Tp = void> struct bit_or;
    template <typename _Tp = void> struct bit_xor;
    template <typename _Tp = void> struct bit_not;
    template <typename _Tp = void> struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x & __y;
        }
    };
    template <typename _Tp = void> struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x | __y;
        }
    };
    template <typename _Tp = void> struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x ^ __y;
        }
    };
    template <typename _Tp = void> struct bit_not : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const         {
            return ~__x;
        }
    };
    template<> struct bit_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_xor<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))) -> decltype(~std::forward<_Tp>(__t))         {
            return ~std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Predicate> class [[deprecated("")]] unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit unary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }
        constexpr bool operator()(const typename _Predicate::argument_type &__x) const         {
            return !this->_M_pred(__x);
        }
    };
    template <typename _Predicate> inline constexpr unary_negate<_Predicate> not1(const _Predicate &__pred) __attribute__((deprecated("use 'std::not_fn' instead")))     {
        return unary_negate<_Predicate>(__pred);
    }
    template <typename _Predicate> class [[deprecated("")]] binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit binary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }
        constexpr bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const         {
            return !this->_M_pred(__x, __y);
        }
    };
    template <typename _Predicate> inline constexpr binary_negate<_Predicate> not2(const _Predicate &__pred) __attribute__((deprecated("use 'std::not_fn' instead")))     {
        return binary_negate<_Predicate>(__pred);
    }
    template <typename _Arg, typename _Result> class __attribute__((deprecated(""))) pointer_to_unary_function : public unary_function<_Arg, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg);
    public:
        pointer_to_unary_function<_Arg, _Result>()         {
        }
        explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__x)(_Arg)) : _M_ptr(__x)         {
        }
        _Result operator()(_Arg __x) const         {
            return this->_M_ptr(__x);
        }
    };
    template <typename _Arg, typename _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg)) __attribute__((deprecated("use 'std::function' instead")))     {
        return pointer_to_unary_function<_Arg, _Result>(__x);
    }
    template <typename _Arg1, typename _Arg2, typename _Result> class __attribute__((deprecated(""))) pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
        pointer_to_binary_function<_Arg1, _Arg2, _Result>()         {
        }
        explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x)         {
        }
        _Result operator()(_Arg1 __x, _Arg2 __y) const         {
            return this->_M_ptr(__x, __y);
        }
    };
    template <typename _Arg1, typename _Arg2, typename _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2)) __attribute__((deprecated("use 'std::function' instead")))     {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
    }
    template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
        _Tp &operator()(_Tp &__x) const         {
            return __x;
        }
        const _Tp &operator()(const _Tp &__x) const         {
            return __x;
        }
    };
    template <typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> {
    };
    template <typename _Pair> struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
        typename _Pair::first_type &operator()(_Pair &__x) const         {
            return __x.first;
        }
        const typename _Pair::first_type &operator()(const _Pair &__x) const         {
            return __x.first;
        }
        template <typename _Pair2> typename _Pair2::first_type &operator()(_Pair2 &__x) const         {
            return __x.first;
        }
        template <typename _Pair2> const typename _Pair2::first_type &operator()(const _Pair2 &__x) const         {
            return __x.first;
        }
    };
    template <typename _Pair> struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
        typename _Pair::second_type &operator()(_Pair &__x) const         {
            return __x.second;
        }
        const typename _Pair::second_type &operator()(const _Pair &__x) const         {
            return __x.second;
        }
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) mem_fun_t : public unary_function<_Tp *, _Ret> {
    public:
        explicit mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
    public:
        explicit const_mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp &__r) const         {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class __attribute__((deprecated(""))) const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit const_mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp &__r) const         {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
    public:
        explicit mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class __attribute__((deprecated(""))) const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp> inline mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)()) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return const_mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)()) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return const_mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg)) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) __attribute__((deprecated("use 'std::mem_fn' instead")))     {
        return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Func, typename _SfinaeType, typename = __void_t<>> struct __has_is_transparent {
    };
    template <typename _Func, typename _SfinaeType> struct __has_is_transparent<_Func, _SfinaeType, __void_t<typename _Func::is_transparent>> {
        typedef void type;
    };
    template <typename _Func, typename _SfinaeType> using __has_is_transparent_t = typename __has_is_transparent<_Func, _SfinaeType>::type;
}
namespace std {
    template <typename _Operation> class __attribute__((deprecated("use 'std::bind' instead"))) binder1st : public unary_function<typename _Operation::second_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::first_argument_type value;
    public:
        binder1st<_Operation>(const _Operation &__x, const typename _Operation::first_argument_type &__y) : op(__x), value(__y)         {
        }
        typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }
        typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }
    };
    template <typename _Operation, typename _Tp> inline binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x) __attribute__((deprecated("use 'std::bind' instead")))     {
        typedef typename _Operation::first_argument_type _Arg1_type;
        return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
    template <typename _Operation> class __attribute__((deprecated("use 'std::bind' instead"))) binder2nd : public unary_function<typename _Operation::first_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::second_argument_type value;
    public:
        binder2nd<_Operation>(const _Operation &__x, const typename _Operation::second_argument_type &__y) : op(__x), value(__y)         {
        }
        typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }
        typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }
    };
    template <typename _Operation, typename _Tp> inline binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x) __attribute__((deprecated("use 'std::bind' instead")))     {
        typedef typename _Operation::second_argument_type _Arg2_type;
        return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
}
namespace std {
    template <typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type> constexpr _Up &&__invfwd(typename remove_reference<_Tp>::type &__t) noexcept     {
        return static_cast<_Up &&>(__t);
    }
    template <typename _Res, typename _Fn, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_other, _Fn &&__f, _Args &&...__args)     {
        return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_memfun_ref, _MemFun &&__f, _Tp &&__t, _Args &&...__args)     {
        return (__invfwd<_Tp>(__t) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemFun, typename _Tp, typename ..._Args> constexpr _Res __invoke_impl(std::__invoke_memfun_deref, _MemFun &&__f, _Tp &&__t, _Args &&...__args)     {
        return ((*std::forward<_Tp>(__t)) .* __f)(std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(std::__invoke_memobj_ref, _MemPtr &&__f, _Tp &&__t)     {
        return __invfwd<_Tp>(__t) .* __f;
    }
    template <typename _Res, typename _MemPtr, typename _Tp> constexpr _Res __invoke_impl(std::__invoke_memobj_deref, _MemPtr &&__f, _Tp &&__t)     {
        return (*std::forward<_Tp>(__t)) .* __f;
    }
    template <typename _Callable, typename ..._Args> constexpr typename __invoke_result<_Callable, _Args...>::type __invoke(_Callable &&__fn, _Args &&...__args) noexcept(__is_nothrow_invocable<_Callable, _Args...>::value__invoke(_Callable &&__fn, _Args &&...__args) noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)     {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        return std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
    template <typename _Res, typename _Callable, typename ..._Args> constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res> __invoke_r(_Callable &&__fn, _Args &&...__args) noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>__invoke_r(_Callable &&__fn, _Args &&...__args) noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)     {
        using __result = __invoke_result<_Callable, _Args...>;
        using __type = typename __result::type;
        using __tag = typename __result::__invoke_type;
        if (is_void_v<_Res>)
            std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
        else
            return std::__invoke_impl<__type>(__tag({}), std::forward<_Callable>(__fn), std::forward<_Args>(__args)...);
    }
}
namespace std {
    template <typename _Res, typename ..._ArgTypes> struct _Maybe_unary_or_binary_function {
    };
    template <typename _Res, typename _T1> struct _Maybe_unary_or_binary_function<_Res, _T1> : std::unary_function<_T1, _Res> {
    };
    template <typename _Res, typename _T1, typename _T2> struct _Maybe_unary_or_binary_function<_Res, _T1, _T2> : std::binary_function<_T1, _T2, _Res> {
    };
    template <typename _Signature> struct _Mem_fn_traits;
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits_base {
        using __result_type = _Res;
        using __maybe_type = _Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes...>;
        using __arity = integral_constant<std::size_t, sizeof...(_ArgTypes)>;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...)> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::false_type;
    };
    template <typename _Res, typename _Class, typename ..._ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes..., ...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
        using __vararg = std::true_type;
    };
    template <typename _Functor, typename = __void_t<>> struct _Maybe_get_result_type {
    };
    template <typename _Functor> struct _Maybe_get_result_type<_Functor, __void_t<typename _Functor::result_type>> {
        typedef typename _Functor::result_type result_type;
    };
    template <typename _Functor> struct _Weak_result_type_impl : _Maybe_get_result_type<_Functor> {
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (_ArgTypes...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (_ArgTypes..., ...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (*)(_ArgTypes...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Res, typename ..._ArgTypes, bool _NE> struct _Weak_result_type_impl<_Res (*)(_ArgTypes..., ...) noexcept(_NE)> {
        typedef _Res result_type;
    };
    template <typename _Functor, bool = is_member_function_pointer<_Functor>::value> struct _Weak_result_type_memfun : _Weak_result_type_impl<_Functor> {
    };
    template <typename _MemFunPtr> struct _Weak_result_type_memfun<_MemFunPtr, true> {
        using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };
    template <typename _Func, typename _Class> struct _Weak_result_type_memfun<_Func _Class::*, false> {
    };
    template <typename _Functor> struct _Weak_result_type : _Weak_result_type_memfun<typename remove_cv<_Functor>::type> {
    };
    template <typename _Tp> class reference_wrapper {
        _Tp *_M_data;
        static constexpr _Tp *_S_fun(_Tp &__r) noexcept         {
            return std::__addressof(__r);
        }
        static void _S_fun(_Tp &&) = delete
        template <typename _Up, typename _Up2 = __remove_cvref_t<_Up>> using __not_same = typename enable_if<!is_same<reference_wrapper<_Tp>, _Up2>::value>::type;
    public:
        typedef _Tp type;
        template <typename _Up, typename = __not_same<_Up>, typename = decltype(reference_wrapper<_Tp>::_S_fun(std::declval<_Up>()))> constexpr reference_wrapper<_Tp>(_Up &&__uref) noexcept(noexcept(reference_wrapper<_Tp>::_S_fun(std::declval<_Up>()))reference_wrapper<_Tp>(_Up &&__uref) noexcept(noexcept(reference_wrapper<_Tp>::_S_fun(std::declval<_Up>()))) : _M_data(reference_wrapper<_Tp>::_S_fun(std::forward<_Up>(__uref)))         {
        }
        reference_wrapper<_Tp>(const reference_wrapper<_Tp> &) = default
        reference_wrapper<_Tp> &operator=(const reference_wrapper<_Tp> &) = default
        constexpr operator _Tp &() const noexcept         {
            return this->get();
        }
        constexpr _Tp &get() const noexcept         {
            return *this->_M_data;
        }
        template <typename ..._Args> constexpr typename result_of<_Tp &(_Args &&...)>::type operator()(_Args &&...__args) const         {
            if (is_object_v<std::reference_wrapper::type>)
                static_assert(sizeof(std::reference_wrapper::type), "type must be complete");
            return std::__invoke(this->get(), std::forward<_Args>(__args)...);
        }
    };
    template <typename _Tp> reference_wrapper(_Tp &) -> reference_wrapper<_Tp>;
    template <typename _Tp> inline constexpr reference_wrapper<_Tp> ref(_Tp &__t) noexcept     {
        return reference_wrapper<_Tp>(__t);
    }
    template <typename _Tp> inline constexpr reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept     {
        return reference_wrapper<const _Tp>(__t);
    }
    template <typename _Tp> void ref(const _Tp &&) = delete
    template <typename _Tp> void cref(const _Tp &&) = delete
    template <typename _Tp> inline constexpr reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) noexcept     {
        return __t;
    }
    template <typename _Tp> inline constexpr reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t) noexcept     {
        return {__t.get()};
    }
}
namespace std {
    struct __allocator_traits_base {
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other>> {
            using type = typename _Tp::template rebind<_Up>::other;
        };
    protected:
        template <typename _Tp> using __pointer = typename _Tp::pointer;
        template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;
        template <typename _Tp> using __v_pointer = typename _Tp::void_pointer;
        template <typename _Tp> using __cv_pointer = typename _Tp::const_void_pointer;
        template <typename _Tp> using __pocca = typename _Tp::propagate_on_container_copy_assignment;
        template <typename _Tp> using __pocma = typename _Tp::propagate_on_container_move_assignment;
        template <typename _Tp> using __pocs = typename _Tp::propagate_on_container_swap;
        template <typename _Tp> using __equal = typename _Tp::is_always_equal;
    };
    template <typename _Alloc, typename _Up> using __alloc_rebind = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
    template <typename _Alloc> struct allocator_traits : std::__allocator_traits_base {
        typedef _Alloc allocator_type;
        typedef typename _Alloc::value_type value_type;
        using pointer = __detected_or_t<std::allocator_traits::value_type *, __pointer, _Alloc>;
    private:
        template <template <typename> class _Func, typename _Tp, typename = void> struct _Ptr {
            using type = typename pointer_traits<pointer>::template rebind<_Tp>;
        };
        template <template <typename> class _Func, typename _Tp> struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>> {
            using type = _Func<_Alloc>;
        };
        template <typename _A2, typename _PtrT, typename = void> struct _Diff {
            using type = typename pointer_traits<_PtrT>::difference_type;
        };
        template <typename _A2, typename _PtrT> struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>> {
            using type = typename _A2::difference_type;
        };
        template <typename _A2, typename _DiffT, typename = void> struct _Size : make_unsigned<_DiffT> {
        };
        template <typename _A2, typename _DiffT> struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
            using type = typename _A2::size_type;
        };
    public:
        using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
        using void_pointer = typename _Ptr<__v_pointer, void>::type;
        using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
        using difference_type = typename _Diff<_Alloc, pointer>::type;
        using size_type = typename _Size<_Alloc, difference_type>::type;
        using propagate_on_container_copy_assignment = __detected_or_t<std::false_type, __pocca, _Alloc>;
        using propagate_on_container_move_assignment = __detected_or_t<std::false_type, __pocma, _Alloc>;
        using propagate_on_container_swap = __detected_or_t<std::false_type, __pocs, _Alloc>;
        using is_always_equal = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;
        template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
        template <typename _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
    private:
        template <typename _Alloc2> static constexpr auto _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint, int) -> decltype(__a.allocate(__n, __hint))         {
            return __a.allocate(__n, __hint);
        }
        template <typename _Alloc2> static constexpr std::allocator_traits::pointer _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer, ...)         {
            return __a.allocate(__n);
        }
        template <typename _Tp, typename ..._Args> struct __construct_helper {
            template <typename _Alloc2, typename = decltype(std::declval<_Alloc2 *>()->construct(std::declval<_Tp *>(), std::declval<_Args>()...))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
            using type = decltype(__test<_Alloc>(0));
        };
        template <typename _Tp, typename ..._Args> using __has_construct = typename __construct_helper<_Tp, _Args...>::type;
        template <typename _Tp, typename ..._Args> static constexpr _Require<__has_construct<_Tp, _Args...>> _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...))_S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))         {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp, typename ..._Args> static constexpr _Require<__and_<__not_<__has_construct<_Tp, _Args...>>, is_constructible<_Tp, _Args...>>> _S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value_S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)         {
            std::construct_at(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Alloc2, typename _Tp> static constexpr auto _S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))_S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))) -> decltype(__a.destroy(__p))         {
            __a.destroy(__p);
        }
        template <typename _Alloc2, typename _Tp> static constexpr void _S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(std::is_nothrow_destructible<_Tp>::value_S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(std::is_nothrow_destructible<_Tp>::value)         {
            std::_Destroy(__p);
        }
        template <typename _Alloc2> static constexpr auto _S_max_size(_Alloc2 &__a, int) -> decltype(__a.max_size())         {
            return __a.max_size();
        }
        template <typename _Alloc2> static constexpr std::allocator_traits::size_type _S_max_size(_Alloc2 &, ...)         {
            return __gnu_cxx::__numeric_traits<size_type>::__max / sizeof(std::allocator_traits::value_type);
        }
        template <typename _Alloc2> static constexpr auto _S_select(_Alloc2 &__a, int) -> decltype(__a.select_on_container_copy_construction())         {
            return __a.select_on_container_copy_construction();
        }
        template <typename _Alloc2> static constexpr _Alloc2 _S_select(_Alloc2 &__a, ...)         {
            return __a;
        }
    public:
        static constexpr std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static constexpr std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint) [[nodiscard("")]]         {
            return _S_allocate(__a, __n, __hint, 0);
        }
        static constexpr void deallocate(_Alloc &__a, std::allocator_traits::pointer __p, std::allocator_traits::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Tp, typename ..._Args> static constexpr auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))) -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))         {
            _S_construct(__a, __p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp> static constexpr void destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0)))         {
            _S_destroy(__a, __p, 0);
        }
        static constexpr std::allocator_traits::size_type max_size(const _Alloc &__a) noexcept         {
            return _S_max_size(__a, 0);
        }
        static constexpr _Alloc select_on_container_copy_construction(const _Alloc &__rhs)         {
            return _S_select(__rhs, 0);
        }
    };
template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static constexpr std::allocator_traits<std::allocator<char>>::pointer allocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char>>::allocator_type &__a, std::allocator_traits<std::allocator<char>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char>>::size_type max_size(const std::allocator_traits<std::allocator<char>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return std::size_t(-1) / sizeof(std::allocator_traits<std::allocator<char>>::value_type);
        }
        static constexpr std::allocator_traits<std::allocator<char>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char>>::allocator_type &__rhs)         {
            return __rhs;
        }
    };
template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::pointer allocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a, std::allocator_traits<std::allocator<wchar_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::size_type max_size(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return std::size_t(-1) / sizeof(std::allocator_traits<std::allocator<wchar_t>>::value_type);
        }
        static constexpr std::allocator_traits<std::allocator<wchar_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<wchar_t>>::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<char8_t>> {
        using allocator_type = allocator<char8_t>;
        using value_type = char8_t;
        using pointer = char8_t *;
        using const_pointer = const char8_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char8_t>>::pointer allocate(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static constexpr std::allocator_traits<std::allocator<char8_t>>::pointer allocate(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char8_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char8_t>>::size_type max_size(const std::allocator_traits<std::allocator<char8_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static constexpr std::allocator_traits<std::allocator<char8_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char8_t>>::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static constexpr std::allocator_traits<std::allocator<char16_t>>::pointer allocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char16_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char16_t>>::size_type max_size(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static constexpr std::allocator_traits<std::allocator<char16_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char16_t>>::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]];
        static constexpr std::allocator_traits<std::allocator<char32_t>>::pointer allocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]];
        static constexpr void deallocate(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a, std::allocator_traits<std::allocator<char32_t>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args);
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused)), _Up *__p);
        static constexpr std::allocator_traits<std::allocator<char32_t>>::size_type max_size(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__a __attribute__((unused))) noexcept;
        static constexpr std::allocator_traits<std::allocator<char32_t>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char32_t>>::allocator_type &__rhs);
    };
    template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
        using allocator_type = allocator<_Tp>;
        using value_type = _Tp;
        using pointer = _Tp *;
        using const_pointer = const _Tp *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static constexpr std::allocator_traits<allocator<type-parameter-0-0>>::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static constexpr std::allocator_traits<allocator<type-parameter-0-0>>::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n, std::allocator_traits<allocator<type-parameter-0-0>>::const_void_pointer __hint) [[nodiscard("")]]         {
            return __a.allocate(__n);
        }
        static constexpr void deallocate(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0>>::pointer __p, std::allocator_traits<allocator<type-parameter-0-0>>::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::valueconstruct(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)         {
            std::construct_at(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static constexpr void destroy(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p) noexcept(is_nothrow_destructible<_Up>::valuedestroy(std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused)), _Up *__p) noexcept(is_nothrow_destructible<_Up>::value)         {
            std::destroy_at(__p);
        }
        static constexpr std::allocator_traits<allocator<type-parameter-0-0>>::size_type max_size(const std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__a __attribute__((unused))) noexcept         {
            return std::size_t(-1) / sizeof(std::allocator_traits<allocator<type-parameter-0-0>>::value_type);
        }
        static constexpr std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<allocator<type-parameter-0-0>>::allocator_type &__rhs)         {
            return __rhs;
        }
    };
    template<> struct allocator_traits<allocator<void>> {
        using allocator_type = allocator<void>;
        using value_type = void;
        using pointer = void *;
        using const_pointer = const void *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up>>;
        static void *allocate(std::allocator_traits<std::allocator<void>>::allocator_type &, std::allocator_traits<std::allocator<void>>::size_type, const void * = nullptr) = delete
        static void deallocate(std::allocator_traits<std::allocator<void>>::allocator_type &, void *, std::allocator_traits<std::allocator<void>>::size_type) = delete
        template <typename _Up, typename ..._Args> static constexpr void construct(std::allocator_traits<std::allocator<void>>::allocator_type &, _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::valueconstruct(std::allocator_traits<std::allocator<void>>::allocator_type &, _Up *__p, _Args &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)         {
            std::_Construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static constexpr void destroy(std::allocator_traits<std::allocator<void>>::allocator_type &, _Up *__p) noexcept(is_nothrow_destructible<_Up>::valuedestroy(std::allocator_traits<std::allocator<void>>::allocator_type &, _Up *__p) noexcept(is_nothrow_destructible<_Up>::value)         {
            std::_Destroy(__p);
        }
        static std::allocator_traits<std::allocator<void>>::size_type max_size(const std::allocator_traits<std::allocator<void>>::allocator_type &) = delete
        static constexpr std::allocator_traits<std::allocator<void>>::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<void>>::allocator_type &__rhs)         {
            return __rhs;
        }
    };
    template <typename _Alloc> inline constexpr void __alloc_on_copy(_Alloc &__one, const _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_copy_assignment __pocca;
        if (__pocca::value)
            __one = __two;
    }
    template <typename _Alloc> constexpr _Alloc __alloc_on_copy(const _Alloc &__a)     {
        typedef allocator_traits<_Alloc> __traits;
        return __traits::select_on_container_copy_construction(__a);
    }
    template <typename _Alloc> inline constexpr void __alloc_on_move(_Alloc &__one, _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_move_assignment __pocma;
        if (__pocma::value)
            __one = std::move(__two);
    }
    template <typename _Alloc> inline constexpr void __alloc_on_swap(_Alloc &__one, _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_swap __pocs;
        if (__pocs::value) {
            using std::swap;
            swap(__one, __two);
        }
    }
    template <typename _Alloc, typename _Tp, typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>, typename = void> struct __is_alloc_insertable_impl : std::false_type {
    };
    template <typename _Alloc, typename _Tp, typename _ValueT> struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, __void_t<decltype(allocator_traits<_Alloc>::construct(std::declval<_Alloc &>(), std::declval<_ValueT *>(), std::declval<_Tp>()))>> : std::true_type {
    };
    template <typename _Alloc> struct __is_copy_insertable : __is_alloc_insertable_impl<_Alloc, const typename _Alloc::value_type &>::type {
    };
    template <typename _Tp> struct __is_copy_insertable<allocator<_Tp>> : is_copy_constructible<_Tp> {
    };
    template <typename _Alloc> struct __is_move_insertable : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type {
    };
    template <typename _Tp> struct __is_move_insertable<allocator<_Tp>> : is_move_constructible<_Tp> {
    };
    template <typename _Alloc, typename = void> struct __is_allocator : std::false_type {
    };
template<> struct __is_allocator<std::allocator<char>, void> : std::true_type {
    };
template<> struct __is_allocator<std::allocator<wchar_t>, void> : std::true_type {
    };
template<> struct __is_allocator<std::allocator<char8_t>, void> : std::true_type {
    };
template<> struct __is_allocator<std::allocator<char16_t>, void> : std::true_type {
    };
template<> struct __is_allocator<std::allocator<char32_t>, void> : std::true_type {
    };
    template <typename _Alloc> struct __is_allocator<_Alloc, __void_t<typename _Alloc::value_type, decltype(std::declval<_Alloc &>().allocate(std::size_t{}))>> : std::true_type {
    };
    template <typename _Alloc> using _RequireAllocator = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _Alloc> using _RequireNotAllocator = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _Alloc> concept __allocator_like = requires (_Alloc &__a) { typename _Alloc::value_type; __a.deallocate(__a.allocate(1U), 1U); };;
    template <typename _ForwardIterator, typename _Allocator> constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)     {
        for (; __first != __last; ++__first)
            allocator_traits<_Allocator>::destroy(__alloc, std::__addressof(*__first));
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &)     {
        _Destroy(__first, __last);
    }
}
namespace __gnu_cxx {
    template <typename _Alloc, typename = typename _Alloc::value_type> struct __alloc_traits : std::allocator_traits<_Alloc> {
        typedef _Alloc allocator_type;
        typedef std::allocator_traits<_Alloc> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...))construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...)))         {
            _Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...);
        }
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p)))destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))         {
            _Base_type::destroy(__a, std::__to_address(__p));
        }
        static constexpr _Alloc _S_select_on_copy(const _Alloc &__a)         {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(_Alloc &__a, _Alloc &__b)         {
            std::__alloc_on_swap(__a, __b);
        }
        static constexpr bool _S_propagate_on_copy_assign()         {
            return _Base_type::propagate_on_container_copy_assignment::value;
        }
        static constexpr bool _S_propagate_on_move_assign()         {
            return _Base_type::propagate_on_container_move_assignment::value;
        }
        static constexpr bool _S_propagate_on_swap()         {
            return _Base_type::propagate_on_container_swap::value;
        }
        static constexpr bool _S_always_equal()         {
            return _Base_type::is_always_equal::value;
        }
        static constexpr bool _S_nothrow_move()         {
            return _S_propagate_on_move_assign() || _S_always_equal();
        }
        template <typename _Tp> struct rebind {
            typedef typename _Base_type::template rebind_alloc<_Tp> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char>, char> : std::allocator_traits<allocator<char>> {
        typedef std::allocator<char> allocator_type;
        typedef std::allocator_traits<allocator<char>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char> &__a, _Ptr __p);
        static constexpr std::allocator<char> _S_select_on_copy(const std::allocator<char> &__a)         {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static constexpr void _S_on_swap(std::allocator<char> &__a, std::allocator<char> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char> {
            typedef typename _Base_type::rebind_alloc<char> other;
        };
    };
template<> struct __alloc_traits<std::allocator<wchar_t>, wchar_t> : std::allocator_traits<allocator<wchar_t>> {
        typedef std::allocator<wchar_t> allocator_type;
        typedef std::allocator_traits<allocator<wchar_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<wchar_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<wchar_t> &__a, _Ptr __p);
        static constexpr std::allocator<wchar_t> _S_select_on_copy(const std::allocator<wchar_t> &__a);
        static constexpr void _S_on_swap(std::allocator<wchar_t> &__a, std::allocator<wchar_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<wchar_t> {
            typedef typename _Base_type::rebind_alloc<wchar_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char8_t>, char8_t> : std::allocator_traits<allocator<char8_t>> {
        typedef std::allocator<char8_t> allocator_type;
        typedef std::allocator_traits<allocator<char8_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char8_t>, char8_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char8_t>, char8_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char8_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char8_t> &__a, _Ptr __p);
        static constexpr std::allocator<char8_t> _S_select_on_copy(const std::allocator<char8_t> &__a);
        static constexpr void _S_on_swap(std::allocator<char8_t> &__a, std::allocator<char8_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char8_t> {
            typedef typename _Base_type::rebind_alloc<char8_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char16_t>, char16_t> : std::allocator_traits<allocator<char16_t>> {
        typedef std::allocator<char16_t> allocator_type;
        typedef std::allocator_traits<allocator<char16_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char16_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char16_t> &__a, _Ptr __p);
        static constexpr std::allocator<char16_t> _S_select_on_copy(const std::allocator<char16_t> &__a);
        static constexpr void _S_on_swap(std::allocator<char16_t> &__a, std::allocator<char16_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char16_t> {
            typedef typename _Base_type::rebind_alloc<char16_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char32_t>, char32_t> : std::allocator_traits<allocator<char32_t>> {
        typedef std::allocator<char32_t> allocator_type;
        typedef std::allocator_traits<allocator<char32_t>> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr>>>;
    public:
        template <typename _Ptr, typename ..._Args> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> construct(std::allocator<char32_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value> destroy(std::allocator<char32_t> &__a, _Ptr __p);
        static constexpr std::allocator<char32_t> _S_select_on_copy(const std::allocator<char32_t> &__a);
        static constexpr void _S_on_swap(std::allocator<char32_t> &__a, std::allocator<char32_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char32_t> {
            typedef typename _Base_type::rebind_alloc<char32_t> other;
        };
    };
}
namespace std {
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
                typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Base;
                static constexpr typename _Base::pointer allocate(std::__cxx11::basic_string::_Char_alloc_type &__a, typename _Base::size_type __n) [[gnu::always_inline]]                 {
                    std::__cxx11::basic_string::pointer __p = _Base::allocate(__a, __n);
                    if (std::is_constant_evaluated())
                        for (std::__cxx11::basic_string::size_type __i = 0; __i < __n; ++__i)
                            std::construct_at(__builtin_addressof(__p[__i]));
                    return __p;
                }
            };
            template <typename _Dummy_for_PR85282> struct _Alloc_traits_impl<char_traits<_CharT>, _Dummy_for_PR85282> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<_Traits, void>;
        public:
            typedef _Traits traits_type;
            typedef typename _Traits::char_type value_type;
            typedef std::__cxx11::basic_string::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string::size_type npos = static_cast<std::__cxx11::basic_string::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string::const_iterator __const_iterator;
        private:
            typedef basic_string_view<_CharT, _Traits> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<_CharT, _Traits, _Alloc> *>>, __not_<is_convertible<const _Tp &, const _CharT *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string::__sv_type _S_to_string_view(std::__cxx11::basic_string::__sv_type __svt) noexcept             {
                return __svt;
            }
            struct __sv_wrapper {
                constexpr explicit __sv_wrapper(std::__cxx11::basic_string::__sv_type __sv) noexcept : _M_sv(__sv)                 {
                }
                std::__cxx11::basic_string::__sv_type _M_sv;
            };
            constexpr explicit basic_string<_CharT, _Traits, _Alloc>(std::__cxx11::basic_string::__sv_wrapper __svw, const _Alloc &__a) : basic_string<_CharT, _Traits, _Alloc>(__svw._M_sv.data(), __svw._M_sv.size(), __a)             {
            }
            struct _Alloc_hider : std::__cxx11::basic_string::allocator_type {
                constexpr _Alloc_hider(std::__cxx11::basic_string::pointer __dat, const _Alloc &__a) : std::__cxx11::basic_string::allocator_type(__a), _M_p(__dat)                 {
                }
                constexpr _Alloc_hider(std::__cxx11::basic_string::pointer __dat, _Alloc &&__a = _Alloc()) : std::__cxx11::basic_string::allocator_type(std::move(__a)), _M_p(__dat)                 {
                }
                std::__cxx11::basic_string::pointer _M_p;
            };
            std::__cxx11::basic_string::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(_CharT)
            };
            union {
                _CharT _M_local_buf[_S_local_capacity + 1];
                std::__cxx11::basic_string::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(std::__cxx11::basic_string::size_type __length)             {
                this->_M_string_length = __length;
            }
            constexpr std::__cxx11::basic_string::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(std::__cxx11::basic_string::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(_M_data()[__n], _CharT());
            }
            constexpr bool _M_is_local() const             {
                return _M_data() == _M_local_data();
            }
            constexpr std::__cxx11::basic_string::pointer _M_create(std::__cxx11::basic_string::size_type &, std::__cxx11::basic_string::size_type);
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string::size_type __size) throw()             {
                _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            constexpr void _M_construct(std::__cxx11::basic_string::size_type __req, _CharT __c);
            constexpr std::__cxx11::basic_string::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
            constexpr std::__cxx11::basic_string::pointer _M_use_local_data() noexcept __attribute__((always_inline))             {
                if (std::is_constant_evaluated())
                    for (_CharT &__c : this->_M_local_buf)
                        __c = _CharT();
                return _M_local_data();
            }
        private:
            constexpr std::__cxx11::basic_string::size_type _M_check(std::__cxx11::basic_string::size_type __pos, const char *__s) const             {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            constexpr void _M_check_length(std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, const char *__s) const             {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            constexpr std::__cxx11::basic_string::size_type _M_limit(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __off) const noexcept             {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const _CharT *__s) const noexcept             {
                return (less<const _CharT *>()(__s, _M_data()) || less<const _CharT *>()(_M_data() + this->size(), __s));
            }
            static constexpr void _S_copy(_CharT *__d, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(_CharT *__d, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static constexpr void _S_assign(_CharT *__d, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template <class _Iterator> static constexpr void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2)             {
                for (; __k1 != __k2; ++__k1 , (void)++__p)
                    traits_type::assign(*__p, *__k1);
            }
            static constexpr void _S_copy_chars(_CharT *__p, std::__cxx11::basic_string::iterator __k1, std::__cxx11::basic_string::iterator __k2) noexcept             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static constexpr void _S_copy_chars(_CharT *__p, std::__cxx11::basic_string::const_iterator __k1, std::__cxx11::basic_string::const_iterator __k2) noexcept             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static constexpr void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr int _S_compare(std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2) noexcept             {
                const std::__cxx11::basic_string::difference_type __d = std::__cxx11::basic_string::difference_type(__n1 - __n2);
                if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                    return __gnu_cxx::__numeric_traits<int>::__max;
                else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                    return __gnu_cxx::__numeric_traits<int>::__min;
                else
                    return int(__d);
            }
            constexpr void _M_assign(const basic_string<_CharT, _Traits, _Alloc> &);
            constexpr void _M_mutate(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, std::__cxx11::basic_string::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n);
        public:
            constexpr basic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::valuebasic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::value) : _M_dataplus(_M_local_data())             {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr explicit basic_string<_CharT, _Traits, _Alloc>(const _Alloc &__a) noexcept : _M_dataplus(_M_local_data(), __a)             {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str) : _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))             {
                _M_construct(__str._M_data(), __str._M_data() + __str.length(), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, npos), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) : _M_dataplus(_M_local_data())             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, std::__cxx11::basic_string::size_type __n, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                _M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<_Alloc>> constexpr basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                if (__s == 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                const _CharT *__end = __s + traits_type::length(__s);
                _M_construct(__s, __end, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<_Alloc>> constexpr basic_string<_CharT, _Traits, _Alloc>(std::__cxx11::basic_string::size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__n, __c);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    _M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(initializer_list<_CharT> __l, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__l.begin(), __l.end(), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()) : _M_dataplus(_M_local_data(), __a)             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                    this->_M_length(__str.length());
                    __str._M_set_length(0);
                } else if (_Alloc_traits::_S_always_equal() || __str.get_allocator() == __a) {
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    __str._M_data(__str._M_local_buf);
                    __str._M_set_length(0);
                } else
                    _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
            }
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc>(_InputIterator __beg, _InputIterator __end, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__beg, __end, std::__iterator_category(__beg));
            }
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string::__sv_type>>> constexpr basic_string<_CharT, _Traits, _Alloc>(const _Tp &__t, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Alloc &__a = _Alloc()) : basic_string<_CharT, _Traits, _Alloc>(_S_to_string_view(__t).substr(__pos, __n), __a)             {
            }
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string<_CharT, _Traits, _Alloc>(const _Tp &__t, const _Alloc &__a = _Alloc()) : basic_string<_CharT, _Traits, _Alloc>(std::__cxx11::basic_string::__sv_wrapper(_S_to_string_view(__t)), __a)             {
            }
            constexpr ~basic_string<_CharT, _Traits, _Alloc>()             {
                this->_M_dispose();
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->assign(__str);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(const _CharT *__s)             {
                return this->assign(__s);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(_CharT __c)             {
                this->assign(1, __c);
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move())             {
                if (!this->_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign() && !_Alloc_traits::_S_always_equal() && _M_get_allocator() != __str._M_get_allocator()) {
                    this->_M_destroy(this->_M_allocated_capacity);
                    _M_data(_M_local_data());
                    this->_M_set_length(0);
                }
                std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
                if (__str._M_is_local()) {
                    if (__builtin_expect(std::__addressof(__str) != this, true)) {
                        if (__str.size())
                            this->_S_copy(_M_data(), __str._M_data(), __str.size());
                        this->_M_set_length(__str.size());
                    }
                } else if (_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal() || _M_get_allocator() == __str._M_get_allocator()) {
                    std::__cxx11::basic_string::pointer __data = nullptr;
                    std::__cxx11::basic_string::size_type __capacity;
                    if (!this->_M_is_local()) {
                        if (_Alloc_traits::_S_always_equal()) {
                            __data = _M_data();
                            __capacity = this->_M_allocated_capacity;
                        } else
                            this->_M_destroy(this->_M_allocated_capacity);
                    }
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    if (__data) {
                        __str._M_data(__data);
                        __str._M_capacity(__capacity);
                    } else
                        __str._M_data(__str._M_local_buf);
                } else
                    assign(__str);
                __str.clear();
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator=(initializer_list<_CharT> __l)             {
                this->assign(__l.begin(), __l.size());
                return *this;
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> operator=(const _Tp &__svt)             {
                return this->assign(__svt);
            }
            constexpr operator __sv_type() const noexcept             {
                return std::__cxx11::basic_string::__sv_type(data(), this->size());
            }
            constexpr std::__cxx11::basic_string::iterator begin() noexcept             {
                return std::__cxx11::basic_string::iterator(_M_data());
            }
            constexpr std::__cxx11::basic_string::const_iterator begin() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(_M_data());
            }
            constexpr std::__cxx11::basic_string::iterator end() noexcept             {
                return std::__cxx11::basic_string::iterator(_M_data() + this->size());
            }
            constexpr std::__cxx11::basic_string::const_iterator end() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(_M_data() + this->size());
            }
            constexpr std::__cxx11::basic_string::reverse_iterator rbegin() noexcept             {
                return std::__cxx11::basic_string::reverse_iterator(this->end());
            }
            constexpr std::__cxx11::basic_string::const_reverse_iterator rbegin() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->end());
            }
            constexpr std::__cxx11::basic_string::reverse_iterator rend() noexcept             {
                return std::__cxx11::basic_string::reverse_iterator(this->begin());
            }
            constexpr std::__cxx11::basic_string::const_reverse_iterator rend() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->begin());
            }
            constexpr std::__cxx11::basic_string::const_iterator cbegin() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(this->_M_data());
            }
            constexpr std::__cxx11::basic_string::const_iterator cend() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(this->_M_data() + this->size());
            }
            constexpr std::__cxx11::basic_string::const_reverse_iterator crbegin() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->end());
            }
            constexpr std::__cxx11::basic_string::const_reverse_iterator crend() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->begin());
            }
        public:
            constexpr std::__cxx11::basic_string::size_type size() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(std::__cxx11::basic_string::size_type __n, _CharT __c);
            constexpr void resize(std::__cxx11::basic_string::size_type __n)             {
                this->resize(__n, _CharT());
            }
            constexpr void shrink_to_fit() noexcept             {
                reserve();
            }
            constexpr std::__cxx11::basic_string::size_type capacity() const noexcept             {
                return this->_M_is_local() ? std::__cxx11::basic_string::size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            constexpr void reserve(std::__cxx11::basic_string::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept             {
                this->_M_set_length(0);
            }
            constexpr bool empty() const noexcept [[nodiscard("")]]             {
                return this->size() == 0;
            }
            constexpr std::__cxx11::basic_string::const_reference operator[](std::__cxx11::basic_string::size_type __pos) const noexcept             {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                return _M_data()[__pos];
            }
            constexpr std::__cxx11::basic_string::reference operator[](std::__cxx11::basic_string::size_type __pos)             {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                ;
                return _M_data()[__pos];
            }
            constexpr std::__cxx11::basic_string::const_reference at(std::__cxx11::basic_string::size_type __n) const             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            constexpr std::__cxx11::basic_string::reference at(std::__cxx11::basic_string::size_type __n)             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            constexpr std::__cxx11::basic_string::reference front() noexcept             {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](0);
            }
            constexpr std::__cxx11::basic_string::const_reference front() const noexcept             {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](0);
            }
            constexpr std::__cxx11::basic_string::reference back() noexcept             {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](this->size() - 1);
            }
            constexpr std::__cxx11::basic_string::const_reference back() const noexcept             {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                return operator[](this->size() - 1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->append(__str);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(const _CharT *__s)             {
                return this->append(__s);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(_CharT __c)             {
                this->push_back(__c);
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &operator+=(initializer_list<_CharT> __l)             {
                return this->append(__l.begin(), __l.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> operator+=(const _Tp &__svt)             {
                return this->append(__svt);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->append(__str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                this->_M_check_length(std::__cxx11::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)             {
                ;
                const std::__cxx11::basic_string::size_type __n = traits_type::length(__s);
                this->_M_check_length(std::__cxx11::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->size(), std::__cxx11::basic_string::size_type(0), __n, __c);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &append(initializer_list<_CharT> __l)             {
                return this->append(__l.begin(), __l.size());
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)             {
                return this->replace(end(), end(), __first, __last);
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> append(const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->append(__sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> append(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->_M_append(__sv.data() + std::__sv_check(__sv.size(), __pos, "basic_string::append"), std::__sv_limit(__sv.size(), __pos, __n));
            }
            constexpr void push_back(_CharT __c)             {
                const std::__cxx11::basic_string::size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, std::__cxx11::basic_string::size_type(0), 0, std::__cxx11::basic_string::size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                if (_Alloc_traits::_S_propagate_on_copy_assign()) {
                    if (!_Alloc_traits::_S_always_equal() && !this->_M_is_local() && _M_get_allocator() != __str._M_get_allocator()) {
                        if (__str.size() <= _S_local_capacity) {
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(this->_M_use_local_data());
                            this->_M_set_length(0);
                        } else {
                            const auto __len = __str.size();
                            auto __alloc = __str._M_get_allocator();
                            auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(__ptr);
                            this->_M_capacity(__len);
                            this->_M_set_length(__len);
                        }
                    }
                    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
                }
                this->_M_assign(__str);
                return *this;
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move())             {
                return *this = std::move(__str);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)             {
                ;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(std::__cxx11::basic_string::size_type(0), this->size(), __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)             {
                return this->replace(begin(), end(), __first, __last);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &assign(initializer_list<_CharT> __l)             {
                return this->assign(__l.begin(), __l.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> assign(const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->assign(__sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> assign(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __sv.data() + std::__sv_check(__sv.size(), __pos, "basic_string::assign"), std::__sv_limit(__sv.size(), __pos, __n));
            }
            constexpr std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __n, __c);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, _InputIterator __beg, _InputIterator __end)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __beg, __end);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            constexpr std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, initializer_list<_CharT> __l)             {
                return this->insert(__p, __l.begin(), __l.end());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                return this->replace(__pos, std::__cxx11::basic_string::size_type(0), __s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, const _CharT *__s)             {
                ;
                return this->replace(__pos, std::__cxx11::basic_string::size_type(0), __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::insert"), std::__cxx11::basic_string::size_type(0), __n, __c);
            }
            constexpr std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::__const_iterator __p, _CharT __c)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->_M_replace_aux(__pos, std::__cxx11::basic_string::size_type(0), std::__cxx11::basic_string::size_type(1), __c);
                return std::__cxx11::basic_string::iterator(_M_data() + __pos);
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> insert(std::__cxx11::basic_string::size_type __pos, const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->insert(__pos, __sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> insert(std::__cxx11::basic_string::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __sv.data() + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"), std::__sv_limit(__sv.size(), __pos2, __n));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &erase(std::__cxx11::basic_string::size_type __pos = 0, std::__cxx11::basic_string::size_type __n = npos)             {
                this->_M_check(__pos, "basic_string::erase");
                if (__n == npos)
                    this->_M_set_length(__pos);
                else if (__n != 0)
                    this->_M_erase(__pos, this->_M_limit(__pos, __n));
                return *this;
            }
            constexpr std::__cxx11::basic_string::iterator erase(std::__cxx11::basic_string::__const_iterator __position)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __position - begin();
                this->_M_erase(__pos, std::__cxx11::basic_string::size_type(1));
                return std::__cxx11::basic_string::iterator(_M_data() + __pos);
            }
            constexpr std::__cxx11::basic_string::iterator erase(std::__cxx11::basic_string::__const_iterator __first, std::__cxx11::basic_string::__const_iterator __last)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __first - begin();
                if (__last == end())
                    this->_M_set_length(__pos);
                else
                    this->_M_erase(__pos, __last - __first);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            constexpr void pop_back() noexcept             {
                do {
                    if (std::__is_constant_evaluated() && !bool(!this->empty()))
                        __builtin_unreachable();
                } while (false);
                this->_M_erase(this->size() - 1, 1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos, __n, __str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos)             {
                return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2)             {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s)             {
                ;
                return this->replace(__pos, __n1, __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __n2, __c);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__i1, __i2, __str._M_data(), __str.size());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__s)             {
                ;
                return this->replace(__i1, __i2, __s, traits_type::length(__s));
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                ;
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2)             {
                ;
                ;
                return this->_M_replace_dispatch(__i1, __i2, __k1, __k2, std::__false_type());
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, _CharT *__k1, _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__k1, const _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::iterator __k1, std::__cxx11::basic_string::iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::const_iterator __k1, std::__cxx11::basic_string::const_iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            constexpr basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, initializer_list<_CharT> __l)             {
                return this->replace(__i1, __i2, __l.begin(), __l.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__pos, __n, __sv.data(), __sv.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__pos1, __n1, __sv.data() + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"), std::__sv_limit(__sv.size(), __pos2, __n2));
            }
            template <typename _Tp> constexpr _If_sv<_Tp, basic_string<_CharT, _Traits, _Alloc> &> replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, const _Tp &__svt)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->replace(__i1 - begin(), __i2 - __i1, __sv);
            }
        private:
            template <class _Integer> constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type)             {
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
            }
            template <class _InputIterator> constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c);
            constexpr basic_string<_CharT, _Traits, _Alloc> &_M_replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, const std::__cxx11::basic_string::size_type __len2);
            constexpr basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, std::__cxx11::basic_string::size_type __n);
        public:
            constexpr std::__cxx11::basic_string::size_type copy(_CharT *__s, std::__cxx11::basic_string::size_type __n, std::__cxx11::basic_string::size_type __pos = 0) const;
            constexpr void swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept;
            constexpr const _CharT *c_str() const noexcept             {
                return _M_data();
            }
            constexpr const _CharT *data() const noexcept             {
                return _M_data();
            }
            constexpr _CharT *data() noexcept             {
                return _M_data();
            }
            constexpr std::__cxx11::basic_string::allocator_type get_allocator() const noexcept             {
                return _M_get_allocator();
            }
            constexpr std::__cxx11::basic_string::size_type find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string::size_type find(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string::size_type> find(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::valuefind(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find(__sv.data(), __pos, __sv.size());
            }
            constexpr std::__cxx11::basic_string::size_type find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find(__s, __pos, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string::size_type find(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept;
            constexpr std::__cxx11::basic_string::size_type rfind(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->rfind(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::valuerfind(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->rfind(__sv.data(), __pos, __sv.size());
            }
            constexpr std::__cxx11::basic_string::size_type rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string::size_type rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const             {
                ;
                return this->rfind(__s, __pos, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string::size_type rfind(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept;
            constexpr std::__cxx11::basic_string::size_type find_first_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find_first_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::valuefind_first_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_first_of(__sv.data(), __pos, __sv.size());
            }
            constexpr std::__cxx11::basic_string::size_type find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string::size_type find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find_first_of(__s, __pos, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string::size_type find_first_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find(__c, __pos);
            }
            constexpr std::__cxx11::basic_string::size_type find_last_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->find_last_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::valuefind_last_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_last_of(__sv.data(), __pos, __sv.size());
            }
            constexpr std::__cxx11::basic_string::size_type find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string::size_type find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                ;
                return this->find_last_of(__s, __pos, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string::size_type find_last_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->rfind(__c, __pos);
            }
            constexpr std::__cxx11::basic_string::size_type find_first_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find_first_not_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::valuefind_first_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = 0) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_first_not_of(__sv.data(), __pos, __sv.size());
            }
            constexpr std::__cxx11::basic_string::size_type find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string::size_type find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find_first_not_of(__s, __pos, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string::size_type find_first_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept;
            constexpr std::__cxx11::basic_string::size_type find_last_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->find_last_not_of(__str.data(), __pos, __str.size());
            }
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::valuefind_last_not_of(const _Tp &__svt, std::__cxx11::basic_string::size_type __pos = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return this->find_last_not_of(__sv.data(), __pos, __sv.size());
            }
            constexpr std::__cxx11::basic_string::size_type find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string::size_type find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                ;
                return this->find_last_not_of(__s, __pos, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string::size_type find_last_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept;
            constexpr basic_string<_CharT, _Traits, _Alloc> substr(std::__cxx11::basic_string::size_type __pos = 0, std::__cxx11::basic_string::size_type __n = npos) const             {
                return basic_string<_CharT, _Traits, _Alloc>(*this, this->_M_check(__pos, "basic_string::substr"), __n);
            }
            constexpr int compare(const basic_string<_CharT, _Traits, _Alloc> &__str) const             {
                const std::__cxx11::basic_string::size_type __size = this->size();
                const std::__cxx11::basic_string::size_type __osize = __str.size();
                const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::valuecompare(const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                const std::__cxx11::basic_string::size_type __size = this->size();
                const std::__cxx11::basic_string::size_type __osize = __sv.size();
                const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __sv.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::valuecompare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Tp &__svt) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return std::__cxx11::basic_string::__sv_type(*this).substr(__pos, __n).compare(__sv);
            }
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const noexcept(is_same<_Tp, __sv_type>::valuecompare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const noexcept(is_same<_Tp, __sv_type>::value)             {
                std::__cxx11::basic_string::__sv_type __sv = __svt;
                return std::__cxx11::basic_string::__sv_type(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
            }
            constexpr int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const;
            constexpr int compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const;
            constexpr int compare(const _CharT *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s) const;
            constexpr int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept             {
                return std::__cxx11::basic_string::__sv_type(this->data(), this->size()).starts_with(__x);
            }
            constexpr bool starts_with(_CharT __x) const noexcept             {
                return std::__cxx11::basic_string::__sv_type(this->data(), this->size()).starts_with(__x);
            }
            constexpr bool starts_with(const _CharT *__x) const noexcept             {
                return std::__cxx11::basic_string::__sv_type(this->data(), this->size()).starts_with(__x);
            }
            constexpr bool ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept             {
                return std::__cxx11::basic_string::__sv_type(this->data(), this->size()).ends_with(__x);
            }
            constexpr bool ends_with(_CharT __x) const noexcept             {
                return std::__cxx11::basic_string::__sv_type(this->data(), this->size()).ends_with(__x);
            }
            constexpr bool ends_with(const _CharT *__x) const noexcept             {
                return std::__cxx11::basic_string::__sv_type(this->data(), this->size()).ends_with(__x);
            }
            friend template <typename, typename, typename> class basic_stringbuf;
        };
template<> class basic_string<char, std::char_traits<char>, std::allocator<char>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char>>::rebind<char>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char>, void>;
        public:
            typedef std::char_traits<char> traits_type;
            typedef typename char_traits<char>::char_type value_type;
            typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char, char_traits<char>, allocator<char>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char, char_traits<char>, allocator<char>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type npos = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char, std::char_traits<char>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char, char_traits<char>, allocator<char>> *>>, __not_<is_convertible<const _Tp &, const char *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_wrapper __svw, const std::allocator<char> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type {
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char)
            };
            union {
                char _M_local_buf[16];
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char());
            }
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer basic_string<char, char_traits<char>, allocator<char>>::_M_create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type &__capacity, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char *>(const char *__beg, const char *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<char *>(char *__beg, char *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char *>(const char *__beg, const char *__end, std::forward_iterator_tag);
            template<> constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_construct<char *>(char *__beg, char *__end, std::forward_iterator_tag)             {
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __dnew = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<char, char_traits<char>, allocator<char>> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __req, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer _M_use_local_data() noexcept __attribute__((always_inline))             {
                if (std::is_constant_evaluated())
                    for (char &__c : this->_M_local_buf)
                        __c = char();
                return this->_M_local_data();
            }
        private:
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_check(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s) const             {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            constexpr void _M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, const char *__s) const             {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type _M_limit(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __off) const noexcept             {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const char *__s) const noexcept             {
                return (less<const char *>()(__s, this->_M_data()) || less<const char *>()(this->_M_data() + this->size(), __s));
            }
            static constexpr void _S_copy(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static constexpr void _S_assign(char *__d, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<char *>(char *__p, char *__k1, char *__k2);
            static constexpr void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char *__p, char *__k1, char *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(char *__p, const char *__k1, const char *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &);
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::_M_mutate(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len2)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __how_much = this->length() - __pos - __len1;
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __new_capacity = this->length() + __len2 - __len1;
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __r = this->_M_create(__new_capacity, this->capacity());
                if (__pos)
                    this->_S_copy(__r, this->_M_data(), __pos);
                if (__s && __len2)
                    this->_S_copy(__r + __pos, __s, __len2);
                if (__how_much)
                    this->_S_copy(__r + __pos + __len2, this->_M_data() + __pos + __len1, __how_much);
                this->_M_dispose();
                this->_M_data(__r);
                this->_M_capacity(__new_capacity);
            }
            constexpr void _M_erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
        public:
            constexpr basic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::valuebasic_string() noexcept(is_nothrow_default_constructible<allocator<char>>::value) : _M_dataplus(this->_M_local_data())             {
                this->_M_use_local_data();
                this->_M_set_length(0);
            }
            constexpr explicit basic_string(const std::allocator<char> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str) : _M_dataplus(this->_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))             {
                this->_M_construct(__str._M_data(), __str._M_data() + __str.length(), std::forward_iterator_tag());
            }
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const std::allocator<char> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a);
            constexpr basic_string(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char>>> constexpr basic_string(const char *__s, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(const char *__s, const std::allocator<char> &__a);
            template <typename = _RequireAllocator<std::allocator<char>>> constexpr basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c, const std::allocator<char> &__a);
            template<> constexpr basic_string<std::allocator<char>>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__n, __c);
            }
;
            constexpr basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, __str.length() + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            constexpr basic_string(initializer_list<char> __l, const std::allocator<char> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, const std::allocator<char> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str, const std::allocator<char> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
            template<> constexpr basic_string<char *, void>(char *__beg, char *__end, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::allocator<char> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char> &__a);
            constexpr ~basic_string<char, char_traits<char>, allocator<char>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type size() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            constexpr void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type capacity() const noexcept             {
                return this->_M_is_local() ? std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            constexpr void basic_string<char, char_traits<char>, allocator<char>>::reserve(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __res)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __capacity = this->capacity();
                if (__res <= __capacity)
                    return;
                std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __tmp = this->_M_create(__res, __capacity);
                this->_S_copy(__tmp, this->_M_data(), this->length() + 1);
                this->_M_dispose();
                this->_M_data(__tmp);
                this->_M_capacity(__res);
            }
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept             {
                this->_M_set_length(0);
            }
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos)             {
                do {
                    if (std::__is_constant_evaluated() && !bool(__pos <= this->size()))
                        __builtin_unreachable();
                } while (false);
                ;
                return this->_M_data()[__pos];
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(char __c)             {
                this->push_back(__c);
                return *this;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &operator+=(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str)             {
                return this->append(__str._M_data(), __str.size());
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                ;
                this->_M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(const char *__s)             {
                ;
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n = traits_type::length(__s);
                this->_M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(initializer_list<char> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr void push_back(char __c)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), 0, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &&__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &assign(initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __p, initializer_list<char> __l);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str)             {
                return this->replace(__pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __str._M_data(), __str.size());
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const char *__s)             {
                ;
                return this->replace(__pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __s, traits_type::length(__s));
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __p, char __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __first, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2)             {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__s);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, char __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, char *__k1, char *__k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, const char *__k1, const char *__k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, initializer_list<char> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &> replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &_M_replace_aux(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2, char __c);
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &basic_string<char, char_traits<char>, allocator<char>>::_M_replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len1, const char *__s, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len2)             {
                this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __old_size = this->size();
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __new_size = __old_size + __len2 - __len1;
                if (__new_size <= this->capacity()) {
                    std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::pointer __p = this->_M_data() + __pos;
                    const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __how_much = __old_size - __pos - __len1;
                    if (std::is_constant_evaluated()) {
                        auto __newp = _Alloc_traits::allocate(this->_M_get_allocator(), __new_size);
                        _S_copy(__newp, this->_M_data(), __pos);
                        _S_copy(__newp + __pos, __s, __len2);
                        _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
                        _S_copy(this->_M_data(), __newp, __new_size);
                        this->_M_get_allocator().deallocate(__newp, __new_size);
                    } else if (this->_M_disjunct(__s)) {
                        if (__how_much && __len1 != __len2)
                            this->_S_move(__p + __len2, __p + __len1, __how_much);
                        if (__len2)
                            this->_S_copy(__p, __s, __len2);
                    } else {
                        if (__len2 && __len2 <= __len1)
                            this->_S_move(__p, __s, __len2);
                        if (__how_much && __len1 != __len2)
                            this->_S_move(__p + __len2, __p + __len1, __how_much);
                        if (__len2 > __len1) {
                            if (__s + __len2 <= __p + __len1)
                                this->_S_move(__p, __s, __len2);
                            else if (__s >= __p + __len1) {
                                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __poff = (__s - __p) + (__len2 - __len1);
                                this->_S_copy(__p, __p + __poff, __len2);
                            } else {
                                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __nleft = (__p + __len1) - __s;
                                this->_S_move(__p, __s, __nleft);
                                this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                            }
                        }
                    }
                } else
                    this->_M_mutate(__pos, __len1, __s, __len2);
                this->_M_set_length(__new_size);
                return *this;
            }
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &basic_string<char, char_traits<char>, allocator<char>>::_M_append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n)             {
                const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __len = __n + this->size();
                if (__len <= this->capacity()) {
                    if (__n)
                        this->_S_copy(this->_M_data() + this->size(), __s, __n);
                } else
                    this->_M_mutate(this->size(), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type(0), __s, __n);
                this->_M_set_length(__len);
                return *this;
            }
        public:
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type basic_string<char, char_traits<char>, allocator<char>>::copy(char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos = 0) const             {
                this->_M_check(__pos, "basic_string::copy");
                __n = this->_M_limit(__pos, __n);
                ;
                if (__n)
                    _S_copy(__s, this->_M_data() + __pos, __n);
                return __n;
            }
            constexpr void swap(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__s) noexcept;
            constexpr const char *c_str() const noexcept             {
                return this->_M_data();
            }
            constexpr const char *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char *data() noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type rfind(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_first_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type find_last_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> substr(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
            constexpr int compare(const char *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char, std::char_traits<char>> __x) const noexcept;
            constexpr bool starts_with(char __x) const noexcept;
            constexpr bool starts_with(const char *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char, std::char_traits<char>> __x) const noexcept;
            constexpr bool ends_with(char __x) const noexcept;
            constexpr bool ends_with(const char *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
template<> class basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t>>::rebind<wchar_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<wchar_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<wchar_t>, void>;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef typename char_traits<wchar_t>::char_type value_type;
            typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type npos = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<wchar_t, std::char_traits<wchar_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *>>, __not_<is_convertible<const _Tp &, const wchar_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_wrapper __svw, const std::allocator<wchar_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type {
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(wchar_t)
            };
            union {
                wchar_t _M_local_buf[4];
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            constexpr void _M_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __length)             {
                this->_M_string_length = __length;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            constexpr void _M_set_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], wchar_t());
            }
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_create(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type &__capacity, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::input_iterator_tag);
            template<> constexpr void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::forward_iterator_tag);
            template<> constexpr void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>::_M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::forward_iterator_tag)             {
                std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __dnew = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type(0)));
                    this->_M_capacity(__dnew);
                } else
                    this->_M_use_local_data();
                struct _Guard {
                    basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> *_M_guarded;
                } __guard(this);
                this->_S_copy_chars(this->_M_data(), __beg, __end);
                __guard._M_guarded = 0;
                this->_M_set_length(__dnew);
            }
;
            constexpr void _M_construct(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __req, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline))             {
                if (std::is_constant_evaluated())
                    for (wchar_t &__c : this->_M_local_buf)
                        __c = wchar_t();
                return this->_M_local_data();
            }
        private:
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_check(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type _M_limit(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const wchar_t *__s) const noexcept;
            static constexpr void _S_copy(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static constexpr void _S_move(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            static constexpr void _S_assign(wchar_t *__d, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static constexpr void _S_copy_chars<wchar_t *>(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
            static constexpr void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static constexpr void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<wchar_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<wchar_t>>> constexpr basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<std::allocator<wchar_t>>(const wchar_t *__s, const std::allocator<wchar_t> &__a);
            template <typename = _RequireAllocator<std::allocator<wchar_t>>> constexpr basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<wchar_t> __l, const std::allocator<wchar_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, const std::allocator<wchar_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str, const std::allocator<wchar_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
            template<> constexpr basic_string<wchar_t *, void>(wchar_t *__beg, wchar_t *__end, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__beg, __end, std::__iterator_category(__beg));
            }
;
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::allocator<wchar_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<wchar_t> &__a);
            constexpr ~basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            constexpr void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            constexpr void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &operator+=(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(initializer_list<wchar_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr void push_back(wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &&__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &assign(initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __p, initializer_list<wchar_t> __l);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __p, wchar_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __first, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__s);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, wchar_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, initializer_list<wchar_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &> replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace_aux(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2, wchar_t __c);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len1, const wchar_t *__s, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &_M_append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type copy(wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__s) noexcept;
            constexpr const wchar_t *c_str() const noexcept             {
                return this->_M_data();
            }
            constexpr const wchar_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr wchar_t *data() noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type rfind(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_first_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type find_last_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> substr(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
            constexpr int compare(const wchar_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
            constexpr bool starts_with(wchar_t __x) const noexcept;
            constexpr bool starts_with(const wchar_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
            constexpr bool ends_with(wchar_t __x) const noexcept;
            constexpr bool ends_with(const wchar_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
template<> class basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char8_t>>::rebind<char8_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char8_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char8_t>, void>;
        public:
            typedef std::char_traits<char8_t> traits_type;
            typedef typename char_traits<char8_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char8_t, std::char_traits<char8_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>> *>>, __not_<is_convertible<const _Tp &, const char8_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_wrapper __svw, const std::allocator<char8_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type {
                std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char8_t)
            };
            union {
                char8_t _M_local_buf[16];
                std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer __p);
            constexpr void _M_length(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __length);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __capacity);
            constexpr void _M_set_length(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_create(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type &, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type);
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char8_t *>(const char8_t *__beg, const char8_t *__end, std::forward_iterator_tag);
            constexpr void _M_construct(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __req, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type &_M_get_allocator() const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline));
        private:
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_check(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type _M_limit(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char8_t *__s) const noexcept;
            static constexpr void _S_copy(char8_t *__d, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            static constexpr void _S_move(char8_t *__d, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            static constexpr void _S_assign(char8_t *__d, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char8_t *__p, _Iterator __k1, _Iterator __k2);
            static constexpr void _S_copy_chars(char8_t *__p, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, char8_t *__k1, char8_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char8_t *__p, const char8_t *__k1, const char8_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len1, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char8_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const std::allocator<char8_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::allocator<char8_t> &__a);
            constexpr basic_string(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::allocator<char8_t> &__a = std::allocator<char8_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char8_t>>> constexpr basic_string(const char8_t *__s, const std::allocator<char8_t> &__a);
            template<> constexpr basic_string<std::allocator<char8_t>>(const char8_t *__s, const std::allocator<char8_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char8_t>>> constexpr basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c, const std::allocator<char8_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<char8_t> __l, const std::allocator<char8_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, const std::allocator<char8_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str, const std::allocator<char8_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::allocator<char8_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char8_t> &__a);
            constexpr ~basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type max_size() const noexcept;
            constexpr void resize(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            constexpr void resize(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference operator[](std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference operator[](std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference at(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference at(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &operator+=(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(initializer_list<char8_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr void push_back(char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &&__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &assign(initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __p, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __p, initializer_list<char8_t> __l);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __p, char8_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> insert(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator erase(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __first, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const char8_t *__s);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, char8_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, char8_t *__k1, char8_t *__k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, const char8_t *__k1, const char8_t *__k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::__const_iterator __i2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, initializer_list<char8_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &> replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace_aux(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2, char8_t __c);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_replace(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len1, const char8_t *__s, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &_M_append(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type copy(char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__s) noexcept;
            constexpr const char8_t *c_str() const noexcept;
            constexpr const char8_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char8_t *data() noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type rfind(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_first_not_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type find_last_not_of(char8_t __c, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> substr(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos1, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>> &__str, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos2, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) const;
            constexpr int compare(const char8_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __pos, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n1, const char8_t *__s, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::allocator<char8_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
            constexpr bool starts_with(char8_t __x) const noexcept;
            constexpr bool starts_with(const char8_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
            constexpr bool ends_with(char8_t __x) const noexcept;
            constexpr bool ends_with(const char8_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t>>::rebind<char16_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char16_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char16_t>, void>;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char16_t, std::char_traits<char16_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> *>>, __not_<is_convertible<const _Tp &, const char16_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_wrapper __svw, const std::allocator<char16_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer __p);
            constexpr void _M_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __length);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __capacity);
            constexpr void _M_set_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_create(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type &, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type);
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag);
            constexpr void _M_construct(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __req, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type &_M_get_allocator() const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline));
        private:
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_check(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type _M_limit(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static constexpr void _S_copy(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            static constexpr void _S_move(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            static constexpr void _S_assign(char16_t *__d, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            static constexpr void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const std::allocator<char16_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            constexpr basic_string(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char16_t>>> constexpr basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            template<> constexpr basic_string<std::allocator<char16_t>>(const char16_t *__s, const std::allocator<char16_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char16_t>>> constexpr basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, const std::allocator<char16_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::allocator<char16_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char16_t> &__a);
            constexpr ~basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type max_size() const noexcept;
            constexpr void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            constexpr void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &operator+=(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr void push_back(char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &&__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &assign(initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __p, initializer_list<char16_t> __l);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __p, char16_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __first, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__s);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, initializer_list<char16_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &> replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace_aux(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2, char16_t __c);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len1, const char16_t *__s, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &_M_append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type copy(char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__s) noexcept;
            constexpr const char16_t *c_str() const noexcept;
            constexpr const char16_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char16_t *data() noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type rfind(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_first_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type find_last_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> substr(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            constexpr int compare(const char16_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
            constexpr bool starts_with(char16_t __x) const noexcept;
            constexpr bool starts_with(const char16_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
            constexpr bool ends_with(char16_t __x) const noexcept;
            constexpr bool ends_with(const char16_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t>>::rebind<char32_t>::other _Char_alloc_type;
            template <typename _Traits2, typename _Dummy_for_PR85282> struct _Alloc_traits_impl
template<> struct _Alloc_traits_impl<std::char_traits<char32_t>, void> : __gnu_cxx::__alloc_traits<_Char_alloc_type> {
            };
            using _Alloc_traits = _Alloc_traits_impl<std::char_traits<char32_t>, void>;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type npos = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __const_iterator;
        private:
            typedef basic_string_view<char32_t, std::char_traits<char32_t>> __sv_type;
            template <typename _Tp, typename _Res> using _If_sv = enable_if_t<__and_<is_convertible<const _Tp &, __sv_type>, __not_<is_convertible<const _Tp *, const basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> *>>, __not_<is_convertible<const _Tp &, const char32_t *>>>::value, _Res>;
            static constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _S_to_string_view(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type __svt) noexcept;
            struct __sv_wrapper {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type _M_sv;
            };
            constexpr explicit basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_wrapper __svw, const std::allocator<char32_t> &__a);
            struct _Alloc_hider : std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_p;
            };
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_allocated_capacity;
            };
            constexpr void _M_data(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer __p);
            constexpr void _M_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __length);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            constexpr void _M_capacity(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __capacity);
            constexpr void _M_set_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_create(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type &, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type);
            constexpr void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            constexpr void _M_destroy(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> constexpr void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> constexpr void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> constexpr void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag);
            constexpr void _M_construct(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __req, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            constexpr const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type &_M_get_allocator() const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::pointer _M_use_local_data() noexcept __attribute__((always_inline));
        private:
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_check(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char *__s) const;
            constexpr void _M_check_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, const char *__s) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type _M_limit(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static constexpr void _S_copy(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            static constexpr void _S_move(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            static constexpr void _S_assign(char32_t *__d, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _Iterator> static constexpr void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            static constexpr void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static constexpr void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept;
            static constexpr int _S_compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) noexcept;
            constexpr void _M_assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &);
            constexpr void _M_mutate(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            constexpr void _M_erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            constexpr basic_string();
            constexpr explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const std::allocator<char32_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            constexpr basic_string(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                if (__s == 0 && __n > 0)
                    std::__throw_logic_error(("basic_string: construction from null is not valid"));
                this->_M_construct(__s, __s + __n, std::forward_iterator_tag());
            }
            template <typename = _RequireAllocator<std::allocator<char32_t>>> constexpr basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            template<> constexpr basic_string<std::allocator<char32_t>>(const char32_t *__s, const std::allocator<char32_t> &__a);
            template <typename = _RequireAllocator<std::allocator<char32_t>>> constexpr basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str) noexcept;
            constexpr basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            constexpr basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, const std::allocator<char32_t> &__a);
            constexpr basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = enable_if_t<is_convertible_v<const _Tp &, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__sv_type>>> constexpr basic_string(const _Tp &__t, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::allocator<char32_t> &__a);
            template <typename _Tp, typename = _If_sv<_Tp, void>> constexpr explicit basic_string(const _Tp &__t, const std::allocator<char32_t> &__a);
            constexpr ~basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>() noexcept             {
                this->_M_dispose();
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator=(const _Tp &__svt);
            constexpr operator __sv_type() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator begin() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator begin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator end() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator end() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rbegin() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reverse_iterator rend() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator rend() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator cend() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crbegin() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reverse_iterator crend() const noexcept;
        public:
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type size() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type max_size() const noexcept;
            constexpr void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            constexpr void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr void shrink_to_fit() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type capacity() const noexcept;
            constexpr void reserve(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __res_arg);
            constexpr void reserve() [[deprecated("use shrink_to_fit() instead")]];
            constexpr void clear() noexcept;
            constexpr bool empty() const noexcept [[nodiscard("")]];
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference front() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference front() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::reference back() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_reference back() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &operator+=(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> operator+=(const _Tp &__svt);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &append(_InputIterator __first, _InputIterator __last);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> append(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr void push_back(char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &&__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(_InputIterator __first, _InputIterator __last);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &assign(initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> assign(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __p, initializer_list<char32_t> __l);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __p, char32_t __c);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __position);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __first, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __last);
            constexpr void pop_back() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__s);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::iterator __k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __k2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, initializer_list<char32_t> __l);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2);
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &> replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, const _Tp &__svt);
        private:
            template <class _Integer> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace_aux(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2, char32_t __c);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len1, const char32_t *__s, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __len2);
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &_M_append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n);
        public:
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type copy(char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr void swap(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__s) noexcept;
            constexpr const char32_t *c_str() const noexcept;
            constexpr const char32_t *data() const noexcept             {
                return this->_M_data();
            }
            constexpr char32_t *data() noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::allocator_type get_allocator() const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> rfind(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type rfind(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_first_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_first_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            template <typename _Tp> constexpr _If_sv<_Tp, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type> find_last_not_of(const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type find_last_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos) const noexcept;
            constexpr std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> substr(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n) const;
            constexpr int compare(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const _Tp &__svt) const;
            template <typename _Tp> constexpr _If_sv<_Tp, int> compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const _Tp &__svt, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str) const;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            constexpr int compare(const char32_t *__s) const noexcept;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s) const;
            constexpr int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>>::size_type __n2) const;
            constexpr bool starts_with(basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
            constexpr bool starts_with(char32_t __x) const noexcept;
            constexpr bool starts_with(const char32_t *__x) const noexcept;
            constexpr bool ends_with(basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
            constexpr bool ends_with(char32_t __x) const noexcept;
            constexpr bool ends_with(const char32_t *__x) const noexcept;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
}
namespace std {
    inline namespace __cxx11 {
        template <typename _InputIterator, typename _CharT = typename iterator_traits<_InputIterator>::value_type, typename _Allocator = allocator<_CharT>, typename = _RequireInputIter<_InputIterator>, typename = _RequireAllocator<_Allocator>> basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator()) -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;
        template <typename _CharT, typename _Traits, typename _Allocator = allocator<_CharT>, typename = _RequireAllocator<_Allocator>> basic_string(basic_string_view<_CharT, _Traits>, const _Allocator & = _Allocator()) -> basic_string<_CharT, _Traits, _Allocator>;
        template <typename _CharT, typename _Traits, typename _Allocator = allocator<_CharT>, typename = _RequireAllocator<_Allocator>> basic_string(basic_string_view<_CharT, _Traits>, typename basic_string<_CharT, _Traits, _Allocator>::size_type, typename basic_string<_CharT, _Traits, _Allocator>::size_type, const _Allocator & = _Allocator()) -> basic_string<_CharT, _Traits, _Allocator>;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> inline constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, const char *__rhs)     {
        basic_string<char, std::char_traits<char>, std::allocator<char>> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str(__lhs);
        __str.append(__size_type(1), __rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char>> &__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        using _Alloc_traits = allocator_traits<_Alloc>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal({}))
            __use_rhs = true;
        else if (__lhs.get_allocator() == __rhs.get_allocator())
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template<> inline constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs)     {
        using _Alloc_traits = allocator_traits<std::allocator<char>>;
        bool __use_rhs = false;
        if (typename _Alloc_traits::is_always_equal{})
            __use_rhs = true;
        if (__use_rhs) {
            const auto __size = __lhs.size() + __rhs.size();
            if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                return std::move(__rhs.insert(0, __lhs));
        }
        return std::move(__lhs.append(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, basic_string<char, std::char_traits<char>, std::allocator<char>> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, 1, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs)     {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char>> &&__lhs, const char *__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs)     {
        return std::move(__lhs.append(1, __rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT> inline constexpr typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator==(const basic_string<_CharT> &__lhs, const basic_string<_CharT> &__rhs) noexcept     {
        return (__lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size()));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr auto operator<=>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))     {
        return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr auto operator<=>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))     {
        return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline constexpr void swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs)))     {
        __lhs.swap(__rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str);
    template<> basic_istream<char> &operator>><char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__is, basic_string<char> &__str);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return std::getline(__is, __str, __is.widen('\n'));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)     {
        return std::getline(__is, __str, __delim);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return std::getline(__is, __str);
    }
    template<> basic_istream<char> &getline<char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__in, basic_string<char> &__str, char __delim);
    template<> basic_istream<wchar_t> &getline<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim);
}
extern "C++" {
    namespace std {
        using ::div_t;
        using ::ldiv_t;
        using ::abort;
        using ::aligned_alloc;
        using ::atexit;
        using ::at_quick_exit;
        using ::atof;
        using ::atoi;
        using ::atol;
        using ::bsearch;
        using ::calloc;
        using ::div;
        using ::exit;
        using ::free;
        using ::getenv;
        using ::labs;
        using ::ldiv;
        using ::malloc;
        using ::mblen;
        using ::mbstowcs;
        using ::mbtowc;
        using ::qsort;
        using ::quick_exit;
        using ::rand;
        using ::realloc;
        using ::srand;
        using ::strtod;
        using ::strtol;
        using ::strtoul;
        using ::system;
        using ::wcstombs;
        using ::wctomb;
        inline ldiv_t div(long __i, long __j)         {
            return ldiv(__i, __j);
        }
    }
    namespace __gnu_cxx {
        using ::lldiv_t;
        using ::_Exit;
        using ::llabs;
        inline lldiv_t div(long long __n, long long __d)         {
            lldiv_t __q;
            __q.quot = __n / __d;
            __q.rem = __n % __d;
            return __q;
        }
        using ::lldiv;
        using ::atoll;
        using ::strtoll;
        using ::strtoull;
        using ::strtof;
        using ::strtold;
    }
    namespace std {
        using ::__gnu_cxx::lldiv_t;
        using ::__gnu_cxx::_Exit;
        using ::__gnu_cxx::llabs;
        using ::__gnu_cxx::div;
        using ::__gnu_cxx::lldiv;
        using ::__gnu_cxx::atoll;
        using ::__gnu_cxx::strtof;
        using ::__gnu_cxx::strtoll;
        using ::__gnu_cxx::strtoull;
        using ::__gnu_cxx::strtold;
    }
}
extern "C" {
    typedef unsigned long size_t;
    typedef struct _G_fpos_t {
        __off_t __pos;
        __mbstate_t __state;
    } __fpos_t;
    typedef struct _G_fpos64_t {
        __off64_t __pos;
        __mbstate_t __state;
    } __fpos64_t;
    struct _IO_FILE;
    struct _IO_marker;
    struct _IO_codecvt;
    struct _IO_wide_data;
    typedef void _IO_lock_t;
    struct _IO_FILE {
        int _flags;
        char *_IO_read_ptr;
        char *_IO_read_end;
        char *_IO_read_base;
        char *_IO_write_base;
        char *_IO_write_ptr;
        char *_IO_write_end;
        char *_IO_buf_base;
        char *_IO_buf_end;
        char *_IO_save_base;
        char *_IO_backup_base;
        char *_IO_save_end;
        struct _IO_marker *_markers;
        struct _IO_FILE *_chain;
        int _fileno;
        int _flags2;
        __off_t _old_offset;
        unsigned short _cur_column;
        signed char _vtable_offset;
        char _shortbuf[1];
        _IO_lock_t *_lock;
        __off64_t _offset;
        struct _IO_codecvt *_codecvt;
        struct _IO_wide_data *_wide_data;
        struct _IO_FILE *_freeres_list;
        void *_freeres_buf;
        size_t __pad5;
        int _mode;
        char _unused2[20];
    };
    typedef __ssize_t (cookie_read_function_t)(void *, char *, size_t);
    typedef __ssize_t (cookie_write_function_t)(void *, const char *, size_t);
    typedef int (cookie_seek_function_t)(void *, __off64_t *, int);
    typedef int (cookie_close_function_t)(void *);
    typedef struct _IO_cookie_io_functions_t {
        cookie_read_function_t *read;
        cookie_write_function_t *write;
        cookie_seek_function_t *seek;
        cookie_close_function_t *close;
    } cookie_io_functions_t;
    typedef __gnuc_va_list va_list;
    typedef __fpos_t fpos_t;
    typedef __fpos64_t fpos64_t;
    extern FILE *stdin;
    extern FILE *stdout;
    extern FILE *stderr;
    extern int remove(const char *__filename) noexcept(trueremove(const char *__filename) noexcept(true);
    extern int rename(const char *__old, const char *__new) noexcept(truerename(const char *__old, const char *__new) noexcept(true);
    extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) noexcept(truerenameat(int __oldfd, const char *__old, int __newfd, const char *__new) noexcept(true);
    extern int renameat2(int __oldfd, const char *__old, int __newfd, const char *__new, unsigned int __flags) noexcept(truerenameat2(int __oldfd, const char *__old, int __newfd, const char *__new, unsigned int __flags) noexcept(true);
    extern int fclose(FILE *__stream);
    extern FILE *tmpfile() __attribute__((malloc));
    extern FILE *tmpfile64() __attribute__((malloc));
    extern char *tmpnam(char [20]) noexcept(truetmpnam(char [20]) noexcept(true);
    extern char *tmpnam_r(char __s[20]) noexcept(truetmpnam_r(char __s[20]) noexcept(true);
    extern char *tempnam(const char *__dir, const char *__pfx) noexcept(truetempnam(const char *__dir, const char *__pfx) noexcept(true) __attribute__((malloc));
    extern int fflush(FILE *__stream);
    extern int fflush_unlocked(FILE *__stream);
    extern int fcloseall();
    extern FILE *fopen(const char *__restrict __filename, const char *__restrict __modes) __attribute__((malloc));
    extern FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes) __attribute__((malloc));
    extern FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fdopen(int __fd, const char *__modes) noexcept(truefdopen(int __fd, const char *__modes) noexcept(true) __attribute__((malloc));
    extern FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, cookie_io_functions_t __io_funcs) noexcept(truefopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, cookie_io_functions_t __io_funcs) noexcept(true) __attribute__((malloc));
    extern FILE *fmemopen(void *__s, size_t __len, const char *__modes) noexcept(truefmemopen(void *__s, size_t __len, const char *__modes) noexcept(true) __attribute__((malloc));
    extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) noexcept(trueopen_memstream(char **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(trueopen_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) noexcept(true) __attribute__((malloc));
    extern void setbuf(FILE *__restrict __stream, char *__restrict __buf) noexcept(truesetbuf(FILE *__restrict __stream, char *__restrict __buf) noexcept(true);
    extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) noexcept(truesetvbuf(FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) noexcept(true);
    extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf, size_t __size) noexcept(truesetbuffer(FILE *__restrict __stream, char *__restrict __buf, size_t __size) noexcept(true);
    extern void setlinebuf(FILE *__stream) noexcept(truesetlinebuf(FILE *__stream) noexcept(true);
    extern int fprintf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int printf(const char *__restrict __format, ...);
    extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) noexcept(truesprintf(char *__restrict __s, const char *__restrict __format, ...) noexcept(true);
    extern int vfprintf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg);
    extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);
    extern int vsprintf(char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(truevsprintf(char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true);
    extern int snprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, ...) noexcept(truesnprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, ...) noexcept(true) __attribute__((format(printf, 3, 4)));
    extern int vsnprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, __gnuc_va_list __arg) noexcept(truevsnprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) __attribute__((format(printf, 3, 0)));
    extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, __gnuc_va_list __arg) noexcept(truevasprintf(char **__restrict __ptr, const char *__restrict __f, __gnuc_va_list __arg) noexcept(true) __attribute__((format(printf, 2, 0)));
    extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(true__asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(trueasprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int vdprintf(int __fd, const char *__restrict __fmt, __gnuc_va_list __arg) __attribute__((format(printf, 2, 0)));
    extern int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((format(printf, 2, 3)));
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int scanf(const char *__restrict __format, ...);
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(truesscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(true);
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...) asm("__isoc99_fscanf");
    extern int scanf(const char *__restrict __format, ...) asm("__isoc99_scanf");
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(truesscanf(const char *__restrict __s, const char *__restrict __format, ...) noexcept(true) asm("__isoc99_sscanf");
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(truevsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) __attribute__((format(scanf, 2, 0)));
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vfscanf") __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vscanf") __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(truevsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept(true) asm("__isoc99_vsscanf") __attribute__((format(scanf, 2, 0)));
    extern int fgetc(FILE *__stream);
    extern int getc(FILE *__stream);
    extern int getchar();
    extern int getc_unlocked(FILE *__stream);
    extern int getchar_unlocked();
    extern int fgetc_unlocked(FILE *__stream);
    extern int fputc(int __c, FILE *__stream);
    extern int putc(int __c, FILE *__stream);
    extern int putchar(int __c);
    extern int fputc_unlocked(int __c, FILE *__stream);
    extern int putc_unlocked(int __c, FILE *__stream);
    extern int putchar_unlocked(int __c);
    extern int getw(FILE *__stream);
    extern int putw(int __w, FILE *__stream);
    extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern char *fgets_unlocked(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream);
    extern int fputs(const char *__restrict __s, FILE *__restrict __stream);
    extern int puts(const char *__s);
    extern int ungetc(int __c, FILE *__stream);
    extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);
    extern int fputs_unlocked(const char *__restrict __s, FILE *__restrict __stream);
    extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern int fseek(FILE *__stream, long __off, int __whence);
    extern long ftell(FILE *__stream);
    extern void rewind(FILE *__stream);
    extern int fseeko(FILE *__stream, __off_t __off, int __whence);
    extern __off_t ftello(FILE *__stream);
    extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos);
    extern int fsetpos(FILE *__stream, const fpos_t *__pos);
    extern int fseeko64(FILE *__stream, __off64_t __off, int __whence);
    extern __off64_t ftello64(FILE *__stream);
    extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos);
    extern int fsetpos64(FILE *__stream, const fpos64_t *__pos);
    extern void clearerr(FILE *__stream) noexcept(trueclearerr(FILE *__stream) noexcept(true);
    extern int feof(FILE *__stream) noexcept(truefeof(FILE *__stream) noexcept(true);
    extern int ferror(FILE *__stream) noexcept(trueferror(FILE *__stream) noexcept(true);
    extern void clearerr_unlocked(FILE *__stream) noexcept(trueclearerr_unlocked(FILE *__stream) noexcept(true);
    extern int feof_unlocked(FILE *__stream) noexcept(truefeof_unlocked(FILE *__stream) noexcept(true);
    extern int ferror_unlocked(FILE *__stream) noexcept(trueferror_unlocked(FILE *__stream) noexcept(true);
    extern void perror(const char *__s);
    extern int fileno(FILE *__stream) noexcept(truefileno(FILE *__stream) noexcept(true);
    extern int fileno_unlocked(FILE *__stream) noexcept(truefileno_unlocked(FILE *__stream) noexcept(true);
    extern int pclose(FILE *__stream);
    extern FILE *popen(const char *__command, const char *__modes) __attribute__((malloc));
    extern char *ctermid(char *__s) noexcept(truectermid(char *__s) noexcept(true);
    extern char *cuserid(char *__s);
    struct obstack;
    extern int obstack_printf(struct obstack *__restrict __obstack, const char *__restrict __format, ...) noexcept(trueobstack_printf(struct obstack *__restrict __obstack, const char *__restrict __format, ...) noexcept(true) __attribute__((format(printf, 2, 3)));
    extern int obstack_vprintf(struct obstack *__restrict __obstack, const char *__restrict __format, __gnuc_va_list __args) noexcept(trueobstack_vprintf(struct obstack *__restrict __obstack, const char *__restrict __format, __gnuc_va_list __args) noexcept(true) __attribute__((format(printf, 2, 0)));
    extern void flockfile(FILE *__stream) noexcept(trueflockfile(FILE *__stream) noexcept(true);
    extern int ftrylockfile(FILE *__stream) noexcept(trueftrylockfile(FILE *__stream) noexcept(true);
    extern void funlockfile(FILE *__stream) noexcept(truefunlockfile(FILE *__stream) noexcept(true);
    extern int __uflow(FILE *);
    extern int __overflow(FILE *, int);
}
namespace std {
    using ::FILE;
    using ::fpos_t;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::printf;
    using ::putc;
    using ::putchar;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
}
namespace __gnu_cxx {
    using ::snprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsnprintf;
    using ::vsscanf;
}
namespace std {
    using ::__gnu_cxx::snprintf;
    using ::__gnu_cxx::vfscanf;
    using ::__gnu_cxx::vscanf;
    using ::__gnu_cxx::vsnprintf;
    using ::__gnu_cxx::vsscanf;
}
extern "C" {
    extern int *__errno_location() noexcept(true__errno_location() noexcept(true) __attribute__((const));
    extern char *program_invocation_name;
    extern char *program_invocation_short_name;
    typedef int error_t;
}
namespace __gnu_cxx {
    template <typename _TRet, typename _Ret = _TRet, typename _CharT, typename ..._Base> _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base...), const char *__name, const _CharT *__str, std::size_t *__idx, _Base ...__base)     {
        _Ret __ret;
        _CharT *__endptr;
        const struct _Save_errno {
            _Save_errno() : _M_errno((*__errno_location()))             {
                (*__errno_location()) = 0;
            }
            ~_Save_errno()             {
                if ((*__errno_location()) == 0)
                    (*__errno_location()) = this->_M_errno;
            }
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
            static bool _S_chk(_TRet, std::false_type)             {
                return false;
            }
            static bool _S_chk(_TRet __val, std::true_type)             {
                return __val < _TRet(__numeric_traits<int>::__min) || __val > _TRet(__numeric_traits<int>::__max);
            }
        };
        const _TRet __tmp = __convf(__str, &__endptr, __base...);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>({})))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        int __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, char, <int>>(unsigned long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        unsigned long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, char, <int>>(long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, char, <int>>(unsigned long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        unsigned long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, char, <>>(float (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        float __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, char, <>>(double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, char, <>>(long double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        long double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        int __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, wchar_t, <int>>(unsigned long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        unsigned long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, wchar_t, <int>>(long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, wchar_t, <int>>(unsigned long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        unsigned long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, wchar_t, <>>(float (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        float __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, wchar_t, <>>(double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, wchar_t, <>>(long double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        long double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template <typename _String, typename _CharT = typename _String::value_type> _String __to_xstring(int (*__convf)(_CharT *, std::size_t, const _CharT *, __va_list_tag *), std::size_t __n, const _CharT *__fmt, ...)     {
        _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return _String(__s, __s + __len);
    }
    template<> std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> __to_xstring<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, char>(int (*__convf)(char *, std::size_t, const char *, __va_list_tag *), std::size_t __n, const char *__fmt, ...)     {
        char *__s = static_cast<char *>(__builtin_alloca(sizeof(char) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>(__s, __s + __len);
    }
    template<> std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>> __to_xstring<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>, wchar_t>(int (*__convf)(wchar_t *, std::size_t, const wchar_t *, __va_list_tag *), std::size_t __n, const wchar_t *__fmt, ...)     {
        wchar_t *__s = static_cast<wchar_t *>(__builtin_alloca(sizeof(wchar_t) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>(__s, __s + __len);
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp> constexpr unsigned int __to_chars_len(_Tp __value, int __base = 10) noexcept         {
            static_assert(is_integral<_Tp>::value, "implementation bug");
            static_assert(is_unsigned<_Tp>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned int>(unsigned int __value, int __base = 10) noexcept         {
            static_assert(is_integral<unsigned int>::value, "implementation bug");
            static_assert(is_unsigned<unsigned int>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long>(unsigned long __value, int __base = 10) noexcept         {
            static_assert(is_integral<unsigned long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template<> constexpr unsigned int __to_chars_len<unsigned long long>(unsigned long long __value, int __base = 10) noexcept         {
            static_assert(is_integral<unsigned long long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long long>::value, "implementation bug");
            unsigned int __n = 1;
            const unsigned int __b2 = __base * __base;
            const unsigned int __b3 = __b2 * __base;
            const unsigned long __b4 = __b3 * __base;
            for (;;) {
                if (__value < (unsigned int)__base)
                    return __n;
                if (__value < __b2)
                    return __n + 1;
                if (__value < __b3)
                    return __n + 2;
                if (__value < __b4)
                    return __n + 3;
                __value /= __b4;
                __n += 4;
            }
        }
        template <typename _Tp> void __to_chars_10_impl(char *__first, unsigned int __len, _Tp __val) noexcept         {
            static_assert(is_integral<_Tp>::value, "implementation bug");
            static_assert(is_unsigned<_Tp>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned int>(char *__first, unsigned int __len, unsigned int __val) noexcept         {
            static_assert(is_integral<unsigned int>::value, "implementation bug");
            static_assert(is_unsigned<unsigned int>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long>(char *__first, unsigned int __len, unsigned long __val) noexcept         {
            static_assert(is_integral<unsigned long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
        template<> void __to_chars_10_impl<unsigned long long>(char *__first, unsigned int __len, unsigned long long __val) noexcept         {
            static_assert(is_integral<unsigned long long>::value, "implementation bug");
            static_assert(is_unsigned<unsigned long long>::value, "implementation bug");
            static constexpr char __digits[201] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899";
            unsigned int __pos = __len - 1;
            while (__val >= 100)
                {
                    const auto __num = (__val % 100) * 2;
                    __val /= 100;
                    __first[__pos] = __digits[__num + 1];
                    __first[__pos - 1] = __digits[__num];
                    __pos -= 2;
                }
            if (__val >= 10) {
                const auto __num = __val * 2;
                __first[1] = __digits[__num + 1];
                __first[0] = __digits[__num];
            } else
                __first[0] = '0' + __val;
        }
    }
}
namespace std {
    inline namespace __cxx11 {
        inline int stoi(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx);
        }
        inline std::string to_string(int __val) noexcept         {
            const bool __neg = __val < 0;
            const unsigned int __uval = __neg ? (unsigned int)~__val + 1U : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned int __val) noexcept         {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(long __val)         {
            const bool __neg = __val < 0;
            const unsigned long __uval = __neg ? (unsigned long)~__val + 1UL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned long __val)         {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(long long __val)         {
            const bool __neg = __val < 0;
            const unsigned long long __uval = __neg ? (unsigned long long)~__val + 1ULL : __val;
            const auto __len = __detail::__to_chars_len(__uval);
            std::string __str(__neg + __len, '-');
            __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
            return __str;
        }
        inline std::string to_string(unsigned long long __val)         {
            std::string __str(__detail::__to_chars_len(__val), '\x00');
            __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
            return __str;
        }
        inline std::string to_string(float __val)         {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(long double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%Lf", __val);
        }
        inline int stoi(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx);
        }
        inline std::wstring to_wstring(int __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(int), L"%d", __val);
        }
        inline std::wstring to_wstring(unsigned int __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned int), L"%u", __val);
        }
        inline std::wstring to_wstring(long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long), L"%ld", __val);
        }
        inline std::wstring to_wstring(unsigned long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long), L"%lu", __val);
        }
        inline std::wstring to_wstring(long long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long long), L"%lld", __val);
        }
        inline std::wstring to_wstring(unsigned long long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long long), L"%llu", __val);
        }
        inline std::wstring to_wstring(float __val)         {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(long double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%Lf", __val);
        }
    }
}
namespace std {
    template<> struct hash<std::string> : public __hash_base<std::size_t, std::string> {
        std::size_t operator()(const std::string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::string>> : std::false_type {
    };
    template<> struct hash<std::wstring> : public __hash_base<std::size_t, std::wstring> {
        std::size_t operator()(const std::wstring &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::wstring>> : std::false_type {
    };
    template<> struct hash<std::u8string> : public __hash_base<std::size_t, std::u8string> {
        std::size_t operator()(const std::u8string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char8_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u8string>> : std::false_type {
    };
    template<> struct hash<std::u16string> : public __hash_base<std::size_t, std::u16string> {
        std::size_t operator()(const std::u16string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u16string>> : std::false_type {
    };
    template<> struct hash<std::u32string> : public __hash_base<std::size_t, std::u32string> {
        std::size_t operator()(const std::u32string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u32string>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_literals {
            inline constexpr basic_string<char> operator""s(const char *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char>{__str, __len};
            }
            inline constexpr basic_string<wchar_t> operator""s(const wchar_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<wchar_t>{__str, __len};
            }
            inline constexpr basic_string<char8_t> operator""s(const char8_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char8_t>{__str, __len};
            }
            inline constexpr basic_string<char16_t> operator""s(const char16_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char16_t>{__str, __len};
            }
            inline constexpr basic_string<char32_t> operator""s(const char32_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char32_t>{__str, __len};
            }
        }
    }
    namespace __detail {
        namespace __variant {
            template <typename> struct _Never_valueless_alt;
            template <typename _Tp, typename _Traits, typename _Alloc> struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>> : __and_<is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>, is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>>::type {
            };
        }
    }
}
namespace std {
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type npos;
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept     {
        if (this == std::__addressof(__s))
            return;
        _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());
        if (this->_M_is_local())
            if (__s._M_is_local()) {
                if (this->length() && __s.length()) {
                    _CharT __tmp_data[_S_local_capacity + 1];
                    traits_type::copy(__tmp_data, __s._M_local_buf, __s.length() + 1);
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                    traits_type::copy(this->_M_local_buf, __tmp_data, __s.length() + 1);
                } else if (__s.length()) {
                    traits_type::copy(this->_M_local_buf, __s._M_local_buf, __s.length() + 1);
                    this->_M_length(__s.length());
                    __s._M_set_length(0);
                    return;
                } else if (this->length()) {
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                    __s._M_length(this->length());
                    this->_M_set_length(0);
                    return;
                }
            } else {
                const std::__cxx11::basic_string::size_type __tmp_capacity = __s._M_allocated_capacity;
                traits_type::copy(__s._M_local_buf, this->_M_local_buf, this->length() + 1);
                _M_data(__s._M_data());
                __s._M_data(__s._M_local_buf);
                this->_M_capacity(__tmp_capacity);
            }
        else {
            const std::__cxx11::basic_string::size_type __tmp_capacity = this->_M_allocated_capacity;
            if (__s._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __s._M_local_buf, __s.length() + 1);
                __s._M_data(_M_data());
                _M_data(this->_M_local_buf);
            } else {
                std::__cxx11::basic_string::pointer __tmp_ptr = _M_data();
                _M_data(__s._M_data());
                __s._M_data(__tmp_ptr);
                this->_M_capacity(__s._M_allocated_capacity);
            }
            __s._M_capacity(__tmp_capacity);
        }
        const std::__cxx11::basic_string::size_type __tmp_length = this->length();
        this->_M_length(__s.length());
        __s._M_length(__tmp_length);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::pointer basic_string<_CharT, _Traits, _Alloc>::_M_create(std::__cxx11::basic_string::size_type &__capacity, std::__cxx11::basic_string::size_type __old_capacity)     {
        if (__capacity > this->max_size())
            std::__throw_length_error(("basic_string::_M_create"));
        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
            __capacity = 2 * __old_capacity;
            if (__capacity > this->max_size())
                __capacity = this->max_size();
        }
        return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag)     {
        std::__cxx11::basic_string::size_type __len = 0;
        std::__cxx11::basic_string::size_type __capacity = std::__cxx11::basic_string::size_type(_S_local_capacity);
        std::__cxx11::basic_string::pointer __p = this->_M_use_local_data();
        while (__beg != __end && __len < __capacity)
            {
                __p[__len++] = *__beg;
                ++__beg;
            }
        struct _Guard {
            constexpr explicit _Guard(basic_string<_CharT, _Traits, _Alloc> *__s) : _M_guarded(__s)             {
            }
            constexpr ~_Guard()             {
                if (this->_M_guarded)
                    this->_M_guarded->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> *_M_guarded;
        } __guard(this);
        while (__beg != __end)
            {
                if (__len == __capacity) {
                    __capacity = __len + 1;
                    std::__cxx11::basic_string::pointer __another = this->_M_create(__capacity, __len);
                    this->_S_copy(__another, _M_data(), __len);
                    this->_M_dispose();
                    _M_data(__another);
                    this->_M_capacity(__capacity);
                }
                traits_type::assign(_M_data()[__len++], *__beg);
                ++__beg;
            }
        __guard._M_guarded = 0;
        this->_M_set_length(__len);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::forward_iterator_tag)     {
        std::__cxx11::basic_string::size_type __dnew = static_cast<std::__cxx11::basic_string::size_type>(std::distance(__beg, __end));
        if (__dnew > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__dnew, std::__cxx11::basic_string::size_type(0)));
            this->_M_capacity(__dnew);
        } else
            this->_M_use_local_data();
        struct _Guard {
            constexpr explicit _Guard(basic_string<_CharT, _Traits, _Alloc> *__s) : _M_guarded(__s)             {
            }
            constexpr ~_Guard()             {
                if (this->_M_guarded)
                    this->_M_guarded->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> *_M_guarded;
        } __guard(this);
        this->_S_copy_chars(_M_data(), __beg, __end);
        __guard._M_guarded = 0;
        this->_M_set_length(__dnew);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(std::__cxx11::basic_string::size_type __n, _CharT __c)     {
        if (__n > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__n, std::__cxx11::basic_string::size_type(0)));
            this->_M_capacity(__n);
        } else
            this->_M_use_local_data();
        if (__n)
            this->_S_assign(_M_data(), __n, __c);
        this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_assign(const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        if (this != std::__addressof(__str)) {
            const std::__cxx11::basic_string::size_type __rsize = __str.length();
            const std::__cxx11::basic_string::size_type __capacity = this->capacity();
            if (__rsize > __capacity) {
                std::__cxx11::basic_string::size_type __new_capacity = __rsize;
                std::__cxx11::basic_string::pointer __tmp = this->_M_create(__new_capacity, __capacity);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__new_capacity);
            }
            if (__rsize)
                this->_S_copy(_M_data(), __str._M_data(), __rsize);
            this->_M_set_length(__rsize);
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::reserve(std::__cxx11::basic_string::size_type __res)     {
        const std::__cxx11::basic_string::size_type __capacity = this->capacity();
        if (__res <= __capacity)
            return;
        std::__cxx11::basic_string::pointer __tmp = this->_M_create(__res, __capacity);
        this->_S_copy(__tmp, _M_data(), this->length() + 1);
        this->_M_dispose();
        _M_data(__tmp);
        this->_M_capacity(__res);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, std::__cxx11::basic_string::size_type __len2)     {
        const std::__cxx11::basic_string::size_type __how_much = this->length() - __pos - __len1;
        std::__cxx11::basic_string::size_type __new_capacity = this->length() + __len2 - __len1;
        std::__cxx11::basic_string::pointer __r = this->_M_create(__new_capacity, this->capacity());
        if (__pos)
            this->_S_copy(__r, _M_data(), __pos);
        if (__s && __len2)
            this->_S_copy(__r + __pos, __s, __len2);
        if (__how_much)
            this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1, __how_much);
        this->_M_dispose();
        _M_data(__r);
        this->_M_capacity(__new_capacity);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_erase(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n)     {
        const std::__cxx11::basic_string::size_type __how_much = this->length() - __pos - __n;
        if (__how_much && __n)
            this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
        this->_M_set_length(this->length() - __n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::reserve()     {
        if (this->_M_is_local())
            return;
        const std::__cxx11::basic_string::size_type __length = this->length();
        const std::__cxx11::basic_string::size_type __capacity = this->_M_allocated_capacity;
        if (__length <= std::__cxx11::basic_string::size_type(_S_local_capacity)) {
            this->_S_copy(this->_M_use_local_data(), _M_data(), __length + 1);
            this->_M_destroy(__capacity);
            _M_data(_M_local_data());
        } else if (__length < __capacity)
            try {
                std::__cxx11::basic_string::pointer __tmp = _Alloc_traits::allocate(_M_get_allocator(), __length + 1);
                this->_S_copy(__tmp, _M_data(), __length + 1);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__length);
            } catch (const __cxxabiv1::__forced_unwind &) {
                throw;
            } catch (...) {
            }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr void basic_string<_CharT, _Traits, _Alloc>::resize(std::__cxx11::basic_string::size_type __n, _CharT __c)     {
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__size < __n)
            this->append(__n - __size, __c);
        else if (__n < __size)
            this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s, std::__cxx11::basic_string::size_type __n)     {
        const std::__cxx11::basic_string::size_type __len = __n + this->size();
        if (__len <= this->capacity()) {
            if (__n)
                this->_S_copy(this->_M_data() + this->size(), __s, __n);
        } else
            this->_M_mutate(this->size(), std::__cxx11::basic_string::size_type(0), __s, __n);
        this->_M_set_length(__len);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InputIterator> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type)     {
        const basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2, this->get_allocator());
        const std::__cxx11::basic_string::size_type __n1 = __i2 - __i1;
        return this->_M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c)     {
        this->_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
        const std::__cxx11::basic_string::size_type __old_size = this->size();
        const std::__cxx11::basic_string::size_type __new_size = __old_size + __n2 - __n1;
        if (__new_size <= this->capacity()) {
            std::__cxx11::basic_string::pointer __p = this->_M_data() + __pos1;
            const std::__cxx11::basic_string::size_type __how_much = __old_size - __pos1 - __n1;
            if (__how_much && __n1 != __n2)
                this->_S_move(__p + __n2, __p + __n1, __how_much);
        } else
            this->_M_mutate(__pos1, __n1, 0, __n2);
        if (__n2)
            this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, const std::__cxx11::basic_string::size_type __len2)     {
        this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
        const std::__cxx11::basic_string::size_type __old_size = this->size();
        const std::__cxx11::basic_string::size_type __new_size = __old_size + __len2 - __len1;
        if (__new_size <= this->capacity()) {
            std::__cxx11::basic_string::pointer __p = this->_M_data() + __pos;
            const std::__cxx11::basic_string::size_type __how_much = __old_size - __pos - __len1;
            if (std::is_constant_evaluated()) {
                auto __newp = _Alloc_traits::allocate(_M_get_allocator(), __new_size);
                _S_copy(__newp, this->_M_data(), __pos);
                _S_copy(__newp + __pos, __s, __len2);
                _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
                _S_copy(this->_M_data(), __newp, __new_size);
                this->_M_get_allocator().deallocate(__newp, __new_size);
            } else if (this->_M_disjunct(__s)) {
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2)
                    this->_S_copy(__p, __s, __len2);
            } else {
                if (__len2 && __len2 <= __len1)
                    this->_S_move(__p, __s, __len2);
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2 > __len1) {
                    if (__s + __len2 <= __p + __len1)
                        this->_S_move(__p, __s, __len2);
                    else if (__s >= __p + __len1) {
                        const std::__cxx11::basic_string::size_type __poff = (__s - __p) + (__len2 - __len1);
                        this->_S_copy(__p, __p + __poff, __len2);
                    } else {
                        const std::__cxx11::basic_string::size_type __nleft = (__p + __len1) - __s;
                        this->_S_move(__p, __s, __nleft);
                        this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                    }
                }
            }
        } else
            this->_M_mutate(__pos, __len1, __s, __len2);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, std::__cxx11::basic_string::size_type __n, std::__cxx11::basic_string::size_type __pos = 0) const     {
        this->_M_check(__pos, "basic_string::copy");
        __n = this->_M_limit(__pos, __n);
        ;
        if (__n)
            _S_copy(__s, _M_data() + __pos, __n);
        return __n;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        ;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        const __size_type __len = _Traits::length(__lhs);
        __string_type __str(_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
        __str.reserve(__len + __rhs.size());
        __str.append(__lhs, __len);
        __str.append(__rhs);
        return __str;
    }
    template<> constexpr basic_string<char, std::char_traits<char>, std::allocator<char>> operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char>> &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> constexpr basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_CharT>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        __string_type __str(_Alloc_traits::_S_select_on_copy(__rhs.get_allocator()));
        const __size_type __len = __rhs.size();
        __str.reserve(__len + 1);
        __str.append(__size_type(1), __lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__n == 0)
            return __pos <= __size ? __pos : npos;
        if (__pos >= __size)
            return npos;
        const _CharT __elem0 = __s[0];
        const _CharT *const __data = data();
        const _CharT *__first = __data + __pos;
        const _CharT *const __last = __data + __size;
        std::__cxx11::basic_string::size_type __len = __size - __pos;
        while (__len >= __n)
            {
                __first = traits_type::find(__first, __len - __n + 1, __elem0);
                if (!__first)
                    return npos;
                if (traits_type::compare(__first, __s, __n) == 0)
                    return __first - __data;
                __len = __last - ++__first;
            }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept     {
        std::__cxx11::basic_string::size_type __ret = npos;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__pos < __size) {
            const _CharT *__data = _M_data();
            const std::__cxx11::basic_string::size_type __n = __size - __pos;
            const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
            if (__p)
                __ret = __p - __data;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__n <= __size) {
            __pos = std::min(std::__cxx11::basic_string::size_type(__size - __n), __pos);
            const _CharT *__data = _M_data();
            do {
                if (traits_type::compare(__data + __pos, __s, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept     {
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(_M_data()[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        for (; __n && __pos < this->size(); ++__pos) {
            const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::find(__s, __n, _M_data()[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept     {
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::eq(_M_data()[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept     {
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(_M_data()[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const     {
        this->_M_check(__pos, "basic_string::compare");
        __n = this->_M_limit(__pos, __n);
        const std::__cxx11::basic_string::size_type __osize = __str.size();
        const std::__cxx11::basic_string::size_type __len = std::min(__n, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
        if (!__r)
            __r = _S_compare(__n, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const     {
        this->_M_check(__pos1, "basic_string::compare");
        __str._M_check(__pos2, "basic_string::compare");
        __n1 = this->_M_limit(__pos1, __n1);
        __n2 = __str._M_limit(__pos2, __n2);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        const std::__cxx11::basic_string::size_type __osize = traits_type::length(__s);
        const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
        int __r = traits_type::compare(_M_data(), __s, __len);
        if (!__r)
            __r = _S_compare(__size, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::__cxx11::basic_string::size_type __osize = traits_type::length(__s);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> constexpr int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        typedef ctype<_CharT> __ctype_type;
        typedef typename __ctype_type::ctype_base __ctype_base;
        __size_type __extracted = 0;
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                __str.erase();
                _CharT __buf[128];
                __size_type __len = 0;
                const std::streamsize __w = __in.width();
                const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        if (__len == sizeof (__buf) / sizeof(_CharT)) {
                            __str.append(__buf, sizeof (__buf) / sizeof(_CharT));
                            __len = 0;
                        }
                        __buf[__len++] = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                __str.append(__buf, __len);
                if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        __size_type __extracted = 0;
        const __size_type __n = __str.max_size();
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            try {
                __str.erase();
                const __int_type __idelim = _Traits::to_int_type(__delim);
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !_Traits::eq_int_type(__c, __idelim))
                    {
                        __str += _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                else if (_Traits::eq_int_type(__c, __idelim)) {
                    ++__extracted;
                    __in.rdbuf()->sbumpc();
                } else
                    __err |= __ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
}
namespace std {
    namespace pmr {
        template <typename _Tp> class polymorphic_allocator;
        template <typename _CharT, typename _Traits = char_traits<_CharT>> using basic_string = std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;
        using string = basic_string<char>;
        using u8string = basic_string<char8_t>;
        using u16string = basic_string<char16_t>;
        using u32string = basic_string<char32_t>;
        using wstring = basic_string<wchar_t>;
    }
    template <typename _Str> struct __hash_string_base : public __hash_base<std::size_t, _Str> {
        std::size_t operator()(const _Str &__s) const noexcept         {
            return hash<basic_string_view<typename _Str::value_type>>({})(__s);
        }
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>>> {
        std::size_t operator()(const std::__cxx11::basic_string<char, std::char_traits<char>, std::pmr::polymorphic_allocator<char>> &__s) const noexcept;
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::pmr::polymorphic_allocator<char8_t>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::pmr::polymorphic_allocator<char8_t>>> {
        std::size_t operator()(const std::__cxx11::basic_string<char8_t, std::char_traits<char8_t>, std::pmr::polymorphic_allocator<char8_t>> &__s) const noexcept;
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>>> {
        std::size_t operator()(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::pmr::polymorphic_allocator<char16_t>> &__s) const noexcept;
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>>> {
        std::size_t operator()(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::pmr::polymorphic_allocator<char32_t>> &__s) const noexcept;
    };
template<> struct __hash_string_base<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>>> : public __hash_base<std::size_t, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>>> {
        std::size_t operator()(const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::pmr::polymorphic_allocator<wchar_t>> &__s) const noexcept;
    };
    template<> struct hash<pmr::string> : public __hash_string_base<pmr::string> {
    };
    template<> struct hash<pmr::u8string> : public __hash_string_base<pmr::u8string> {
    };
    template<> struct hash<pmr::u16string> : public __hash_string_base<pmr::u16string> {
    };
    template<> struct hash<pmr::u32string> : public __hash_string_base<pmr::u32string> {
    };
    template<> struct hash<pmr::wstring> : public __hash_string_base<pmr::wstring> {
    };
}
namespace std {
    template <typename _CharT, typename _Traits, typename _Alloc, typename _Predicate> inline constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type erase_if(basic_string<_CharT, _Traits, _Alloc> &__cont, _Predicate __pred)     {
        using namespace __gnu_cxx;
        const auto __osz = __cont.size();
        const auto __end = __cont.end();
        auto __removed = std::__remove_if(__cont.begin(), __end, __ops::__pred_iter(std::ref(__pred)));
        __cont.erase(__removed, __end);
        return __osz - __cont.size();
    }
    template <typename _CharT, typename _Traits, typename _Alloc, typename _Up> inline constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type erase(basic_string<_CharT, _Traits, _Alloc> &__cont, const _Up &__value)     {
        using namespace __gnu_cxx;
        const auto __osz = __cont.size();
        const auto __end = __cont.end();
        auto __removed = std::__remove_if(__cont.begin(), __end, __ops::__iter_equals_val(__value));
        __cont.erase(__removed, __end);
        return __osz - __cont.size();
    }
}
namespace std {
    class locale {
    public:
        typedef int category;
        class facet;
        class id;
        class _Impl;
        friend  class facet;
        friend  class _Impl;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
        static const std::locale::category none = 0;
        static const std::locale::category ctype = 1L << 0;
        static const std::locale::category numeric = 1L << 1;
        static const std::locale::category collate = 1L << 2;
        static const std::locale::category time = 1L << 3;
        static const std::locale::category monetary = 1L << 4;
        static const std::locale::category messages = 1L << 5;
        static const std::locale::category all = (ctype | numeric | collate | time | monetary | messages);
        locale() throw();
        locale(const std::locale &__other) throw();
        explicit locale(const char *__s);
        locale(const std::locale &__base, const char *__s, std::locale::category __cat);
        explicit locale(const std::string &__s) : NULL TYPE(__s.c_str())         {
        }
        locale(const std::locale &__base, const std::string &__s, std::locale::category __cat) : NULL TYPE(__base, __s.c_str(), __cat)         {
        }
        locale(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        template <typename _Facet> locale(const std::locale &__other, _Facet *__f);
        ~locale() throw();
        const std::locale &operator=(const std::locale &__other) throw();
        template <typename _Facet> std::locale combine(const std::locale &__other) const;
        std::string name() const __attribute__((abi_tag("cxx11")));
        bool operator==(const std::locale &__other) const throw();
        template <typename _Char, typename _Traits, typename _Alloc> bool operator()(const basic_string<_Char, _Traits, _Alloc> &__s1, const basic_string<_Char, _Traits, _Alloc> &__s2) const;
        static std::locale global(const std::locale &__loc);
        static const std::locale &classic();
    private:
        std::locale::_Impl *_M_impl;
        static std::locale::_Impl *_S_classic;
        static std::locale::_Impl *_S_global;
        static const char *const *const _S_categories;
        enum  {
            _S_categories_size = 6 + 6
        };
        static __gthread_once_t _S_once;
        explicit locale(std::locale::_Impl *) throw();
        static void _S_initialize();
        static void _S_initialize_once() throw();
        static std::locale::category _S_normalize_category(std::locale::category);
        void _M_coalesce(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        static const std::locale::id *const _S_twinned_facets[];
    };
    class facet {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        mutable _Atomic_word _M_refcount;
        static std::__c_locale _S_c_locale;
        static const char _S_c_name[2];
        static __gthread_once_t _S_once;
        static void _S_initialize_once();
    protected:
        explicit facet(std::size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)         {
        }
        virtual ~facet() noexcept;
        static void _S_create_c_locale(std::__c_locale &__cloc, const char *__s, std::__c_locale __old = 0);
        static std::__c_locale _S_clone_c_locale(std::__c_locale &__cloc) throw();
        static void _S_destroy_c_locale(std::__c_locale &__cloc);
        static std::__c_locale _S_lc_ctype_c_locale(std::__c_locale __cloc, const char *__s);
        static std::__c_locale _S_get_c_locale();
        static const char *_S_get_c_name() throw() __attribute__((const));
        facet(const std::locale::facet &) = delete
        std::locale::facet &operator=(const std::locale::facet &) = delete
    private:
        void _M_add_reference() const throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() const throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        const std::locale::facet *_M_sso_shim(const std::locale::id *) const;
        const std::locale::facet *_M_cow_shim(const std::locale::id *) const;
    protected:
        class __shim;
    };
    class id {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        mutable std::size_t _M_index;
        static _Atomic_word _S_refcount;
        void operator=(const std::locale::id &);
        id(const std::locale::id &);
    public:
        id()         {
        }
        std::size_t _M_id() const throw();
    };
    class _Impl {
    public:
        friend  class locale;
        friend  class locale::facet;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
    private:
        _Atomic_word _M_refcount;
        const std::locale::facet **_M_facets;
        std::size_t _M_facets_size;
        const std::locale::facet **_M_caches;
        char **_M_names;
        static const locale::id *const _S_id_ctype[];
        static const locale::id *const _S_id_numeric[];
        static const locale::id *const _S_id_collate[];
        static const locale::id *const _S_id_time[];
        static const locale::id *const _S_id_monetary[];
        static const locale::id *const _S_id_messages[];
        static const locale::id *const *const _S_facet_categories[];
        void _M_add_reference() throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        _Impl(const std::locale::_Impl &, std::size_t);
        _Impl(const char *, std::size_t);
        _Impl(std::size_t) throw();
        ~_Impl() throw();
        _Impl(const std::locale::_Impl &);
        void operator=(const std::locale::_Impl &);
        bool _M_check_same_name()         {
            bool __ret = true;
            if (this->_M_names[1])
                for (std::size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
                    __ret = __builtin_strcmp(this->_M_names[__i], this->_M_names[__i + 1]) == 0;
            return __ret;
        }
        void _M_replace_categories(const std::locale::_Impl *, std::locale::category);
        void _M_replace_category(const std::locale::_Impl *, const locale::id *const *);
        void _M_replace_facet(const std::locale::_Impl *, const locale::id *);
        void _M_install_facet(const locale::id *, const std::locale::facet *);
        template <typename _Facet> void _M_init_facet(_Facet *__facet)         {
            this->_M_install_facet(&_Facet::id, __facet);
        }
        template <typename _Facet> void _M_init_facet_unchecked(_Facet *__facet)         {
            __facet->_M_add_reference();
            this->_M_facets[_Facet::id._M_id()] = __facet;
        }
        void _M_install_cache(const std::locale::facet *, std::size_t);
        void _M_init_extra(std::locale::facet **);
        void _M_init_extra(void *, void *, const char *, const char *);
    };
    template <typename _CharT> class collate : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale())         {
        }
        explicit collate<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))         {
        }
        int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const         {
            return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }
        std::__cxx11::collate::string_type transform(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_transform(__lo, __hi);
        }
        long hash(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_hash(__lo, __hi);
        }
        int _M_compare(const _CharT *, const _CharT *) const throw();
        std::size_t _M_transform(_CharT *, const _CharT *, std::size_t) const throw();
    protected:
        virtual ~collate<_CharT>()         {
            _S_destroy_c_locale(this->_M_c_locale_collate);
        }
        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const;
        virtual std::__cxx11::collate::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const;
        virtual long do_hash(const _CharT *__lo, const _CharT *__hi) const;
    };
    locale::id id;
    template <> int collate<char>::_M_compare(const char *, const char *) const throw();
    template <> std::size_t collate<char>::_M_transform(char *, const char *, std::size_t) const throw();
    template <> int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const throw();
    template <> std::size_t collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    template <typename _CharT> class collate_byname : public collate<_CharT> {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
        explicit collate_byname<_CharT>(const char *__s, std::size_t __refs = 0) : collate<_CharT>(__refs)         {
            if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                this->_S_destroy_c_locale(this->_M_c_locale_collate);
                this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }
        explicit collate_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : collate_byname<_CharT>(__s.c_str(), __refs)         {
        }
    protected:
        virtual ~collate_byname<_CharT>()         {
        }
    };
}
namespace std {
    template <typename _Facet> locale::locale(const std::locale &__other, _Facet *__f)     {
        this->_M_impl = new std::locale::_Impl(*__other._M_impl, 1);
        try {
            this->_M_impl->_M_install_facet(&_Facet::id, __f);
        } catch (...) {
            this->_M_impl->_M_remove_reference();
            throw;
        }
        delete [] this->_M_impl->_M_names[0];
        this->_M_impl->_M_names[0] = 0;
    }
    template <typename _Facet> std::locale locale::combine(const std::locale &__other) const     {
        std::locale::_Impl *__tmp = new std::locale::_Impl(*this->_M_impl, 1);
        try {
            __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
        } catch (...) {
            __tmp->_M_remove_reference();
            throw;
        }
        return std::locale(__tmp);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> bool locale::operator()(const basic_string<_CharT, _Traits, _Alloc> &__s1, const basic_string<_CharT, _Traits, _Alloc> &__s2) const     {
        typedef std::collate<_CharT> __collate_type;
        const __collate_type &__collate = use_facet<__collate_type>(*this);
        return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0);
    }
    template <typename _Facet> bool has_facet(const std::locale &__loc) throw()     {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        return (__i < __loc._M_impl->_M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]));
    }
    template <typename _Facet> const _Facet &use_facet(const std::locale &__loc)     {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
            __throw_bad_cast();
        return dynamic_cast<const _Facet &>(*__facets[__i]);
    }
    template <typename _CharT> int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const throw()     {
        return 0;
    }
    template <typename _CharT> std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, std::size_t) const throw()     {
        return 0;
    }
    template <typename _CharT> int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const     {
        const std::__cxx11::collate::string_type __one(__lo1, __hi1);
        const std::__cxx11::collate::string_type __two(__lo2, __hi2);
        const _CharT *__p = __one.c_str();
        const _CharT *__pend = __one.data() + __one.length();
        const _CharT *__q = __two.c_str();
        const _CharT *__qend = __two.data() + __two.length();
        for (;;) {
            const int __res = this->_M_compare(__p, __q);
            if (__res)
                return __res;
            __p += char_traits<_CharT>::length(__p);
            __q += char_traits<_CharT>::length(__q);
            if (__p == __pend && __q == __qend)
                return 0;
            else if (__p == __pend)
                return -1;
            else if (__q == __qend)
                return 1;
            __p++;
            __q++;
        }
    }
    template <typename _CharT> typename collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const     {
        std::__cxx11::collate::string_type __ret;
        const std::__cxx11::collate::string_type __str(__lo, __hi);
        const _CharT *__p = __str.c_str();
        const _CharT *__pend = __str.data() + __str.length();
        std::size_t __len = (__hi - __lo) * 2;
        _CharT *__c = new _CharT [__len];
        try {
            for (;;) {
                std::size_t __res = this->_M_transform(__c, __p, __len);
                if (__res >= __len) {
                    __len = __res + 1;
                    delete [] __c , __c = 0;
                    __c = new _CharT [__len];
                    __res = this->_M_transform(__c, __p, __len);
                }
                __ret.append(__c, __res);
                __p += char_traits<_CharT>::length(__p);
                if (__p == __pend)
                    break;
                __p++;
                __ret.push_back(_CharT());
            }
        } catch (...) {
            delete [] __c;
            throw;
        }
        delete [] __c;
        return __ret;
    }
    template <typename _CharT> long collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const     {
        unsigned long __val = 0;
        for (; __lo < __hi; ++__lo)
            __val = *__lo + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::__digits - 7)));
        return static_cast<long>(__val);
    }
    template<> class collate<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        std::__cxx11::collate<char>::string_type transform(const char *__lo, const char *__hi) const;
        long hash(const char *__lo, const char *__hi) const;
        int _M_compare(const char *, const char *) const throw();
        std::size_t _M_transform(char *, const char *, std::size_t) const throw();
    protected:
        virtual ~collate<char>() noexcept;
        virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        virtual std::__cxx11::collate<char>::string_type do_transform(const char *__lo, const char *__hi) const;
        virtual long do_hash(const char *__lo, const char *__hi) const;
    };
    template<> class collate_byname<char> : public collate<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<char>() noexcept;
    };
    template<> class collate<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        std::__cxx11::collate<wchar_t>::string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
        long hash(const wchar_t *__lo, const wchar_t *__hi) const;
        int _M_compare(const wchar_t *, const wchar_t *) const throw();
        std::size_t _M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    protected:
        virtual ~collate<wchar_t>() noexcept;
        virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        virtual std::__cxx11::collate<wchar_t>::string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
        virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
    };
    template<> class collate_byname<wchar_t> : public collate<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<wchar_t>() noexcept;
    };
}
namespace std {
    enum class errc : int {
        address_family_not_supported = 97,
        address_in_use = 98,
        address_not_available = 99,
        already_connected = 106,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 74,
        broken_pipe = 32,
        connection_aborted = 103,
        connection_already_in_progress = 114,
        connection_refused = 111,
        connection_reset = 104,
        cross_device_link = 18,
        destination_address_required = 89,
        device_or_resource_busy = 16,
        directory_not_empty = 39,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 36,
        function_not_supported = 38,
        host_unreachable = 113,
        identifier_removed = 43,
        illegal_byte_sequence = 84,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 90,
        network_down = 100,
        network_reset = 102,
        network_unreachable = 101,
        no_buffer_space = 105,
        no_child_process = 10,
        no_link = 67,
        no_lock_available = 37,
        no_message_available = 61,
        no_message = 42,
        no_protocol_option = 92,
        no_space_on_device = 28,
        no_stream_resources = 63,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 88,
        not_a_stream = 60,
        not_connected = 107,
        not_enough_memory = 12,
        not_supported = 95,
        operation_canceled = 125,
        operation_in_progress = 115,
        operation_not_permitted = 1,
        operation_not_supported = 95,
        operation_would_block = 11,
        owner_dead = 130,
        permission_denied = 13,
        protocol_error = 71,
        protocol_not_supported = 93,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 35,
        resource_unavailable_try_again = 11,
        result_out_of_range = 34,
        state_not_recoverable = 131,
        stream_timeout = 62,
        text_file_busy = 26,
        timed_out = 110,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_symbolic_link_levels = 40,
        value_too_large = 75,
        wrong_protocol_type = 91
    };
}
namespace std {
    struct __cow_string {
        union {
            const char *_M_p;
            char _M_bytes[8];
        };
        __cow_string();
        __cow_string(const std::string &);
        __cow_string(const char *, std::size_t);
        __cow_string(const std::__cow_string &) noexcept;
        std::__cow_string &operator=(const std::__cow_string &) noexcept;
        ~__cow_string();
        __cow_string(std::__cow_string &&) noexcept;
        std::__cow_string &operator=(std::__cow_string &&) noexcept;
    };
    typedef basic_string<char> __sso_string;
    class logic_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit logic_error(const std::string &__arg);
        explicit logic_error(const char *);
        logic_error(std::logic_error &&) noexcept;
        std::logic_error &operator=(std::logic_error &&) noexcept;
        logic_error(const std::logic_error &) noexcept;
        std::logic_error &operator=(const std::logic_error &) noexcept;
        virtual ~logic_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class domain_error : public std::logic_error {
    public:
        explicit domain_error(const std::string &__arg);
        explicit domain_error(const char *);
        domain_error(const std::domain_error &) = default
        std::domain_error &operator=(const std::domain_error &) = default
        domain_error(std::domain_error &&) = default
        std::domain_error &operator=(std::domain_error &&) = default
        virtual ~domain_error() noexcept;
    };
    class invalid_argument : public std::logic_error {
    public:
        explicit invalid_argument(const std::string &__arg);
        explicit invalid_argument(const char *);
        invalid_argument(const std::invalid_argument &) = default
        std::invalid_argument &operator=(const std::invalid_argument &) = default
        invalid_argument(std::invalid_argument &&) = default
        std::invalid_argument &operator=(std::invalid_argument &&) = default
        virtual ~invalid_argument() noexcept;
    };
    class length_error : public std::logic_error {
    public:
        explicit length_error(const std::string &__arg);
        explicit length_error(const char *);
        length_error(const std::length_error &) = default
        std::length_error &operator=(const std::length_error &) = default
        length_error(std::length_error &&) = default
        std::length_error &operator=(std::length_error &&) = default
        virtual ~length_error() noexcept;
    };
    class out_of_range : public std::logic_error {
    public:
        explicit out_of_range(const std::string &__arg);
        explicit out_of_range(const char *);
        out_of_range(const std::out_of_range &) = default
        std::out_of_range &operator=(const std::out_of_range &) = default
        out_of_range(std::out_of_range &&) = default
        std::out_of_range &operator=(std::out_of_range &&) = default
        virtual ~out_of_range() noexcept;
    };
    class runtime_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit runtime_error(const std::string &__arg);
        explicit runtime_error(const char *);
        runtime_error(std::runtime_error &&) noexcept;
        std::runtime_error &operator=(std::runtime_error &&) noexcept;
        runtime_error(const std::runtime_error &) noexcept;
        std::runtime_error &operator=(const std::runtime_error &) noexcept;
        virtual ~runtime_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class range_error : public std::runtime_error {
    public:
        explicit range_error(const std::string &__arg);
        explicit range_error(const char *);
        range_error(const std::range_error &) = default
        std::range_error &operator=(const std::range_error &) = default
        range_error(std::range_error &&) = default
        std::range_error &operator=(std::range_error &&) = default
        virtual ~range_error() noexcept;
    };
    class overflow_error : public std::runtime_error {
    public:
        explicit overflow_error(const std::string &__arg);
        explicit overflow_error(const char *);
        overflow_error(const std::overflow_error &) = default
        std::overflow_error &operator=(const std::overflow_error &) = default
        overflow_error(std::overflow_error &&) = default
        std::overflow_error &operator=(std::overflow_error &&) = default
        virtual ~overflow_error() noexcept;
    };
    class underflow_error : public std::runtime_error {
    public:
        explicit underflow_error(const std::string &__arg);
        explicit underflow_error(const char *);
        underflow_error(const std::underflow_error &) = default
        std::underflow_error &operator=(const std::underflow_error &) = default
        underflow_error(std::underflow_error &&) = default
        std::underflow_error &operator=(std::underflow_error &&) = default
        virtual ~underflow_error() noexcept;
    };
}
namespace std {
    class error_code;
    class error_condition;
    class system_error;
    template <typename _Tp> struct is_error_code_enum : public std::false_type {
    };
template<> struct is_error_code_enum<std::_V2::error_category> : public std::false_type {
    };
template<> struct is_error_code_enum<int> : public std::false_type {
    };
template<> struct is_error_code_enum<std::strong_ordering> : public std::false_type {
    };
template<> struct is_error_code_enum<std::error_code> : public std::false_type {
    };
template<> struct is_error_code_enum<const char *> : public std::false_type {
    };
    template <typename _Tp> struct is_error_condition_enum : public std::false_type {
    };
template<> struct is_error_condition_enum<std::_V2::error_category> : public std::false_type {
    };
template<> struct is_error_condition_enum<std::strong_ordering> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::errc> : public std::true_type {
    };
    template <typename _Tp> constexpr bool is_error_code_enum_v = is_error_code_enum<_Tp>::value;
    template <typename _Tp> constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;
    inline namespace _V2 {
        class error_category {
        public:
            error_category() noexcept = default
            virtual ~error_category();
            error_category(const std::_V2::error_category &) = delete
            std::_V2::error_category &operator=(const std::_V2::error_category &) = delete
            virtual const char *name() const noexcept = 0;
        private:
            virtual std::__cow_string _M_message(int) const __attribute__((abi_tag("cxx11")));
        public:
            virtual std::string message(int) const __attribute__((abi_tag("cxx11"))) = 0;
        public:
            virtual std::error_condition default_error_condition(int __i) const noexcept;
            virtual bool equivalent(int __i, const std::error_condition &__cond) const noexcept;
            virtual bool equivalent(const std::error_code &__code, int __i) const noexcept;
            bool operator==(const std::_V2::error_category &__other) const noexcept             {
                return this == &__other;
            }
            std::strong_ordering operator<=>(const std::_V2::error_category &__rhs) const noexcept             {
                return std::compare_three_way()(this, &__rhs);
            }
        };
        const std::_V2::error_category &generic_category() noexcept __attribute__((const));
        const std::_V2::error_category &system_category() noexcept __attribute__((const));
    }
    std::error_code make_error_code(std::errc) noexcept;
    class error_code {
    public:
        error_code() noexcept : _M_value(0), _M_cat(&system_category())         {
        }
        error_code(int __v, const std::_V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat)         {
        }
        template <typename _ErrorCodeEnum, typename = typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type> error_code(_ErrorCodeEnum __e) noexcept         {
            *this = make_error_code(__e);
        }
        template<> error_code<std::io_errc, void>(std::io_errc __e) noexcept        void assign(int __v, const std::_V2::error_category &__cat) noexcept         {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        void clear() noexcept         {
            this->assign(0, system_category());
        }
        template <typename _ErrorCodeEnum> typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value, error_code &>::type operator=(_ErrorCodeEnum __e) noexcept         {
            return *this = make_error_code(__e);
        }
        int value() const noexcept         {
            return this->_M_value;
        }
        const std::_V2::error_category &category() const noexcept         {
            return *this->_M_cat;
        }
        std::error_condition default_error_condition() const noexcept;
        std::string message() const __attribute__((abi_tag("cxx11")))         {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept         {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const std::_V2::error_category *_M_cat;
    };
    inline std::error_code make_error_code(std::errc __e) noexcept     {
        return std::error_code(static_cast<int>(__e), generic_category());
    }
    inline std::strong_ordering operator<=>(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
            return __c;
        return __lhs.value() <=> __rhs.value();
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::error_code &__e)     {
        return (__os << __e.category().name() << ':' << __e.value());
    }
    std::error_condition make_error_condition(std::errc) noexcept;
    class error_condition {
    public:
        error_condition() noexcept : _M_value(0), _M_cat(&generic_category())         {
        }
        error_condition(int __v, const std::_V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat)         {
        }
        template <typename _ErrorConditionEnum, typename = typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type> error_condition(_ErrorConditionEnum __e) noexcept         {
            *this = make_error_condition(__e);
        }
        void assign(int __v, const std::_V2::error_category &__cat) noexcept         {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        template <typename _ErrorConditionEnum> typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value, error_condition &>::type operator=(_ErrorConditionEnum __e) noexcept         {
            return *this = make_error_condition(__e);
        }
        void clear() noexcept         {
            this->assign(0, generic_category());
        }
        int value() const noexcept         {
            return this->_M_value;
        }
        const std::_V2::error_category &category() const noexcept         {
            return *this->_M_cat;
        }
        std::string message() const __attribute__((abi_tag("cxx11")))         {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept         {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const std::_V2::error_category *_M_cat;
    };
    inline std::error_condition make_error_condition(std::errc __e) noexcept     {
        return std::error_condition(static_cast<int>(__e), generic_category());
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value()));
    }
    inline bool operator==(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline std::strong_ordering operator<=>(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
            return __c;
        return __lhs.value() <=> __rhs.value();
    }
    class system_error : public std::runtime_error {
    private:
        std::error_code _M_code;
    public:
        system_error(std::error_code __ec = std::error_code()) : std::runtime_error(__ec.message()), _M_code(__ec)         {
        }
        system_error(std::error_code __ec, const std::string &__what) : std::runtime_error(__what + ": " + __ec.message()), _M_code(__ec)         {
        }
        system_error(std::error_code __ec, const char *__what) : std::runtime_error(__what + (": " + __ec.message())), _M_code(__ec)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat, const char *__what) : NULL TYPE(std::error_code(__v, __ecat), __what)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat) : std::runtime_error(std::error_code(__v, __ecat).message()), _M_code(__v, __ecat)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat, const std::string &__what) : std::runtime_error(__what + ": " + std::error_code(__v, __ecat).message()), _M_code(__v, __ecat)         {
        }
        system_error(const std::system_error &) = default
        std::system_error &operator=(const std::system_error &) = default
        virtual ~system_error() noexcept;
        const std::error_code &code() const noexcept         {
            return this->_M_code;
        }
    };
}
namespace std {
    template<> struct hash<std::error_code> : public __hash_base<std::size_t, std::error_code> {
        std::size_t operator()(const std::error_code &__e) const noexcept         {
            const std::size_t __tmp = std::_Hash_impl::hash(__e.value());
            return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
        }
    };
    template<> struct hash<std::error_condition> : public __hash_base<std::size_t, std::error_condition> {
        std::size_t operator()(const std::error_condition &__e) const noexcept         {
            const std::size_t __tmp = std::_Hash_impl::hash(__e.value());
            return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
        }
    };
}
namespace std {
    enum _Ios_Fmtflags {
        _S_boolalpha = 1L << 0,
        _S_dec = 1L << 1,
        _S_fixed = 1L << 2,
        _S_hex = 1L << 3,
        _S_internal = 1L << 4,
        _S_left = 1L << 5,
        _S_oct = 1L << 6,
        _S_right = 1L << 7,
        _S_scientific = 1L << 8,
        _S_showbase = 1L << 9,
        _S_showpoint = 1L << 10,
        _S_showpos = 1L << 11,
        _S_skipws = 1L << 12,
        _S_unitbuf = 1L << 13,
        _S_uppercase = 1L << 14,
        _S_adjustfield = _S_left | _S_right | _S_internal,
        _S_basefield = _S_dec | _S_oct | _S_hex,
        _S_floatfield = _S_scientific | _S_fixed,
        _S_ios_fmtflags_end = 1L << 16,
        _S_ios_fmtflags_max = 2147483647,
        _S_ios_fmtflags_min = ~2147483647
    };
    inline constexpr std::_Ios_Fmtflags operator&(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator|(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator^(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator~(std::_Ios_Fmtflags __a)     {
        return std::_Ios_Fmtflags(~static_cast<int>(__a));
    }
    inline const std::_Ios_Fmtflags &operator|=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Fmtflags &operator&=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Fmtflags &operator^=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Openmode {
        _S_app = 1L << 0,
        _S_ate = 1L << 1,
        _S_bin = 1L << 2,
        _S_in = 1L << 3,
        _S_out = 1L << 4,
        _S_trunc = 1L << 5,
        _S_noreplace = 1L << 6,
        _S_ios_openmode_end = 1L << 16,
        _S_ios_openmode_max = 2147483647,
        _S_ios_openmode_min = ~2147483647
    };
    inline constexpr std::_Ios_Openmode operator&(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator|(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator^(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator~(std::_Ios_Openmode __a)     {
        return std::_Ios_Openmode(~static_cast<int>(__a));
    }
    inline const std::_Ios_Openmode &operator|=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Openmode &operator&=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Openmode &operator^=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Iostate {
        _S_goodbit = 0,
        _S_badbit = 1L << 0,
        _S_eofbit = 1L << 1,
        _S_failbit = 1L << 2,
        _S_ios_iostate_end = 1L << 16,
        _S_ios_iostate_max = 2147483647,
        _S_ios_iostate_min = ~2147483647
    };
    inline constexpr std::_Ios_Iostate operator&(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator|(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator^(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator~(std::_Ios_Iostate __a)     {
        return std::_Ios_Iostate(~static_cast<int>(__a));
    }
    inline const std::_Ios_Iostate &operator|=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Iostate &operator&=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Iostate &operator^=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Seekdir {
        _S_beg = 0,
        _S_cur = 1,
        _S_end = 2,
        _S_ios_seekdir_end = 1L << 16
    };
    enum class io_errc : int {
        stream = 1
    };
    template<> struct is_error_code_enum<std::io_errc> : public std::true_type {
    };
    const std::_V2::error_category &iostream_category() noexcept;
    inline std::error_code make_error_code(std::io_errc __e) noexcept     {
        return std::error_code(static_cast<int>(__e), iostream_category());
    }
    inline std::error_condition make_error_condition(std::io_errc __e) noexcept     {
        return std::error_condition(static_cast<int>(__e), iostream_category());
    }
    class ios_base {
    public:
        class __attribute__((abi_tag("cxx11"))) failure : public std::system_error {
        public:
            explicit failure(const std::string &__str);
            explicit failure(const std::string &, const std::error_code &);
            explicit failure(const char *, const std::error_code & = io_errc::stream);
            virtual ~failure() throw();
            virtual const char *what() const throw();
        };
        typedef std::_Ios_Fmtflags fmtflags;
        static const std::ios_base::fmtflags boolalpha = _S_boolalpha;
        static const std::ios_base::fmtflags dec = _S_dec;
        static const std::ios_base::fmtflags fixed = _S_fixed;
        static const std::ios_base::fmtflags hex = _S_hex;
        static const std::ios_base::fmtflags internal = _S_internal;
        static const std::ios_base::fmtflags left = _S_left;
        static const std::ios_base::fmtflags oct = _S_oct;
        static const std::ios_base::fmtflags right = _S_right;
        static const std::ios_base::fmtflags scientific = _S_scientific;
        static const std::ios_base::fmtflags showbase = _S_showbase;
        static const std::ios_base::fmtflags showpoint = _S_showpoint;
        static const std::ios_base::fmtflags showpos = _S_showpos;
        static const std::ios_base::fmtflags skipws = _S_skipws;
        static const std::ios_base::fmtflags unitbuf = _S_unitbuf;
        static const std::ios_base::fmtflags uppercase = _S_uppercase;
        static const std::ios_base::fmtflags adjustfield = _S_adjustfield;
        static const std::ios_base::fmtflags basefield = _S_basefield;
        static const std::ios_base::fmtflags floatfield = _S_floatfield;
        typedef std::_Ios_Iostate iostate;
        static const std::ios_base::iostate badbit = _S_badbit;
        static const std::ios_base::iostate eofbit = _S_eofbit;
        static const std::ios_base::iostate failbit = _S_failbit;
        static const std::ios_base::iostate goodbit = _S_goodbit;
        typedef std::_Ios_Openmode openmode;
        static const std::ios_base::openmode app = _S_app;
        static const std::ios_base::openmode ate = _S_ate;
        static const std::ios_base::openmode binary = _S_bin;
        static const std::ios_base::openmode in = _S_in;
        static const std::ios_base::openmode out = _S_out;
        static const std::ios_base::openmode trunc = _S_trunc;
        static const std::ios_base::openmode __noreplace = _S_noreplace;
        typedef std::_Ios_Seekdir seekdir;
        static const std::ios_base::seekdir beg = _S_beg;
        static const std::ios_base::seekdir cur = _S_cur;
        static const std::ios_base::seekdir end = _S_end;
        enum event {
            erase_event,
            imbue_event,
            copyfmt_event
        };
        typedef void (*event_callback)(std::ios_base::event, std::ios_base &, int);
        void register_callback(std::ios_base::event_callback __fn, int __index);
    protected:
        std::streamsize _M_precision;
        std::streamsize _M_width;
        std::ios_base::fmtflags _M_flags;
        std::ios_base::iostate _M_exception;
        std::ios_base::iostate _M_streambuf_state;
        struct _Callback_list {
            std::ios_base::_Callback_list *_M_next;
            ios_base::event_callback _M_fn;
            int _M_index;
            _Atomic_word _M_refcount;
            _Callback_list(ios_base::event_callback __fn, int __index, std::ios_base::_Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)             {
            }
            void _M_add_reference()             {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
            }
            int _M_remove_reference()             {
                ;
                int __res = __gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1);
                if (__res == 0) {
                    ;
                }
                return __res;
            }
        };
        std::ios_base::_Callback_list *_M_callbacks;
        void _M_call_callbacks(std::ios_base::event __ev) throw();
        void _M_dispose_callbacks() throw();
        struct _Words {
            void *_M_pword;
            long _M_iword;
            _Words() : _M_pword(0), _M_iword(0)             {
            }
        };
        std::ios_base::_Words _M_word_zero;
        enum  {
            _S_local_word_size = 8
        };
        std::ios_base::_Words _M_local_word[8];
        int _M_word_size;
        std::ios_base::_Words *_M_word;
        std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
        std::locale _M_ios_locale;
        void _M_init() throw();
    public:
        class Init {
            friend  class ios_base;
        public:
            Init();
            ~Init() noexcept;
            Init(const std::ios_base::Init &) = default
            std::ios_base::Init &operator=(const std::ios_base::Init &) = default
        private:
            static _Atomic_word _S_refcount;
            static bool _S_synced_with_stdio;
        };
        std::ios_base::fmtflags flags() const         {
            return this->_M_flags;
        }
        std::ios_base::fmtflags flags(std::ios_base::fmtflags __fmtfl)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags = __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags |= __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl, std::ios_base::fmtflags __mask)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags &= ~ __mask;
            this->_M_flags |= (__fmtfl & __mask);
            return __old;
        }
        void unsetf(std::ios_base::fmtflags __mask)         {
            this->_M_flags &= ~ __mask;
        }
        std::streamsize precision() const         {
            return this->_M_precision;
        }
        std::streamsize precision(std::streamsize __prec)         {
            std::streamsize __old = this->_M_precision;
            this->_M_precision = __prec;
            return __old;
        }
        std::streamsize width() const         {
            return this->_M_width;
        }
        std::streamsize width(std::streamsize __wide)         {
            std::streamsize __old = this->_M_width;
            this->_M_width = __wide;
            return __old;
        }
        static bool sync_with_stdio(bool __sync = true);
        std::locale imbue(const std::locale &__loc) throw();
        std::locale getloc() const         {
            return this->_M_ios_locale;
        }
        const std::locale &_M_getloc() const         {
            return this->_M_ios_locale;
        }
        static int xalloc() throw();
        long &iword(int __ix)         {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, true);
            return __word._M_iword;
        }
        void *&pword(int __ix)         {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, false);
            return __word._M_pword;
        }
        virtual ~ios_base() throw();
    protected:
        ios_base() throw();
    public:
        ios_base(const std::ios_base &) = delete
        std::ios_base &operator=(const std::ios_base &) = delete
    protected:
        void _M_move(std::ios_base &) noexcept;
        void _M_swap(std::ios_base &__rhs) noexcept;
    };
    inline std::ios_base &boolalpha(std::ios_base &__base)     {
        __base.setf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &noboolalpha(std::ios_base &__base)     {
        __base.unsetf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &showbase(std::ios_base &__base)     {
        __base.setf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &noshowbase(std::ios_base &__base)     {
        __base.unsetf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &showpoint(std::ios_base &__base)     {
        __base.setf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &noshowpoint(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &showpos(std::ios_base &__base)     {
        __base.setf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &noshowpos(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &skipws(std::ios_base &__base)     {
        __base.setf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &noskipws(std::ios_base &__base)     {
        __base.unsetf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &uppercase(std::ios_base &__base)     {
        __base.setf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &nouppercase(std::ios_base &__base)     {
        __base.unsetf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &unitbuf(std::ios_base &__base)     {
        __base.setf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &nounitbuf(std::ios_base &__base)     {
        __base.unsetf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &internal(std::ios_base &__base)     {
        __base.setf(ios_base::internal, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &left(std::ios_base &__base)     {
        __base.setf(ios_base::left, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &right(std::ios_base &__base)     {
        __base.setf(ios_base::right, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &dec(std::ios_base &__base)     {
        __base.setf(ios_base::dec, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &hex(std::ios_base &__base)     {
        __base.setf(ios_base::hex, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &oct(std::ios_base &__base)     {
        __base.setf(ios_base::oct, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &fixed(std::ios_base &__base)     {
        __base.setf(ios_base::fixed, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &scientific(std::ios_base &__base)     {
        __base.setf(ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &hexfloat(std::ios_base &__base)     {
        __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &defaultfloat(std::ios_base &__base)     {
        __base.unsetf(ios_base::floatfield);
        return __base;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf::char_type, std::basic_streambuf::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(std::istream &, char *, std::streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf::char_type *_M_in_beg;
        std::basic_streambuf::char_type *_M_in_cur;
        std::basic_streambuf::char_type *_M_in_end;
        std::basic_streambuf::char_type *_M_out_beg;
        std::basic_streambuf::char_type *_M_out_cur;
        std::basic_streambuf::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<_CharT, _Traits>()         {
        }
        std::locale pubimbue(const std::locale &__loc)         {
            std::locale __tmp(this->getloc());
            this->imbue(__loc);
            this->_M_buf_locale = __loc;
            return __tmp;
        }
        std::locale getloc() const         {
            return this->_M_buf_locale;
        }
        basic_streambuf<_CharT, _Traits> *pubsetbuf(std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->setbuf(__s, __n);
        }
        std::basic_streambuf::pos_type pubseekoff(std::basic_streambuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekoff(__off, __way, __mode);
        }
        std::basic_streambuf::pos_type pubseekpos(std::basic_streambuf::pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekpos(__sp, __mode);
        }
        int pubsync()         {
            return this->sync();
        }
        std::streamsize in_avail()         {
            const std::streamsize __ret = this->egptr() - this->gptr();
            return __ret ? __ret : this->showmanyc();
        }
        std::basic_streambuf::int_type snextc()         {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
                __ret = this->sgetc();
            return __ret;
        }
        std::basic_streambuf::int_type sbumpc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true)) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            } else
                __ret = this->uflow();
            return __ret;
        }
        std::basic_streambuf::int_type sgetc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true))
                __ret = traits_type::to_int_type(*this->gptr());
            else
                __ret = this->underflow();
            return __ret;
        }
        std::streamsize sgetn(std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->xsgetn(__s, __n);
        }
        std::basic_streambuf::int_type sputbackc(std::basic_streambuf::char_type __c)         {
            std::basic_streambuf::int_type __ret;
            const bool __testpos = this->eback() < this->gptr();
            if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
                __ret = this->pbackfail(traits_type::to_int_type(__c));
            else {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            }
            return __ret;
        }
        std::basic_streambuf::int_type sungetc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->eback() < this->gptr(), true)) {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            } else
                __ret = this->pbackfail();
            return __ret;
        }
        std::basic_streambuf::int_type sputc(std::basic_streambuf::char_type __c)         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->pptr() < this->epptr(), true)) {
                *this->pptr() = __c;
                this->pbump(1);
                __ret = traits_type::to_int_type(__c);
            } else
                __ret = this->overflow(traits_type::to_int_type(__c));
            return __ret;
        }
        std::streamsize sputn(const std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->xsputn(__s, __n);
        }
    protected:
        basic_streambuf<_CharT, _Traits>() : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(std::locale())         {
        }
        std::basic_streambuf::char_type *eback() const         {
            return this->_M_in_beg;
        }
        std::basic_streambuf::char_type *gptr() const         {
            return this->_M_in_cur;
        }
        std::basic_streambuf::char_type *egptr() const         {
            return this->_M_in_end;
        }
        void gbump(int __n)         {
            this->_M_in_cur += __n;
        }
        void setg(std::basic_streambuf::char_type *__gbeg, std::basic_streambuf::char_type *__gnext, std::basic_streambuf::char_type *__gend)         {
            this->_M_in_beg = __gbeg;
            this->_M_in_cur = __gnext;
            this->_M_in_end = __gend;
        }
        std::basic_streambuf::char_type *pbase() const         {
            return this->_M_out_beg;
        }
        std::basic_streambuf::char_type *pptr() const         {
            return this->_M_out_cur;
        }
        std::basic_streambuf::char_type *epptr() const         {
            return this->_M_out_end;
        }
        void pbump(int __n)         {
            this->_M_out_cur += __n;
        }
        void setp(std::basic_streambuf::char_type *__pbeg, std::basic_streambuf::char_type *__pend)         {
            this->_M_out_beg = this->_M_out_cur = __pbeg;
            this->_M_out_end = __pend;
        }
        virtual void imbue(const std::locale &__loc __attribute__((unused)))         {
        }
        virtual basic_streambuf<std::basic_streambuf::char_type, _Traits> *setbuf(std::basic_streambuf::char_type *, std::streamsize)         {
            return this;
        }
        virtual std::basic_streambuf::pos_type seekoff(std::basic_streambuf::off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual std::basic_streambuf::pos_type seekpos(std::basic_streambuf::pos_type, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual int sync()         {
            return 0;
        }
        virtual std::streamsize showmanyc()         {
            return 0;
        }
        virtual std::streamsize xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type underflow()         {
            return traits_type::eof();
        }
        virtual std::basic_streambuf::int_type uflow()         {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
            if (!__testeof) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            }
            return __ret;
        }
        virtual std::basic_streambuf::int_type pbackfail(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused)))         {
            return traits_type::eof();
        }
        virtual std::streamsize xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type overflow(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused)))         {
            return traits_type::eof();
        }
        void __safe_gbump(std::streamsize __n)         {
            this->_M_in_cur += __n;
        }
        void __safe_pbump(std::streamsize __n)         {
            this->_M_out_cur += __n;
        }
    protected:
        basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &);
        basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &);
        void swap(basic_streambuf<_CharT, _Traits> &__sb)         {
            std::swap(this->_M_in_beg, __sb._M_in_beg);
            std::swap(this->_M_in_cur, __sb._M_in_cur);
            std::swap(this->_M_in_end, __sb._M_in_end);
            std::swap(this->_M_out_beg, __sb._M_out_beg);
            std::swap(this->_M_out_cur, __sb._M_out_cur);
            std::swap(this->_M_out_end, __sb._M_out_end);
            std::swap(this->_M_buf_locale, __sb._M_buf_locale);
        }
    };
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits>::basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &) = default
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits> &std::basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf<_CharT, _Traits> &) = default
    template<> std::streamsize __copy_streambufs_eof<char, std::char_traits<char>>(basic_streambuf<char> *__sbin, basic_streambuf<char> *__sbout, bool &__ineof);
    template<> std::streamsize __copy_streambufs_eof<wchar_t, std::char_traits<wchar_t>>(basic_streambuf<wchar_t> *__sbin, basic_streambuf<wchar_t> *__sbout, bool &__ineof);
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n)     {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->egptr() - this->gptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(__s, this->gptr(), __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_gbump(__len);
                }
                if (__ret < __n) {
                    const std::basic_streambuf::int_type __c = this->uflow();
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        traits_type::assign(*__s++, traits_type::to_char_type(__c));
                        ++__ret;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n)     {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->epptr() - this->pptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(this->pptr(), __s, __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_pbump(__len);
                }
                if (__ret < __n) {
                    std::basic_streambuf::int_type __c = this->overflow(traits_type::to_int_type(*__s));
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        ++__ret;
                        ++__s;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)     {
        std::streamsize __ret = 0;
        __ineof = true;
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
            {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof())) {
                    __ineof = false;
                    break;
                }
                ++__ret;
                __c = __sbin->snextc();
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> inline std::streamsize __copy_streambufs(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout)     {
        bool __ineof;
        return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
    template<> class basic_streambuf<char> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<char, std::char_traits<char>>::char_type, std::basic_streambuf<char, std::char_traits<char>>::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(std::istream &, char *, std::streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_in_beg;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_in_cur;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_in_end;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_out_beg;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_out_cur;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<char>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<char> *pubsetbuf(std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char, std::char_traits<char>>::pos_type pubseekoff(std::basic_streambuf<char, std::char_traits<char>>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<char, std::char_traits<char>>::pos_type pubseekpos(std::basic_streambuf<char, std::char_traits<char>>::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<char, std::char_traits<char>>::int_type snextc();
        std::basic_streambuf<char, std::char_traits<char>>::int_type sbumpc();
        std::basic_streambuf<char, std::char_traits<char>>::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char, std::char_traits<char>>::int_type sputbackc(std::basic_streambuf<char, std::char_traits<char>>::char_type __c);
        std::basic_streambuf<char, std::char_traits<char>>::int_type sungetc();
        std::basic_streambuf<char, std::char_traits<char>>::int_type sputc(std::basic_streambuf<char, std::char_traits<char>>::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf();
        std::basic_streambuf<char, std::char_traits<char>>::char_type *eback() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *gptr() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *egptr() const;
        void gbump(int __n);
        void setg(std::basic_streambuf<char, std::char_traits<char>>::char_type *__gbeg, std::basic_streambuf<char, std::char_traits<char>>::char_type *__gnext, std::basic_streambuf<char, std::char_traits<char>>::char_type *__gend);
        std::basic_streambuf<char, std::char_traits<char>>::char_type *pbase() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *pptr() const;
        std::basic_streambuf<char, std::char_traits<char>>::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<char, std::char_traits<char>>::char_type *__pbeg, std::basic_streambuf<char, std::char_traits<char>>::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<char, std::char_traits<char>>::char_type, std::char_traits<char>> *setbuf(std::basic_streambuf<char, std::char_traits<char>>::char_type *, std::streamsize);
        virtual std::basic_streambuf<char, std::char_traits<char>>::pos_type seekoff(std::basic_streambuf<char, std::char_traits<char>>::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<char, std::char_traits<char>>::pos_type seekpos(std::basic_streambuf<char, std::char_traits<char>>::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type underflow();
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type uflow();
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type pbackfail(std::basic_streambuf<char, std::char_traits<char>>::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char, std::char_traits<char>>::int_type overflow(std::basic_streambuf<char, std::char_traits<char>>::int_type __c __attribute__((unused)));
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<char> &);
        std::basic_streambuf<char> &operator=(const std::basic_streambuf<char> &);
        void swap(std::basic_streambuf<char> &__sb);
    };
    template<> class basic_streambuf<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend void __istream_extract(std::istream &, char *, std::streamsize);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_in_beg;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_in_cur;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_in_end;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_out_beg;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_out_cur;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<wchar_t>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<wchar_t> *pubsetbuf(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type pubseekoff(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type pubseekpos(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type snextc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sbumpc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sputbackc(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sungetc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type sputc(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *eback() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *gptr() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *egptr() const;
        void gbump(int __n);
        void setg(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__gbeg, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__gnext, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__gend);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *pbase() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *pptr() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__pbeg, std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type, std::char_traits<wchar_t>> *setbuf(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *, std::streamsize);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type seekoff(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type seekpos(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type underflow();
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type uflow();
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type pbackfail(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type overflow(std::basic_streambuf<wchar_t, std::char_traits<wchar_t>>::int_type __c __attribute__((unused)));
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<wchar_t> &);
        std::basic_streambuf<wchar_t> &operator=(const std::basic_streambuf<wchar_t> &);
        void swap(std::basic_streambuf<wchar_t> &__sb);
    };
}
typedef unsigned long wctype_t;
enum  {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = ((__ISwupper) < 8 ? (int)((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int)((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int)((1UL << (__ISwupper)) >> 8) : (int)((1UL << (__ISwupper)) >> 24)))),
    _ISwlower = ((__ISwlower) < 8 ? (int)((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int)((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int)((1UL << (__ISwlower)) >> 8) : (int)((1UL << (__ISwlower)) >> 24)))),
    _ISwalpha = ((__ISwalpha) < 8 ? (int)((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int)((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int)((1UL << (__ISwalpha)) >> 8) : (int)((1UL << (__ISwalpha)) >> 24)))),
    _ISwdigit = ((__ISwdigit) < 8 ? (int)((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int)((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int)((1UL << (__ISwdigit)) >> 8) : (int)((1UL << (__ISwdigit)) >> 24)))),
    _ISwxdigit = ((__ISwxdigit) < 8 ? (int)((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int)((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int)((1UL << (__ISwxdigit)) >> 8) : (int)((1UL << (__ISwxdigit)) >> 24)))),
    _ISwspace = ((__ISwspace) < 8 ? (int)((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int)((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int)((1UL << (__ISwspace)) >> 8) : (int)((1UL << (__ISwspace)) >> 24)))),
    _ISwprint = ((__ISwprint) < 8 ? (int)((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int)((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int)((1UL << (__ISwprint)) >> 8) : (int)((1UL << (__ISwprint)) >> 24)))),
    _ISwgraph = ((__ISwgraph) < 8 ? (int)((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int)((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int)((1UL << (__ISwgraph)) >> 8) : (int)((1UL << (__ISwgraph)) >> 24)))),
    _ISwblank = ((__ISwblank) < 8 ? (int)((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int)((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int)((1UL << (__ISwblank)) >> 8) : (int)((1UL << (__ISwblank)) >> 24)))),
    _ISwcntrl = ((__ISwcntrl) < 8 ? (int)((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int)((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int)((1UL << (__ISwcntrl)) >> 8) : (int)((1UL << (__ISwcntrl)) >> 24)))),
    _ISwpunct = ((__ISwpunct) < 8 ? (int)((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int)((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int)((1UL << (__ISwpunct)) >> 8) : (int)((1UL << (__ISwpunct)) >> 24)))),
    _ISwalnum = ((__ISwalnum) < 8 ? (int)((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int)((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int)((1UL << (__ISwalnum)) >> 8) : (int)((1UL << (__ISwalnum)) >> 24))))
};
extern "C" {
    extern int iswalnum(wint_t __wc) noexcept(trueiswalnum(wint_t __wc) noexcept(true);
    extern int iswalpha(wint_t __wc) noexcept(trueiswalpha(wint_t __wc) noexcept(true);
    extern int iswcntrl(wint_t __wc) noexcept(trueiswcntrl(wint_t __wc) noexcept(true);
    extern int iswdigit(wint_t __wc) noexcept(trueiswdigit(wint_t __wc) noexcept(true);
    extern int iswgraph(wint_t __wc) noexcept(trueiswgraph(wint_t __wc) noexcept(true);
    extern int iswlower(wint_t __wc) noexcept(trueiswlower(wint_t __wc) noexcept(true);
    extern int iswprint(wint_t __wc) noexcept(trueiswprint(wint_t __wc) noexcept(true);
    extern int iswpunct(wint_t __wc) noexcept(trueiswpunct(wint_t __wc) noexcept(true);
    extern int iswspace(wint_t __wc) noexcept(trueiswspace(wint_t __wc) noexcept(true);
    extern int iswupper(wint_t __wc) noexcept(trueiswupper(wint_t __wc) noexcept(true);
    extern int iswxdigit(wint_t __wc) noexcept(trueiswxdigit(wint_t __wc) noexcept(true);
    extern int iswblank(wint_t __wc) noexcept(trueiswblank(wint_t __wc) noexcept(true);
    extern wctype_t wctype(const char *__property) noexcept(truewctype(const char *__property) noexcept(true);
    extern int iswctype(wint_t __wc, wctype_t __desc) noexcept(trueiswctype(wint_t __wc, wctype_t __desc) noexcept(true);
    extern wint_t towlower(wint_t __wc) noexcept(truetowlower(wint_t __wc) noexcept(true);
    extern wint_t towupper(wint_t __wc) noexcept(truetowupper(wint_t __wc) noexcept(true);
}
extern "C" {
    typedef const __int32_t *wctrans_t;
    extern wctrans_t wctrans(const char *__property) noexcept(truewctrans(const char *__property) noexcept(true);
    extern wint_t towctrans(wint_t __wc, wctrans_t __desc) noexcept(truetowctrans(wint_t __wc, wctrans_t __desc) noexcept(true);
    extern int iswalnum_l(wint_t __wc, locale_t __locale) noexcept(trueiswalnum_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswalpha_l(wint_t __wc, locale_t __locale) noexcept(trueiswalpha_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswcntrl_l(wint_t __wc, locale_t __locale) noexcept(trueiswcntrl_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswdigit_l(wint_t __wc, locale_t __locale) noexcept(trueiswdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswgraph_l(wint_t __wc, locale_t __locale) noexcept(trueiswgraph_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswlower_l(wint_t __wc, locale_t __locale) noexcept(trueiswlower_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswprint_l(wint_t __wc, locale_t __locale) noexcept(trueiswprint_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswpunct_l(wint_t __wc, locale_t __locale) noexcept(trueiswpunct_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswspace_l(wint_t __wc, locale_t __locale) noexcept(trueiswspace_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswupper_l(wint_t __wc, locale_t __locale) noexcept(trueiswupper_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswxdigit_l(wint_t __wc, locale_t __locale) noexcept(trueiswxdigit_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern int iswblank_l(wint_t __wc, locale_t __locale) noexcept(trueiswblank_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wctype_t wctype_l(const char *__property, locale_t __locale) noexcept(truewctype_l(const char *__property, locale_t __locale) noexcept(true);
    extern int iswctype_l(wint_t __wc, wctype_t __desc, locale_t __locale) noexcept(trueiswctype_l(wint_t __wc, wctype_t __desc, locale_t __locale) noexcept(true);
    extern wint_t towlower_l(wint_t __wc, locale_t __locale) noexcept(truetowlower_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wint_t towupper_l(wint_t __wc, locale_t __locale) noexcept(truetowupper_l(wint_t __wc, locale_t __locale) noexcept(true);
    extern wctrans_t wctrans_l(const char *__property, locale_t __locale) noexcept(truewctrans_l(const char *__property, locale_t __locale) noexcept(true);
    extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, locale_t __locale) noexcept(truetowctrans_l(wint_t __wc, wctrans_t __desc, locale_t __locale) noexcept(true);
}
namespace std {
    using ::wctrans_t;
    using ::wctype_t;
    using ::wint_t;
    using ::iswalnum;
    using ::iswalpha;
    using ::iswblank;
    using ::iswcntrl;
    using ::iswctype;
    using ::iswdigit;
    using ::iswgraph;
    using ::iswlower;
    using ::iswprint;
    using ::iswpunct;
    using ::iswspace;
    using ::iswupper;
    using ::iswxdigit;
    using ::towctrans;
    using ::towlower;
    using ::towupper;
    using ::wctrans;
    using ::wctype;
}
namespace std {
    struct ctype_base {
        typedef const int *__to_type;
        typedef unsigned short mask;
        static const std::ctype_base::mask upper = _ISupper;
        static const std::ctype_base::mask lower = _ISlower;
        static const std::ctype_base::mask alpha = _ISalpha;
        static const std::ctype_base::mask digit = _ISdigit;
        static const std::ctype_base::mask xdigit = _ISxdigit;
        static const std::ctype_base::mask space = _ISspace;
        static const std::ctype_base::mask print = _ISprint;
        static const std::ctype_base::mask graph = _ISalpha | _ISdigit | _ISpunct;
        static const std::ctype_base::mask cntrl = _IScntrl;
        static const std::ctype_base::mask punct = _ISpunct;
        static const std::ctype_base::mask alnum = _ISalpha | _ISdigit;
        static const std::ctype_base::mask blank = _ISblank;
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator : public iterator<std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT> {
    public:
        using pointer = void;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename _Traits::int_type int_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_istream<_CharT, _Traits> istream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2 *, bool);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2>>::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
    private:
        mutable std::istreambuf_iterator::streambuf_type *_M_sbuf;
        std::istreambuf_iterator::int_type _M_c;
    public:
        constexpr istreambuf_iterator<_CharT, _Traits>() noexcept : _M_sbuf(0), _M_c(traits_type::eof())         {
        }
        constexpr istreambuf_iterator<_CharT, _Traits>(std::default_sentinel_t) noexcept : istreambuf_iterator<_CharT, _Traits>()         {
        }
        istreambuf_iterator<_CharT, _Traits>(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        ~istreambuf_iterator<_CharT, _Traits>() = default
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::istream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits> &operator=(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        std::istreambuf_iterator::char_type operator*() const [[nodiscard("")]]         {
            std::istreambuf_iterator::int_type __c = this->_M_get();
            return traits_type::to_char_type(__c);
        }
        istreambuf_iterator<_CharT, _Traits> &operator++()         {
            ;
            this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return *this;
        }
        istreambuf_iterator<_CharT, _Traits> operator++(int)         {
            ;
            istreambuf_iterator<_CharT, _Traits> __old = *this;
            __old._M_c = this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return __old;
        }
        bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const [[nodiscard("")]]         {
            return this->_M_at_eof() == __b._M_at_eof();
        }
    private:
        std::istreambuf_iterator::int_type _M_get() const         {
            std::istreambuf_iterator::int_type __ret = this->_M_c;
            if (this->_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = this->_M_sbuf->sgetc()))
                this->_M_sbuf = 0;
            return __ret;
        }
        bool _M_at_eof() const         {
            return _S_is_eof(this->_M_get());
        }
        static bool _S_is_eof(std::istreambuf_iterator::int_type __c)         {
            const std::istreambuf_iterator::int_type __eof = traits_type::eof();
            return traits_type::eq_int_type(__c, __eof);
        }
        friend bool operator==(const istreambuf_iterator<_CharT, _Traits> &__i, std::default_sentinel_t __s) [[nodiscard("")]]         {
            return __i._M_at_eof();
        }
;
    };
    template <typename _CharT, typename _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) [[nodiscard("")]]     {
        return __a.equal(__b);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    public:
        using difference_type = std::ptrdiff_t;
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2>>::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
    private:
        std::ostreambuf_iterator::streambuf_type *_M_sbuf;
        bool _M_failed;
    public:
        constexpr ostreambuf_iterator<_CharT, _Traits>() noexcept : _M_sbuf(nullptr), _M_failed(true)         {
        }
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::ostream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_failed(!this->_M_sbuf)         {
        }
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_failed(!this->_M_sbuf)         {
        }
        ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c)         {
            if (!this->_M_failed && _Traits::eq_int_type(this->_M_sbuf->sputc(__c), _Traits::eof()))
                this->_M_failed = true;
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator*() [[nodiscard("")]]         {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++(int)         {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++()         {
            return *this;
        }
        bool failed() const noexcept [[nodiscard("")]]         {
            return this->_M_failed;
        }
        ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, std::streamsize __len)         {
            if (__builtin_expect(!this->_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
                this->_M_failed = true;
            return *this;
        }
    };
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type copy(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, ostreambuf_iterator<_CharT> __result)     {
        if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed) {
            bool __ineof;
            __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
            if (!__ineof)
                __result._M_failed = true;
        }
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT>>::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, _CharT *__result)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf) {
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    const std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        traits_type::copy(__result, __sb->gptr(), __n);
                        __sb->__safe_gbump(__n);
                        __result += __n;
                        __c = __sb->underflow();
                    } else {
                        *__result++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                    }
                }
        }
        return __result;
    }
    template <typename _CharT, typename _Size> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT *__result, bool __strict __attribute__((unused)))     {
        if (__n == 0)
            return __result;
        ;
        _CharT *__beg = __result;
        __result += __it._M_sbuf->sgetn(__beg, __n);
        ;
        return __result;
    }
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, istreambuf_iterator<_CharT>>::__type find(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, const _CharT &__val)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        if (__first._M_sbuf && !__last._M_sbuf) {
            const int_type __ival = traits_type::to_int_type(__val);
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __ival))
                {
                    std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                        if (__p)
                            __n = __p - __sb->gptr();
                        __sb->__safe_gbump(__n);
                        __c = __sb->sgetc();
                    } else
                        __c = __sb->snextc();
                }
            __first._M_c = __eof;
        }
        return __first;
    }
    template <typename _CharT, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, void>::__type advance(istreambuf_iterator<_CharT> &__i, _Distance __n)     {
        if (__n == 0)
            return;
        do {
            if (std::__is_constant_evaluated() && !bool(__n > 0))
                __builtin_unreachable();
        } while (false);
        ;
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        streambuf_type *__sb = __i._M_sbuf;
        while (__n > 0)
            {
                std::streamsize __size = __sb->egptr() - __sb->gptr();
                if (__size > __n) {
                    __sb->__safe_gbump(__n);
                    break;
                }
                __sb->__safe_gbump(__size);
                __n -= __size;
                if (traits_type::eq_int_type(__sb->underflow(), __eof)) {
                    ;
                    break;
                }
            }
        __i._M_c = __eof;
    }
}
namespace std {
    template <typename _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<float>(const char *, float &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<double>(const char *, double &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<long double>(const char *, long double &, ios_base::iostate &, const std::__c_locale &) throw();
    template <typename _CharT, typename _Traits> struct __pad {
        static void _S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen);
    };
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last);
    template <typename _CharT> inline ostreambuf_iterator<_CharT> __write(ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)     {
        __s._M_put(__ws, __len);
        return __s;
    }
    template <typename _CharT, typename _OutIter> inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)     {
        for (int __j = 0; __j < __len; __j++ , ++__s)
            *__s = __ws[__j];
        return __s;
    }
    template <typename _CharT> class __ctype_abstract_base : public locale::facet, public std::ctype_base {
    public:
        typedef _CharT char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const         {
            return this->do_is(__m, __c);
        }
        const std::__ctype_abstract_base::char_type *is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const         {
            return this->do_is(__lo, __hi, __vec);
        }
        const std::__ctype_abstract_base::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_scan_is(__m, __lo, __hi);
        }
        const std::__ctype_abstract_base::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_scan_not(__m, __lo, __hi);
        }
        std::__ctype_abstract_base::char_type toupper(std::__ctype_abstract_base::char_type __c) const         {
            return this->do_toupper(__c);
        }
        const std::__ctype_abstract_base::char_type *toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type tolower(std::__ctype_abstract_base::char_type __c) const         {
            return this->do_tolower(__c);
        }
        const std::__ctype_abstract_base::char_type *tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type widen(char __c) const         {
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const         {
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const         {
            return this->do_narrow(__c, __dfault);
        }
        const std::__ctype_abstract_base::char_type *narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const         {
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
    protected:
        explicit __ctype_abstract_base<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        virtual ~__ctype_abstract_base<_CharT>()         {
        }
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_toupper(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_tolower(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const = 0;
    };
template<> class __ctype_abstract_base<wchar_t> : public locale::facet, public std::ctype_base {
    public:
        typedef wchar_t char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type widen(char __c) const;
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const;
        char narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
    protected:
        explicit __ctype_abstract_base(std::size_t __refs);
        virtual ~__ctype_abstract_base<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template <typename _CharT> class ctype : public __ctype_abstract_base<_CharT> {
    public:
        typedef _CharT char_type;
        typedef typename __ctype_abstract_base<_CharT>::mask mask;
        static locale::id id;
        explicit ctype<_CharT>(std::size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs)         {
        }
    protected:
        virtual ~ctype<_CharT>();
        virtual bool do_is(std::ctype::mask __m, std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_is(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, std::ctype::mask *__vec) const;
        virtual const std::ctype::char_type *do_scan_is(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual const std::ctype::char_type *do_scan_not(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_toupper(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_toupper(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_tolower(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_tolower(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype::char_type *__dest) const;
        virtual char do_narrow(std::ctype::char_type, char __dfault) const;
        virtual const std::ctype::char_type *do_narrow(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, char __dfault, char *__to) const;
    };
    locale::id id;
    template <typename _CharT, typename _Traits, typename _Alloc> class ctype<basic_string<_CharT, _Traits, _Alloc>>;
    template<> class ctype<char> : public locale::facet, public std::ctype_base {
    public:
        typedef char char_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_del;
        std::ctype_base::__to_type _M_toupper;
        std::ctype_base::__to_type _M_tolower;
        const std::ctype_base::mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const std::size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        inline bool is(std::ctype_base::mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, std::ctype_base::mask *__vec) const;
        inline const char *scan_is(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        std::ctype<char>::char_type toupper(std::ctype<char>::char_type __c) const         {
            return this->do_toupper(__c);
        }
        const std::ctype<char>::char_type *toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }
        std::ctype<char>::char_type tolower(std::ctype<char>::char_type __c) const         {
            return this->do_tolower(__c);
        }
        const std::ctype<char>::char_type *tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }
        std::ctype<char>::char_type widen(char __c) const         {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const         {
            if (this->_M_widen_ok == 1) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::ctype<char>::char_type __c, char __dfault) const         {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }
        const std::ctype<char>::char_type *narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault, char *__to) const         {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
        const std::ctype_base::mask *table() const throw()         {
            return this->_M_table;
        }
        static const std::ctype_base::mask *classic_table() throw();
    protected:
        virtual ~ctype<char>() noexcept;
        virtual std::ctype<char>::char_type do_toupper(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_tolower(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_widen(char __c) const         {
            return __c;
        }
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const         {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
        virtual char do_narrow(std::ctype<char>::char_type __c, char __dfault __attribute__((unused))) const         {
            return __c;
        }
        virtual const std::ctype<char>::char_type *do_narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault __attribute__((unused)), char *__to) const         {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    };
    template<> class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        std::ctype_base::mask _M_bit[16];
        std::ctype<wchar_t>::__wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, std::size_t __refs = 0);
    protected:
        std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const std::ctype_base::mask __m) const throw();
        virtual ~ctype<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_is(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_toupper(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_toupper(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_tolower(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_tolower(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<wchar_t>::char_type *__to) const;
        virtual char do_narrow(std::ctype<wchar_t>::char_type __c, char __dfault) const;
        virtual const std::ctype<wchar_t>::char_type *do_narrow(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    };
    template <typename _CharT> class ctype_byname : public ctype<_CharT> {
    public:
        typedef typename ctype<_CharT>::mask mask;
        explicit ctype_byname<_CharT>(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : ctype_byname<_CharT>(__s.c_str(), __refs)         {
        }
    protected:
        virtual ~ctype_byname<_CharT>()         {
        }
    };
    template<> class ctype_byname<char> : public ctype<char> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<char>() noexcept;
    };
    template<> class ctype_byname<wchar_t> : public ctype<wchar_t> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<wchar_t>() noexcept;
    };
}
namespace std {
    bool ctype<char>::is(std::ctype_base::mask __m, char __c) const     {
        return this->_M_table[static_cast<unsigned char>(__c)] & __m;
    }
    const char *ctype<char>::is(const char *__low, const char *__high, std::ctype_base::mask *__vec) const     {
        while (__low < __high)
            *__vec++ = this->_M_table[static_cast<unsigned char>(*__low++)];
        return __high;
    }
    const char *ctype<char>::scan_is(std::ctype_base::mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && !(this->_M_table[static_cast<unsigned char>(*__low)] & __m))
            ++__low;
        return __low;
    }
    const char *ctype<char>::scan_not(std::ctype_base::mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && (this->_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
            ++__low;
        return __low;
    }
}
namespace std {
    class __num_base {
    public:
        enum  {
            _S_ominus,
            _S_oplus,
            _S_ox,
            _S_oX,
            _S_odigits,
            _S_odigits_end = _S_odigits + 16,
            _S_oudigits = _S_odigits_end,
            _S_oudigits_end = _S_oudigits + 16,
            _S_oe = _S_odigits + 14,
            _S_oE = _S_oudigits + 14,
            _S_oend = _S_oudigits_end
        };
        static const char *_S_atoms_out;
        static const char *_S_atoms_in;
        enum  {
            _S_iminus,
            _S_iplus,
            _S_ix,
            _S_iX,
            _S_izero,
            _S_ie = _S_izero + 14,
            _S_iE = _S_izero + 20,
            _S_iend = 26
        };
        static void _S_format_float(const std::ios_base &__io, char *__fptr, char __mod) throw();
    };
    template <typename _CharT> struct __numpunct_cache : public locale::facet {
        const char *_M_grouping;
        std::size_t _M_grouping_size;
        bool _M_use_grouping;
        const _CharT *_M_truename;
        std::size_t _M_truename_size;
        const _CharT *_M_falsename;
        std::size_t _M_falsename_size;
        _CharT _M_decimal_point;
        _CharT _M_thousands_sep;
        _CharT _M_atoms_out[36];
        _CharT _M_atoms_in[26];
        bool _M_allocated;
        __numpunct_cache<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)         {
        }
        ~__numpunct_cache<_CharT>();
        void _M_cache(const std::locale &__loc);
    private:
        __numpunct_cache<_CharT> &operator=(const __numpunct_cache<_CharT> &);
        explicit __numpunct_cache<_CharT>(const __numpunct_cache<_CharT> &);
    };
    template <typename _CharT> __numpunct_cache<_CharT>::~__numpunct_cache<_CharT>()     {
        if (this->_M_allocated) {
            delete [] this->_M_grouping;
            delete [] this->_M_truename;
            delete [] this->_M_falsename;
        }
    }
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            typedef __numpunct_cache<_CharT> __cache_type;
        protected:
            std::__cxx11::numpunct::__cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::__cxx11::numpunct::__cache_type *__cache, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(__cache)             {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct(__cloc);
            }
            std::__cxx11::numpunct::char_type decimal_point() const             {
                return this->do_decimal_point();
            }
            std::__cxx11::numpunct::char_type thousands_sep() const             {
                return this->do_thousands_sep();
            }
            std::string grouping() const             {
                return this->do_grouping();
            }
            std::__cxx11::numpunct::string_type truename() const             {
                return this->do_truename();
            }
            std::__cxx11::numpunct::string_type falsename() const             {
                return this->do_falsename();
            }
        protected:
            virtual ~numpunct<_CharT>();
            virtual std::__cxx11::numpunct::char_type do_decimal_point() const             {
                return this->_M_data->_M_decimal_point;
            }
            virtual std::__cxx11::numpunct::char_type do_thousands_sep() const             {
                return this->_M_data->_M_thousands_sep;
            }
            virtual std::string do_grouping() const             {
                return this->_M_data->_M_grouping;
            }
            virtual std::__cxx11::numpunct::string_type do_truename() const             {
                return this->_M_data->_M_truename;
            }
            virtual std::__cxx11::numpunct::string_type do_falsename() const             {
                return this->_M_data->_M_falsename;
            }
            void _M_initialize_numpunct(std::__c_locale __cloc = 0);
        };
        locale::id id;
        template <> numpunct<char>::~numpunct<char>() noexcept;
        template <> void numpunct<char>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <> numpunct<wchar_t>::~numpunct<wchar_t>() noexcept;
        template <> void numpunct<wchar_t>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <typename _CharT> class numpunct_byname : public numpunct<_CharT> {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit numpunct_byname<_CharT>(const char *__s, std::size_t __refs = 0) : numpunct<_CharT>(__refs)             {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                    std::__c_locale __tmp;
                    this->_S_create_c_locale(__tmp, __s);
                    this->_M_initialize_numpunct(__tmp);
                    this->_S_destroy_c_locale(__tmp);
                }
            }
            explicit numpunct_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : numpunct_byname<_CharT>(__s.c_str(), __refs)             {
            }
        protected:
            virtual ~numpunct_byname<_CharT>()             {
            }
        };
    }
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _InIter iter_type;
        static locale::id id;
        explicit num_get<_CharT, _InIter>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
    protected:
        virtual ~num_get<_CharT, _InIter>()         {
        }
        std::num_get::iter_type _M_extract_float(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get::iter_type _M_extract_int(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            if (__len <= 10) {
                if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
                    __ret = __c - _CharT2('0');
            } else {
                if (__c >= _CharT2('0') && __c <= _CharT2('9'))
                    __ret = __c - _CharT2('0');
                else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                    __ret = 10 + (__c - _CharT2('a'));
                else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                    __ret = 10 + (__c - _CharT2('A'));
            }
            return __ret;
        }
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            const std::num_get::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
            if (__q) {
                __ret = __q - __zero;
                if (__ret > 15)
                    __ret -= 6;
            }
            return __ret;
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    locale::id id;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _OutIter iter_type;
        static locale::id id;
        explicit num_put<_CharT, _OutIter>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
    protected:
        template <typename _ValueT> std::num_put::iter_type _M_insert_float(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, const std::num_put::char_type *__p, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put::iter_type _M_insert_int(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, std::ios_base &__io, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put::char_type *__new, const std::num_put::char_type *__cs, int &__len) const;
        virtual ~num_put<_CharT, _OutIter>()         {
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, long double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, const void *) const;
    };
    locale::id id;
    template <typename _CharT> inline bool isspace(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space, __c);
    }
    template <typename _CharT> inline bool isprint(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print, __c);
    }
    template <typename _CharT> inline bool iscntrl(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl, __c);
    }
    template <typename _CharT> inline bool isupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper, __c);
    }
    template <typename _CharT> inline bool islower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower, __c);
    }
    template <typename _CharT> inline bool isalpha(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha, __c);
    }
    template <typename _CharT> inline bool isdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit, __c);
    }
    template <typename _CharT> inline bool ispunct(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct, __c);
    }
    template <typename _CharT> inline bool isxdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit, __c);
    }
    template <typename _CharT> inline bool isalnum(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum, __c);
    }
    template <typename _CharT> inline bool isgraph(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph, __c);
    }
    template <typename _CharT> inline bool isblank(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).is(ctype_base::blank, __c);
    }
    template <typename _CharT> inline _CharT toupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).toupper(__c);
    }
    template <typename _CharT> inline _CharT tolower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT>>(__loc).tolower(__c);
    }
}
namespace std {
    template <typename _Facet> struct __use_cache {
        const _Facet *operator()(const std::locale &__loc) const;
    };
    template <typename _CharT> struct __use_cache<__numpunct_cache<_CharT>> {
        const __numpunct_cache<_CharT> *operator()(const std::locale &__loc) const         {
            const std::size_t __i = numpunct<_CharT>::id._M_id();
            const locale::facet **__caches = __loc._M_impl->_M_caches;
            if (!__caches[__i]) {
                __numpunct_cache<_CharT> *__tmp = 0;
                try {
                    __tmp = new __numpunct_cache<_CharT>;
                    __tmp->_M_cache(__loc);
                } catch (...) {
                    delete __tmp;
                    throw;
                }
                __loc._M_impl->_M_install_cache(__tmp, __i);
            }
            return static_cast<const __numpunct_cache<_CharT> *>(__caches[__i]);
        }
    };
    template <typename _CharT> void __numpunct_cache<_CharT>::_M_cache(const std::locale &__loc)     {
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
        char *__grouping = 0;
        _CharT *__truename = 0;
        _CharT *__falsename = 0;
        try {
            const std::string &__g = __np.grouping();
            this->_M_grouping_size = __g.size();
            __grouping = new char [this->_M_grouping_size];
            __g.copy(__grouping, this->_M_grouping_size);
            this->_M_use_grouping = (this->_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0 && (__grouping[0] != __gnu_cxx::__numeric_traits<char>::__max));
            const basic_string<_CharT> &__tn = __np.truename();
            this->_M_truename_size = __tn.size();
            __truename = new _CharT [this->_M_truename_size];
            __tn.copy(__truename, this->_M_truename_size);
            const basic_string<_CharT> &__fn = __np.falsename();
            this->_M_falsename_size = __fn.size();
            __falsename = new _CharT [this->_M_falsename_size];
            __fn.copy(__falsename, this->_M_falsename_size);
            this->_M_decimal_point = __np.decimal_point();
            this->_M_thousands_sep = __np.thousands_sep();
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
            __ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, this->_M_atoms_out);
            __ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, this->_M_atoms_in);
            this->_M_grouping = __grouping;
            this->_M_truename = __truename;
            this->_M_falsename = __falsename;
            this->_M_allocated = true;
        } catch (...) {
            delete [] __grouping;
            delete [] __truename;
            delete [] __falsename;
            throw;
        }
    }
    bool __verify_grouping(const char *__grouping, std::size_t __grouping_size, const std::string &__grouping_tmp) throw() __attribute__((pure));
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, std::string &__xtrc) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        bool __testeof = __beg == __end;
        if (!__testeof) {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                __xtrc += __plus ? '+' : '-';
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_mantissa = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero]) {
                    if (!__found_mantissa) {
                        __xtrc += '0';
                        __found_mantissa = true;
                    }
                    ++__sep_pos;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                } else
                    break;
            }
        bool __found_dec = false;
        bool __found_sci = false;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    const int __digit = _M_find(__lit_zero, 10, __c);
                    if (__digit != -1) {
                        __xtrc += '0' + __digit;
                        __found_mantissa = true;
                    } else if (__c == __lc->_M_decimal_point && !__found_dec && !__found_sci) {
                        __xtrc += '.';
                        __found_dec = true;
                    } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                        __xtrc += 'e';
                        __found_sci = true;
                        if (++__beg != __end) {
                            __c = *__beg;
                            const bool __plus = __c == __lit[__num_base::_S_iplus];
                            if (__plus || __c == __lit[__num_base::_S_iminus])
                                __xtrc += __plus ? '+' : '-';
                            else
                                continue;
                        } else {
                            __testeof = true;
                            break;
                        }
                    } else
                        break;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (!__found_dec && !__found_sci) {
                            if (__sep_pos) {
                                __found_grouping += static_cast<char>(__sep_pos);
                                __sep_pos = 0;
                            } else {
                                __xtrc.clear();
                                break;
                            }
                        } else
                            break;
                    } else if (__c == __lc->_M_decimal_point) {
                        if (!__found_dec && !__found_sci) {
                            if (__found_grouping.size())
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += '.';
                            __found_dec = true;
                        } else
                            break;
                    } else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                        if (__q) {
                            __xtrc += '0' + (__q - __lit_zero);
                            __found_mantissa = true;
                            ++__sep_pos;
                        } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                            if (__found_grouping.size() && !__found_dec)
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end) {
                                __c = *__beg;
                                const bool __plus = __c == __lit[__num_base::_S_iplus];
                                if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
                                    __xtrc += __plus ? '+' : '-';
                                else
                                    continue;
                            } else {
                                __testeof = true;
                                break;
                            }
                        } else
                            break;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            if (!__found_dec && !__found_sci)
                __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> template <typename _ValueT> _InIter num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, _ValueT &__v) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
        const bool __oct = __basefield == ios_base::oct;
        int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
        bool __testeof = __beg == __end;
        bool __negative = false;
        if (!__testeof) {
            __c = *__beg;
            __negative = __c == __lit[__num_base::_S_iminus];
            if ((__negative || __c == __lit[__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_zero = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero] && (!__found_zero || __base == 10)) {
                    __found_zero = true;
                    ++__sep_pos;
                    if (__basefield == 0)
                        __base = 8;
                    if (__base == 8)
                        __sep_pos = 0;
                } else if (__found_zero && (__c == __lit[__num_base::_S_ix] || __c == __lit[__num_base::_S_iX])) {
                    if (__basefield == 0)
                        __base = 16;
                    if (__base == 16) {
                        __found_zero = false;
                        __sep_pos = 0;
                    } else
                        break;
                } else
                    break;
                if (++__beg != __end) {
                    __c = *__beg;
                    if (!__found_zero)
                        break;
                } else
                    __testeof = true;
            }
        const std::size_t __len = (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);
        typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        bool __testfail = false;
        bool __testoverflow = false;
        const __unsigned_type __max = (__negative && __num_traits::__is_signed) ? - static_cast<__unsigned_type>(__num_traits::__min) : __num_traits::__max;
        const __unsigned_type __smax = __max / __base;
        __unsigned_type __result = 0;
        int __digit = 0;
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    __digit = _M_find(__lit_zero, __len, __c);
                    if (__digit == -1)
                        break;
                    if (__result > __smax)
                        __testoverflow = true;
                    else {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                        ++__sep_pos;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (__sep_pos) {
                            __found_grouping += static_cast<char>(__sep_pos);
                            __sep_pos = 0;
                        } else {
                            __testfail = true;
                            break;
                        }
                    } else if (__c == __lc->_M_decimal_point)
                        break;
                    else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                        if (!__q)
                            break;
                        __digit = __q - __lit_zero;
                        if (__digit > 15)
                            __digit -= 6;
                        if (__result > __smax)
                            __testoverflow = true;
                        else {
                            __result *= __base;
                            __testoverflow |= __result > __max - __digit;
                            __result += __digit;
                            ++__sep_pos;
                        }
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        if ((!__sep_pos && !__found_zero && !__found_grouping.size()) || __testfail) {
            __v = 0;
            __err = ios_base::failbit;
        } else if (__testoverflow) {
            if (__negative && __num_traits::__is_signed)
                __v = __num_traits::__min;
            else
                __v = __num_traits::__max;
            __err = ios_base::failbit;
        } else
            __v = __negative ? - __result : __result;
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const     {
        if (!(__io.flags() & ios_base::boolalpha)) {
            long __l = -1;
            __beg = _M_extract_int(__beg, __end, __io, __err, __l);
            if (__l == 0 || __l == 1)
                __v = bool(__l);
            else {
                __v = true;
                __err = ios_base::failbit;
                if (__beg == __end)
                    __err |= ios_base::eofbit;
            }
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            bool __testf = true;
            bool __testt = true;
            bool __donef = __lc->_M_falsename_size == 0;
            bool __donet = __lc->_M_truename_size == 0;
            bool __testeof = false;
            std::size_t __n = 0;
            while (!__donef || !__donet)
                {
                    if (__beg == __end) {
                        __testeof = true;
                        break;
                    }
                    const std::num_get::char_type __c = *__beg;
                    if (!__donef)
                        __testf = __c == __lc->_M_falsename[__n];
                    if (!__testf && __donet)
                        break;
                    if (!__donet)
                        __testt = __c == __lc->_M_truename[__n];
                    if (!__testt && __donef)
                        break;
                    if (!__testt && !__testf)
                        break;
                    ++__n;
                    ++__beg;
                    __donef = !__testf || __n >= __lc->_M_falsename_size;
                    __donet = !__testt || __n >= __lc->_M_truename_size;
                }
            if (__testf && __n == __lc->_M_falsename_size && __n) {
                __v = false;
                if (__testt && __n == __lc->_M_truename_size)
                    __err = ios_base::failbit;
                else
                    __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else if (__testt && __n == __lc->_M_truename_size && __n) {
                __v = true;
                __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else {
                __v = false;
                __err = ios_base::failbit;
                if (__testeof)
                    __err |= ios_base::eofbit;
            }
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const     {
        typedef ios_base::fmtflags fmtflags;
        const fmtflags __fmt = __io.flags();
        __io.flags((__fmt & ~ ios_base::basefield) | ios_base::hex);
        typedef __gnu_cxx::__conditional_type<(sizeof(void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        _UIntPtrType __ul;
        __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
        __io.flags(__fmt);
        __v = reinterpret_cast<void *>(__ul);
        return __beg;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, std::streamsize __w, std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const     {
        __pad<_CharT, char_traits<_CharT>>::_S_pad(__io, __fill, __new, __cs, __w, __len);
        __len = static_cast<int>(__w);
    }
    template <typename _CharT, typename _ValueT> int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags __flags, bool __dec)     {
        _CharT *__buf = __bufend;
        if (__builtin_expect(__dec, true)) {
            do {
                *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
                __v /= 10;
            } while (__v != 0);
        } else if ((__flags & ios_base::basefield) == ios_base::oct) {
            do {
                *--__buf = __lit[(__v & 7) + __num_base::_S_odigits];
                __v >>= 3;
            } while (__v != 0);
        } else {
            const bool __uppercase = __flags & ios_base::uppercase;
            const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
            do {
                *--__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
            } while (__v != 0);
        }
        return __bufend - __buf;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, std::size_t __grouping_size, _CharT __sep, std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const     {
        _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
        __len = __p - __new;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, std::ios_base &__io, _CharT __fill, _ValueT __v) const     {
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_out;
        const ios_base::fmtflags __flags = __io.flags();
        const int __ilen = 5 * sizeof(_ValueT);
        _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
        const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
        const bool __dec = (__basefield != ios_base::oct && __basefield != ios_base::hex);
        const __unsigned_type __u = ((__v > 0 || !__dec) ? __unsigned_type(__v) : - __unsigned_type(__v));
        int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
        __cs += __ilen - __len;
        if (__lc->_M_use_grouping) {
            _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
            this->_M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
            __cs = __cs2 + 2;
        }
        if (__builtin_expect(__dec, true)) {
            if (__v >= 0) {
                if (bool(__flags & ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
                    *--__cs = __lit[__num_base::_S_oplus] , ++__len;
            } else
                *--__cs = __lit[__num_base::_S_ominus] , ++__len;
        } else if (bool(__flags & ios_base::showbase) && __v) {
            if (__basefield == ios_base::oct)
                *--__cs = __lit[__num_base::_S_odigits] , ++__len;
            else {
                const bool __uppercase = __flags & ios_base::uppercase;
                *--__cs = __lit[__num_base::_S_ox + __uppercase];
                *--__cs = __lit[__num_base::_S_odigits];
                __len += 2;
            }
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
        }
        __io.width(0);
        return std::__write(__s, __cs, __len);
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const     {
        const int __declen = __p ? __p - __cs : __len;
        _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
        int __newlen = __p2 - __new;
        if (__p) {
            char_traits<_CharT>::copy(__p2, __p, __len - __declen);
            __newlen += __len - __declen;
        }
        __len = __newlen;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const     {
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const std::streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
        const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
        int __len;
        char __fbuf[16];
        __num_base::_S_format_float(__io, __fbuf, __mod);
        const bool __use_prec = (__io.flags() & ios_base::floatfield) != ios_base::floatfield;
        int __cs_size = __max_digits * 3;
        char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        else
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        if (__len >= __cs_size) {
            __cs_size = __len + 1;
            __cs = static_cast<char *>(__builtin_alloca(__cs_size));
            if (__use_prec)
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
            else
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        }
        const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
        _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
        __ctype.widen(__cs, __cs + __len, __ws);
        _CharT *__wp = 0;
        const char *__p = char_traits<char>::find(__cs, __len, '.');
        if (__p) {
            __wp = __ws + (__p - __cs);
            *__wp = __lc->_M_decimal_point;
        }
        if (__lc->_M_use_grouping && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9' && __cs[1] >= '0' && __cs[2] >= '0'))) {
            _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
            std::streamsize __off = 0;
            if (__cs[0] == '-' || __cs[0] == '+') {
                __off = 1;
                __ws2[0] = __ws[0];
                __len -= 1;
            }
            this->_M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
            __len += __off;
            __ws = __ws2;
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __ws3, __ws, __len);
            __ws = __ws3;
        }
        __io.width(0);
        return std::__write(__s, __ws, __len);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        if ((__flags & ios_base::boolalpha) == 0) {
            const long __l = __v;
            __s = _M_insert_int(__s, __io, __fill, __l);
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
            int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
            const std::streamsize __w = __io.width();
            if (__w > static_cast<std::streamsize>(__len)) {
                const std::streamsize __plen = __w - __len;
                _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
                char_traits<_CharT>::assign(__ps, __plen, __fill);
                __io.width(0);
                if ((__flags & ios_base::adjustfield) == ios_base::left) {
                    __s = std::__write(__s, __name, __len);
                    __s = std::__write(__s, __ps, __plen);
                } else {
                    __s = std::__write(__s, __ps, __plen);
                    __s = std::__write(__s, __name, __len);
                }
                return __s;
            }
            __io.width(0);
            __s = std::__write(__s, __name, __len);
        }
        return __s;
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const     {
        return _M_insert_float(__s, __io, __fill, char(), __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const     {
        return _M_insert_float(__s, __io, __fill, 'L', __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        const ios_base::fmtflags __fmt = ~ (ios_base::basefield | ios_base::uppercase);
        __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
        typedef __gnu_cxx::__conditional_type<(sizeof(const void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
        __io.flags(__flags);
        return __s;
    }
    template <typename _CharT, typename _Traits> void __pad<_CharT, _Traits>::_S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen)     {
        const std::size_t __plen = static_cast<std::size_t>(__newlen - __oldlen);
        const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
        if (__adjust == ios_base::left) {
            _Traits::copy(__news, __olds, __oldlen);
            _Traits::assign(__news + __oldlen, __plen, __fill);
            return;
        }
        std::size_t __mod = 0;
        if (__adjust == ios_base::internal) {
            const std::locale &__loc = __io._M_getloc();
            const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);
            if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0]) {
                __news[0] = __olds[0];
                __mod = 1;
                ++__news;
            } else if (__ctype.widen('0') == __olds[0] && __oldlen > 1 && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1])) {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
            }
        }
        _Traits::assign(__news, __plen, __fill);
        _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last)     {
        std::size_t __idx = 0;
        std::size_t __ctr = 0;
        while (__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0 && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
            {
                __last -= __gbeg[__idx];
                __idx < __gsize - 1 ? ++__idx : ++__ctr;
            }
        while (__first != __last)
            *__s++ = *__first++;
        while (__ctr--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        while (__idx--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        return __s;
    }
    template<> class numpunct<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        typedef __numpunct_cache<char> __cache_type;
    protected:
        std::__cxx11::numpunct<char>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::__cxx11::numpunct<char>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::__cxx11::numpunct<char>::char_type decimal_point() const;
        std::__cxx11::numpunct<char>::char_type thousands_sep() const;
        std::string grouping() const;
        std::__cxx11::numpunct<char>::string_type truename() const;
        std::__cxx11::numpunct<char>::string_type falsename() const;
    protected:
        virtual ~numpunct<char>() noexcept;
        virtual std::__cxx11::numpunct<char>::char_type do_decimal_point() const;
        virtual std::__cxx11::numpunct<char>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::__cxx11::numpunct<char>::string_type do_truename() const;
        virtual std::__cxx11::numpunct<char>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<char> : public numpunct<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<char>() noexcept;
    };
    template<> class num_get<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char, std::char_traits<char>> iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<char>() noexcept;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_extract_float(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_extract_int(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char, std::char_traits<char>> iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, bool __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, double __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long double __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_insert_float(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __sep, const std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__p, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__new, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type _M_insert_int(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __sep, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__new, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__new, const std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type *__cs, int &__len) const;
        virtual ~num_put<char>() noexcept;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, bool __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, long long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type, double) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type, long double) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char>>>::char_type, const void *) const;
    };
    template<> class ctype_byname<char>;
    template<> class numpunct<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        typedef __numpunct_cache<wchar_t> __cache_type;
    protected:
        std::__cxx11::numpunct<wchar_t>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::__cxx11::numpunct<wchar_t>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::__cxx11::numpunct<wchar_t>::char_type decimal_point() const;
        std::__cxx11::numpunct<wchar_t>::char_type thousands_sep() const;
        std::string grouping() const;
        std::__cxx11::numpunct<wchar_t>::string_type truename() const;
        std::__cxx11::numpunct<wchar_t>::string_type falsename() const;
    protected:
        virtual ~numpunct<wchar_t>() noexcept;
        virtual std::__cxx11::numpunct<wchar_t>::char_type do_decimal_point() const;
        virtual std::__cxx11::numpunct<wchar_t>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::__cxx11::numpunct<wchar_t>::string_type do_truename() const;
        virtual std::__cxx11::numpunct<wchar_t>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<wchar_t> : public numpunct<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<wchar_t>() noexcept;
    };
    template<> class num_get<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>> iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<wchar_t>() noexcept;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_extract_float(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_extract_int(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>> iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, bool __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, double __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long double __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_insert_float(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __sep, const std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__p, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__new, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type _M_insert_int(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __sep, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__new, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__new, const std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type *__cs, int &__len) const;
        virtual ~num_put<wchar_t>() noexcept;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, bool __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, long long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type, double) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type, long double) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>>::char_type, const void *) const;
    };
    template<> class ctype_byname<wchar_t>;
}
namespace std {
    template <typename _Facet> inline const _Facet &__check_facet(const _Facet *__f)     {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios : public std::ios_base {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef ctype<_CharT> __ctype_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
    protected:
        basic_ostream<_CharT, _Traits> *_M_tie;
        mutable std::basic_ios::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<_CharT, _Traits> *_M_streambuf;
        const std::basic_ios::__ctype_type *_M_ctype;
        const std::basic_ios::__num_put_type *_M_num_put;
        const std::basic_ios::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const         {
            return !this->fail();
        }
        bool operator!() const         {
            return this->fail();
        }
        std::ios_base::iostate rdstate() const         {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state = goodbit);
        void setstate(std::ios_base::iostate __state)         {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state)         {
            this->_M_streambuf_state |= __state;
            if (this->exceptions() & __state)
                throw;
        }
        bool good() const         {
            return this->rdstate() == 0;
        }
        bool eof() const         {
            return (this->rdstate() & eofbit) != 0;
        }
        bool fail() const         {
            return (this->rdstate() & (badbit | failbit)) != 0;
        }
        bool bad() const         {
            return (this->rdstate() & badbit) != 0;
        }
        std::ios_base::iostate exceptions() const         {
            return this->_M_exception;
        }
        void exceptions(std::ios_base::iostate __except)         {
            this->_M_exception = __except;
            this->clear(this->_M_streambuf_state);
        }
        explicit basic_ios<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
            this->init(__sb);
        }
        virtual ~basic_ios<_CharT, _Traits>()         {
        }
        basic_ostream<_CharT, _Traits> *tie() const         {
            return this->_M_tie;
        }
        basic_ostream<_CharT, _Traits> *tie(basic_ostream<_CharT, _Traits> *__tiestr)         {
            basic_ostream<_CharT, _Traits> *__old = this->_M_tie;
            this->_M_tie = __tiestr;
            return __old;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf() const         {
            return this->_M_streambuf;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
        std::basic_ios::char_type fill() const         {
            if (!this->_M_fill_init) {
                this->_M_fill = this->widen(' ');
                this->_M_fill_init = true;
            }
            return this->_M_fill;
        }
        std::basic_ios::char_type fill(std::basic_ios::char_type __ch)         {
            std::basic_ios::char_type __old = this->fill();
            this->_M_fill = __ch;
            return __old;
        }
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios::char_type __c, char __dfault) const         {
            return __check_facet(this->_M_ctype).narrow(__c, __dfault);
        }
        std::basic_ios::char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios<_CharT, _Traits>() : std::ios_base(), _M_tie(0), _M_fill(std::basic_ios::char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
        }
        void init(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits>(const basic_ios<_CharT, _Traits> &) = delete
        basic_ios<_CharT, _Traits> &operator=(const basic_ios<_CharT, _Traits> &) = delete
        void move(basic_ios<_CharT, _Traits> &__rhs)         {
            this->ios_base::_M_move(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            this->tie(__rhs.tie(nullptr));
            this->_M_fill = __rhs._M_fill;
            this->_M_fill_init = __rhs._M_fill_init;
            this->_M_streambuf = nullptr;
        }
        void move(basic_ios<_CharT, _Traits> &&__rhs)         {
            this->move(__rhs);
        }
        void swap(basic_ios<_CharT, _Traits> &__rhs) noexcept         {
            this->ios_base::_M_swap(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            __rhs._M_cache_locale(__rhs._M_ios_locale);
            std::swap(this->_M_tie, __rhs._M_tie);
            std::swap(this->_M_fill, __rhs._M_fill);
            std::swap(this->_M_fill_init, __rhs._M_fill_init);
        }
        void set_rdbuf(basic_streambuf<_CharT, _Traits> *__sb)         {
            this->_M_streambuf = __sb;
        }
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::clear(std::ios_base::iostate __state = goodbit)     {
        if (this->rdbuf())
            this->_M_streambuf_state = __state;
        else
            this->_M_streambuf_state = __state | badbit;
        if (this->exceptions() & this->rdstate())
            __throw_ios_failure(("basic_ios::clear"));
    }
    template <typename _CharT, typename _Traits> basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits> *__sb)     {
        basic_streambuf<_CharT, _Traits> *__old = this->_M_streambuf;
        this->_M_streambuf = __sb;
        this->clear();
        return __old;
    }
    template <typename _CharT, typename _Traits> basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits> &__rhs)     {
        if (this != std::__addressof(__rhs)) {
            std::ios_base::_Words *__words = (__rhs._M_word_size <= _S_local_word_size) ? this->_M_local_word : new std::ios_base::_Words [__rhs._M_word_size];
            std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
            if (__cb)
                __cb->_M_add_reference();
            this->_M_call_callbacks(erase_event);
            if (this->_M_word != this->_M_local_word) {
                delete [] this->_M_word;
                this->_M_word = 0;
            }
            this->_M_dispose_callbacks();
            this->_M_callbacks = __cb;
            for (int __i = 0; __i < __rhs._M_word_size; ++__i)
                __words[__i] = __rhs._M_word[__i];
            this->_M_word = __words;
            this->_M_word_size = __rhs._M_word_size;
            this->flags(__rhs.flags());
            this->width(__rhs.width());
            this->precision(__rhs.precision());
            this->tie(__rhs.tie());
            this->fill(__rhs.fill());
            this->_M_ios_locale = __rhs.getloc();
            this->_M_cache_locale(this->_M_ios_locale);
            this->_M_call_callbacks(copyfmt_event);
            this->exceptions(__rhs.exceptions());
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::locale basic_ios<_CharT, _Traits>::imbue(const std::locale &__loc)     {
        std::locale __old(this->getloc());
        this->ios_base::imbue(__loc);
        this->_M_cache_locale(__loc);
        if (this->rdbuf() != 0)
            this->rdbuf()->pubimbue(__loc);
        return __old;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits> *__sb)     {
        this->ios_base::_M_init();
        this->_M_cache_locale(this->_M_ios_locale);
        this->_M_fill = _CharT();
        this->_M_fill_init = false;
        this->_M_tie = 0;
        this->_M_exception = goodbit;
        this->_M_streambuf = __sb;
        this->_M_streambuf_state = __sb ? goodbit : badbit;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::_M_cache_locale(const std::locale &__loc)     {
        if (__builtin_expect(has_facet<std::basic_ios::__ctype_type>(__loc), true))
            this->_M_ctype = std::__addressof(use_facet<std::basic_ios::__ctype_type>(__loc));
        else
            this->_M_ctype = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_put_type>(__loc), true))
            this->_M_num_put = std::__addressof(use_facet<std::basic_ios::__num_put_type>(__loc));
        else
            this->_M_num_put = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_get_type>(__loc), true))
            this->_M_num_get = std::__addressof(use_facet<std::basic_ios::__num_get_type>(__loc));
        else
            this->_M_num_get = 0;
    }
    template<> class basic_ios<char> : public std::ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char>>> __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char>>> __num_get_type;
    protected:
        basic_ostream<char, std::char_traits<char>> *_M_tie;
        mutable std::basic_ios<char, std::char_traits<char>>::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, std::char_traits<char>> *_M_streambuf;
        const std::basic_ios<char, std::char_traits<char>>::__ctype_type *_M_ctype;
        const std::basic_ios<char, std::char_traits<char>>::__num_put_type *_M_num_put;
        const std::basic_ios<char, std::char_traits<char>>::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const         {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state)         {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<char, std::char_traits<char>> *__sb);
        virtual ~basic_ios<char>() throw();
        basic_ostream<char, std::char_traits<char>> *tie() const;
        basic_ostream<char, std::char_traits<char>> *tie(basic_ostream<char, std::char_traits<char>> *__tiestr);
        basic_streambuf<char, std::char_traits<char>> *rdbuf() const;
        basic_streambuf<char, std::char_traits<char>> *rdbuf(basic_streambuf<char, std::char_traits<char>> *__sb);
        std::basic_ios<char> &copyfmt(const std::basic_ios<char> &__rhs);
        std::basic_ios<char, std::char_traits<char>>::char_type fill() const;
        std::basic_ios<char, std::char_traits<char>>::char_type fill(std::basic_ios<char, std::char_traits<char>>::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<char, std::char_traits<char>>::char_type __c, char __dfault) const;
        std::basic_ios<char, std::char_traits<char>>::char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<char, std::char_traits<char>> *__sb);
        basic_ios(const std::basic_ios<char> &) = delete
        std::basic_ios<char> &operator=(const std::basic_ios<char> &) = delete
        void move(std::basic_ios<char> &__rhs);
        void move(std::basic_ios<char> &&__rhs);
        void swap(std::basic_ios<char> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<char, std::char_traits<char>> *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
    template<> class basic_ios<wchar_t> : public std::ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_get_type;
    protected:
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *_M_tie;
        mutable std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *_M_streambuf;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t>>::__ctype_type *_M_ctype;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t>>::__num_put_type *_M_num_put;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t>>::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const;
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state);
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        virtual ~basic_ios<wchar_t>() throw();
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *tie() const;
        basic_ostream<wchar_t, std::char_traits<wchar_t>> *tie(basic_ostream<wchar_t, std::char_traits<wchar_t>> *__tiestr);
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *rdbuf() const;
        basic_streambuf<wchar_t, std::char_traits<wchar_t>> *rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        std::basic_ios<wchar_t> &copyfmt(const std::basic_ios<wchar_t> &__rhs);
        std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type fill() const;
        std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type fill(std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type __c, char __dfault) const;
        std::basic_ios<wchar_t, std::char_traits<wchar_t>>::char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        basic_ios(const std::basic_ios<wchar_t> &) = delete
        std::basic_ios<wchar_t> &operator=(const std::basic_ios<wchar_t> &) = delete
        void move(std::basic_ios<wchar_t> &__rhs);
        void move(std::basic_ios<wchar_t> &&__rhs);
        void swap(std::basic_ios<wchar_t> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> __num_put_type;
        typedef ctype<_CharT> __ctype_type;
        explicit basic_ostream<_CharT, _Traits>(std::basic_ostream::__streambuf_type *__sb)         {
            this->init(__sb);
        }
        virtual ~basic_ostream<_CharT, _Traits>()         {
        }
        class sentry;
        friend  class sentry;
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ostream_type &(*__pf)(std::basic_ostream::__ostream_type &))         {
            return __pf(*this);
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ios_type &(*__pf)(std::basic_ostream::__ios_type &))         {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(bool __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(short __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned short __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(int __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned int __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(long long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(double __f)         {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(float __f)         {
            return _M_insert(static_cast<double>(__f));
        }
        std::basic_ostream::__ostream_type &operator<<(long double __f)         {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(const void *__p)         {
            return _M_insert(__p);
        }
        std::basic_ostream::__ostream_type &operator<<(std::nullptr_t)         {
            return *this << "nullptr";
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__streambuf_type *__sb);
        std::basic_ostream::__ostream_type &put(std::basic_ostream::char_type __c);
        std::basic_ostream::__ostream_type &write(const std::basic_ostream::char_type *__s, std::streamsize __n);
        std::basic_ostream::__ostream_type &flush();
        std::basic_ostream::pos_type tellp();
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::pos_type);
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::off_type, ios_base::seekdir);
    protected:
        basic_ostream<_CharT, _Traits>()         {
            this->init(0);
        }
        basic_ostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &)         {
        }
        basic_ostream<_CharT, _Traits>(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits>(basic_ostream<_CharT, _Traits> &&__rhs) : std::basic_ostream::__ios_type()         {
            __ios_type::move(__rhs);
        }
        basic_ostream<_CharT, _Traits> &operator=(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits> &operator=(basic_ostream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_ostream<_CharT, _Traits> &__rhs)         {
            __ios_type::swap(__rhs);
        }
        template <typename _ValueT> std::basic_ostream::__ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const std::basic_ostream::char_type *__s, std::streamsize __n)         {
            std::__ostream_insert(*this, __s, __n);
        }
    };
    class sentry {
        bool _M_ok;
        basic_ostream<_CharT, _Traits> &_M_os;
    public:
        explicit sentry(basic_ostream<_CharT, _Traits> &__os);
        ~sentry()         {
            if (bool(this->_M_os.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                if (this->_M_os.rdbuf() && this->_M_os.rdbuf()->pubsync() == -1)
                    this->_M_os.setstate(ios_base::badbit);
            }
        }
        explicit operator bool() const         {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, _CharT __c)     {
        if (__out.width() != 0)
            return __ostream_insert(__out, & __c, 1);
        __out.put(__c);
        return __out;
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, char __c)    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, char __c)     {
        return (__out << __out.widen(__c));
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, char __c)    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, char __c)     {
        if (__out.width() != 0)
            return __ostream_insert(__out, &__c, 1);
        __out.put(__c);
        return __out;
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, signed char __c)     {
        return (__out << static_cast<char>(__c));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, unsigned char __c)     {
        return (__out << static_cast<char>(__c));
    }
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, wchar_t) = delete    template<> basic_ostream<char, std::char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &, wchar_t) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, char8_t) = delete    template<> basic_ostream<char, std::char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &, char8_t) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, char16_t) = delete    template<> basic_ostream<char, std::char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &, char16_t) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, char32_t) = delete    template<> basic_ostream<char, std::char_traits<char>> &operator<<<std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &, char32_t) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, char8_t) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, char16_t) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, char32_t) = delete
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template<> inline basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, const char *__s)    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s);
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const signed char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const unsigned char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const wchar_t *) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const char8_t *) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const char16_t *) = delete
    template <typename _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &, const char32_t *) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, const char8_t *) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, const char16_t *) = delete
    template <typename _Traits> basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &, const char32_t *) = delete
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os)     {
        return flush(__os.put(__os.widen('\n')));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.put(_CharT());
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.flush();
    }
    template <typename _Tp> concept __derived_from_ios_base = is_class_v<_Tp> && (!is_same_v<_Tp, std::ios_base>) && requires (_Tp *__t, std::ios_base *__b) { __b = __t; };;
    template <typename _Os, typename _Tp> using __rvalue_stream_insertion_t = _Os &&;
    template <typename _Ostream, typename _Tp> inline __rvalue_stream_insertion_t<_Ostream, _Tp> operator<<(_Ostream &&__os, const _Tp &__x)     {
        __os << __x;
        return std::move(__os);
    }
    template <typename _CharT, typename _Traits> class __syncbuf_base : public basic_streambuf<_CharT, _Traits> {
    public:
        static bool *_S_get(basic_streambuf<_CharT, _Traits> *__buf [[maybe_unused]]) noexcept         {
            if (auto __p = dynamic_cast<__syncbuf_base<_CharT, _Traits> *>(__buf))
                return & __p->_M_emit_on_sync;
            return nullptr;
        }
    protected:
        __syncbuf_base<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__w = nullptr) : _M_wrapped(__w)         {
        }
        basic_streambuf<_CharT, _Traits> *_M_wrapped = nullptr;
        bool _M_emit_on_sync = false;
        bool _M_needs_sync = false;
    };
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &emit_on_flush(basic_ostream<_CharT, _Traits> &__os)     {
        if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
            *__flag = true;
        return __os;
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &noemit_on_flush(basic_ostream<_CharT, _Traits> &__os)     {
        if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
            *__flag = false;
        return __os;
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush_emit(basic_ostream<_CharT, _Traits> &__os)     {
        struct _Restore {
            ~_Restore()             {
                *this->_M_flag = this->_M_prev;
            }
            bool _M_prev = false;
            bool *_M_flag = &this->_M_prev;
        } __restore;
        if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf())) {
            __restore._M_prev = *__flag;
            __restore._M_flag = __flag;
            *__flag = true;
        }
        __os.flush();
        return __os;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits> &__os) : _M_ok(false), _M_os(__os)     {
        if (__os.tie() && __os.good())
            __os.tie()->flush();
        if (__os.good())
            this->_M_ok = true;
        else if (__os.bad())
            __os.setstate(ios_base::failbit);
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::__num_put_type &__np = __check_facet(this->_M_num_put);
                if (__np.put(*this, *this, this->fill(), __v).failed())
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(short __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(int __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream::__streambuf_type *__sbin)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb && __sbin) {
            try {
                if (!__copy_streambufs(__sbin, this->rdbuf()))
                    __err |= ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbin)
            __err |= ios_base::badbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(std::basic_ostream::char_type __c)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::int_type __put = this->rdbuf()->sputc(__c);
                if (traits_type::eq_int_type(__put, traits_type::eof()))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, std::streamsize __n)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (this->rdbuf()->sputn(__s, __n) != __n)
                    __err = ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(ios_base::badbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush()     {
        if (std::basic_ostream::__streambuf_type *__buf = this->rdbuf()) {
            std::basic_ostream::sentry __cerb(*this);
            if (__cerb) {
                ios_base::iostate __err = ios_base::goodbit;
                try {
                    if (this->rdbuf()->pubsync() == -1)
                        __err |= ios_base::badbit;
                } catch (__cxxabiv1::__forced_unwind &) {
                    this->_M_setstate(ios_base::badbit);
                    throw;
                } catch (...) {
                    this->_M_setstate(ios_base::badbit);
                }
                if (__err)
                    this->setstate(__err);
            }
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()     {
        std::basic_ostream::sentry __cerb(*this);
        std::basic_ostream::pos_type __ret = std::basic_ostream::pos_type(-1);
        if (!this->fail())
            __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::pos_type __pos)     {
        std::basic_ostream::sentry __cerb(*this);
        if (!this->fail()) {
            const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
            if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::off_type __off, ios_base::seekdir __dir)     {
        std::basic_ostream::sentry __cerb(*this);
        if (!this->fail()) {
            const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
            if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                this->setstate(ios_base::failbit);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else {
            const std::size_t __clen = char_traits<char>::length(__s);
            try {
                struct __ptr_guard {
                    _CharT *__p;
                    __ptr_guard(_CharT *__ip) : __p(__ip)                     {
                    }
                    ~__ptr_guard()                     {
                        delete [] this->__p;
                    }
                    _CharT *__get()                     {
                        return this->__p;
                    }
                } __pg(new _CharT [__clen]);
                _CharT *__ws = __pg.__get();
                for (std::size_t __i = 0; __i < __clen; ++__i)
                    __ws[__i] = __out.widen(__s[__i]);
                __ostream_insert(__out, __ws, __clen);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(ios_base::badbit);
            }
        }
        return __out;
    }
    template<> basic_ostream<char, std::char_traits<char>> &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char>> &__out, const char *__s)    template<> class basic_ostream<char> : virtual public basic_ios<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
        typedef basic_ios<char, std::char_traits<char>> __ios_type;
        typedef basic_ostream<char, std::char_traits<char>> __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char>>> __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(std::basic_ostream<char, std::char_traits<char>>::__streambuf_type *__sb);
        virtual ~basic_ostream<char>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<char, std::char_traits<char>> &_M_os;
        public:
            explicit sentry(basic_ostream<char, std::char_traits<char>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &(*__pf)(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &));
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char>>::__ios_type &(*__pf)(std::basic_ostream<char, std::char_traits<char>>::__ios_type &));
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(bool __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(short __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(int __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(long long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(double __f);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(float __f);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(long double __f);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::nullptr_t);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char>>::__streambuf_type *__sb);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &put(std::basic_ostream<char, std::char_traits<char>>::char_type __c);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &write(const std::basic_ostream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &flush();
        std::basic_ostream<char, std::char_traits<char>>::pos_type tellp();
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &seekp(std::basic_ostream<char, std::char_traits<char>>::pos_type);
        std::basic_ostream<char, std::char_traits<char>>::__ostream_type &seekp(std::basic_ostream<char, std::char_traits<char>>::off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<char, std::char_traits<char>> &);
        basic_ostream(const std::basic_ostream<char> &) = delete
        basic_ostream(std::basic_ostream<char> &&__rhs);
        std::basic_ostream<char> &operator=(const std::basic_ostream<char> &) = delete
        std::basic_ostream<char> &operator=(std::basic_ostream<char> &&__rhs);
        void swap(std::basic_ostream<char> &__rhs);
        template <typename _ValueT> std::basic_ostream<char, std::char_traits<char>>::__ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const std::basic_ostream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
    };
    template<> class basic_ostream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t>> __ios_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t>> __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        virtual ~basic_ostream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, std::char_traits<wchar_t>> &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, std::char_traits<wchar_t>> &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &(*__pf)(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ios_type &(*__pf)(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ios_type &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(bool __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(short __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(int __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(long long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(double __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(float __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(long double __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::nullptr_t);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &put(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &write(const std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &flush();
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::pos_type tellp();
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &seekp(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::pos_type);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &seekp(std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<wchar_t, std::char_traits<wchar_t>> &);
        basic_ostream(const std::basic_ostream<wchar_t> &) = delete
        basic_ostream(std::basic_ostream<wchar_t> &&__rhs);
        std::basic_ostream<wchar_t> &operator=(const std::basic_ostream<wchar_t> &) = delete
        std::basic_ostream<wchar_t> &operator=(std::basic_ostream<wchar_t> &&__rhs);
        void swap(std::basic_ostream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::__ostream_type &_M_insert(_ValueT __v);
    private:
        void _M_write(const std::basic_ostream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> __num_get_type;
        typedef ctype<_CharT> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream<_CharT, _Traits>(std::basic_istream::__streambuf_type *__sb) : _M_gcount(std::streamsize(0))         {
            this->init(__sb);
        }
        virtual ~basic_istream<_CharT, _Traits>()         {
            this->_M_gcount = std::streamsize(0);
        }
        class sentry;
        friend  class sentry;
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__istream_type &(*__pf)(std::basic_istream::__istream_type &))         {
            return __pf(*this);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__ios_type &(*__pf)(std::basic_istream::__ios_type &))         {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(bool &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(short &__n);
        std::basic_istream::__istream_type &operator>>(unsigned short &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(int &__n);
        std::basic_istream::__istream_type &operator>>(unsigned int &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(float &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(double &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(long double &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(void *&__p)         {
            return _M_extract(__p);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__streambuf_type *__sb);
        std::streamsize gcount() const         {
            return this->_M_gcount;
        }
        std::basic_istream::int_type get();
        std::basic_istream::__istream_type &get(std::basic_istream::char_type &__c);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n)         {
            return this->get(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb)         {
            return this->get(__sb, this->widen('\n'));
        }
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n)         {
            return this->getline(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &ignore(std::streamsize __n, std::basic_istream::int_type __delim);
        std::basic_istream::__istream_type &ignore(std::streamsize __n);
        std::basic_istream::__istream_type &ignore();
        std::basic_istream::int_type peek();
        std::basic_istream::__istream_type &read(std::basic_istream::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream::char_type *__s, std::streamsize __n);
        std::basic_istream::__istream_type &putback(std::basic_istream::char_type __c);
        std::basic_istream::__istream_type &unget();
        int sync();
        std::basic_istream::pos_type tellg();
        std::basic_istream::__istream_type &seekg(std::basic_istream::pos_type);
        std::basic_istream::__istream_type &seekg(std::basic_istream::off_type, ios_base::seekdir);
    protected:
        basic_istream<_CharT, _Traits>() : _M_gcount(std::streamsize(0))         {
            this->init(0);
        }
        basic_istream<_CharT, _Traits>(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits>(basic_istream<_CharT, _Traits> &&__rhs) : std::basic_istream::__ios_type(), _M_gcount(__rhs._M_gcount)         {
            __ios_type::move(__rhs);
            __rhs._M_gcount = 0;
        }
        basic_istream<_CharT, _Traits> &operator=(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits> &operator=(basic_istream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_istream<_CharT, _Traits> &__rhs)         {
            __ios_type::swap(__rhs);
            std::swap(this->_M_gcount, __rhs._M_gcount);
        }
        template <typename _ValueT> std::basic_istream::__istream_type &_M_extract(_ValueT &__v);
    };
    template <> basic_istream<char> &basic_istream<char>::getline(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::int_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::getline(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type __delim);
    class sentry {
        bool _M_ok;
    public:
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::__ctype_type __ctype_type;
        typedef typename _Traits::int_type __int_type;
        explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
        explicit operator bool() const         {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c);
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <typename _CharT, typename _Traits> void __istream_extract(basic_istream<_CharT, _Traits> &, _CharT *, std::streamsize);
    void __istream_extract(std::istream &, char *, std::streamsize);
    template <typename _CharT, typename _Traits, std::size_t _Num> inline basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT (&__s)[_Num])     {
        static_assert(_Num <= __gnu_cxx::__numeric_traits<streamsize>::__max);
        std::__istream_extract(__in, __s, _Num);
        return __in;
    }
    template <class _Traits, std::size_t _Num> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char (&__s)[_Num])     {
        return __in >> reinterpret_cast<char (&)[_Num]>(__s);
    }
    template <class _Traits, std::size_t _Num> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char (&__s)[_Num])     {
        return __in >> reinterpret_cast<char (&)[_Num]>(__s);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        explicit basic_iostream<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::basic_iostream::__istream_type(__sb), std::basic_iostream::__ostream_type(__sb)         {
        }
        virtual ~basic_iostream<_CharT, _Traits>()         {
        }
    protected:
        basic_iostream<_CharT, _Traits>() : std::basic_iostream::__istream_type(), std::basic_iostream::__ostream_type()         {
        }
        basic_iostream<_CharT, _Traits>(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &&__rhs) : std::basic_iostream::__istream_type(std::move(__rhs)), std::basic_iostream::__ostream_type(*this)         {
        }
        basic_iostream<_CharT, _Traits> &operator=(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits> &operator=(basic_iostream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_iostream<_CharT, _Traits> &__rhs)         {
            __istream_type::swap(__rhs);
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is);
    template <typename _Is, typename _Tp> using __rvalue_stream_extraction_t = _Is &&;
    template <typename _Istream, typename _Tp> inline __rvalue_stream_extraction_t<_Istream, _Tp> operator>>(_Istream &&__is, _Tp &&__x)     {
        __is >> std::forward<_Tp>(__x);
        return std::move(__is);
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits> &__in, bool __noskip = false) : _M_ok(false)     {
        ios_base::iostate __err = ios_base::goodbit;
        if (__in.good()) {
            try {
                if (__in.tie())
                    __in.tie()->flush();
                if (!__noskip && bool(__in.flags() & ios_base::skipws)) {
                    const std::basic_istream::sentry::__int_type __eof = traits_type::eof();
                    std::basic_istream::sentry::__streambuf_type *__sb = __in.rdbuf();
                    std::basic_istream::sentry::__int_type __c = __sb->sgetc();
                    const std::basic_istream::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
                    while (!traits_type::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
                        __c = __sb->snextc();
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (__in.good() && __err == ios_base::goodbit)
            this->_M_ok = true;
        else {
            __err |= ios_base::failbit;
            __in.setstate(__err);
        }
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __v);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(short &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<short>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<short>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__max;
                } else
                    __n = short(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(int &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<int>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<int>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__max;
                } else
                    __n = int(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(std::basic_istream::__streambuf_type *__sbout)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb && __sbout) {
            try {
                bool __ineof;
                if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
                    __err |= ios_base::failbit;
                if (__ineof)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::failbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbout)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()     {
        const std::basic_istream::int_type __eof = traits_type::eof();
        std::basic_istream::int_type __c = __eof;
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                __c = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__c, __eof))
                    this->_M_gcount = 1;
                else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type &__c)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __cb = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__cb, traits_type::eof())) {
                    this->_M_gcount = 1;
                    __c = traits_type::to_char_type(__cb);
                } else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        ++this->_M_gcount;
                        __c = __sb->snextc();
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__this_sb = this->rdbuf();
                std::basic_istream::int_type __c = __this_sb->sgetc();
                std::basic_istream::char_type __c2 = traits_type::to_char_type(__c);
                unsigned long long __gcount = 0;
                while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                    {
                        ++__gcount;
                        __c = __this_sb->snextc();
                        __c2 = traits_type::to_char_type(__c);
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)
                    this->_M_gcount = __gcount;
                else
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                        ++this->_M_gcount;
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else {
                    if (traits_type::eq_int_type(__c, __idelim)) {
                        __sb->sbumpc();
                        ++this->_M_gcount;
                    } else
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore()     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
                    __err |= ios_base::eofbit;
                else
                    this->_M_gcount = 1;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
                    if (__large_ignore)
                        this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                } else if (this->_M_gcount < __n) {
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n, std::basic_istream::int_type __delim)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
                    if (__large_ignore)
                        this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                    else {
                        if (this->_M_gcount != __n)
                            ++this->_M_gcount;
                        __sb->sbumpc();
                    }
                } else if (this->_M_gcount < __n) {
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                    else {
                        ++this->_M_gcount;
                        __sb->sbumpc();
                    }
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()     {
        std::basic_istream::int_type __c = traits_type::eof();
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __c = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__c, traits_type::eof()))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(std::basic_istream::char_type *__s, std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                this->_M_gcount = this->rdbuf()->sgetn(__s, __n);
                if (this->_M_gcount != __n)
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_istream<_CharT, _Traits>::readsome(std::basic_istream::char_type *__s, std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::streamsize __num = this->rdbuf()->in_avail();
                if (__num > 0)
                    this->_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
                else if (__num == -1)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return this->_M_gcount;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(std::basic_istream::char_type __c)     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget()     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> int basic_istream<_CharT, _Traits>::sync()     {
        int __ret = -1;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (__sb) {
                    if (__sb->pubsync() == -1)
                        __err |= ios_base::badbit;
                    else
                        __ret = 0;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()     {
        std::basic_istream::pos_type __ret = std::basic_istream::pos_type(-1);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                if (!this->fail())
                    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::pos_type __pos)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::off_type __off, ios_base::seekdir __dir)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::int_type __int_type;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __int_type __cb = __in.rdbuf()->sbumpc();
                if (!_Traits::eq_int_type(__cb, _Traits::eof()))
                    __c = _Traits::to_char_type(__cb);
                else
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template <typename _CharT, typename _Traits> void __istream_extract(basic_istream<_CharT, _Traits> &__in, _CharT *__s, std::streamsize __num)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename _Traits::int_type int_type;
        typedef _CharT char_type;
        typedef ctype<_CharT> __ctype_type;
        std::streamsize __extracted = 0;
        ios_base::iostate __err = ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                std::streamsize __width = __in.width();
                if (0 < __width && __width < __num)
                    __num = __width;
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                int_type __c = __sb->sgetc();
                while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        *__s++ = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __sb->snextc();
                    }
                if (__extracted < __num - 1 && _Traits::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                *__s = char_type();
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= ios_base::failbit;
        if (__err)
            __in.setstate(__err);
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__in)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename __istream_type::int_type __int_type;
        typedef ctype<_CharT> __ctype_type;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                __int_type __c = __sb->sgetc();
                while (true)
                    {
                        if (_Traits::eq_int_type(__c, __eof)) {
                            __err = ios_base::eofbit;
                            break;
                        }
                        if (!__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                            break;
                        __c = __sb->snextc();
                    }
            } catch (const __cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template<> class basic_istream<char> : virtual public basic_ios<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
        typedef basic_ios<char, std::char_traits<char>> __ios_type;
        typedef basic_istream<char, std::char_traits<char>> __istream_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char>>> __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<char, std::char_traits<char>>::__streambuf_type *__sb);
        virtual ~basic_istream<char>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::char_traits<char>> __streambuf_type;
            typedef basic_istream<char, std::char_traits<char>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, std::char_traits<char>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char>>::__istream_type &(*__pf)(std::basic_istream<char, std::char_traits<char>>::__istream_type &));
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char>>::__ios_type &(*__pf)(std::basic_istream<char, std::char_traits<char>>::__ios_type &));
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(bool &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(short &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(int &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(long long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(float &__f);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(double &__f);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(long double &__f);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(void *&__p);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char>>::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<char, std::char_traits<char>>::int_type get();
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::char_type &__c);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::__streambuf_type &__sb, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &get(std::basic_istream<char, std::char_traits<char>>::__streambuf_type &__sb);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &getline(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::char_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &getline(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &ignore(std::streamsize __n, std::basic_istream<char, std::char_traits<char>>::int_type __delim);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &ignore();
        std::basic_istream<char, std::char_traits<char>>::int_type peek();
        std::basic_istream<char, std::char_traits<char>>::__istream_type &read(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<char, std::char_traits<char>>::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &putback(std::basic_istream<char, std::char_traits<char>>::char_type __c);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &unget();
        int sync();
        std::basic_istream<char, std::char_traits<char>>::pos_type tellg();
        std::basic_istream<char, std::char_traits<char>>::__istream_type &seekg(std::basic_istream<char, std::char_traits<char>>::pos_type);
        std::basic_istream<char, std::char_traits<char>>::__istream_type &seekg(std::basic_istream<char, std::char_traits<char>>::off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const std::basic_istream<char> &) = delete
        basic_istream(std::basic_istream<char> &&__rhs);
        std::basic_istream<char> &operator=(const std::basic_istream<char> &) = delete
        std::basic_istream<char> &operator=(std::basic_istream<char> &&__rhs);
        void swap(std::basic_istream<char> &__rhs);
        template <typename _ValueT> std::basic_istream<char, std::char_traits<char>>::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<char> : public basic_istream<char, std::char_traits<char>>, public basic_ostream<char, std::char_traits<char>> {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, std::char_traits<char>> __istream_type;
        typedef basic_ostream<char, std::char_traits<char>> __ostream_type;
        explicit basic_iostream(basic_streambuf<char, std::char_traits<char>> *__sb);
        virtual ~basic_iostream<char>() throw();
    protected:
        basic_iostream();
        basic_iostream(const std::basic_iostream<char> &) = delete
        basic_iostream(std::basic_iostream<char> &&__rhs);
        std::basic_iostream<char> &operator=(const std::basic_iostream<char> &) = delete
        std::basic_iostream<char> &operator=(std::basic_iostream<char> &&__rhs);
        void swap(std::basic_iostream<char> &__rhs);
    };
    template<> class basic_istream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t>> __ios_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t>>> __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        virtual ~basic_istream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, std::char_traits<wchar_t>> __streambuf_type;
            typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, std::char_traits<wchar_t>> &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &(*__pf)(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__ios_type &(*__pf)(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__ios_type &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(bool &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(short &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(int &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(long long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(float &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(double &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(long double &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(void *&__p);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type get();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type &__c);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type &__sb, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__streambuf_type &__sb);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &getline(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &getline(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &ignore(std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &ignore();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::int_type peek();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &read(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &putback(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::char_type __c);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &unget();
        int sync();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::pos_type tellg();
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &seekg(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::pos_type);
        std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &seekg(std::basic_istream<wchar_t, std::char_traits<wchar_t>>::off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const std::basic_istream<wchar_t> &) = delete
        basic_istream(std::basic_istream<wchar_t> &&__rhs);
        std::basic_istream<wchar_t> &operator=(const std::basic_istream<wchar_t> &) = delete
        std::basic_istream<wchar_t> &operator=(std::basic_istream<wchar_t> &&__rhs);
        void swap(std::basic_istream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_istream<wchar_t, std::char_traits<wchar_t>>::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<wchar_t> : public basic_istream<wchar_t, std::char_traits<wchar_t>>, public basic_ostream<wchar_t, std::char_traits<wchar_t>> {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t>> __istream_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t>> __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, std::char_traits<wchar_t>> *__sb);
        virtual ~basic_iostream<wchar_t>() throw();
    protected:
        basic_iostream();
        basic_iostream(const std::basic_iostream<wchar_t> &) = delete
        basic_iostream(std::basic_iostream<wchar_t> &&__rhs);
        std::basic_iostream<wchar_t> &operator=(const std::basic_iostream<wchar_t> &) = delete
        std::basic_iostream<wchar_t> &operator=(std::basic_iostream<wchar_t> &&__rhs);
        void swap(std::basic_iostream<wchar_t> &__rhs);
    };
}
namespace std {
    extern std::istream cin;
    extern std::ostream cout;
    extern std::ostream cerr;
    extern std::ostream clog;
    extern std::wistream wcin;
    extern std::wostream wcout;
    extern std::wostream wcerr;
    extern std::wostream wclog;
    static ios_base::Init __ioinit;
}
template <typename A, typename ...Rest> constexpr auto parse(token_list<A, Rest...>) {
    if (sizeof...(Rest) >= 0) {
        return handle_prefix(A({}));
    } else {
        return 0;
    }
}
template<> constexpr int parse<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, <integer<2>>>(token_list<list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>) {
    if (sizeof...(Rest) >= 0) {
        return handle_prefix(list<token_list<plus, integer<3>, list<token_list<plus, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>{});
    }
}
int main() {
    auto x = ([]() -> std::string_view {
        return "(+ 3 (+ 3 (+ 2 2) 2))";
    });
    using tokens = decltype(tokenize(x));
    constexpr auto res = parse(tokens{});
    std::cout << ";; " << res << "\n";
}
constexpr bool is_same_type = std::is_same<list_start, list_start>::value;
constexpr bool is_same_type = std::is_same<list_start, list_end>::value;
constexpr bool is_same_type = std::is_same<plus, list_end>::value;
constexpr bool is_same_type = std::is_same<whitespace, list_end>::value;
constexpr bool is_same_type = std::is_same<integer<3>, list_end>::value;
constexpr bool is_same_type = std::is_same<integer<2>, list_end>::value;
constexpr bool is_same_type = std::is_same<list_end, list_end>::value;
constexpr bool is_same_type = std::is_same<plus, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<plus, integer>::value;
constexpr bool is_char_v = is_templated_int_collection<plus, c>::value;
constexpr bool is_same_type = std::is_same<plus, whitespace>::value;
constexpr bool is_same_type = std::is_same<whitespace, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<whitespace, integer>::value;
constexpr bool is_char_v = is_templated_int_collection<whitespace, c>::value;
constexpr bool is_same_type = std::is_same<whitespace, whitespace>::value;
constexpr bool is_same_type = std::is_same<integer<3>, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<integer<3>, integer>::value;
constexpr bool is_same_type = std::is_same<integer<2>, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<integer<2>, integer>::value;
constexpr bool is_integer_v = is_templated_int_collection<list_end, integer>::value;
constexpr bool is_same_type = std::is_same<list_end, list_start>::value;
constexpr bool is_same_type = std::is_same<plus, plus>::value;
