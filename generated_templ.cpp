namespace std {
    typedef unsigned long size_t;
    typedef long ptrdiff_t;
    typedef decltype(nullptr) nullptr_t;
}
namespace std {
    inline namespace __cxx11 {
    }
}
namespace __gnu_cxx {
    inline namespace __cxx11 {
    }
}
namespace std {
    template <typename> class allocator;
    template <typename, typename> struct uses_allocator;
}
namespace std {
    template <class _CharT> struct char_traits;
    template<> struct char_traits<char>;
    template<> struct char_traits<wchar_t>;
    template<> struct char_traits<char8_t>;
    template<> struct char_traits<char16_t>;
    template<> struct char_traits<char32_t>;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string;
    }
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    typedef basic_string<char8_t> u8string;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
}
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef unsigned long size_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned int wint_t;
typedef struct {
    int __count;
    union {
        unsigned int __wch;
        char __wchb[4];
    } __value;
} __mbstate_t;
typedef __mbstate_t mbstate_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct __locale_struct {
    struct __locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern "C" {
    struct tm;
    extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(1, 2)));
    extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw() __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) throw();
    extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) throw();
    extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) throw();
    extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) throw();
    extern wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((malloc));
    extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw() __attribute__((pure));
    extern size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw() __attribute__((pure));
    extern size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
    extern size_t wcslen(const wchar_t *__s) throw() __attribute__((pure));
    extern wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) throw() __attribute__((pure));
    extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) throw() __attribute__((pure));
    extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((pure));
    extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) throw();
    extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wint_t btowc(int __c) throw();
    extern int wctob(wint_t __c) throw();
    extern int mbsinit(const mbstate_t *__ps) throw() __attribute__((pure));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) throw();
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) throw();
    extern size_t __mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern int wcwidth(wchar_t __c) throw();
    extern int wcswidth(const wchar_t *__s, size_t __n) throw();
    extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float32 wcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float64 wcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float32x wcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float64x wcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
    extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw();
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) throw();
    extern int fwide(__FILE *__fp, int __mode) throw();
    extern int fwprintf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wprintf(const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) throw();
    extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wscanf(const wchar_t *__restrict __format, ...);
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) asm("__isoc99_fwscanf");
    extern int wscanf(const wchar_t *__restrict __format, ...) asm("__isoc99_wscanf");
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw() asm("__isoc99_swscanf");
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vfwscanf");
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vwscanf");
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw() asm("__isoc99_vswscanf");
    extern wint_t fgetwc(__FILE *__stream);
    extern wint_t getwc(__FILE *__stream);
    extern wint_t getwchar();
    extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
    extern wint_t getwc_unlocked(__FILE *__stream);
    extern wint_t getwchar_unlocked();
    extern wint_t fgetwc_unlocked(__FILE *__stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) throw();
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) throw();
}
namespace std {
    using ::mbstate_t;
}
extern "C++" {
    namespace std {
        using ::wint_t;
        using ::btowc;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::fwprintf;
        using ::fwscanf;
        using ::getwc;
        using ::getwchar;
        using ::mbrlen;
        using ::mbrtowc;
        using ::mbsinit;
        using ::mbsrtowcs;
        using ::putwc;
        using ::putwchar;
        using ::swprintf;
        using ::swscanf;
        using ::ungetwc;
        using ::vfwprintf;
        using ::vfwscanf;
        using ::vswprintf;
        using ::vswscanf;
        using ::vwprintf;
        using ::vwscanf;
        using ::wcrtomb;
        using ::wcscat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcscpy;
        using ::wcscspn;
        using ::wcsftime;
        using ::wcslen;
        using ::wcsncat;
        using ::wcsncmp;
        using ::wcsncpy;
        using ::wcsrtombs;
        using ::wcsspn;
        using ::wcstod;
        using ::wcstof;
        using ::wcstok;
        using ::wcstol;
        using ::wcstoul;
        using ::wcsxfrm;
        using ::wctob;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wprintf;
        using ::wscanf;
        using ::wcschr;
        using ::wcspbrk;
        using ::wcsrchr;
        using ::wcsstr;
        using ::wmemchr;
        inline wchar_t *wcschr(wchar_t *__p, wchar_t __c)         {
            return wcschr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2)         {
            return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c)         {
            return wcsrchr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2)         {
            return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, std::size_t __n)         {
            return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
        }
    }
}
namespace __gnu_cxx {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
namespace std {
    using std::wcstof;
    using std::vfwscanf;
    using std::vswscanf;
    using std::vwscanf;
    using std::wcstold;
    using std::wcstoll;
    using std::wcstoull;
}
namespace std {
    typedef long streamoff;
    typedef std::ptrdiff_t streamsize;
    template <typename _StateT> class fpos {
    private:
        std::streamoff _M_off;
        _StateT _M_state;
    public:
        fpos<_StateT>() : _M_off(0), _M_state()         {
        }
        fpos<_StateT>(std::streamoff __off) : _M_off(__off), _M_state()         {
        }
        fpos<_StateT>(const fpos<_StateT> &) = default
        fpos<_StateT> &operator=(const fpos<_StateT> &) = default
        ~fpos<_StateT>() = default
        operator streamoff() const         {
            return this->_M_off;
        }
        void state(_StateT __st)         {
            this->_M_state = __st;
        }
        _StateT state() const         {
            return this->_M_state;
        }
        fpos<_StateT> &operator+=(std::streamoff __off)         {
            this->_M_off += __off;
            return *this;
        }
        fpos<_StateT> &operator-=(std::streamoff __off)         {
            this->_M_off -= __off;
            return *this;
        }
        fpos<_StateT> operator+(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos += __off;
            return __pos;
        }
        fpos<_StateT> operator-(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos -= __off;
            return __pos;
        }
        std::streamoff operator-(const fpos<_StateT> &__other) const         {
            return this->_M_off - __other._M_off;
        }
    };
    template <typename _StateT> inline bool operator==(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) == std::streamoff(__rhs);
    }
    template <typename _StateT> inline bool operator!=(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) != std::streamoff(__rhs);
    }
    typedef fpos<mbstate_t> streampos;
    typedef fpos<mbstate_t> wstreampos;
    typedef fpos<mbstate_t> u8streampos;
    typedef fpos<mbstate_t> u16streampos;
    typedef fpos<mbstate_t> u32streampos;
}
namespace std {
    class ios_base;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_filebuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ifstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ofstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_fstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    typedef basic_ios<char> ios;
    typedef basic_streambuf<char> streambuf;
    typedef basic_istream<char> istream;
    typedef basic_ostream<char> ostream;
    typedef basic_iostream<char> iostream;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_istringstream<char> istringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_filebuf<char> filebuf;
    typedef basic_ifstream<char> ifstream;
    typedef basic_ofstream<char> ofstream;
    typedef basic_fstream<char> fstream;
    typedef basic_ios<wchar_t> wios;
    typedef basic_streambuf<wchar_t> wstreambuf;
    typedef basic_istream<wchar_t> wistream;
    typedef basic_ostream<wchar_t> wostream;
    typedef basic_iostream<wchar_t> wiostream;
    typedef basic_stringbuf<wchar_t> wstringbuf;
    typedef basic_istringstream<wchar_t> wistringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;
    typedef basic_stringstream<wchar_t> wstringstream;
    typedef basic_filebuf<wchar_t> wfilebuf;
    typedef basic_ifstream<wchar_t> wifstream;
    typedef basic_ofstream<wchar_t> wofstream;
    typedef basic_fstream<wchar_t> wfstream;
}
namespace std {
    void __throw_bad_exception();
    void __throw_bad_alloc();
    void __throw_bad_cast();
    void __throw_bad_typeid();
    void __throw_logic_error(const char *);
    void __throw_domain_error(const char *);
    void __throw_invalid_argument(const char *);
    void __throw_length_error(const char *);
    void __throw_out_of_range(const char *);
    void __throw_out_of_range_fmt(const char *, ...);
    void __throw_runtime_error(const char *);
    void __throw_range_error(const char *);
    void __throw_overflow_error(const char *);
    void __throw_underflow_error(const char *);
    void __throw_ios_failure(const char *);
    void __throw_ios_failure(const char *, int);
    void __throw_system_error(int);
    void __throw_future_error(int);
    void __throw_bad_function_call();
}
extern "C++" {
    namespace std {
        struct __true_type {
        };
        struct __false_type {
        };
        template <bool> struct __truth_type {
            typedef std::__false_type __type;
        };
        template<> struct __truth_type<true> {
            typedef std::__true_type __type;
        };
        template <class _Sp, class _Tp> struct __traitor {
            enum  {
                __value = bool(_Sp::__value) || bool(_Tp::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
template<> struct __traitor<std::__is_arithmetic<char>, std::__is_pointer<char>> {
            enum  {
                __value = bool(__is_arithmetic<char>::__value) || bool(__is_pointer<char>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
template<> struct __traitor<std::__is_integer<char>, std::__is_floating<char>> {
            enum  {
                __value = bool(__is_integer<char>::__value) || bool(__is_floating<char>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
template<> struct __traitor<std::__is_arithmetic<wchar_t>, std::__is_pointer<wchar_t>> {
            enum  {
                __value = bool(__is_arithmetic<wchar_t>::__value) || bool(__is_pointer<wchar_t>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
template<> struct __traitor<std::__is_integer<wchar_t>, std::__is_floating<wchar_t>> {
            enum  {
                __value = bool(__is_integer<wchar_t>::__value) || bool(__is_floating<wchar_t>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
template<> struct __traitor<std::__is_arithmetic<char8_t>, std::__is_pointer<char8_t>> {
            enum  {
                __value = bool(__is_arithmetic<char8_t>::__value) || bool(__is_pointer<char8_t>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
template<> struct __traitor<std::__is_integer<char8_t>, std::__is_floating<char8_t>> {
            enum  {
                __value = bool(__is_integer<char8_t>::__value) || bool(__is_floating<char8_t>::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template <typename, typename> struct __are_same {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __are_same<_Tp, _Tp> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_void {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_void<void> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_integer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<long double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<bool> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char8_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char16_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char32_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_floating {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_floating<char> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_floating<wchar_t> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_floating<char8_t> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_floating<float> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<long double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_pointer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_pointer<char> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_pointer<wchar_t> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_pointer<char8_t> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __is_pointer<_Tp *> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_arithmetic : public __traitor<__is_integer<_Tp>, __is_floating<_Tp>> {
        };
template<> struct __is_arithmetic<char> : public __traitor<__is_integer<char>, __is_floating<char>> {
        };
template<> struct __is_arithmetic<wchar_t> : public __traitor<__is_integer<wchar_t>, __is_floating<wchar_t>> {
        };
template<> struct __is_arithmetic<char8_t> : public __traitor<__is_integer<char8_t>, __is_floating<char8_t>> {
        };
        template <typename _Tp> struct __is_scalar : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>> {
        };
template<> struct __is_scalar<char> : public __traitor<__is_arithmetic<char>, __is_pointer<char>> {
        };
template<> struct __is_scalar<wchar_t> : public __traitor<__is_arithmetic<wchar_t>, __is_pointer<wchar_t>> {
        };
template<> struct __is_scalar<char8_t> : public __traitor<__is_arithmetic<char8_t>, __is_pointer<char8_t>> {
        };
        template <typename _Tp> struct __is_char {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_char<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_char<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_byte {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_byte<wchar_t> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_byte<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        enum class byte : unsigned char;
        template<> struct __is_byte<std::byte> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<char8_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename> struct iterator_traits
template<> struct iterator_traits<const char *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char *;
            using reference = const char &;
        }
template<> struct iterator_traits<char *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<char>;
            using difference_type = std::ptrdiff_t;
            using pointer = char *;
            using reference = char &;
        }
template<> struct iterator_traits<const wchar_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const wchar_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const wchar_t *;
            using reference = const wchar_t &;
        }
template<> struct iterator_traits<wchar_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<wchar_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = wchar_t *;
            using reference = wchar_t &;
        }
template<> struct iterator_traits<const char8_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char8_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char8_t *;
            using reference = const char8_t &;
        }
template<> struct iterator_traits<char8_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<char8_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = char8_t *;
            using reference = char8_t &;
        }
template<> struct iterator_traits<const char16_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char16_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char16_t *;
            using reference = const char16_t &;
        }
template<> struct iterator_traits<const char32_t *> {
            using iterator_concept = std::contiguous_iterator_tag;
            using iterator_category = std::random_access_iterator_tag;
            using value_type = remove_cv_t<const char32_t>;
            using difference_type = std::ptrdiff_t;
            using pointer = const char32_t *;
            using reference = const char32_t &;
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable {
            enum  {
                __value = __is_trivially_copyable(_Tp)
            };
        };
template<> struct __is_nonvolatile_trivially_copyable<char> {
            enum  {
                __value = __is_trivially_copyable(char)
            };
        };
template<> struct __is_nonvolatile_trivially_copyable<wchar_t> {
            enum  {
                __value = __is_trivially_copyable(wchar_t)
            };
        };
template<> struct __is_nonvolatile_trivially_copyable<char8_t> {
            enum  {
                __value = __is_trivially_copyable(char8_t)
            };
        };
template<> struct __is_nonvolatile_trivially_copyable<char16_t> {
            enum  {
                __value = __is_trivially_copyable(char16_t)
            };
        };
template<> struct __is_nonvolatile_trivially_copyable<char32_t> {
            enum  {
                __value = __is_trivially_copyable(char32_t)
            };
        };
        template <typename _Tp> struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
            enum  {
                __value = 0
            };
        };
        template <typename _OutputIter, typename _InputIter> struct __memcpyable {
            enum  {
                __value = 0
            };
        };
template<> struct __memcpyable<char *, const char *> : __is_nonvolatile_trivially_copyable<char> {
        };
template<> struct __memcpyable<wchar_t *, const wchar_t *> : __is_nonvolatile_trivially_copyable<wchar_t> {
        };
template<> struct __memcpyable<char8_t *, const char8_t *> : __is_nonvolatile_trivially_copyable<char8_t> {
        };
template<> struct __memcpyable<char16_t *, const char16_t *> : __is_nonvolatile_trivially_copyable<char16_t> {
        };
template<> struct __memcpyable<char32_t *, const char32_t *> : __is_nonvolatile_trivially_copyable<char32_t> {
        };
        template <typename _Tp> struct __memcpyable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcpyable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Iter1, typename _Iter2> struct __memcmpable {
            enum  {
                __value = 0
            };
        };
        template <typename _Tp> struct __memcmpable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<const _Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp> struct __memcmpable<_Tp *, const _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
        };
        template <typename _Tp, bool _TreatAsBytes = __is_byte<_Tp>::__value> struct __is_memcmp_ordered {
            static const bool __value = _Tp(-1) > _Tp(1);
        };
        template <typename _Tp> struct __is_memcmp_ordered<_Tp, false> {
            static const bool __value = false;
        };
        template <typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)> struct __is_memcmp_ordered_with {
            static const bool __value = __is_memcmp_ordered<_Tp>::__value && __is_memcmp_ordered<_Up>::__value;
        };
        template <typename _Tp, typename _Up> struct __is_memcmp_ordered_with<_Tp, _Up, false> {
            static const bool __value = false;
        };
        template<> struct __is_memcmp_ordered_with<std::byte, std::byte, true> {
            static constexpr bool __value = true;
        };
        template <typename _Tp, bool _SameSize> struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize> {
            static constexpr bool __value = false;
        };
        template <typename _Up, bool _SameSize> struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize> {
            static constexpr bool __value = false;
        };
        template <typename _Tp> struct __is_move_iterator {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_move_iterator<const char *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_move_iterator<const wchar_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_move_iterator<const char8_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_move_iterator<const char16_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_move_iterator<const char32_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Iterator> inline constexpr _Iterator __miter_base(_Iterator __it)         {
            return __it;
        }
        template<> inline constexpr const char *__miter_base<const char *>(const char *__it)         {
            return __it;
        }
        template<> inline constexpr const wchar_t *__miter_base<const wchar_t *>(const wchar_t *__it)         {
            return __it;
        }
        template<> inline constexpr const char8_t *__miter_base<const char8_t *>(const char8_t *__it)         {
            return __it;
        }
        template<> inline constexpr const char16_t *__miter_base<const char16_t *>(const char16_t *__it)         {
            return __it;
        }
        template<> inline constexpr const char32_t *__miter_base<const char32_t *>(const char32_t *__it)         {
            return __it;
        }
    }
}
extern "C++" {
    namespace __gnu_cxx {
        template <bool, typename> struct __enable_if {
        };
template<> struct __enable_if<false, void> {
        };
template<> struct __enable_if<true, void> {
            typedef void __type;
        };
template<> struct __enable_if<false, double> {
        };
template<> struct __enable_if<false, bool> {
        };
        template <typename _Tp> struct __enable_if<true, _Tp> {
            typedef _Tp __type;
        };
        template <bool _Cond, typename _Iftrue, typename _Iffalse> struct __conditional_type {
            typedef _Iftrue __type;
        };
        template <typename _Iftrue, typename _Iffalse> struct __conditional_type<false, _Iftrue, _Iffalse> {
            typedef _Iffalse __type;
        };
        template <typename _Tp> struct __add_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __add_unsigned<char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<signed char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<short> {
            typedef unsigned short __type;
        };
        template<> struct __add_unsigned<int> {
            typedef unsigned int __type;
        };
        template<> struct __add_unsigned<long> {
            typedef unsigned long __type;
        };
        template<> struct __add_unsigned<long long> {
            typedef unsigned long long __type;
        };
        template<> struct __add_unsigned<bool>;
        template<> struct __add_unsigned<wchar_t>;
        template <typename _Tp> struct __remove_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __remove_unsigned<char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned short> {
            typedef short __type;
        };
        template<> struct __remove_unsigned<unsigned int> {
            typedef int __type;
        };
        template<> struct __remove_unsigned<unsigned long> {
            typedef long __type;
        };
        template<> struct __remove_unsigned<unsigned long long> {
            typedef long long __type;
        };
        template<> struct __remove_unsigned<bool>;
        template<> struct __remove_unsigned<wchar_t>;
        template <typename _Type> inline bool __is_null_pointer(_Type *__ptr)         {
            return __ptr == 0;
        }
        template <typename _Type> inline bool __is_null_pointer(_Type)         {
            return false;
        }
        inline bool __is_null_pointer(std::nullptr_t)         {
            return true;
        }
        template <typename _Tp, bool = std::__is_integer<_Tp>::__value> struct __promote {
            typedef double __type;
        };
        template <typename _Tp> struct __promote<_Tp, false> {
        };
        template<> struct __promote<long double> {
            typedef long double __type;
        };
        template<> struct __promote<double> {
            typedef double __type;
        };
        template<> struct __promote<float> {
            typedef float __type;
        };
        template <typename _Tp, typename _Up, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type> struct __promote_2 {
            typedef typeof (_Tp2() + _Up2()) __type;
        };
template<> struct __promote_2<float, float, float, float> {
            typedef typeof (float() + float()) __type;
        };
template<> struct __promote_2<long double, long double, long double, long double> {
            typedef typeof (long double() + long double()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type> struct __promote_3 {
            typedef typeof (_Tp2() + _Up2() + _Vp2()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type, typename _Wp2 = typename __promote<_Wp>::__type> struct __promote_4 {
            typedef typeof (_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
        };
    }
}
namespace __gnu_cxx {
    template <typename _Tp> struct __is_integer_nonstrict : public std::__is_integer<_Tp> {
        using std::__is_integer<_Tp>::__value;
        enum  {
            __width = __value ? sizeof(_Tp) * 8 : 0
        };
    };
template<> struct __is_integer_nonstrict<long> : public std::__is_integer<long> {
        using std::__is_integer<long>::__value;
        enum  {
            __width = __value ? sizeof(long) * 8 : 0
        };
    };
template<> struct __is_integer_nonstrict<int> : public std::__is_integer<int> {
        using std::__is_integer<int>::__value;
        enum  {
            __width = __value ? sizeof(int) * 8 : 0
        };
    };
    template <typename _Value> struct __numeric_traits_integer {
        static_assert(__is_integer_nonstrict<_Value>::__value, "invalid specialization");
        static const bool __is_signed = (_Value)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<_Value>::__width - __is_signed;
        static const _Value __max = __is_signed ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1) : ~(_Value)0;
        static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };
template<> struct __numeric_traits_integer<long> {
        static_assert(__is_integer_nonstrict<long>::__value, "invalid specialization");
        static const bool __is_signed = (long)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<long>::__width - __is_signed;
        static const long __max = __is_signed ? (((((long)1 << (__digits - 1)) - 1) << 1) + 1) : ~(long)0;
        static const long __min = __is_signed ? -__max - 1 : (long)0;
    };
template<> struct __numeric_traits_integer<int> {
        static_assert(__is_integer_nonstrict<int>::__value, "invalid specialization");
        static const bool __is_signed = (int)(-1) < 0;
        static const int __digits = __is_integer_nonstrict<int>::__width - __is_signed;
        static const int __max = __is_signed ? (((((int)1 << (__digits - 1)) - 1) << 1) + 1) : ~(int)0;
        static const int __min = __is_signed ? -__max - 1 : (int)0;
    };
    const _Value __min;
    const _Value __max;
    const bool __is_signed;
    const int __digits;
    template<> struct __is_integer_nonstrict<__int128> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
        enum  {
            __width = 128
        };
    };
    template<> struct __is_integer_nonstrict<unsigned __int128> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
        enum  {
            __width = 128
        };
    };
    template <typename _Tp> using __int_traits = __numeric_traits_integer<_Tp>;
    template <typename _Value> struct __numeric_traits_floating {
        static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
    const int __max_digits10;
    const bool __is_signed;
    const int __digits10;
    const int __max_exponent10;
    template <typename _Value> struct __numeric_traits : public __conditional_type<__is_integer_nonstrict<_Value>::__value, __numeric_traits_integer<_Value>, __numeric_traits_floating<_Value>>::__type {
    };
    const bool __is_signed;
    const int __digits;
    const long __max;
    const bool __is_signed;
    const int __digits;
    const int __max;
    const int __min;
}
namespace std {
    template <typename _Tp> inline constexpr _Tp *__addressof(_Tp &__r) noexcept     {
        return __builtin_addressof(__r);
    }
}
namespace std {
    template <typename _Tp, _Tp __v> struct integral_constant {
        static constexpr _Tp value = __v;
        typedef _Tp value_type;
        typedef integral_constant<_Tp, __v> type;
        constexpr operator value_type() const noexcept         {
            return value;
        }
        constexpr std::integral_constant::value_type operator()() const noexcept         {
            return value;
        }
    };
template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        typedef bool value_type;
        typedef integral_constant<bool, true> type;
        constexpr operator value_type() const noexcept         {
            return value;
        }
        constexpr std::integral_constant<bool, true>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        typedef bool value_type;
        typedef integral_constant<bool, false> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, false>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long, 0> {
        static constexpr unsigned long value;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 0UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 0>::value_type operator()() const noexcept;
    };
    constexpr _Tp value;
    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;
    template <bool __v> using __bool_constant = integral_constant<bool, __v>;
    template <bool __v> using bool_constant = integral_constant<bool, __v>;
    template <bool, typename, typename> struct conditional
template<> struct conditional<false, std::is_lvalue_reference<const char *>, std::is_rvalue_reference<const char *>> {
        typedef std::is_rvalue_reference<const char *> type;
    }
template<> struct conditional<false, std::is_reference<const char *>, std::__or_<std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>> type;
    }
template<> struct conditional<false, std::is_function<const char *>, std::__or_<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> {
        typedef std::__or_<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>> type;
    }
template<> struct conditional<false, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>> {
        typedef std::__is_array_unknown_bounds<const char *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<const char *, 0>>, std::is_array<const char *>> {
        typedef std::is_array<const char *> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char *>, std::is_rvalue_reference<char *>> {
        typedef std::is_rvalue_reference<char *> type;
    }
template<> struct conditional<false, std::is_reference<char *>, std::__or_<std::is_function<char *>, std::is_void<char *>, std::__is_array_unknown_bounds<char *>>> {
        typedef std::__or_<std::is_function<char *>, std::is_void<char *>, std::__is_array_unknown_bounds<char *>> type;
    }
template<> struct conditional<false, std::is_function<char *>, std::__or_<std::is_void<char *>, std::__is_array_unknown_bounds<char *>>> {
        typedef std::__or_<std::is_void<char *>, std::__is_array_unknown_bounds<char *>> type;
    }
template<> struct conditional<false, std::is_void<char *>, std::__is_array_unknown_bounds<char *>> {
        typedef std::__is_array_unknown_bounds<char *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char *, 0>>, std::is_array<char *>> {
        typedef std::is_array<char *> type;
    }
template<> struct conditional<false, std::is_function<const char>, std::__or_<std::is_reference<const char>, std::is_void<const char>>> {
        typedef std::__or_<std::is_reference<const char>, std::is_void<const char>> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const char>, std::is_rvalue_reference<const char>> {
        typedef std::is_rvalue_reference<const char> type;
    }
template<> struct conditional<false, std::is_reference<const char>, std::is_void<const char>> {
        typedef std::is_void<const char> type;
    }
template<> struct conditional<false, std::is_move_assignable<char>, std::is_copy_assignable<char>> {
        typedef std::is_copy_assignable<char> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char>, std::is_rvalue_reference<char>> {
        typedef std::is_rvalue_reference<char> type;
    }
template<> struct conditional<false, std::is_reference<char>, std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    }
template<> struct conditional<false, std::is_function<char>, std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    }
template<> struct conditional<false, std::is_void<char>, std::__is_array_unknown_bounds<char>> {
        typedef std::__is_array_unknown_bounds<char> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char, 0>>, std::is_array<char>> {
        typedef std::is_array<char> type;
    }
template<> struct conditional<false, std::is_function<char>, std::__or_<std::is_reference<char>, std::is_void<char>>> {
        typedef std::__or_<std::is_reference<char>, std::is_void<char>> type;
    }
template<> struct conditional<false, std::is_reference<char>, std::is_void<char>> {
        typedef std::is_void<char> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const wchar_t *>, std::is_rvalue_reference<const wchar_t *>> {
        typedef std::is_rvalue_reference<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_reference<const wchar_t *>, std::__or_<std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_function<const wchar_t *>, std::__or_<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> {
        typedef std::__or_<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>> {
        typedef std::__is_array_unknown_bounds<const wchar_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<const wchar_t *, 0>>, std::is_array<const wchar_t *>> {
        typedef std::is_array<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<wchar_t *>, std::is_rvalue_reference<wchar_t *>> {
        typedef std::is_rvalue_reference<wchar_t *> type;
    }
template<> struct conditional<false, std::is_reference<wchar_t *>, std::__or_<std::is_function<wchar_t *>, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>>> {
        typedef std::__or_<std::is_function<wchar_t *>, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>> type;
    }
template<> struct conditional<false, std::is_function<wchar_t *>, std::__or_<std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>>> {
        typedef std::__or_<std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>> type;
    }
template<> struct conditional<false, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>> {
        typedef std::__is_array_unknown_bounds<wchar_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<wchar_t *, 0>>, std::is_array<wchar_t *>> {
        typedef std::is_array<wchar_t *> type;
    }
template<> struct conditional<false, std::is_function<const wchar_t>, std::__or_<std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> {
        typedef std::__or_<std::is_reference<const wchar_t>, std::is_void<const wchar_t>> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const wchar_t>, std::is_rvalue_reference<const wchar_t>> {
        typedef std::is_rvalue_reference<const wchar_t> type;
    }
template<> struct conditional<false, std::is_reference<const wchar_t>, std::is_void<const wchar_t>> {
        typedef std::is_void<const wchar_t> type;
    }
template<> struct conditional<false, std::is_move_assignable<wchar_t>, std::is_copy_assignable<wchar_t>> {
        typedef std::is_copy_assignable<wchar_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>> {
        typedef std::is_rvalue_reference<wchar_t> type;
    }
template<> struct conditional<false, std::is_reference<wchar_t>, std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    }
template<> struct conditional<false, std::is_function<wchar_t>, std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    }
template<> struct conditional<false, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> {
        typedef std::__is_array_unknown_bounds<wchar_t> type;
    }
template<> struct conditional<false, std::__not_<std::extent<wchar_t, 0>>, std::is_array<wchar_t>> {
        typedef std::is_array<wchar_t> type;
    }
template<> struct conditional<false, std::is_function<wchar_t>, std::__or_<std::is_reference<wchar_t>, std::is_void<wchar_t>>> {
        typedef std::__or_<std::is_reference<wchar_t>, std::is_void<wchar_t>> type;
    }
template<> struct conditional<false, std::is_reference<wchar_t>, std::is_void<wchar_t>> {
        typedef std::is_void<wchar_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const char8_t *>, std::is_rvalue_reference<const char8_t *>> {
        typedef std::is_rvalue_reference<const char8_t *> type;
    }
template<> struct conditional<false, std::is_reference<const char8_t *>, std::__or_<std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char8_t *>, std::__or_<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> {
        typedef std::__or_<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>> {
        typedef std::__is_array_unknown_bounds<const char8_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<const char8_t *, 0>>, std::is_array<const char8_t *>> {
        typedef std::is_array<const char8_t *> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char8_t *>, std::is_rvalue_reference<char8_t *>> {
        typedef std::is_rvalue_reference<char8_t *> type;
    }
template<> struct conditional<false, std::is_reference<char8_t *>, std::__or_<std::is_function<char8_t *>, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>>> {
        typedef std::__or_<std::is_function<char8_t *>, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>> type;
    }
template<> struct conditional<false, std::is_function<char8_t *>, std::__or_<std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>>> {
        typedef std::__or_<std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>> type;
    }
template<> struct conditional<false, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>> {
        typedef std::__is_array_unknown_bounds<char8_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char8_t *, 0>>, std::is_array<char8_t *>> {
        typedef std::is_array<char8_t *> type;
    }
template<> struct conditional<false, std::is_function<const char8_t>, std::__or_<std::is_reference<const char8_t>, std::is_void<const char8_t>>> {
        typedef std::__or_<std::is_reference<const char8_t>, std::is_void<const char8_t>> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const char8_t>, std::is_rvalue_reference<const char8_t>> {
        typedef std::is_rvalue_reference<const char8_t> type;
    }
template<> struct conditional<false, std::is_reference<const char8_t>, std::is_void<const char8_t>> {
        typedef std::is_void<const char8_t> type;
    }
template<> struct conditional<false, std::is_move_assignable<char8_t>, std::is_copy_assignable<char8_t>> {
        typedef std::is_copy_assignable<char8_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char8_t>, std::is_rvalue_reference<char8_t>> {
        typedef std::is_rvalue_reference<char8_t> type;
    }
template<> struct conditional<false, std::is_reference<char8_t>, std::__or_<std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> {
        typedef std::__or_<std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>> type;
    }
template<> struct conditional<false, std::is_function<char8_t>, std::__or_<std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> {
        typedef std::__or_<std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>> type;
    }
template<> struct conditional<false, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>> {
        typedef std::__is_array_unknown_bounds<char8_t> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char8_t, 0>>, std::is_array<char8_t>> {
        typedef std::is_array<char8_t> type;
    }
template<> struct conditional<false, std::is_function<char8_t>, std::__or_<std::is_reference<char8_t>, std::is_void<char8_t>>> {
        typedef std::__or_<std::is_reference<char8_t>, std::is_void<char8_t>> type;
    }
template<> struct conditional<false, std::is_reference<char8_t>, std::is_void<char8_t>> {
        typedef std::is_void<char8_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const char16_t *>, std::is_rvalue_reference<const char16_t *>> {
        typedef std::is_rvalue_reference<const char16_t *> type;
    }
template<> struct conditional<false, std::is_reference<const char16_t *>, std::__or_<std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char16_t *>, std::__or_<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> {
        typedef std::__or_<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>> {
        typedef std::__is_array_unknown_bounds<const char16_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<const char16_t *, 0>>, std::is_array<const char16_t *>> {
        typedef std::is_array<const char16_t *> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char16_t *>, std::is_rvalue_reference<char16_t *>> {
        typedef std::is_rvalue_reference<char16_t *> type;
    }
template<> struct conditional<false, std::is_reference<char16_t *>, std::__or_<std::is_function<char16_t *>, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>>> {
        typedef std::__or_<std::is_function<char16_t *>, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>> type;
    }
template<> struct conditional<false, std::is_function<char16_t *>, std::__or_<std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>>> {
        typedef std::__or_<std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>> type;
    }
template<> struct conditional<false, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>> {
        typedef std::__is_array_unknown_bounds<char16_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char16_t *, 0>>, std::is_array<char16_t *>> {
        typedef std::is_array<char16_t *> type;
    }
template<> struct conditional<false, std::is_function<const char16_t>, std::__or_<std::is_reference<const char16_t>, std::is_void<const char16_t>>> {
        typedef std::__or_<std::is_reference<const char16_t>, std::is_void<const char16_t>> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const char16_t>, std::is_rvalue_reference<const char16_t>> {
        typedef std::is_rvalue_reference<const char16_t> type;
    }
template<> struct conditional<false, std::is_reference<const char16_t>, std::is_void<const char16_t>> {
        typedef std::is_void<const char16_t> type;
    }
template<> struct conditional<false, std::is_move_assignable<char16_t>, std::is_copy_assignable<char16_t>> {
        typedef std::is_copy_assignable<char16_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>> {
        typedef std::is_rvalue_reference<char16_t> type;
    }
template<> struct conditional<false, std::is_reference<char16_t>, std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    }
template<> struct conditional<false, std::is_function<char16_t>, std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    }
template<> struct conditional<false, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> {
        typedef std::__is_array_unknown_bounds<char16_t> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char16_t, 0>>, std::is_array<char16_t>> {
        typedef std::is_array<char16_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const char32_t *>, std::is_rvalue_reference<const char32_t *>> {
        typedef std::is_rvalue_reference<const char32_t *> type;
    }
template<> struct conditional<false, std::is_reference<const char32_t *>, std::__or_<std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char32_t *>, std::__or_<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> {
        typedef std::__or_<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>> {
        typedef std::__is_array_unknown_bounds<const char32_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<const char32_t *, 0>>, std::is_array<const char32_t *>> {
        typedef std::is_array<const char32_t *> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char32_t *>, std::is_rvalue_reference<char32_t *>> {
        typedef std::is_rvalue_reference<char32_t *> type;
    }
template<> struct conditional<false, std::is_reference<char32_t *>, std::__or_<std::is_function<char32_t *>, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>>> {
        typedef std::__or_<std::is_function<char32_t *>, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>> type;
    }
template<> struct conditional<false, std::is_function<char32_t *>, std::__or_<std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>>> {
        typedef std::__or_<std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>> type;
    }
template<> struct conditional<false, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>> {
        typedef std::__is_array_unknown_bounds<char32_t *> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char32_t *, 0>>, std::is_array<char32_t *>> {
        typedef std::is_array<char32_t *> type;
    }
template<> struct conditional<false, std::is_function<const char32_t>, std::__or_<std::is_reference<const char32_t>, std::is_void<const char32_t>>> {
        typedef std::__or_<std::is_reference<const char32_t>, std::is_void<const char32_t>> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<const char32_t>, std::is_rvalue_reference<const char32_t>> {
        typedef std::is_rvalue_reference<const char32_t> type;
    }
template<> struct conditional<false, std::is_reference<const char32_t>, std::is_void<const char32_t>> {
        typedef std::is_void<const char32_t> type;
    }
template<> struct conditional<false, std::is_move_assignable<char32_t>, std::is_copy_assignable<char32_t>> {
        typedef std::is_copy_assignable<char32_t> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>> {
        typedef std::is_rvalue_reference<char32_t> type;
    }
template<> struct conditional<false, std::is_reference<char32_t>, std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    }
template<> struct conditional<false, std::is_function<char32_t>, std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    }
template<> struct conditional<false, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> {
        typedef std::__is_array_unknown_bounds<char32_t> type;
    }
template<> struct conditional<false, std::__not_<std::extent<char32_t, 0>>, std::is_array<char32_t>> {
        typedef std::is_array<char32_t> type;
    }
template<> struct conditional<false, std::is_void<const char *>, std::__or_<std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>> type;
    }
template<> struct conditional<false, std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>> {
        typedef std::is_function<const char *> type;
    }
template<> struct conditional<false, std::is_reference<const char *>, std::is_scalar<const char *>> {
        typedef std::is_scalar<const char *> type;
    }
template<> struct conditional<false, std::is_integral<const char *>, std::is_floating_point<const char *>> {
        typedef std::is_floating_point<const char *> type;
    }
template<> struct conditional<false, std::is_arithmetic<const char *>, std::__or_<std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
        typedef std::__or_<std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>> type;
    }
template<> struct conditional<false, std::is_enum<const char *>, std::__or_<std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
        typedef std::__or_<std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>> type;
    }
template<> struct conditional<true, std::is_pointer<const char *>, std::__or_<std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
        typedef std::is_pointer<const char *> type;
    }
template<> struct conditional<false, std::is_function<const char *>, std::__or_<std::is_reference<const char *>, std::is_void<const char *>>> {
        typedef std::__or_<std::is_reference<const char *>, std::is_void<const char *>> type;
    }
template<> struct conditional<false, std::is_reference<const char *>, std::is_void<const char *>> {
        typedef std::is_void<const char *> type;
    }
template<> struct conditional<false, std::is_void<const char *>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    }
template<> struct conditional<false, std::is_function<const char *>, std::is_array<const char *>> {
        typedef std::is_array<const char *> type;
    }
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<const char *const &>, std::is_array<const char *const &>>> {
        typedef std::__or_<std::is_function<const char *const &>, std::is_array<const char *const &>> type;
    }
template<> struct conditional<false, std::is_function<const char *const &>, std::is_array<const char *const &>> {
        typedef std::is_array<const char *const &> type;
    }
template<> struct conditional<true, std::__is_nt_assignable_impl<const char *&, const char *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char *&, const char *&&> type;
    }
template<> struct conditional<true, std::is_integral<long>, std::is_floating_point<long>> {
        typedef std::is_integral<long> type;
    }
template<> struct conditional<false, std::is_void<const char &>, std::__or_<std::is_function<const char &>, std::is_array<const char &>>> {
        typedef std::__or_<std::is_function<const char &>, std::is_array<const char &>> type;
    }
template<> struct conditional<false, std::is_function<const char &>, std::is_array<const char &>> {
        typedef std::is_array<const char &> type;
    }
template<> struct conditional<false, std::is_void<char &>, std::__or_<std::is_function<const char &>, std::is_array<const char &>>> {
        typedef std::__or_<std::is_function<const char &>, std::is_array<const char &>> type;
    }
template<> struct conditional<false, std::is_void<const char &&>, std::__or_<std::is_function<const char &>, std::is_array<const char &>>> {
        typedef std::__or_<std::is_function<const char &>, std::is_array<const char &>> type;
    }
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>> type;
    }
template<> struct conditional<false, std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>> {
        typedef std::is_array<const volatile std::input_iterator_tag *> type;
    }
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>> type;
    }
template<> struct conditional<false, std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>> {
        typedef std::is_array<const volatile std::forward_iterator_tag *> type;
    }
template<> struct conditional<false, std::is_void<const char *&>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    }
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    }
template<> struct conditional<false, std::is_void<const char *const>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    }
template<> struct conditional<false, std::is_void<bool>, std::__or_<std::is_function<bool>, std::is_array<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_array<bool>> type;
    }
template<> struct conditional<false, std::is_function<bool>, std::is_array<bool>> {
        typedef std::is_array<bool> type;
    }
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>> type;
    }
template<> struct conditional<false, std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>> {
        typedef std::is_array<const volatile std::bidirectional_iterator_tag *> type;
    }
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>> type;
    }
template<> struct conditional<false, std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>> {
        typedef std::is_array<const volatile std::random_access_iterator_tag *> type;
    }
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>> type;
    }
template<> struct conditional<false, std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>> {
        typedef std::is_array<const volatile std::contiguous_iterator_tag *> type;
    }
template<> struct conditional<true, std::__is_referenceable<const char &, void>, std::is_void<const char &>> {
        typedef std::__is_referenceable<const char &, void> type;
    }
template<> struct conditional<false, std::is_void<unsigned long>, std::__or_<std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>> type;
    }
template<> struct conditional<false, std::__not_<std::extent<unsigned long, 0>>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    }
template<> struct conditional<false, std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>> {
        typedef std::is_function<unsigned long> type;
    }
template<> struct conditional<false, std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>> {
        typedef std::is_rvalue_reference<unsigned long> type;
    }
template<> struct conditional<false, std::is_reference<unsigned long>, std::is_scalar<unsigned long>> {
        typedef std::is_scalar<unsigned long> type;
    }
template<> struct conditional<true, std::is_integral<unsigned long>, std::is_floating_point<unsigned long>> {
        typedef std::is_integral<unsigned long> type;
    }
template<> struct conditional<true, std::is_arithmetic<unsigned long>, std::__or_<std::is_enum<unsigned long>, std::is_pointer<unsigned long>, std::is_member_pointer<unsigned long>, std::is_null_pointer<unsigned long>>> {
        typedef std::is_arithmetic<unsigned long> type;
    }
template<> struct conditional<false, std::is_reference<unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    }
template<> struct conditional<false, std::is_function<unsigned long>, std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    }
template<> struct conditional<false, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> {
        typedef std::__is_array_unknown_bounds<unsigned long> type;
    }
template<> struct conditional<false, std::is_void<unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    }
template<> struct conditional<false, std::is_function<unsigned long>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    }
template<> struct conditional<false, std::is_void<unsigned long &>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    }
template<> struct conditional<false, std::is_void<const unsigned long &>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    }
template<> struct conditional<false, std::is_void<const unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    }
template<> struct conditional<false, std::is_function<unsigned long>, std::__or_<std::is_reference<unsigned long>, std::is_void<unsigned long>>> {
        typedef std::__or_<std::is_reference<unsigned long>, std::is_void<unsigned long>> type;
    }
template<> struct conditional<false, std::is_reference<unsigned long>, std::is_void<unsigned long>> {
        typedef std::is_void<unsigned long> type;
    }
template<> struct conditional<false, std::is_void<const unsigned long &>, std::__or_<std::is_function<const unsigned long &>, std::is_array<const unsigned long &>>> {
        typedef std::__or_<std::is_function<const unsigned long &>, std::is_array<const unsigned long &>> type;
    }
template<> struct conditional<false, std::is_function<const unsigned long &>, std::is_array<const unsigned long &>> {
        typedef std::is_array<const unsigned long &> type;
    }
template<> struct conditional<true, std::__is_nt_assignable_impl<unsigned long &, unsigned long &&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<unsigned long &, unsigned long &&> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *>, std::__or_<std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>> type;
    }
template<> struct conditional<false, std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>> {
        typedef std::is_function<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_reference<const wchar_t *>, std::is_scalar<const wchar_t *>> {
        typedef std::is_scalar<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_integral<const wchar_t *>, std::is_floating_point<const wchar_t *>> {
        typedef std::is_floating_point<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_arithmetic<const wchar_t *>, std::__or_<std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
        typedef std::__or_<std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_enum<const wchar_t *>, std::__or_<std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
        typedef std::__or_<std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>> type;
    }
template<> struct conditional<true, std::is_pointer<const wchar_t *>, std::__or_<std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
        typedef std::is_pointer<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_function<const wchar_t *>, std::__or_<std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> {
        typedef std::__or_<std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>> {
        typedef std::is_void<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> {
        typedef std::is_array<const wchar_t *> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>>> {
        typedef std::__or_<std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>> type;
    }
template<> struct conditional<false, std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>> {
        typedef std::is_array<const wchar_t *const &> type;
    }
template<> struct conditional<true, std::__is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t &>, std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
        typedef std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> type;
    }
template<> struct conditional<false, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> {
        typedef std::is_array<const wchar_t &> type;
    }
template<> struct conditional<false, std::is_void<wchar_t &>, std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
        typedef std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t &&>, std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
        typedef std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *&>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    }
template<> struct conditional<false, std::is_void<const wchar_t *const>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    }
template<> struct conditional<true, std::__is_referenceable<const wchar_t &, void>, std::is_void<const wchar_t &>> {
        typedef std::__is_referenceable<const wchar_t &, void> type;
    }
template<> struct conditional<false, std::is_void<const char8_t *>, std::__or_<std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>> type;
    }
template<> struct conditional<false, std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>> {
        typedef std::is_function<const char8_t *> type;
    }
template<> struct conditional<false, std::is_reference<const char8_t *>, std::is_scalar<const char8_t *>> {
        typedef std::is_scalar<const char8_t *> type;
    }
template<> struct conditional<false, std::is_integral<const char8_t *>, std::is_floating_point<const char8_t *>> {
        typedef std::is_floating_point<const char8_t *> type;
    }
template<> struct conditional<false, std::is_arithmetic<const char8_t *>, std::__or_<std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
        typedef std::__or_<std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>> type;
    }
template<> struct conditional<false, std::is_enum<const char8_t *>, std::__or_<std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
        typedef std::__or_<std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>> type;
    }
template<> struct conditional<true, std::is_pointer<const char8_t *>, std::__or_<std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
        typedef std::is_pointer<const char8_t *> type;
    }
template<> struct conditional<false, std::is_function<const char8_t *>, std::__or_<std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> {
        typedef std::__or_<std::is_reference<const char8_t *>, std::is_void<const char8_t *>> type;
    }
template<> struct conditional<false, std::is_reference<const char8_t *>, std::is_void<const char8_t *>> {
        typedef std::is_void<const char8_t *> type;
    }
template<> struct conditional<false, std::is_void<const char8_t *>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char8_t *>, std::is_array<const char8_t *>> {
        typedef std::is_array<const char8_t *> type;
    }
template<> struct conditional<false, std::is_void<const char8_t *const &>, std::__or_<std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>>> {
        typedef std::__or_<std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>> type;
    }
template<> struct conditional<false, std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>> {
        typedef std::is_array<const char8_t *const &> type;
    }
template<> struct conditional<true, std::__is_nt_assignable_impl<const char8_t *&, const char8_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char8_t *&, const char8_t *&&> type;
    }
template<> struct conditional<false, std::is_void<const char8_t &>, std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
        typedef std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>> type;
    }
template<> struct conditional<false, std::is_function<const char8_t &>, std::is_array<const char8_t &>> {
        typedef std::is_array<const char8_t &> type;
    }
template<> struct conditional<false, std::is_void<char8_t &>, std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
        typedef std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>> type;
    }
template<> struct conditional<false, std::is_void<const char8_t &&>, std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
        typedef std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>> type;
    }
template<> struct conditional<false, std::is_void<const char8_t *&>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char8_t *const &>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char8_t *const>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    }
template<> struct conditional<true, std::__is_referenceable<const char8_t &, void>, std::is_void<const char8_t &>> {
        typedef std::__is_referenceable<const char8_t &, void> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *>, std::__or_<std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>> type;
    }
template<> struct conditional<false, std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>> {
        typedef std::is_function<const char16_t *> type;
    }
template<> struct conditional<false, std::is_reference<const char16_t *>, std::is_scalar<const char16_t *>> {
        typedef std::is_scalar<const char16_t *> type;
    }
template<> struct conditional<false, std::is_integral<const char16_t *>, std::is_floating_point<const char16_t *>> {
        typedef std::is_floating_point<const char16_t *> type;
    }
template<> struct conditional<false, std::is_arithmetic<const char16_t *>, std::__or_<std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
        typedef std::__or_<std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_enum<const char16_t *>, std::__or_<std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
        typedef std::__or_<std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>> type;
    }
template<> struct conditional<true, std::is_pointer<const char16_t *>, std::__or_<std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
        typedef std::is_pointer<const char16_t *> type;
    }
template<> struct conditional<false, std::is_function<const char16_t *>, std::__or_<std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> {
        typedef std::__or_<std::is_reference<const char16_t *>, std::is_void<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_reference<const char16_t *>, std::is_void<const char16_t *>> {
        typedef std::is_void<const char16_t *> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char16_t *>, std::is_array<const char16_t *>> {
        typedef std::is_array<const char16_t *> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>>> {
        typedef std::__or_<std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>> type;
    }
template<> struct conditional<false, std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>> {
        typedef std::is_array<const char16_t *const &> type;
    }
template<> struct conditional<true, std::__is_nt_assignable_impl<const char16_t *&, const char16_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char16_t *&, const char16_t *&&> type;
    }
template<> struct conditional<false, std::is_void<const char16_t &>, std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
        typedef std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>> type;
    }
template<> struct conditional<false, std::is_function<const char16_t &>, std::is_array<const char16_t &>> {
        typedef std::is_array<const char16_t &> type;
    }
template<> struct conditional<false, std::is_void<char16_t &>, std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
        typedef std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>> type;
    }
template<> struct conditional<false, std::is_void<const char16_t &&>, std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
        typedef std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *&>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char16_t *const>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    }
template<> struct conditional<true, std::__is_referenceable<const char16_t &, void>, std::is_void<const char16_t &>> {
        typedef std::__is_referenceable<const char16_t &, void> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *>, std::__or_<std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>> type;
    }
template<> struct conditional<false, std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>> {
        typedef std::is_function<const char32_t *> type;
    }
template<> struct conditional<false, std::is_reference<const char32_t *>, std::is_scalar<const char32_t *>> {
        typedef std::is_scalar<const char32_t *> type;
    }
template<> struct conditional<false, std::is_integral<const char32_t *>, std::is_floating_point<const char32_t *>> {
        typedef std::is_floating_point<const char32_t *> type;
    }
template<> struct conditional<false, std::is_arithmetic<const char32_t *>, std::__or_<std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
        typedef std::__or_<std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_enum<const char32_t *>, std::__or_<std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
        typedef std::__or_<std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>> type;
    }
template<> struct conditional<true, std::is_pointer<const char32_t *>, std::__or_<std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
        typedef std::is_pointer<const char32_t *> type;
    }
template<> struct conditional<false, std::is_function<const char32_t *>, std::__or_<std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> {
        typedef std::__or_<std::is_reference<const char32_t *>, std::is_void<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_reference<const char32_t *>, std::is_void<const char32_t *>> {
        typedef std::is_void<const char32_t *> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_function<const char32_t *>, std::is_array<const char32_t *>> {
        typedef std::is_array<const char32_t *> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>>> {
        typedef std::__or_<std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>> type;
    }
template<> struct conditional<false, std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>> {
        typedef std::is_array<const char32_t *const &> type;
    }
template<> struct conditional<true, std::__is_nt_assignable_impl<const char32_t *&, const char32_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char32_t *&, const char32_t *&&> type;
    }
template<> struct conditional<false, std::is_void<const char32_t &>, std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
        typedef std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>> type;
    }
template<> struct conditional<false, std::is_function<const char32_t &>, std::is_array<const char32_t &>> {
        typedef std::is_array<const char32_t &> type;
    }
template<> struct conditional<false, std::is_void<char32_t &>, std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
        typedef std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>> type;
    }
template<> struct conditional<false, std::is_void<const char32_t &&>, std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
        typedef std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *&>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    }
template<> struct conditional<false, std::is_void<const char32_t *const>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    }
template<> struct conditional<true, std::__is_referenceable<const char32_t &, void>, std::is_void<const char32_t &>> {
        typedef std::__is_referenceable<const char32_t &, void> type;
    };
    template <typename _Type> struct __type_identity {
        using type = _Type;
    };
template<> struct __type_identity<const char *> {
        using type = const char *;
    };
template<> struct __type_identity<char *> {
        using type = char *;
    };
template<> struct __type_identity<char> {
        using type = char;
    };
template<> struct __type_identity<const wchar_t *> {
        using type = const wchar_t *;
    };
template<> struct __type_identity<wchar_t *> {
        using type = wchar_t *;
    };
template<> struct __type_identity<wchar_t> {
        using type = wchar_t;
    };
template<> struct __type_identity<const char8_t *> {
        using type = const char8_t *;
    };
template<> struct __type_identity<char8_t *> {
        using type = char8_t *;
    };
template<> struct __type_identity<char8_t> {
        using type = char8_t;
    };
template<> struct __type_identity<const char16_t *> {
        using type = const char16_t *;
    };
template<> struct __type_identity<char16_t *> {
        using type = char16_t *;
    };
template<> struct __type_identity<char16_t> {
        using type = char16_t;
    };
template<> struct __type_identity<const char32_t *> {
        using type = const char32_t *;
    };
template<> struct __type_identity<char32_t *> {
        using type = char32_t *;
    };
template<> struct __type_identity<char32_t> {
        using type = char32_t;
    };
template<> struct __type_identity<unsigned long> {
        using type = unsigned long;
    };
    template <typename _Tp> using __type_identity_t = typename __type_identity<_Tp>::type;
    template <typename ...> struct __or_
template<> struct __or_<<std::is_reference<const char *>, std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> : public conditional<is_reference<const char *>::value, is_reference<const char *>, __or_<is_function<const char *>, is_void<const char *>, __is_array_unknown_bounds<const char *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char *>, std::is_rvalue_reference<const char *>>> : public conditional<is_lvalue_reference<const char *>::value, is_lvalue_reference<const char *>, is_rvalue_reference<const char *>>::type {
    }
template<> struct __or_<<std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> : public conditional<is_function<const char *>::value, is_function<const char *>, __or_<is_void<const char *>, __is_array_unknown_bounds<const char *>>>::type {
    }
template<> struct __or_<<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> : public conditional<is_void<const char *>::value, is_void<const char *>, __is_array_unknown_bounds<const char *>>::type {
    }
template<> struct __or_<<std::is_reference<char *>, std::is_function<char *>, std::is_void<char *>, std::__is_array_unknown_bounds<char *>>> : public conditional<is_reference<char *>::value, is_reference<char *>, __or_<is_function<char *>, is_void<char *>, __is_array_unknown_bounds<char *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char *>, std::is_rvalue_reference<char *>>> : public conditional<is_lvalue_reference<char *>::value, is_lvalue_reference<char *>, is_rvalue_reference<char *>>::type {
    }
template<> struct __or_<<std::is_function<char *>, std::is_void<char *>, std::__is_array_unknown_bounds<char *>>> : public conditional<is_function<char *>::value, is_function<char *>, __or_<is_void<char *>, __is_array_unknown_bounds<char *>>>::type {
    }
template<> struct __or_<<std::is_void<char *>, std::__is_array_unknown_bounds<char *>>> : public conditional<is_void<char *>::value, is_void<char *>, __is_array_unknown_bounds<char *>>::type {
    }
template<> struct __or_<<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>> : public conditional<is_function<const char>::value, is_function<const char>, __or_<is_reference<const char>, is_void<const char>>>::type {
    }
template<> struct __or_<<std::is_reference<const char>, std::is_void<const char>>> : public conditional<is_reference<const char>::value, is_reference<const char>, is_void<const char>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char>, std::is_rvalue_reference<const char>>> : public conditional<is_lvalue_reference<const char>::value, is_lvalue_reference<const char>, is_rvalue_reference<const char>>::type {
    }
template<> struct __or_<<std::is_reference<char>, std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public conditional<is_reference<char>::value, is_reference<char>, __or_<is_function<char>, is_void<char>, __is_array_unknown_bounds<char>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char>, std::is_rvalue_reference<char>>> : public conditional<is_lvalue_reference<char>::value, is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    }
template<> struct __or_<<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public conditional<is_function<char>::value, is_function<char>, __or_<is_void<char>, __is_array_unknown_bounds<char>>>::type {
    }
template<> struct __or_<<std::is_void<char>, std::__is_array_unknown_bounds<char>>> : public conditional<is_void<char>::value, is_void<char>, __is_array_unknown_bounds<char>>::type {
    }
template<> struct __or_<<std::is_function<char>, std::is_reference<char>, std::is_void<char>>> : public conditional<is_function<char>::value, is_function<char>, __or_<is_reference<char>, is_void<char>>>::type {
    }
template<> struct __or_<<std::is_reference<char>, std::is_void<char>>> : public conditional<is_reference<char>::value, is_reference<char>, is_void<char>>::type {
    }
template<> struct __or_<<std::is_reference<const wchar_t *>, std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> : public conditional<is_reference<const wchar_t *>::value, is_reference<const wchar_t *>, __or_<is_function<const wchar_t *>, is_void<const wchar_t *>, __is_array_unknown_bounds<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const wchar_t *>, std::is_rvalue_reference<const wchar_t *>>> : public conditional<is_lvalue_reference<const wchar_t *>::value, is_lvalue_reference<const wchar_t *>, is_rvalue_reference<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> : public conditional<is_function<const wchar_t *>::value, is_function<const wchar_t *>, __or_<is_void<const wchar_t *>, __is_array_unknown_bounds<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> : public conditional<is_void<const wchar_t *>::value, is_void<const wchar_t *>, __is_array_unknown_bounds<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_reference<wchar_t *>, std::is_function<wchar_t *>, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>>> : public conditional<is_reference<wchar_t *>::value, is_reference<wchar_t *>, __or_<is_function<wchar_t *>, is_void<wchar_t *>, __is_array_unknown_bounds<wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<wchar_t *>, std::is_rvalue_reference<wchar_t *>>> : public conditional<is_lvalue_reference<wchar_t *>::value, is_lvalue_reference<wchar_t *>, is_rvalue_reference<wchar_t *>>::type {
    }
template<> struct __or_<<std::is_function<wchar_t *>, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>>> : public conditional<is_function<wchar_t *>::value, is_function<wchar_t *>, __or_<is_void<wchar_t *>, __is_array_unknown_bounds<wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>>> : public conditional<is_void<wchar_t *>::value, is_void<wchar_t *>, __is_array_unknown_bounds<wchar_t *>>::type {
    }
template<> struct __or_<<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : public conditional<is_function<const wchar_t>::value, is_function<const wchar_t>, __or_<is_reference<const wchar_t>, is_void<const wchar_t>>>::type {
    }
template<> struct __or_<<std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : public conditional<is_reference<const wchar_t>::value, is_reference<const wchar_t>, is_void<const wchar_t>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const wchar_t>, std::is_rvalue_reference<const wchar_t>>> : public conditional<is_lvalue_reference<const wchar_t>::value, is_lvalue_reference<const wchar_t>, is_rvalue_reference<const wchar_t>>::type {
    }
template<> struct __or_<<std::is_reference<wchar_t>, std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public conditional<is_reference<wchar_t>::value, is_reference<wchar_t>, __or_<is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>>> : public conditional<is_lvalue_reference<wchar_t>::value, is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    }
template<> struct __or_<<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public conditional<is_function<wchar_t>::value, is_function<wchar_t>, __or_<is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>>::type {
    }
template<> struct __or_<<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> : public conditional<is_void<wchar_t>::value, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>::type {
    }
template<> struct __or_<<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>> : public conditional<is_function<wchar_t>::value, is_function<wchar_t>, __or_<is_reference<wchar_t>, is_void<wchar_t>>>::type {
    }
template<> struct __or_<<std::is_reference<wchar_t>, std::is_void<wchar_t>>> : public conditional<is_reference<wchar_t>::value, is_reference<wchar_t>, is_void<wchar_t>>::type {
    }
template<> struct __or_<<std::is_reference<const char8_t *>, std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> : public conditional<is_reference<const char8_t *>::value, is_reference<const char8_t *>, __or_<is_function<const char8_t *>, is_void<const char8_t *>, __is_array_unknown_bounds<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char8_t *>, std::is_rvalue_reference<const char8_t *>>> : public conditional<is_lvalue_reference<const char8_t *>::value, is_lvalue_reference<const char8_t *>, is_rvalue_reference<const char8_t *>>::type {
    }
template<> struct __or_<<std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> : public conditional<is_function<const char8_t *>::value, is_function<const char8_t *>, __or_<is_void<const char8_t *>, __is_array_unknown_bounds<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> : public conditional<is_void<const char8_t *>::value, is_void<const char8_t *>, __is_array_unknown_bounds<const char8_t *>>::type {
    }
template<> struct __or_<<std::is_reference<char8_t *>, std::is_function<char8_t *>, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>>> : public conditional<is_reference<char8_t *>::value, is_reference<char8_t *>, __or_<is_function<char8_t *>, is_void<char8_t *>, __is_array_unknown_bounds<char8_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char8_t *>, std::is_rvalue_reference<char8_t *>>> : public conditional<is_lvalue_reference<char8_t *>::value, is_lvalue_reference<char8_t *>, is_rvalue_reference<char8_t *>>::type {
    }
template<> struct __or_<<std::is_function<char8_t *>, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>>> : public conditional<is_function<char8_t *>::value, is_function<char8_t *>, __or_<is_void<char8_t *>, __is_array_unknown_bounds<char8_t *>>>::type {
    }
template<> struct __or_<<std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>>> : public conditional<is_void<char8_t *>::value, is_void<char8_t *>, __is_array_unknown_bounds<char8_t *>>::type {
    }
template<> struct __or_<<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>> : public conditional<is_function<const char8_t>::value, is_function<const char8_t>, __or_<is_reference<const char8_t>, is_void<const char8_t>>>::type {
    }
template<> struct __or_<<std::is_reference<const char8_t>, std::is_void<const char8_t>>> : public conditional<is_reference<const char8_t>::value, is_reference<const char8_t>, is_void<const char8_t>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char8_t>, std::is_rvalue_reference<const char8_t>>> : public conditional<is_lvalue_reference<const char8_t>::value, is_lvalue_reference<const char8_t>, is_rvalue_reference<const char8_t>>::type {
    }
template<> struct __or_<<std::is_reference<char8_t>, std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> : public conditional<is_reference<char8_t>::value, is_reference<char8_t>, __or_<is_function<char8_t>, is_void<char8_t>, __is_array_unknown_bounds<char8_t>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char8_t>, std::is_rvalue_reference<char8_t>>> : public conditional<is_lvalue_reference<char8_t>::value, is_lvalue_reference<char8_t>, is_rvalue_reference<char8_t>>::type {
    }
template<> struct __or_<<std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> : public conditional<is_function<char8_t>::value, is_function<char8_t>, __or_<is_void<char8_t>, __is_array_unknown_bounds<char8_t>>>::type {
    }
template<> struct __or_<<std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> : public conditional<is_void<char8_t>::value, is_void<char8_t>, __is_array_unknown_bounds<char8_t>>::type {
    }
template<> struct __or_<<std::is_function<char8_t>, std::is_reference<char8_t>, std::is_void<char8_t>>> : public conditional<is_function<char8_t>::value, is_function<char8_t>, __or_<is_reference<char8_t>, is_void<char8_t>>>::type {
    }
template<> struct __or_<<std::is_reference<char8_t>, std::is_void<char8_t>>> : public conditional<is_reference<char8_t>::value, is_reference<char8_t>, is_void<char8_t>>::type {
    }
template<> struct __or_<<std::is_reference<const char16_t *>, std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> : public conditional<is_reference<const char16_t *>::value, is_reference<const char16_t *>, __or_<is_function<const char16_t *>, is_void<const char16_t *>, __is_array_unknown_bounds<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char16_t *>, std::is_rvalue_reference<const char16_t *>>> : public conditional<is_lvalue_reference<const char16_t *>::value, is_lvalue_reference<const char16_t *>, is_rvalue_reference<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> : public conditional<is_function<const char16_t *>::value, is_function<const char16_t *>, __or_<is_void<const char16_t *>, __is_array_unknown_bounds<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> : public conditional<is_void<const char16_t *>::value, is_void<const char16_t *>, __is_array_unknown_bounds<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_reference<char16_t *>, std::is_function<char16_t *>, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>>> : public conditional<is_reference<char16_t *>::value, is_reference<char16_t *>, __or_<is_function<char16_t *>, is_void<char16_t *>, __is_array_unknown_bounds<char16_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char16_t *>, std::is_rvalue_reference<char16_t *>>> : public conditional<is_lvalue_reference<char16_t *>::value, is_lvalue_reference<char16_t *>, is_rvalue_reference<char16_t *>>::type {
    }
template<> struct __or_<<std::is_function<char16_t *>, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>>> : public conditional<is_function<char16_t *>::value, is_function<char16_t *>, __or_<is_void<char16_t *>, __is_array_unknown_bounds<char16_t *>>>::type {
    }
template<> struct __or_<<std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>>> : public conditional<is_void<char16_t *>::value, is_void<char16_t *>, __is_array_unknown_bounds<char16_t *>>::type {
    }
template<> struct __or_<<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>> : public conditional<is_function<const char16_t>::value, is_function<const char16_t>, __or_<is_reference<const char16_t>, is_void<const char16_t>>>::type {
    }
template<> struct __or_<<std::is_reference<const char16_t>, std::is_void<const char16_t>>> : public conditional<is_reference<const char16_t>::value, is_reference<const char16_t>, is_void<const char16_t>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char16_t>, std::is_rvalue_reference<const char16_t>>> : public conditional<is_lvalue_reference<const char16_t>::value, is_lvalue_reference<const char16_t>, is_rvalue_reference<const char16_t>>::type {
    }
template<> struct __or_<<std::is_reference<char16_t>, std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public conditional<is_reference<char16_t>::value, is_reference<char16_t>, __or_<is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>>> : public conditional<is_lvalue_reference<char16_t>::value, is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    }
template<> struct __or_<<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public conditional<is_function<char16_t>::value, is_function<char16_t>, __or_<is_void<char16_t>, __is_array_unknown_bounds<char16_t>>>::type {
    }
template<> struct __or_<<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> : public conditional<is_void<char16_t>::value, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>::type {
    }
template<> struct __or_<<std::is_reference<const char32_t *>, std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> : public conditional<is_reference<const char32_t *>::value, is_reference<const char32_t *>, __or_<is_function<const char32_t *>, is_void<const char32_t *>, __is_array_unknown_bounds<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char32_t *>, std::is_rvalue_reference<const char32_t *>>> : public conditional<is_lvalue_reference<const char32_t *>::value, is_lvalue_reference<const char32_t *>, is_rvalue_reference<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> : public conditional<is_function<const char32_t *>::value, is_function<const char32_t *>, __or_<is_void<const char32_t *>, __is_array_unknown_bounds<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> : public conditional<is_void<const char32_t *>::value, is_void<const char32_t *>, __is_array_unknown_bounds<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_reference<char32_t *>, std::is_function<char32_t *>, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>>> : public conditional<is_reference<char32_t *>::value, is_reference<char32_t *>, __or_<is_function<char32_t *>, is_void<char32_t *>, __is_array_unknown_bounds<char32_t *>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char32_t *>, std::is_rvalue_reference<char32_t *>>> : public conditional<is_lvalue_reference<char32_t *>::value, is_lvalue_reference<char32_t *>, is_rvalue_reference<char32_t *>>::type {
    }
template<> struct __or_<<std::is_function<char32_t *>, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>>> : public conditional<is_function<char32_t *>::value, is_function<char32_t *>, __or_<is_void<char32_t *>, __is_array_unknown_bounds<char32_t *>>>::type {
    }
template<> struct __or_<<std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>>> : public conditional<is_void<char32_t *>::value, is_void<char32_t *>, __is_array_unknown_bounds<char32_t *>>::type {
    }
template<> struct __or_<<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>> : public conditional<is_function<const char32_t>::value, is_function<const char32_t>, __or_<is_reference<const char32_t>, is_void<const char32_t>>>::type {
    }
template<> struct __or_<<std::is_reference<const char32_t>, std::is_void<const char32_t>>> : public conditional<is_reference<const char32_t>::value, is_reference<const char32_t>, is_void<const char32_t>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<const char32_t>, std::is_rvalue_reference<const char32_t>>> : public conditional<is_lvalue_reference<const char32_t>::value, is_lvalue_reference<const char32_t>, is_rvalue_reference<const char32_t>>::type {
    }
template<> struct __or_<<std::is_reference<char32_t>, std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public conditional<is_reference<char32_t>::value, is_reference<char32_t>, __or_<is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>>> : public conditional<is_lvalue_reference<char32_t>::value, is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    }
template<> struct __or_<<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public conditional<is_function<char32_t>::value, is_function<char32_t>, __or_<is_void<char32_t>, __is_array_unknown_bounds<char32_t>>>::type {
    }
template<> struct __or_<<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> : public conditional<is_void<char32_t>::value, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>::type {
    }
template<> struct __or_<<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>>> : public conditional<is_void<const char *>::value, is_void<const char *>, __or_<__is_array_unknown_bounds<const char *>, is_function<const char *>>>::type {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>>> : public conditional<__is_array_unknown_bounds<const char *>::value, __is_array_unknown_bounds<const char *>, is_function<const char *>>::type {
    }
template<> struct __or_<<std::is_reference<const char *>, std::is_scalar<const char *>>> : public conditional<is_reference<const char *>::value, is_reference<const char *>, is_scalar<const char *>>::type {
    }
template<> struct __or_<<std::is_arithmetic<const char *>, std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> : public conditional<is_arithmetic<const char *>::value, is_arithmetic<const char *>, __or_<is_enum<const char *>, is_pointer<const char *>, is_member_pointer<const char *>, is_null_pointer<const char *>>>::type {
    }
template<> struct __or_<<std::is_integral<const char *>, std::is_floating_point<const char *>>> : public conditional<is_integral<const char *>::value, is_integral<const char *>, is_floating_point<const char *>>::type {
    }
template<> struct __or_<<std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> : public conditional<is_enum<const char *>::value, is_enum<const char *>, __or_<is_pointer<const char *>, is_member_pointer<const char *>, is_null_pointer<const char *>>>::type {
    }
template<> struct __or_<<std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> : public conditional<is_pointer<const char *>::value, is_pointer<const char *>, __or_<is_member_pointer<const char *>, is_null_pointer<const char *>>>::type {
    }
template<> struct __or_<<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>> : public conditional<is_function<const char *>::value, is_function<const char *>, __or_<is_reference<const char *>, is_void<const char *>>>::type {
    }
template<> struct __or_<<std::is_reference<const char *>, std::is_void<const char *>>> : public conditional<is_reference<const char *>::value, is_reference<const char *>, is_void<const char *>>::type {
    }
template<> struct __or_<<std::is_void<const char *>, std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_void<const char *>::value, is_void<const char *>, __or_<is_function<const char *>, is_array<const char *>>>::type {
    }
template<> struct __or_<<std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_function<const char *>::value, is_function<const char *>, is_array<const char *>>::type {
    }
template<> struct __or_<<std::is_void<const char *const &>, std::is_function<const char *const &>, std::is_array<const char *const &>>> : public conditional<is_void<const char *const &>::value, is_void<const char *const &>, __or_<is_function<const char *const &>, is_array<const char *const &>>>::type {
    }
template<> struct __or_<<std::is_function<const char *const &>, std::is_array<const char *const &>>> : public conditional<is_function<const char *const &>::value, is_function<const char *const &>, is_array<const char *const &>>::type {
    }
template<> struct __or_<<std::is_integral<long>, std::is_floating_point<long>>> : public conditional<is_integral<long>::value, is_integral<long>, is_floating_point<long>>::type {
    }
template<> struct __or_<<std::is_void<const char &>, std::is_function<const char &>, std::is_array<const char &>>> : public conditional<is_void<const char &>::value, is_void<const char &>, __or_<is_function<const char &>, is_array<const char &>>>::type {
    }
template<> struct __or_<<std::is_function<const char &>, std::is_array<const char &>>> : public conditional<is_function<const char &>::value, is_function<const char &>, is_array<const char &>>::type {
    }
template<> struct __or_<<std::is_void<char &>, std::is_function<const char &>, std::is_array<const char &>>> : public conditional<is_void<char &>::value, is_void<char &>, __or_<is_function<const char &>, is_array<const char &>>>::type {
    }
template<> struct __or_<<std::is_void<const char &&>, std::is_function<const char &>, std::is_array<const char &>>> : public conditional<is_void<const char &&>::value, is_void<const char &&>, __or_<is_function<const char &>, is_array<const char &>>>::type {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>>> : public conditional<is_void<const volatile contiguous_iterator_tag *>::value, is_void<const volatile contiguous_iterator_tag *>, __or_<is_function<const volatile input_iterator_tag *>, is_array<const volatile input_iterator_tag *>>>::type {
    }
template<> struct __or_<<std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>>> : public conditional<is_function<const volatile input_iterator_tag *>::value, is_function<const volatile input_iterator_tag *>, is_array<const volatile input_iterator_tag *>>::type {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>>> : public conditional<is_void<const volatile contiguous_iterator_tag *>::value, is_void<const volatile contiguous_iterator_tag *>, __or_<is_function<const volatile forward_iterator_tag *>, is_array<const volatile forward_iterator_tag *>>>::type {
    }
template<> struct __or_<<std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>>> : public conditional<is_function<const volatile forward_iterator_tag *>::value, is_function<const volatile forward_iterator_tag *>, is_array<const volatile forward_iterator_tag *>>::type {
    }
template<> struct __or_<<std::is_void<const char *&>, std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_void<const char *&>::value, is_void<const char *&>, __or_<is_function<const char *>, is_array<const char *>>>::type {
    }
template<> struct __or_<<std::is_void<const char *const &>, std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_void<const char *const &>::value, is_void<const char *const &>, __or_<is_function<const char *>, is_array<const char *>>>::type {
    }
template<> struct __or_<<std::is_void<const char *const>, std::is_function<const char *>, std::is_array<const char *>>> : public conditional<is_void<const char *const>::value, is_void<const char *const>, __or_<is_function<const char *>, is_array<const char *>>>::type {
    }
template<> struct __or_<<std::is_void<bool>, std::is_function<bool>, std::is_array<bool>>> : public conditional<is_void<bool>::value, is_void<bool>, __or_<is_function<bool>, is_array<bool>>>::type {
    }
template<> struct __or_<<std::is_function<bool>, std::is_array<bool>>> : public conditional<is_function<bool>::value, is_function<bool>, is_array<bool>>::type {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>>> : public conditional<is_void<const volatile contiguous_iterator_tag *>::value, is_void<const volatile contiguous_iterator_tag *>, __or_<is_function<const volatile bidirectional_iterator_tag *>, is_array<const volatile bidirectional_iterator_tag *>>>::type {
    }
template<> struct __or_<<std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>>> : public conditional<is_function<const volatile bidirectional_iterator_tag *>::value, is_function<const volatile bidirectional_iterator_tag *>, is_array<const volatile bidirectional_iterator_tag *>>::type {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>>> : public conditional<is_void<const volatile contiguous_iterator_tag *>::value, is_void<const volatile contiguous_iterator_tag *>, __or_<is_function<const volatile random_access_iterator_tag *>, is_array<const volatile random_access_iterator_tag *>>>::type {
    }
template<> struct __or_<<std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>>> : public conditional<is_function<const volatile random_access_iterator_tag *>::value, is_function<const volatile random_access_iterator_tag *>, is_array<const volatile random_access_iterator_tag *>>::type {
    }
template<> struct __or_<<std::is_void<const volatile std::contiguous_iterator_tag *>, std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>>> : public conditional<is_void<const volatile contiguous_iterator_tag *>::value, is_void<const volatile contiguous_iterator_tag *>, __or_<is_function<const volatile contiguous_iterator_tag *>, is_array<const volatile contiguous_iterator_tag *>>>::type {
    }
template<> struct __or_<<std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>>> : public conditional<is_function<const volatile contiguous_iterator_tag *>::value, is_function<const volatile contiguous_iterator_tag *>, is_array<const volatile contiguous_iterator_tag *>>::type {
    }
template<> struct __or_<<std::__is_referenceable<const char &, void>, std::is_void<const char &>>> : public conditional<__is_referenceable<const char &, void>::value, __is_referenceable<const char &, void>, is_void<const char &>>::type {
    }
template<> struct __or_<<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>>> : public conditional<is_void<unsigned long>::value, is_void<unsigned long>, __or_<__is_array_unknown_bounds<unsigned long>, is_function<unsigned long>>>::type {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>>> : public conditional<__is_array_unknown_bounds<unsigned long>::value, __is_array_unknown_bounds<unsigned long>, is_function<unsigned long>>::type {
    }
template<> struct __or_<<std::is_reference<unsigned long>, std::is_scalar<unsigned long>>> : public conditional<is_reference<unsigned long>::value, is_reference<unsigned long>, is_scalar<unsigned long>>::type {
    }
template<> struct __or_<<std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>>> : public conditional<is_lvalue_reference<unsigned long>::value, is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    }
template<> struct __or_<<std::is_arithmetic<unsigned long>, std::is_enum<unsigned long>, std::is_pointer<unsigned long>, std::is_member_pointer<unsigned long>, std::is_null_pointer<unsigned long>>> : public conditional<is_arithmetic<unsigned long>::value, is_arithmetic<unsigned long>, __or_<is_enum<unsigned long>, is_pointer<unsigned long>, is_member_pointer<unsigned long>, is_null_pointer<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_integral<unsigned long>, std::is_floating_point<unsigned long>>> : public conditional<is_integral<unsigned long>::value, is_integral<unsigned long>, is_floating_point<unsigned long>>::type {
    }
template<> struct __or_<<std::is_reference<unsigned long>, std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public conditional<is_reference<unsigned long>::value, is_reference<unsigned long>, __or_<is_function<unsigned long>, is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public conditional<is_function<unsigned long>::value, is_function<unsigned long>, __or_<is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> : public conditional<is_void<unsigned long>::value, is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>::type {
    }
template<> struct __or_<<std::is_void<unsigned long>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_void<unsigned long>::value, is_void<unsigned long>, __or_<is_function<unsigned long>, is_array<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_function<unsigned long>::value, is_function<unsigned long>, is_array<unsigned long>>::type {
    }
template<> struct __or_<<std::is_void<unsigned long &>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_void<unsigned long &>::value, is_void<unsigned long &>, __or_<is_function<unsigned long>, is_array<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_void<const unsigned long &>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_void<const unsigned long &>::value, is_void<const unsigned long &>, __or_<is_function<unsigned long>, is_array<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_void<const unsigned long>, std::is_function<unsigned long>, std::is_array<unsigned long>>> : public conditional<is_void<const unsigned long>::value, is_void<const unsigned long>, __or_<is_function<unsigned long>, is_array<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>> : public conditional<is_function<unsigned long>::value, is_function<unsigned long>, __or_<is_reference<unsigned long>, is_void<unsigned long>>>::type {
    }
template<> struct __or_<<std::is_reference<unsigned long>, std::is_void<unsigned long>>> : public conditional<is_reference<unsigned long>::value, is_reference<unsigned long>, is_void<unsigned long>>::type {
    }
template<> struct __or_<<std::is_void<const unsigned long &>, std::is_function<const unsigned long &>, std::is_array<const unsigned long &>>> : public conditional<is_void<const unsigned long &>::value, is_void<const unsigned long &>, __or_<is_function<const unsigned long &>, is_array<const unsigned long &>>>::type {
    }
template<> struct __or_<<std::is_function<const unsigned long &>, std::is_array<const unsigned long &>>> : public conditional<is_function<const unsigned long &>::value, is_function<const unsigned long &>, is_array<const unsigned long &>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>>> : public conditional<is_void<const wchar_t *>::value, is_void<const wchar_t *>, __or_<__is_array_unknown_bounds<const wchar_t *>, is_function<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>>> : public conditional<__is_array_unknown_bounds<const wchar_t *>::value, __is_array_unknown_bounds<const wchar_t *>, is_function<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_reference<const wchar_t *>, std::is_scalar<const wchar_t *>>> : public conditional<is_reference<const wchar_t *>::value, is_reference<const wchar_t *>, is_scalar<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_arithmetic<const wchar_t *>, std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> : public conditional<is_arithmetic<const wchar_t *>::value, is_arithmetic<const wchar_t *>, __or_<is_enum<const wchar_t *>, is_pointer<const wchar_t *>, is_member_pointer<const wchar_t *>, is_null_pointer<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_integral<const wchar_t *>, std::is_floating_point<const wchar_t *>>> : public conditional<is_integral<const wchar_t *>::value, is_integral<const wchar_t *>, is_floating_point<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> : public conditional<is_enum<const wchar_t *>::value, is_enum<const wchar_t *>, __or_<is_pointer<const wchar_t *>, is_member_pointer<const wchar_t *>, is_null_pointer<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> : public conditional<is_pointer<const wchar_t *>::value, is_pointer<const wchar_t *>, __or_<is_member_pointer<const wchar_t *>, is_null_pointer<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : public conditional<is_function<const wchar_t *>::value, is_function<const wchar_t *>, __or_<is_reference<const wchar_t *>, is_void<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : public conditional<is_reference<const wchar_t *>::value, is_reference<const wchar_t *>, is_void<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_void<const wchar_t *>::value, is_void<const wchar_t *>, __or_<is_function<const wchar_t *>, is_array<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_function<const wchar_t *>::value, is_function<const wchar_t *>, is_array<const wchar_t *>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *const &>, std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>>> : public conditional<is_void<const wchar_t *const &>::value, is_void<const wchar_t *const &>, __or_<is_function<const wchar_t *const &>, is_array<const wchar_t *const &>>>::type {
    }
template<> struct __or_<<std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>>> : public conditional<is_function<const wchar_t *const &>::value, is_function<const wchar_t *const &>, is_array<const wchar_t *const &>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t &>, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public conditional<is_void<const wchar_t &>::value, is_void<const wchar_t &>, __or_<is_function<const wchar_t &>, is_array<const wchar_t &>>>::type {
    }
template<> struct __or_<<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public conditional<is_function<const wchar_t &>::value, is_function<const wchar_t &>, is_array<const wchar_t &>>::type {
    }
template<> struct __or_<<std::is_void<wchar_t &>, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public conditional<is_void<wchar_t &>::value, is_void<wchar_t &>, __or_<is_function<const wchar_t &>, is_array<const wchar_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t &&>, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> : public conditional<is_void<const wchar_t &&>::value, is_void<const wchar_t &&>, __or_<is_function<const wchar_t &>, is_array<const wchar_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *&>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_void<const wchar_t *&>::value, is_void<const wchar_t *&>, __or_<is_function<const wchar_t *>, is_array<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *const &>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_void<const wchar_t *const &>::value, is_void<const wchar_t *const &>, __or_<is_function<const wchar_t *>, is_array<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const wchar_t *const>, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> : public conditional<is_void<const wchar_t *const>::value, is_void<const wchar_t *const>, __or_<is_function<const wchar_t *>, is_array<const wchar_t *>>>::type {
    }
template<> struct __or_<<std::__is_referenceable<const wchar_t &, void>, std::is_void<const wchar_t &>>> : public conditional<__is_referenceable<const wchar_t &, void>::value, __is_referenceable<const wchar_t &, void>, is_void<const wchar_t &>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>>> : public conditional<is_void<const char8_t *>::value, is_void<const char8_t *>, __or_<__is_array_unknown_bounds<const char8_t *>, is_function<const char8_t *>>>::type {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>>> : public conditional<__is_array_unknown_bounds<const char8_t *>::value, __is_array_unknown_bounds<const char8_t *>, is_function<const char8_t *>>::type {
    }
template<> struct __or_<<std::is_reference<const char8_t *>, std::is_scalar<const char8_t *>>> : public conditional<is_reference<const char8_t *>::value, is_reference<const char8_t *>, is_scalar<const char8_t *>>::type {
    }
template<> struct __or_<<std::is_arithmetic<const char8_t *>, std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> : public conditional<is_arithmetic<const char8_t *>::value, is_arithmetic<const char8_t *>, __or_<is_enum<const char8_t *>, is_pointer<const char8_t *>, is_member_pointer<const char8_t *>, is_null_pointer<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_integral<const char8_t *>, std::is_floating_point<const char8_t *>>> : public conditional<is_integral<const char8_t *>::value, is_integral<const char8_t *>, is_floating_point<const char8_t *>>::type {
    }
template<> struct __or_<<std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> : public conditional<is_enum<const char8_t *>::value, is_enum<const char8_t *>, __or_<is_pointer<const char8_t *>, is_member_pointer<const char8_t *>, is_null_pointer<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> : public conditional<is_pointer<const char8_t *>::value, is_pointer<const char8_t *>, __or_<is_member_pointer<const char8_t *>, is_null_pointer<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : public conditional<is_function<const char8_t *>::value, is_function<const char8_t *>, __or_<is_reference<const char8_t *>, is_void<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : public conditional<is_reference<const char8_t *>::value, is_reference<const char8_t *>, is_void<const char8_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t *>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public conditional<is_void<const char8_t *>::value, is_void<const char8_t *>, __or_<is_function<const char8_t *>, is_array<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public conditional<is_function<const char8_t *>::value, is_function<const char8_t *>, is_array<const char8_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t *const &>, std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>>> : public conditional<is_void<const char8_t *const &>::value, is_void<const char8_t *const &>, __or_<is_function<const char8_t *const &>, is_array<const char8_t *const &>>>::type {
    }
template<> struct __or_<<std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>>> : public conditional<is_function<const char8_t *const &>::value, is_function<const char8_t *const &>, is_array<const char8_t *const &>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t &>, std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public conditional<is_void<const char8_t &>::value, is_void<const char8_t &>, __or_<is_function<const char8_t &>, is_array<const char8_t &>>>::type {
    }
template<> struct __or_<<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public conditional<is_function<const char8_t &>::value, is_function<const char8_t &>, is_array<const char8_t &>>::type {
    }
template<> struct __or_<<std::is_void<char8_t &>, std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public conditional<is_void<char8_t &>::value, is_void<char8_t &>, __or_<is_function<const char8_t &>, is_array<const char8_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t &&>, std::is_function<const char8_t &>, std::is_array<const char8_t &>>> : public conditional<is_void<const char8_t &&>::value, is_void<const char8_t &&>, __or_<is_function<const char8_t &>, is_array<const char8_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t *&>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public conditional<is_void<const char8_t *&>::value, is_void<const char8_t *&>, __or_<is_function<const char8_t *>, is_array<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t *const &>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public conditional<is_void<const char8_t *const &>::value, is_void<const char8_t *const &>, __or_<is_function<const char8_t *>, is_array<const char8_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char8_t *const>, std::is_function<const char8_t *>, std::is_array<const char8_t *>>> : public conditional<is_void<const char8_t *const>::value, is_void<const char8_t *const>, __or_<is_function<const char8_t *>, is_array<const char8_t *>>>::type {
    }
template<> struct __or_<<std::__is_referenceable<const char8_t &, void>, std::is_void<const char8_t &>>> : public conditional<__is_referenceable<const char8_t &, void>::value, __is_referenceable<const char8_t &, void>, is_void<const char8_t &>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>>> : public conditional<is_void<const char16_t *>::value, is_void<const char16_t *>, __or_<__is_array_unknown_bounds<const char16_t *>, is_function<const char16_t *>>>::type {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>>> : public conditional<__is_array_unknown_bounds<const char16_t *>::value, __is_array_unknown_bounds<const char16_t *>, is_function<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_reference<const char16_t *>, std::is_scalar<const char16_t *>>> : public conditional<is_reference<const char16_t *>::value, is_reference<const char16_t *>, is_scalar<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_arithmetic<const char16_t *>, std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> : public conditional<is_arithmetic<const char16_t *>::value, is_arithmetic<const char16_t *>, __or_<is_enum<const char16_t *>, is_pointer<const char16_t *>, is_member_pointer<const char16_t *>, is_null_pointer<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_integral<const char16_t *>, std::is_floating_point<const char16_t *>>> : public conditional<is_integral<const char16_t *>::value, is_integral<const char16_t *>, is_floating_point<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> : public conditional<is_enum<const char16_t *>::value, is_enum<const char16_t *>, __or_<is_pointer<const char16_t *>, is_member_pointer<const char16_t *>, is_null_pointer<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> : public conditional<is_pointer<const char16_t *>::value, is_pointer<const char16_t *>, __or_<is_member_pointer<const char16_t *>, is_null_pointer<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : public conditional<is_function<const char16_t *>::value, is_function<const char16_t *>, __or_<is_reference<const char16_t *>, is_void<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : public conditional<is_reference<const char16_t *>::value, is_reference<const char16_t *>, is_void<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public conditional<is_void<const char16_t *>::value, is_void<const char16_t *>, __or_<is_function<const char16_t *>, is_array<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public conditional<is_function<const char16_t *>::value, is_function<const char16_t *>, is_array<const char16_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *const &>, std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>>> : public conditional<is_void<const char16_t *const &>::value, is_void<const char16_t *const &>, __or_<is_function<const char16_t *const &>, is_array<const char16_t *const &>>>::type {
    }
template<> struct __or_<<std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>>> : public conditional<is_function<const char16_t *const &>::value, is_function<const char16_t *const &>, is_array<const char16_t *const &>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t &>, std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public conditional<is_void<const char16_t &>::value, is_void<const char16_t &>, __or_<is_function<const char16_t &>, is_array<const char16_t &>>>::type {
    }
template<> struct __or_<<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public conditional<is_function<const char16_t &>::value, is_function<const char16_t &>, is_array<const char16_t &>>::type {
    }
template<> struct __or_<<std::is_void<char16_t &>, std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public conditional<is_void<char16_t &>::value, is_void<char16_t &>, __or_<is_function<const char16_t &>, is_array<const char16_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t &&>, std::is_function<const char16_t &>, std::is_array<const char16_t &>>> : public conditional<is_void<const char16_t &&>::value, is_void<const char16_t &&>, __or_<is_function<const char16_t &>, is_array<const char16_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *&>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public conditional<is_void<const char16_t *&>::value, is_void<const char16_t *&>, __or_<is_function<const char16_t *>, is_array<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *const &>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public conditional<is_void<const char16_t *const &>::value, is_void<const char16_t *const &>, __or_<is_function<const char16_t *>, is_array<const char16_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char16_t *const>, std::is_function<const char16_t *>, std::is_array<const char16_t *>>> : public conditional<is_void<const char16_t *const>::value, is_void<const char16_t *const>, __or_<is_function<const char16_t *>, is_array<const char16_t *>>>::type {
    }
template<> struct __or_<<std::__is_referenceable<const char16_t &, void>, std::is_void<const char16_t &>>> : public conditional<__is_referenceable<const char16_t &, void>::value, __is_referenceable<const char16_t &, void>, is_void<const char16_t &>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>>> : public conditional<is_void<const char32_t *>::value, is_void<const char32_t *>, __or_<__is_array_unknown_bounds<const char32_t *>, is_function<const char32_t *>>>::type {
    }
template<> struct __or_<<std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>>> : public conditional<__is_array_unknown_bounds<const char32_t *>::value, __is_array_unknown_bounds<const char32_t *>, is_function<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_reference<const char32_t *>, std::is_scalar<const char32_t *>>> : public conditional<is_reference<const char32_t *>::value, is_reference<const char32_t *>, is_scalar<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_arithmetic<const char32_t *>, std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> : public conditional<is_arithmetic<const char32_t *>::value, is_arithmetic<const char32_t *>, __or_<is_enum<const char32_t *>, is_pointer<const char32_t *>, is_member_pointer<const char32_t *>, is_null_pointer<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_integral<const char32_t *>, std::is_floating_point<const char32_t *>>> : public conditional<is_integral<const char32_t *>::value, is_integral<const char32_t *>, is_floating_point<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> : public conditional<is_enum<const char32_t *>::value, is_enum<const char32_t *>, __or_<is_pointer<const char32_t *>, is_member_pointer<const char32_t *>, is_null_pointer<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> : public conditional<is_pointer<const char32_t *>::value, is_pointer<const char32_t *>, __or_<is_member_pointer<const char32_t *>, is_null_pointer<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : public conditional<is_function<const char32_t *>::value, is_function<const char32_t *>, __or_<is_reference<const char32_t *>, is_void<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : public conditional<is_reference<const char32_t *>::value, is_reference<const char32_t *>, is_void<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public conditional<is_void<const char32_t *>::value, is_void<const char32_t *>, __or_<is_function<const char32_t *>, is_array<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public conditional<is_function<const char32_t *>::value, is_function<const char32_t *>, is_array<const char32_t *>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *const &>, std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>>> : public conditional<is_void<const char32_t *const &>::value, is_void<const char32_t *const &>, __or_<is_function<const char32_t *const &>, is_array<const char32_t *const &>>>::type {
    }
template<> struct __or_<<std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>>> : public conditional<is_function<const char32_t *const &>::value, is_function<const char32_t *const &>, is_array<const char32_t *const &>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t &>, std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public conditional<is_void<const char32_t &>::value, is_void<const char32_t &>, __or_<is_function<const char32_t &>, is_array<const char32_t &>>>::type {
    }
template<> struct __or_<<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public conditional<is_function<const char32_t &>::value, is_function<const char32_t &>, is_array<const char32_t &>>::type {
    }
template<> struct __or_<<std::is_void<char32_t &>, std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public conditional<is_void<char32_t &>::value, is_void<char32_t &>, __or_<is_function<const char32_t &>, is_array<const char32_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t &&>, std::is_function<const char32_t &>, std::is_array<const char32_t &>>> : public conditional<is_void<const char32_t &&>::value, is_void<const char32_t &&>, __or_<is_function<const char32_t &>, is_array<const char32_t &>>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *&>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public conditional<is_void<const char32_t *&>::value, is_void<const char32_t *&>, __or_<is_function<const char32_t *>, is_array<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *const &>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public conditional<is_void<const char32_t *const &>::value, is_void<const char32_t *const &>, __or_<is_function<const char32_t *>, is_array<const char32_t *>>>::type {
    }
template<> struct __or_<<std::is_void<const char32_t *const>, std::is_function<const char32_t *>, std::is_array<const char32_t *>>> : public conditional<is_void<const char32_t *const>::value, is_void<const char32_t *const>, __or_<is_function<const char32_t *>, is_array<const char32_t *>>>::type {
    }
template<> struct __or_<<std::__is_referenceable<const char32_t &, void>, std::is_void<const char32_t &>>> : public conditional<__is_referenceable<const char32_t &, void>::value, __is_referenceable<const char32_t &, void>, is_void<const char32_t &>>::type {
    };
    template<> struct __or_<> : public std::false_type {
    };
    template <typename _B1> struct __or_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __or_<_B1, _B2> : public conditional<_B1::value, _B1, _B2>::type {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __or_<_B1, _B2, _B3, _Bn...> : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type {
    };
    template <typename ...> struct __and_
template<> struct __and_<<std::is_array<const char *>, std::__not_<std::extent<const char *, 0>>>> : public conditional<is_array<const char *>::value, __not_<extent<const char *, 0>>, is_array<const char *>>::type {
    }
template<> struct __and_<<std::is_array<char *>, std::__not_<std::extent<char *, 0>>>> : public conditional<is_array<char *>::value, __not_<extent<char *, 0>>, is_array<char *>>::type {
    }
template<> struct __and_<<std::is_array<char>, std::__not_<std::extent<char, 0>>>> : public conditional<is_array<char>::value, __not_<extent<char, 0>>, is_array<char>>::type {
    }
template<> struct __and_<<std::is_array<const wchar_t *>, std::__not_<std::extent<const wchar_t *, 0>>>> : public conditional<is_array<const wchar_t *>::value, __not_<extent<const wchar_t *, 0>>, is_array<const wchar_t *>>::type {
    }
template<> struct __and_<<std::is_array<wchar_t *>, std::__not_<std::extent<wchar_t *, 0>>>> : public conditional<is_array<wchar_t *>::value, __not_<extent<wchar_t *, 0>>, is_array<wchar_t *>>::type {
    }
template<> struct __and_<<std::is_array<wchar_t>, std::__not_<std::extent<wchar_t, 0>>>> : public conditional<is_array<wchar_t>::value, __not_<extent<wchar_t, 0>>, is_array<wchar_t>>::type {
    }
template<> struct __and_<<std::is_array<const char8_t *>, std::__not_<std::extent<const char8_t *, 0>>>> : public conditional<is_array<const char8_t *>::value, __not_<extent<const char8_t *, 0>>, is_array<const char8_t *>>::type {
    }
template<> struct __and_<<std::is_array<char8_t *>, std::__not_<std::extent<char8_t *, 0>>>> : public conditional<is_array<char8_t *>::value, __not_<extent<char8_t *, 0>>, is_array<char8_t *>>::type {
    }
template<> struct __and_<<std::is_array<char8_t>, std::__not_<std::extent<char8_t, 0>>>> : public conditional<is_array<char8_t>::value, __not_<extent<char8_t, 0>>, is_array<char8_t>>::type {
    }
template<> struct __and_<<std::is_array<const char16_t *>, std::__not_<std::extent<const char16_t *, 0>>>> : public conditional<is_array<const char16_t *>::value, __not_<extent<const char16_t *, 0>>, is_array<const char16_t *>>::type {
    }
template<> struct __and_<<std::is_array<char16_t *>, std::__not_<std::extent<char16_t *, 0>>>> : public conditional<is_array<char16_t *>::value, __not_<extent<char16_t *, 0>>, is_array<char16_t *>>::type {
    }
template<> struct __and_<<std::is_array<char16_t>, std::__not_<std::extent<char16_t, 0>>>> : public conditional<is_array<char16_t>::value, __not_<extent<char16_t, 0>>, is_array<char16_t>>::type {
    }
template<> struct __and_<<std::is_array<const char32_t *>, std::__not_<std::extent<const char32_t *, 0>>>> : public conditional<is_array<const char32_t *>::value, __not_<extent<const char32_t *, 0>>, is_array<const char32_t *>>::type {
    }
template<> struct __and_<<std::is_array<char32_t *>, std::__not_<std::extent<char32_t *, 0>>>> : public conditional<is_array<char32_t *>::value, __not_<extent<char32_t *, 0>>, is_array<char32_t *>>::type {
    }
template<> struct __and_<<std::is_array<char32_t>, std::__not_<std::extent<char32_t, 0>>>> : public conditional<is_array<char32_t>::value, __not_<extent<char32_t, 0>>, is_array<char32_t>>::type {
    }
template<> struct __and_<<std::integral_constant<bool, true>, std::__is_nt_assignable_impl<const char *&, const char *&&>>> : public conditional<integral_constant<bool, true>::value, __is_nt_assignable_impl<const char *&, const char *&&>, integral_constant<bool, true>>::type {
    }
template<> struct __and_<<std::is_convertible<const char &&, const char &>>> : public std::is_convertible<const char &&, const char &> {
    }
template<> struct __and_<<std::is_array<unsigned long>, std::__not_<std::extent<unsigned long, 0>>>> : public conditional<is_array<unsigned long>::value, __not_<extent<unsigned long, 0>>, is_array<unsigned long>>::type {
    }
template<> struct __and_<<std::integral_constant<bool, true>, std::__is_nt_assignable_impl<unsigned long &, unsigned long &&>>> : public conditional<integral_constant<bool, true>::value, __is_nt_assignable_impl<unsigned long &, unsigned long &&>, integral_constant<bool, true>>::type {
    }
template<> struct __and_<<std::integral_constant<bool, true>, std::__is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&>>> : public conditional<integral_constant<bool, true>::value, __is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&>, integral_constant<bool, true>>::type {
    }
template<> struct __and_<<std::is_convertible<const wchar_t &&, const wchar_t &>>> : public std::is_convertible<const wchar_t &&, const wchar_t &> {
    }
template<> struct __and_<<std::integral_constant<bool, true>, std::__is_nt_assignable_impl<const char8_t *&, const char8_t *&&>>> : public conditional<integral_constant<bool, true>::value, __is_nt_assignable_impl<const char8_t *&, const char8_t *&&>, integral_constant<bool, true>>::type {
    }
template<> struct __and_<<std::is_convertible<const char8_t &&, const char8_t &>>> : public std::is_convertible<const char8_t &&, const char8_t &> {
    }
template<> struct __and_<<std::integral_constant<bool, true>, std::__is_nt_assignable_impl<const char16_t *&, const char16_t *&&>>> : public conditional<integral_constant<bool, true>::value, __is_nt_assignable_impl<const char16_t *&, const char16_t *&&>, integral_constant<bool, true>>::type {
    }
template<> struct __and_<<std::is_convertible<const char16_t &&, const char16_t &>>> : public std::is_convertible<const char16_t &&, const char16_t &> {
    }
template<> struct __and_<<std::integral_constant<bool, true>, std::__is_nt_assignable_impl<const char32_t *&, const char32_t *&&>>> : public conditional<integral_constant<bool, true>::value, __is_nt_assignable_impl<const char32_t *&, const char32_t *&&>, integral_constant<bool, true>>::type {
    }
template<> struct __and_<<std::is_convertible<const char32_t &&, const char32_t &>>> : public std::is_convertible<const char32_t &&, const char32_t &> {
    };
    template<> struct __and_<> : public std::true_type {
    };
    template <typename _B1> struct __and_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __and_<_B1, _B2> : public conditional<_B1::value, _B2, _B1>::type {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __and_<_B1, _B2, _B3, _Bn...> : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type {
    };
    template <typename _Pp> struct __not_ : public __bool_constant<!bool(_Pp::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char>, std::is_reference<const char>, std::is_void<const char>>> : public __bool_constant<!bool(__or_<is_function<const char>, is_reference<const char>, is_void<const char>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<char>, std::is_reference<char>, std::is_void<char>>> : public __bool_constant<!bool(__or_<is_function<char>, is_reference<char>, is_void<char>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const wchar_t>, std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> : public __bool_constant<!bool(__or_<is_function<const wchar_t>, is_reference<const wchar_t>, is_void<const wchar_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<wchar_t>, std::is_reference<wchar_t>, std::is_void<wchar_t>>> : public __bool_constant<!bool(__or_<is_function<wchar_t>, is_reference<wchar_t>, is_void<wchar_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char8_t>, std::is_reference<const char8_t>, std::is_void<const char8_t>>> : public __bool_constant<!bool(__or_<is_function<const char8_t>, is_reference<const char8_t>, is_void<const char8_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<char8_t>, std::is_reference<char8_t>, std::is_void<char8_t>>> : public __bool_constant<!bool(__or_<is_function<char8_t>, is_reference<char8_t>, is_void<char8_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char16_t>, std::is_reference<const char16_t>, std::is_void<const char16_t>>> : public __bool_constant<!bool(__or_<is_function<const char16_t>, is_reference<const char16_t>, is_void<const char16_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char32_t>, std::is_reference<const char32_t>, std::is_void<const char32_t>>> : public __bool_constant<!bool(__or_<is_function<const char32_t>, is_reference<const char32_t>, is_void<const char32_t>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char *>, std::is_reference<const char *>, std::is_void<const char *>>> : public __bool_constant<!bool(__or_<is_function<const char *>, is_reference<const char *>, is_void<const char *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<unsigned long>, std::is_reference<unsigned long>, std::is_void<unsigned long>>> : public __bool_constant<!bool(__or_<is_function<unsigned long>, is_reference<unsigned long>, is_void<unsigned long>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const wchar_t *>, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> : public __bool_constant<!bool(__or_<is_function<const wchar_t *>, is_reference<const wchar_t *>, is_void<const wchar_t *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char8_t *>, std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> : public __bool_constant<!bool(__or_<is_function<const char8_t *>, is_reference<const char8_t *>, is_void<const char8_t *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char16_t *>, std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> : public __bool_constant<!bool(__or_<is_function<const char16_t *>, is_reference<const char16_t *>, is_void<const char16_t *>>::value)> {
    };
template<> struct __not_<std::__or_<std::is_function<const char32_t *>, std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> : public __bool_constant<!bool(__or_<is_function<const char32_t *>, is_reference<const char32_t *>, is_void<const char32_t *>>::value)> {
    };
    template <typename ..._Bn> constexpr bool __or_v = __or_<_Bn...>::value;
    template <typename ..._Bn> constexpr bool __and_v = __and_<_Bn...>::value;
    template <typename ..._Bn> struct conjunction : __and_<_Bn...> {
    };
    template <typename ..._Bn> struct disjunction : __or_<_Bn...> {
    };
    template <typename _Pp> struct negation : __not_<_Pp> {
    };
    template <typename ..._Bn> constexpr bool conjunction_v = conjunction<_Bn...>::value;
    template <typename ..._Bn> constexpr bool disjunction_v = disjunction<_Bn...>::value;
    template <typename _Pp> constexpr bool negation_v = negation<_Pp>::value;
    template <typename> struct is_reference
template<> struct is_reference<const char *> : public __or_<is_lvalue_reference<const char *>, is_rvalue_reference<const char *>>::type {
    }
template<> struct is_reference<char *> : public __or_<is_lvalue_reference<char *>, is_rvalue_reference<char *>>::type {
    }
template<> struct is_reference<const char> : public __or_<is_lvalue_reference<const char>, is_rvalue_reference<const char>>::type {
    }
template<> struct is_reference<char> : public __or_<is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    }
template<> struct is_reference<const wchar_t *> : public __or_<is_lvalue_reference<const wchar_t *>, is_rvalue_reference<const wchar_t *>>::type {
    }
template<> struct is_reference<wchar_t *> : public __or_<is_lvalue_reference<wchar_t *>, is_rvalue_reference<wchar_t *>>::type {
    }
template<> struct is_reference<const wchar_t> : public __or_<is_lvalue_reference<const wchar_t>, is_rvalue_reference<const wchar_t>>::type {
    }
template<> struct is_reference<wchar_t> : public __or_<is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    }
template<> struct is_reference<const char8_t *> : public __or_<is_lvalue_reference<const char8_t *>, is_rvalue_reference<const char8_t *>>::type {
    }
template<> struct is_reference<char8_t *> : public __or_<is_lvalue_reference<char8_t *>, is_rvalue_reference<char8_t *>>::type {
    }
template<> struct is_reference<const char8_t> : public __or_<is_lvalue_reference<const char8_t>, is_rvalue_reference<const char8_t>>::type {
    }
template<> struct is_reference<char8_t> : public __or_<is_lvalue_reference<char8_t>, is_rvalue_reference<char8_t>>::type {
    }
template<> struct is_reference<const char16_t *> : public __or_<is_lvalue_reference<const char16_t *>, is_rvalue_reference<const char16_t *>>::type {
    }
template<> struct is_reference<char16_t *> : public __or_<is_lvalue_reference<char16_t *>, is_rvalue_reference<char16_t *>>::type {
    }
template<> struct is_reference<const char16_t> : public __or_<is_lvalue_reference<const char16_t>, is_rvalue_reference<const char16_t>>::type {
    }
template<> struct is_reference<char16_t> : public __or_<is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    }
template<> struct is_reference<const char32_t *> : public __or_<is_lvalue_reference<const char32_t *>, is_rvalue_reference<const char32_t *>>::type {
    }
template<> struct is_reference<char32_t *> : public __or_<is_lvalue_reference<char32_t *>, is_rvalue_reference<char32_t *>>::type {
    }
template<> struct is_reference<const char32_t> : public __or_<is_lvalue_reference<const char32_t>, is_rvalue_reference<const char32_t>>::type {
    }
template<> struct is_reference<char32_t> : public __or_<is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    }
template<> struct is_reference<unsigned long> : public __or_<is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    };
    template <typename> struct is_function
template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    }
template<> struct is_function<char *> : public __bool_constant<!is_const<char *const>::value> {
    }
template<> struct is_function<const char> : public __bool_constant<!is_const<const const char>::value> {
    }
template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    }
template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    }
template<> struct is_function<wchar_t *> : public __bool_constant<!is_const<wchar_t *const>::value> {
    }
template<> struct is_function<const wchar_t> : public __bool_constant<!is_const<const const wchar_t>::value> {
    }
template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    }
template<> struct is_function<const char8_t *> : public __bool_constant<!is_const<const char8_t *const>::value> {
    }
template<> struct is_function<char8_t *> : public __bool_constant<!is_const<char8_t *const>::value> {
    }
template<> struct is_function<const char8_t> : public __bool_constant<!is_const<const const char8_t>::value> {
    }
template<> struct is_function<char8_t> : public __bool_constant<!is_const<const char8_t>::value> {
    }
template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    }
template<> struct is_function<char16_t *> : public __bool_constant<!is_const<char16_t *const>::value> {
    }
template<> struct is_function<const char16_t> : public __bool_constant<!is_const<const const char16_t>::value> {
    }
template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    }
template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    }
template<> struct is_function<char32_t *> : public __bool_constant<!is_const<char32_t *const>::value> {
    }
template<> struct is_function<const char32_t> : public __bool_constant<!is_const<const const char32_t>::value> {
    }
template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    }
template<> struct is_function<const char *const &> : public std::false_type {
    }
template<> struct is_function<const char &> : public std::false_type {
    }
template<> struct is_function<const volatile std::input_iterator_tag *> : public __bool_constant<!is_const<const volatile input_iterator_tag *const>::value> {
    }
template<> struct is_function<const volatile std::forward_iterator_tag *> : public __bool_constant<!is_const<const volatile forward_iterator_tag *const>::value> {
    }
template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    }
template<> struct is_function<const volatile std::bidirectional_iterator_tag *> : public __bool_constant<!is_const<const volatile bidirectional_iterator_tag *const>::value> {
    }
template<> struct is_function<const volatile std::random_access_iterator_tag *> : public __bool_constant<!is_const<const volatile random_access_iterator_tag *const>::value> {
    }
template<> struct is_function<const volatile std::contiguous_iterator_tag *> : public __bool_constant<!is_const<const volatile contiguous_iterator_tag *const>::value> {
    }
template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    }
template<> struct is_function<const unsigned long &> : public std::false_type {
    }
template<> struct is_function<const wchar_t *const &> : public std::false_type {
    }
template<> struct is_function<const wchar_t &> : public std::false_type {
    }
template<> struct is_function<const char8_t *const &> : public std::false_type {
    }
template<> struct is_function<const char8_t &> : public std::false_type {
    }
template<> struct is_function<const char16_t *const &> : public std::false_type {
    }
template<> struct is_function<const char16_t &> : public std::false_type {
    }
template<> struct is_function<const char32_t *const &> : public std::false_type {
    }
template<> struct is_function<const char32_t &> : public std::false_type {
    };
    template <typename> struct is_void
template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    }
template<> struct is_void<const char *> : public __is_void_helper<__remove_cv_t<const char *>>::type {
    }
template<> struct is_void<char *> : public __is_void_helper<__remove_cv_t<char *>>::type {
    }
template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    }
template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    }
template<> struct is_void<const wchar_t *> : public __is_void_helper<__remove_cv_t<const wchar_t *>>::type {
    }
template<> struct is_void<wchar_t *> : public __is_void_helper<__remove_cv_t<wchar_t *>>::type {
    }
template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    }
template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    }
template<> struct is_void<const char8_t *> : public __is_void_helper<__remove_cv_t<const char8_t *>>::type {
    }
template<> struct is_void<char8_t *> : public __is_void_helper<__remove_cv_t<char8_t *>>::type {
    }
template<> struct is_void<const char8_t> : public __is_void_helper<__remove_cv_t<const char8_t>>::type {
    }
template<> struct is_void<char8_t> : public __is_void_helper<__remove_cv_t<char8_t>>::type {
    }
template<> struct is_void<const char16_t *> : public __is_void_helper<__remove_cv_t<const char16_t *>>::type {
    }
template<> struct is_void<char16_t *> : public __is_void_helper<__remove_cv_t<char16_t *>>::type {
    }
template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    }
template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    }
template<> struct is_void<const char32_t *> : public __is_void_helper<__remove_cv_t<const char32_t *>>::type {
    }
template<> struct is_void<char32_t *> : public __is_void_helper<__remove_cv_t<char32_t *>>::type {
    }
template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    }
template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    }
template<> struct is_void<const char *const &> : public __is_void_helper<__remove_cv_t<const char *const &>>::type {
    }
template<> struct is_void<const char &> : public __is_void_helper<__remove_cv_t<const char &>>::type {
    }
template<> struct is_void<char &> : public __is_void_helper<__remove_cv_t<char &>>::type {
    }
template<> struct is_void<const char &&> : public __is_void_helper<__remove_cv_t<const char &&>>::type {
    }
template<> struct is_void<const volatile std::contiguous_iterator_tag *> : public __is_void_helper<__remove_cv_t<const volatile contiguous_iterator_tag *>>::type {
    }
template<> struct is_void<const char *&> : public __is_void_helper<__remove_cv_t<const char *&>>::type {
    }
template<> struct is_void<const char *const> : public __is_void_helper<__remove_cv_t<const char *const>>::type {
    }
template<> struct is_void<bool> : public __is_void_helper<__remove_cv_t<bool>>::type {
    }
template<> struct is_void<unsigned long> : public __is_void_helper<__remove_cv_t<unsigned long>>::type {
    }
template<> struct is_void<unsigned long &> : public __is_void_helper<__remove_cv_t<unsigned long &>>::type {
    }
template<> struct is_void<const unsigned long &> : public __is_void_helper<__remove_cv_t<const unsigned long &>>::type {
    }
template<> struct is_void<const unsigned long> : public __is_void_helper<__remove_cv_t<const unsigned long>>::type {
    }
template<> struct is_void<const wchar_t *const &> : public __is_void_helper<__remove_cv_t<const wchar_t *const &>>::type {
    }
template<> struct is_void<const wchar_t &> : public __is_void_helper<__remove_cv_t<const wchar_t &>>::type {
    }
template<> struct is_void<wchar_t &> : public __is_void_helper<__remove_cv_t<wchar_t &>>::type {
    }
template<> struct is_void<const wchar_t &&> : public __is_void_helper<__remove_cv_t<const wchar_t &&>>::type {
    }
template<> struct is_void<const wchar_t *&> : public __is_void_helper<__remove_cv_t<const wchar_t *&>>::type {
    }
template<> struct is_void<const wchar_t *const> : public __is_void_helper<__remove_cv_t<const wchar_t *const>>::type {
    }
template<> struct is_void<const char8_t *const &> : public __is_void_helper<__remove_cv_t<const char8_t *const &>>::type {
    }
template<> struct is_void<const char8_t &> : public __is_void_helper<__remove_cv_t<const char8_t &>>::type {
    }
template<> struct is_void<char8_t &> : public __is_void_helper<__remove_cv_t<char8_t &>>::type {
    }
template<> struct is_void<const char8_t &&> : public __is_void_helper<__remove_cv_t<const char8_t &&>>::type {
    }
template<> struct is_void<const char8_t *&> : public __is_void_helper<__remove_cv_t<const char8_t *&>>::type {
    }
template<> struct is_void<const char8_t *const> : public __is_void_helper<__remove_cv_t<const char8_t *const>>::type {
    }
template<> struct is_void<const char16_t *const &> : public __is_void_helper<__remove_cv_t<const char16_t *const &>>::type {
    }
template<> struct is_void<const char16_t &> : public __is_void_helper<__remove_cv_t<const char16_t &>>::type {
    }
template<> struct is_void<char16_t &> : public __is_void_helper<__remove_cv_t<char16_t &>>::type {
    }
template<> struct is_void<const char16_t &&> : public __is_void_helper<__remove_cv_t<const char16_t &&>>::type {
    }
template<> struct is_void<const char16_t *&> : public __is_void_helper<__remove_cv_t<const char16_t *&>>::type {
    }
template<> struct is_void<const char16_t *const> : public __is_void_helper<__remove_cv_t<const char16_t *const>>::type {
    }
template<> struct is_void<const char32_t *const &> : public __is_void_helper<__remove_cv_t<const char32_t *const &>>::type {
    }
template<> struct is_void<const char32_t &> : public __is_void_helper<__remove_cv_t<const char32_t &>>::type {
    }
template<> struct is_void<char32_t &> : public __is_void_helper<__remove_cv_t<char32_t &>>::type {
    }
template<> struct is_void<const char32_t &&> : public __is_void_helper<__remove_cv_t<const char32_t &&>>::type {
    }
template<> struct is_void<const char32_t *&> : public __is_void_helper<__remove_cv_t<const char32_t *&>>::type {
    }
template<> struct is_void<const char32_t *const> : public __is_void_helper<__remove_cv_t<const char32_t *const>>::type {
    };
    template <typename> struct __is_array_unknown_bounds
template<> struct __is_array_unknown_bounds<const char *> : public __and_<is_array<const char *>, __not_<extent<const char *>>> {
    }
template<> struct __is_array_unknown_bounds<char *> : public __and_<is_array<char *>, __not_<extent<char *>>> {
    }
template<> struct __is_array_unknown_bounds<char> : public __and_<is_array<char>, __not_<extent<char>>> {
    }
template<> struct __is_array_unknown_bounds<const wchar_t *> : public __and_<is_array<const wchar_t *>, __not_<extent<const wchar_t *>>> {
    }
template<> struct __is_array_unknown_bounds<wchar_t *> : public __and_<is_array<wchar_t *>, __not_<extent<wchar_t *>>> {
    }
template<> struct __is_array_unknown_bounds<wchar_t> : public __and_<is_array<wchar_t>, __not_<extent<wchar_t>>> {
    }
template<> struct __is_array_unknown_bounds<const char8_t *> : public __and_<is_array<const char8_t *>, __not_<extent<const char8_t *>>> {
    }
template<> struct __is_array_unknown_bounds<char8_t *> : public __and_<is_array<char8_t *>, __not_<extent<char8_t *>>> {
    }
template<> struct __is_array_unknown_bounds<char8_t> : public __and_<is_array<char8_t>, __not_<extent<char8_t>>> {
    }
template<> struct __is_array_unknown_bounds<const char16_t *> : public __and_<is_array<const char16_t *>, __not_<extent<const char16_t *>>> {
    }
template<> struct __is_array_unknown_bounds<char16_t *> : public __and_<is_array<char16_t *>, __not_<extent<char16_t *>>> {
    }
template<> struct __is_array_unknown_bounds<char16_t> : public __and_<is_array<char16_t>, __not_<extent<char16_t>>> {
    }
template<> struct __is_array_unknown_bounds<const char32_t *> : public __and_<is_array<const char32_t *>, __not_<extent<const char32_t *>>> {
    }
template<> struct __is_array_unknown_bounds<char32_t *> : public __and_<is_array<char32_t *>, __not_<extent<char32_t *>>> {
    }
template<> struct __is_array_unknown_bounds<char32_t> : public __and_<is_array<char32_t>, __not_<extent<char32_t>>> {
    }
template<> struct __is_array_unknown_bounds<unsigned long> : public __and_<is_array<unsigned long>, __not_<extent<unsigned long>>> {
    };
    template <typename _Tp, std::size_t = sizeof(_Tp)> constexpr std::true_type __is_complete_or_unbounded(__type_identity<_Tp>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char *, 8>(__type_identity<const char *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char *, 8>(__type_identity<char *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char, 1>(__type_identity<char>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const wchar_t *, 8>(__type_identity<const wchar_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<wchar_t *, 8>(__type_identity<wchar_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<wchar_t, 4>(__type_identity<wchar_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char8_t *, 8>(__type_identity<const char8_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char8_t *, 8>(__type_identity<char8_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char8_t, 1>(__type_identity<char8_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char16_t *, 8>(__type_identity<const char16_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char16_t *, 8>(__type_identity<char16_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char16_t, 2>(__type_identity<char16_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<const char32_t *, 8>(__type_identity<const char32_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char32_t *, 8>(__type_identity<char32_t *>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<char32_t, 4>(__type_identity<char32_t>)     {
        return {};
    }
    template<> constexpr std::true_type __is_complete_or_unbounded<unsigned long, 8>(__type_identity<unsigned long>)     {
        return {};
    }
    template <typename _TypeIdentity, typename _NestedType = typename _TypeIdentity::type> constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>, __is_array_unknown_bounds<_NestedType>>::type __is_complete_or_unbounded(_TypeIdentity)     {
        return {};
    }
    template<> constexpr typename __or_<is_reference<const char *>, is_function<const char *>, is_void<const char *>, __is_array_unknown_bounds<const char *>>::type __is_complete_or_unbounded<std::__type_identity<const char *>, const char *>(std::__type_identity<const char *>)    template<> constexpr typename __or_<is_reference<char *>, is_function<char *>, is_void<char *>, __is_array_unknown_bounds<char *>>::type __is_complete_or_unbounded<std::__type_identity<char *>, char *>(std::__type_identity<char *>)    template<> constexpr typename __or_<is_reference<char>, is_function<char>, is_void<char>, __is_array_unknown_bounds<char>>::type __is_complete_or_unbounded<std::__type_identity<char>, char>(std::__type_identity<char>)    template<> constexpr typename __or_<is_reference<const wchar_t *>, is_function<const wchar_t *>, is_void<const wchar_t *>, __is_array_unknown_bounds<const wchar_t *>>::type __is_complete_or_unbounded<std::__type_identity<const wchar_t *>, const wchar_t *>(std::__type_identity<const wchar_t *>)    template<> constexpr typename __or_<is_reference<wchar_t *>, is_function<wchar_t *>, is_void<wchar_t *>, __is_array_unknown_bounds<wchar_t *>>::type __is_complete_or_unbounded<std::__type_identity<wchar_t *>, wchar_t *>(std::__type_identity<wchar_t *>)    template<> constexpr typename __or_<is_reference<wchar_t>, is_function<wchar_t>, is_void<wchar_t>, __is_array_unknown_bounds<wchar_t>>::type __is_complete_or_unbounded<std::__type_identity<wchar_t>, wchar_t>(std::__type_identity<wchar_t>)    template<> constexpr typename __or_<is_reference<const char8_t *>, is_function<const char8_t *>, is_void<const char8_t *>, __is_array_unknown_bounds<const char8_t *>>::type __is_complete_or_unbounded<std::__type_identity<const char8_t *>, const char8_t *>(std::__type_identity<const char8_t *>)    template<> constexpr typename __or_<is_reference<char8_t *>, is_function<char8_t *>, is_void<char8_t *>, __is_array_unknown_bounds<char8_t *>>::type __is_complete_or_unbounded<std::__type_identity<char8_t *>, char8_t *>(std::__type_identity<char8_t *>)    template<> constexpr typename __or_<is_reference<char8_t>, is_function<char8_t>, is_void<char8_t>, __is_array_unknown_bounds<char8_t>>::type __is_complete_or_unbounded<std::__type_identity<char8_t>, char8_t>(std::__type_identity<char8_t>)    template<> constexpr typename __or_<is_reference<const char16_t *>, is_function<const char16_t *>, is_void<const char16_t *>, __is_array_unknown_bounds<const char16_t *>>::type __is_complete_or_unbounded<std::__type_identity<const char16_t *>, const char16_t *>(std::__type_identity<const char16_t *>)    template<> constexpr typename __or_<is_reference<char16_t *>, is_function<char16_t *>, is_void<char16_t *>, __is_array_unknown_bounds<char16_t *>>::type __is_complete_or_unbounded<std::__type_identity<char16_t *>, char16_t *>(std::__type_identity<char16_t *>)    template<> constexpr typename __or_<is_reference<char16_t>, is_function<char16_t>, is_void<char16_t>, __is_array_unknown_bounds<char16_t>>::type __is_complete_or_unbounded<std::__type_identity<char16_t>, char16_t>(std::__type_identity<char16_t>)    template<> constexpr typename __or_<is_reference<const char32_t *>, is_function<const char32_t *>, is_void<const char32_t *>, __is_array_unknown_bounds<const char32_t *>>::type __is_complete_or_unbounded<std::__type_identity<const char32_t *>, const char32_t *>(std::__type_identity<const char32_t *>)    template<> constexpr typename __or_<is_reference<char32_t *>, is_function<char32_t *>, is_void<char32_t *>, __is_array_unknown_bounds<char32_t *>>::type __is_complete_or_unbounded<std::__type_identity<char32_t *>, char32_t *>(std::__type_identity<char32_t *>)    template<> constexpr typename __or_<is_reference<char32_t>, is_function<char32_t>, is_void<char32_t>, __is_array_unknown_bounds<char32_t>>::type __is_complete_or_unbounded<std::__type_identity<char32_t>, char32_t>(std::__type_identity<char32_t>)    template<> constexpr typename __or_<is_reference<unsigned long>, is_function<unsigned long>, is_void<unsigned long>, __is_array_unknown_bounds<unsigned long>>::type __is_complete_or_unbounded<std::__type_identity<unsigned long>, unsigned long>(std::__type_identity<unsigned long>)    template <typename _Tp> struct __success_type {
        typedef _Tp type;
    };
    struct __failure_type {
    };
    template <typename> struct remove_cv
template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    }
template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    }
template<> struct remove_cv<char8_t> {
        using type = char8_t;
    }
template<> struct remove_cv<unsigned char> {
        using type = unsigned char;
    }
template<> struct remove_cv<char16_t> {
        using type = char16_t;
    }
template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    }
template<> struct remove_cv<char32_t> {
        using type = char32_t;
    }
template<> struct remove_cv<void> {
        using type = void;
    }
template<> struct remove_cv<const char *> {
        using type = const char *;
    }
template<> struct remove_cv<char *> {
        using type = char *;
    }
template<> struct remove_cv<const char> {
        using type = char;
    }
template<> struct remove_cv<char> {
        using type = char;
    }
template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    }
template<> struct remove_cv<const wchar_t *> {
        using type = const wchar_t *;
    }
template<> struct remove_cv<wchar_t *> {
        using type = wchar_t *;
    }
template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    }
template<> struct remove_cv<const char8_t *> {
        using type = const char8_t *;
    }
template<> struct remove_cv<char8_t *> {
        using type = char8_t *;
    }
template<> struct remove_cv<const char8_t> {
        using type = char8_t;
    }
template<> struct remove_cv<const char16_t *> {
        using type = const char16_t *;
    }
template<> struct remove_cv<char16_t *> {
        using type = char16_t *;
    }
template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    }
template<> struct remove_cv<const char32_t *> {
        using type = const char32_t *;
    }
template<> struct remove_cv<char32_t *> {
        using type = char32_t *;
    }
template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    }
template<> struct remove_cv<const char *const &> {
        using type = const char *const &;
    }
template<> struct remove_cv<long> {
        using type = long;
    }
template<> struct remove_cv<const char &> {
        using type = const char &;
    }
template<> struct remove_cv<char &> {
        using type = char &;
    }
template<> struct remove_cv<const char &&> {
        using type = const char &&;
    }
template<> struct remove_cv<const volatile std::contiguous_iterator_tag *> {
        using type = const volatile std::contiguous_iterator_tag *;
    }
template<> struct remove_cv<const char *&> {
        using type = const char *&;
    }
template<> struct remove_cv<const char *const> {
        using type = const char *;
    }
template<> struct remove_cv<bool> {
        using type = bool;
    }
template<> struct remove_cv<unsigned long &> {
        using type = unsigned long &;
    }
template<> struct remove_cv<const unsigned long &> {
        using type = const unsigned long &;
    }
template<> struct remove_cv<const unsigned long> {
        using type = unsigned long;
    }
template<> struct remove_cv<const wchar_t *const &> {
        using type = const wchar_t *const &;
    }
template<> struct remove_cv<const wchar_t &> {
        using type = const wchar_t &;
    }
template<> struct remove_cv<wchar_t &> {
        using type = wchar_t &;
    }
template<> struct remove_cv<const wchar_t &&> {
        using type = const wchar_t &&;
    }
template<> struct remove_cv<const wchar_t *&> {
        using type = const wchar_t *&;
    }
template<> struct remove_cv<const wchar_t *const> {
        using type = const wchar_t *;
    }
template<> struct remove_cv<const char8_t *const &> {
        using type = const char8_t *const &;
    }
template<> struct remove_cv<const char8_t &> {
        using type = const char8_t &;
    }
template<> struct remove_cv<char8_t &> {
        using type = char8_t &;
    }
template<> struct remove_cv<const char8_t &&> {
        using type = const char8_t &&;
    }
template<> struct remove_cv<const char8_t *&> {
        using type = const char8_t *&;
    }
template<> struct remove_cv<const char8_t *const> {
        using type = const char8_t *;
    }
template<> struct remove_cv<const char16_t *const &> {
        using type = const char16_t *const &;
    }
template<> struct remove_cv<const char16_t &> {
        using type = const char16_t &;
    }
template<> struct remove_cv<char16_t &> {
        using type = char16_t &;
    }
template<> struct remove_cv<const char16_t &&> {
        using type = const char16_t &&;
    }
template<> struct remove_cv<const char16_t *&> {
        using type = const char16_t *&;
    }
template<> struct remove_cv<const char16_t *const> {
        using type = const char16_t *;
    }
template<> struct remove_cv<const char32_t *const &> {
        using type = const char32_t *const &;
    }
template<> struct remove_cv<const char32_t &> {
        using type = const char32_t &;
    }
template<> struct remove_cv<char32_t &> {
        using type = char32_t &;
    }
template<> struct remove_cv<const char32_t &&> {
        using type = const char32_t &&;
    }
template<> struct remove_cv<const char32_t *&> {
        using type = const char32_t *&;
    }
template<> struct remove_cv<const char32_t *const> {
        using type = const char32_t *;
    };
    template <typename _Tp> using __remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename> struct is_const
template<> struct is_const<wchar_t> : public std::false_type {
    }
template<> struct is_const<char8_t> : public std::false_type {
    }
template<> struct is_const<char16_t> : public std::false_type {
    }
template<> struct is_const<char32_t> : public std::false_type {
    }
template<> struct is_const<unsigned int> : public std::false_type {
    }
template<> struct is_const<unsigned char> : public std::false_type {
    }
template<> struct is_const<unsigned short> : public std::false_type {
    }
template<> struct is_const<const char *const> : public std::true_type {
    }
template<> struct is_const<char *const> : public std::true_type {
    }
template<> struct is_const<const char> : public std::true_type {
    }
template<> struct is_const<const wchar_t *const> : public std::true_type {
    }
template<> struct is_const<wchar_t *const> : public std::true_type {
    }
template<> struct is_const<const wchar_t> : public std::true_type {
    }
template<> struct is_const<const char8_t *const> : public std::true_type {
    }
template<> struct is_const<char8_t *const> : public std::true_type {
    }
template<> struct is_const<const char8_t> : public std::true_type {
    }
template<> struct is_const<const char16_t *const> : public std::true_type {
    }
template<> struct is_const<char16_t *const> : public std::true_type {
    }
template<> struct is_const<const char16_t> : public std::true_type {
    }
template<> struct is_const<const char32_t *const> : public std::true_type {
    }
template<> struct is_const<char32_t *const> : public std::true_type {
    }
template<> struct is_const<const char32_t> : public std::true_type {
    }
template<> struct is_const<char> : public std::false_type {
    }
template<> struct is_const<const volatile std::input_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const volatile std::forward_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const bool> : public std::true_type {
    }
template<> struct is_const<const volatile std::bidirectional_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const volatile std::random_access_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const volatile std::contiguous_iterator_tag *const> : public std::true_type {
    }
template<> struct is_const<const unsigned long> : public std::true_type {
    };
    template <typename> struct __is_void_helper : public std::false_type {
    };
template<> struct __is_void_helper<const char *> : public std::false_type {
    };
template<> struct __is_void_helper<char *> : public std::false_type {
    };
template<> struct __is_void_helper<char> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t *> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t *> : public std::false_type {
    };
template<> struct __is_void_helper<char8_t *> : public std::false_type {
    };
template<> struct __is_void_helper<char8_t> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *> : public std::false_type {
    };
template<> struct __is_void_helper<char16_t *> : public std::false_type {
    };
template<> struct __is_void_helper<char16_t> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *> : public std::false_type {
    };
template<> struct __is_void_helper<char32_t *> : public std::false_type {
    };
template<> struct __is_void_helper<char32_t> : public std::false_type {
    };
template<> struct __is_void_helper<const char *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char &> : public std::false_type {
    };
template<> struct __is_void_helper<char &> : public std::false_type {
    };
template<> struct __is_void_helper<const char &&> : public std::false_type {
    };
template<> struct __is_void_helper<const volatile std::contiguous_iterator_tag *> : public std::false_type {
    };
template<> struct __is_void_helper<const char *&> : public std::false_type {
    };
template<> struct __is_void_helper<bool> : public std::false_type {
    };
template<> struct __is_void_helper<unsigned long> : public std::false_type {
    };
template<> struct __is_void_helper<unsigned long &> : public std::false_type {
    };
template<> struct __is_void_helper<const unsigned long &> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t &> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const wchar_t *&> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t &> : public std::false_type {
    };
template<> struct __is_void_helper<char8_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const char8_t *&> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t &> : public std::false_type {
    };
template<> struct __is_void_helper<char16_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const char16_t *&> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *const &> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t &> : public std::false_type {
    };
template<> struct __is_void_helper<char32_t &> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t &&> : public std::false_type {
    };
template<> struct __is_void_helper<const char32_t *&> : public std::false_type {
    };
    template<> struct __is_void_helper<void> : public std::true_type {
    };
    template <typename _Tp> struct is_void : public __is_void_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_void<void> : public __is_void_helper<__remove_cv_t<void>>::type {
    };
template<> struct is_void<const char *> : public __is_void_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_void<char *> : public __is_void_helper<__remove_cv_t<char *>>::type {
    };
template<> struct is_void<const char> : public __is_void_helper<__remove_cv_t<const char>>::type {
    };
template<> struct is_void<char> : public __is_void_helper<__remove_cv_t<char>>::type {
    };
template<> struct is_void<const wchar_t *> : public __is_void_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_void<wchar_t *> : public __is_void_helper<__remove_cv_t<wchar_t *>>::type {
    };
template<> struct is_void<const wchar_t> : public __is_void_helper<__remove_cv_t<const wchar_t>>::type {
    };
template<> struct is_void<wchar_t> : public __is_void_helper<__remove_cv_t<wchar_t>>::type {
    };
template<> struct is_void<const char8_t *> : public __is_void_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_void<char8_t *> : public __is_void_helper<__remove_cv_t<char8_t *>>::type {
    };
template<> struct is_void<const char8_t> : public __is_void_helper<__remove_cv_t<const char8_t>>::type {
    };
template<> struct is_void<char8_t> : public __is_void_helper<__remove_cv_t<char8_t>>::type {
    };
template<> struct is_void<const char16_t *> : public __is_void_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_void<char16_t *> : public __is_void_helper<__remove_cv_t<char16_t *>>::type {
    };
template<> struct is_void<const char16_t> : public __is_void_helper<__remove_cv_t<const char16_t>>::type {
    };
template<> struct is_void<char16_t> : public __is_void_helper<__remove_cv_t<char16_t>>::type {
    };
template<> struct is_void<const char32_t *> : public __is_void_helper<__remove_cv_t<const char32_t *>>::type {
    };
template<> struct is_void<char32_t *> : public __is_void_helper<__remove_cv_t<char32_t *>>::type {
    };
template<> struct is_void<const char32_t> : public __is_void_helper<__remove_cv_t<const char32_t>>::type {
    };
template<> struct is_void<char32_t> : public __is_void_helper<__remove_cv_t<char32_t>>::type {
    };
template<> struct is_void<const char *const &> : public __is_void_helper<__remove_cv_t<const char *const &>>::type {
    };
template<> struct is_void<const char &> : public __is_void_helper<__remove_cv_t<const char &>>::type {
    };
template<> struct is_void<char &> : public __is_void_helper<__remove_cv_t<char &>>::type {
    };
template<> struct is_void<const char &&> : public __is_void_helper<__remove_cv_t<const char &&>>::type {
    };
template<> struct is_void<const volatile std::contiguous_iterator_tag *> : public __is_void_helper<__remove_cv_t<const volatile contiguous_iterator_tag *>>::type {
    };
template<> struct is_void<const char *&> : public __is_void_helper<__remove_cv_t<const char *&>>::type {
    };
template<> struct is_void<const char *const> : public __is_void_helper<__remove_cv_t<const char *const>>::type {
    };
template<> struct is_void<bool> : public __is_void_helper<__remove_cv_t<bool>>::type {
    };
template<> struct is_void<unsigned long> : public __is_void_helper<__remove_cv_t<unsigned long>>::type {
    };
template<> struct is_void<unsigned long &> : public __is_void_helper<__remove_cv_t<unsigned long &>>::type {
    };
template<> struct is_void<const unsigned long &> : public __is_void_helper<__remove_cv_t<const unsigned long &>>::type {
    };
template<> struct is_void<const unsigned long> : public __is_void_helper<__remove_cv_t<const unsigned long>>::type {
    };
template<> struct is_void<const wchar_t *const &> : public __is_void_helper<__remove_cv_t<const wchar_t *const &>>::type {
    };
template<> struct is_void<const wchar_t &> : public __is_void_helper<__remove_cv_t<const wchar_t &>>::type {
    };
template<> struct is_void<wchar_t &> : public __is_void_helper<__remove_cv_t<wchar_t &>>::type {
    };
template<> struct is_void<const wchar_t &&> : public __is_void_helper<__remove_cv_t<const wchar_t &&>>::type {
    };
template<> struct is_void<const wchar_t *&> : public __is_void_helper<__remove_cv_t<const wchar_t *&>>::type {
    };
template<> struct is_void<const wchar_t *const> : public __is_void_helper<__remove_cv_t<const wchar_t *const>>::type {
    };
template<> struct is_void<const char8_t *const &> : public __is_void_helper<__remove_cv_t<const char8_t *const &>>::type {
    };
template<> struct is_void<const char8_t &> : public __is_void_helper<__remove_cv_t<const char8_t &>>::type {
    };
template<> struct is_void<char8_t &> : public __is_void_helper<__remove_cv_t<char8_t &>>::type {
    };
template<> struct is_void<const char8_t &&> : public __is_void_helper<__remove_cv_t<const char8_t &&>>::type {
    };
template<> struct is_void<const char8_t *&> : public __is_void_helper<__remove_cv_t<const char8_t *&>>::type {
    };
template<> struct is_void<const char8_t *const> : public __is_void_helper<__remove_cv_t<const char8_t *const>>::type {
    };
template<> struct is_void<const char16_t *const &> : public __is_void_helper<__remove_cv_t<const char16_t *const &>>::type {
    };
template<> struct is_void<const char16_t &> : public __is_void_helper<__remove_cv_t<const char16_t &>>::type {
    };
template<> struct is_void<char16_t &> : public __is_void_helper<__remove_cv_t<char16_t &>>::type {
    };
template<> struct is_void<const char16_t &&> : public __is_void_helper<__remove_cv_t<const char16_t &&>>::type {
    };
template<> struct is_void<const char16_t *&> : public __is_void_helper<__remove_cv_t<const char16_t *&>>::type {
    };
template<> struct is_void<const char16_t *const> : public __is_void_helper<__remove_cv_t<const char16_t *const>>::type {
    };
template<> struct is_void<const char32_t *const &> : public __is_void_helper<__remove_cv_t<const char32_t *const &>>::type {
    };
template<> struct is_void<const char32_t &> : public __is_void_helper<__remove_cv_t<const char32_t &>>::type {
    };
template<> struct is_void<char32_t &> : public __is_void_helper<__remove_cv_t<char32_t &>>::type {
    };
template<> struct is_void<const char32_t &&> : public __is_void_helper<__remove_cv_t<const char32_t &&>>::type {
    };
template<> struct is_void<const char32_t *&> : public __is_void_helper<__remove_cv_t<const char32_t *&>>::type {
    };
template<> struct is_void<const char32_t *const> : public __is_void_helper<__remove_cv_t<const char32_t *const>>::type {
    };
    template <typename> struct __is_integral_helper : public std::false_type {
    };
template<> struct __is_integral_helper<const char *> : public std::false_type {
    };
template<> struct __is_integral_helper<const wchar_t *> : public std::false_type {
    };
template<> struct __is_integral_helper<const char8_t *> : public std::false_type {
    };
template<> struct __is_integral_helper<const char16_t *> : public std::false_type {
    };
template<> struct __is_integral_helper<const char32_t *> : public std::false_type {
    };
    template<> struct __is_integral_helper<bool> : public std::true_type {
    };
    template<> struct __is_integral_helper<char> : public std::true_type {
    };
    template<> struct __is_integral_helper<signed char> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned char> : public std::true_type {
    };
    template<> struct __is_integral_helper<wchar_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char8_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char16_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char32_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<short> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned short> : public std::true_type {
    };
    template<> struct __is_integral_helper<int> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned int> : public std::true_type {
    };
    template<> struct __is_integral_helper<long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long> : public std::true_type {
    };
    template<> struct __is_integral_helper<long long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long long> : public std::true_type {
    };
    template <typename _Tp> struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_integral<wchar_t> : public __is_integral_helper<__remove_cv_t<wchar_t>>::type {
    };
template<> struct is_integral<unsigned int> : public __is_integral_helper<__remove_cv_t<unsigned int>>::type {
    };
template<> struct is_integral<char8_t> : public __is_integral_helper<__remove_cv_t<char8_t>>::type {
    };
template<> struct is_integral<unsigned char> : public __is_integral_helper<__remove_cv_t<unsigned char>>::type {
    };
template<> struct is_integral<char16_t> : public __is_integral_helper<__remove_cv_t<char16_t>>::type {
    };
template<> struct is_integral<unsigned short> : public __is_integral_helper<__remove_cv_t<unsigned short>>::type {
    };
template<> struct is_integral<char32_t> : public __is_integral_helper<__remove_cv_t<char32_t>>::type {
    };
template<> struct is_integral<unsigned long> : public __is_integral_helper<__remove_cv_t<unsigned long>>::type {
    };
template<> struct is_integral<const char *> : public __is_integral_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_integral<long> : public __is_integral_helper<__remove_cv_t<long>>::type {
    };
template<> struct is_integral<const wchar_t *> : public __is_integral_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_integral<const char8_t *> : public __is_integral_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_integral<const char16_t *> : public __is_integral_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_integral<const char32_t *> : public __is_integral_helper<__remove_cv_t<const char32_t *>>::type {
    };
    template <typename> struct __is_floating_point_helper : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const wchar_t *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char8_t *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char16_t *> : public std::false_type {
    };
template<> struct __is_floating_point_helper<const char32_t *> : public std::false_type {
    };
    template<> struct __is_floating_point_helper<float> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<double> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<long double> : public std::true_type {
    };
    template <typename _Tp> struct is_floating_point : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_floating_point<const char *> : public __is_floating_point_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_floating_point<const wchar_t *> : public __is_floating_point_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_floating_point<const char8_t *> : public __is_floating_point_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_floating_point<const char16_t *> : public __is_floating_point_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_floating_point<const char32_t *> : public __is_floating_point_helper<__remove_cv_t<const char32_t *>>::type {
    };
    template <typename> struct is_array : public std::false_type {
    };
template<> struct is_array<const char *> : public std::false_type {
    };
template<> struct is_array<char *> : public std::false_type {
    };
template<> struct is_array<char> : public std::false_type {
    };
template<> struct is_array<const wchar_t *> : public std::false_type {
    };
template<> struct is_array<wchar_t *> : public std::false_type {
    };
template<> struct is_array<wchar_t> : public std::false_type {
    };
template<> struct is_array<const char8_t *> : public std::false_type {
    };
template<> struct is_array<char8_t *> : public std::false_type {
    };
template<> struct is_array<char8_t> : public std::false_type {
    };
template<> struct is_array<const char16_t *> : public std::false_type {
    };
template<> struct is_array<char16_t *> : public std::false_type {
    };
template<> struct is_array<char16_t> : public std::false_type {
    };
template<> struct is_array<const char32_t *> : public std::false_type {
    };
template<> struct is_array<char32_t *> : public std::false_type {
    };
template<> struct is_array<char32_t> : public std::false_type {
    };
template<> struct is_array<const char *const &> : public std::false_type {
    };
template<> struct is_array<const char &> : public std::false_type {
    };
template<> struct is_array<const volatile std::input_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<const volatile std::forward_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<bool> : public std::false_type {
    };
template<> struct is_array<const volatile std::bidirectional_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<const volatile std::random_access_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<const volatile std::contiguous_iterator_tag *> : public std::false_type {
    };
template<> struct is_array<unsigned long> : public std::false_type {
    };
template<> struct is_array<const unsigned long &> : public std::false_type {
    };
template<> struct is_array<const wchar_t *const &> : public std::false_type {
    };
template<> struct is_array<const wchar_t &> : public std::false_type {
    };
template<> struct is_array<const char8_t *const &> : public std::false_type {
    };
template<> struct is_array<const char8_t &> : public std::false_type {
    };
template<> struct is_array<const char16_t *const &> : public std::false_type {
    };
template<> struct is_array<const char16_t &> : public std::false_type {
    };
template<> struct is_array<const char32_t *const &> : public std::false_type {
    };
template<> struct is_array<const char32_t &> : public std::false_type {
    };
    template <typename _Tp, std::size_t _Size> struct is_array<_Tp [_Size]> : public std::true_type {
    };
    template <typename _Tp> struct is_array<_Tp []> : public std::true_type {
    };
    template <typename> struct __is_pointer_helper : public std::false_type {
    };
template<> struct __is_pointer_helper<const char *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const wchar_t *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const char8_t *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const char16_t *> : public std::true_type {
    };
template<> struct __is_pointer_helper<const char32_t *> : public std::true_type {
    };
    template <typename _Tp> struct __is_pointer_helper<_Tp *> : public std::true_type {
    };
    template <typename _Tp> struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
template<> struct is_pointer<const char *> : public __is_pointer_helper<__remove_cv_t<const char *>>::type {
    };
template<> struct is_pointer<const wchar_t *> : public __is_pointer_helper<__remove_cv_t<const wchar_t *>>::type {
    };
template<> struct is_pointer<const char8_t *> : public __is_pointer_helper<__remove_cv_t<const char8_t *>>::type {
    };
template<> struct is_pointer<const char16_t *> : public __is_pointer_helper<__remove_cv_t<const char16_t *>>::type {
    };
template<> struct is_pointer<const char32_t *> : public __is_pointer_helper<__remove_cv_t<const char32_t *>>::type {
    };
    template <typename> struct is_lvalue_reference : public std::false_type {
    };
template<> struct is_lvalue_reference<const char *> : public std::false_type {
    };
template<> struct is_lvalue_reference<char *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char> : public std::false_type {
    };
template<> struct is_lvalue_reference<char> : public std::false_type {
    };
template<> struct is_lvalue_reference<const wchar_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<wchar_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const wchar_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<wchar_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char8_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<char8_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char8_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char8_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char16_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<char16_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char16_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char16_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char32_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<char32_t *> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char32_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<char32_t> : public std::false_type {
    };
template<> struct is_lvalue_reference<const char *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char &> : public std::true_type {
    };
template<> struct is_lvalue_reference<unsigned long> : public std::false_type {
    };
template<> struct is_lvalue_reference<unsigned long &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const wchar_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const wchar_t &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char8_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char8_t &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char16_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char16_t &> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char32_t *&> : public std::true_type {
    };
template<> struct is_lvalue_reference<const char32_t &> : public std::true_type {
    };
    template <typename _Tp> struct is_lvalue_reference<_Tp &> : public std::true_type {
    };
    template <typename> struct is_rvalue_reference : public std::false_type {
    };
template<> struct is_rvalue_reference<const char *> : public std::false_type {
    };
template<> struct is_rvalue_reference<char *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char> : public std::false_type {
    };
template<> struct is_rvalue_reference<char> : public std::false_type {
    };
template<> struct is_rvalue_reference<const wchar_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<wchar_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const wchar_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<wchar_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char8_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<char8_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char8_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char8_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char16_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<char16_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char16_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char16_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char32_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<char32_t *> : public std::false_type {
    };
template<> struct is_rvalue_reference<const char32_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<char32_t> : public std::false_type {
    };
template<> struct is_rvalue_reference<unsigned long> : public std::false_type {
    };
    template <typename _Tp> struct is_rvalue_reference<_Tp &&> : public std::true_type {
    };
    template <typename> struct __is_member_object_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public __not_<is_function<_Tp>>::type {
    };
    template <typename _Tp> struct is_member_object_pointer : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename> struct __is_member_function_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type {
    };
    template <typename _Tp> struct is_member_function_pointer : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {
    };
template<> struct is_enum<wchar_t> : public integral_constant<bool, __is_enum(wchar_t)> {
    };
template<> struct is_enum<unsigned int> : public integral_constant<bool, __is_enum(unsigned int)> {
    };
template<> struct is_enum<char8_t> : public integral_constant<bool, __is_enum(char8_t)> {
    };
template<> struct is_enum<unsigned char> : public integral_constant<bool, __is_enum(unsigned char)> {
    };
template<> struct is_enum<char16_t> : public integral_constant<bool, __is_enum(char16_t)> {
    };
template<> struct is_enum<unsigned short> : public integral_constant<bool, __is_enum(unsigned short)> {
    };
template<> struct is_enum<char32_t> : public integral_constant<bool, __is_enum(char32_t)> {
    };
template<> struct is_enum<const char *> : public integral_constant<bool, __is_enum(const char *)> {
    };
template<> struct is_enum<const char *const> : public integral_constant<bool, __is_enum(const char *const)> {
    };
template<> struct is_enum<unsigned long> : public integral_constant<bool, __is_enum(unsigned long)> {
    };
template<> struct is_enum<const wchar_t *> : public integral_constant<bool, __is_enum(const wchar_t *)> {
    };
template<> struct is_enum<const wchar_t *const> : public integral_constant<bool, __is_enum(const wchar_t *const)> {
    };
template<> struct is_enum<const char8_t *> : public integral_constant<bool, __is_enum(const char8_t *)> {
    };
template<> struct is_enum<const char8_t *const> : public integral_constant<bool, __is_enum(const char8_t *const)> {
    };
template<> struct is_enum<const char16_t *> : public integral_constant<bool, __is_enum(const char16_t *)> {
    };
template<> struct is_enum<const char16_t *const> : public integral_constant<bool, __is_enum(const char16_t *const)> {
    };
template<> struct is_enum<const char32_t *> : public integral_constant<bool, __is_enum(const char32_t *)> {
    };
template<> struct is_enum<const char32_t *const> : public integral_constant<bool, __is_enum(const char32_t *const)> {
    };
    template <typename _Tp> struct is_union : public integral_constant<bool, __is_union(_Tp)> {
    };
template<> struct is_union<const char *> : public integral_constant<bool, __is_union(const char *)> {
    };
template<> struct is_union<const char *const> : public integral_constant<bool, __is_union(const char *const)> {
    };
template<> struct is_union<unsigned long> : public integral_constant<bool, __is_union(unsigned long)> {
    };
template<> struct is_union<const wchar_t *> : public integral_constant<bool, __is_union(const wchar_t *)> {
    };
template<> struct is_union<const wchar_t *const> : public integral_constant<bool, __is_union(const wchar_t *const)> {
    };
template<> struct is_union<const char8_t *> : public integral_constant<bool, __is_union(const char8_t *)> {
    };
template<> struct is_union<const char8_t *const> : public integral_constant<bool, __is_union(const char8_t *const)> {
    };
template<> struct is_union<const char16_t *> : public integral_constant<bool, __is_union(const char16_t *)> {
    };
template<> struct is_union<const char16_t *const> : public integral_constant<bool, __is_union(const char16_t *const)> {
    };
template<> struct is_union<const char32_t *> : public integral_constant<bool, __is_union(const char32_t *)> {
    };
template<> struct is_union<const char32_t *const> : public integral_constant<bool, __is_union(const char32_t *const)> {
    };
    template <typename _Tp> struct is_class : public integral_constant<bool, __is_class(_Tp)> {
    };
template<> struct is_class<const char *> : public integral_constant<bool, __is_class(const char *)> {
    };
template<> struct is_class<const char *const> : public integral_constant<bool, __is_class(const char *const)> {
    };
template<> struct is_class<unsigned long> : public integral_constant<bool, __is_class(unsigned long)> {
    };
template<> struct is_class<const wchar_t *> : public integral_constant<bool, __is_class(const wchar_t *)> {
    };
template<> struct is_class<const wchar_t *const> : public integral_constant<bool, __is_class(const wchar_t *const)> {
    };
template<> struct is_class<const char8_t *> : public integral_constant<bool, __is_class(const char8_t *)> {
    };
template<> struct is_class<const char8_t *const> : public integral_constant<bool, __is_class(const char8_t *const)> {
    };
template<> struct is_class<const char16_t *> : public integral_constant<bool, __is_class(const char16_t *)> {
    };
template<> struct is_class<const char16_t *const> : public integral_constant<bool, __is_class(const char16_t *const)> {
    };
template<> struct is_class<const char32_t *> : public integral_constant<bool, __is_class(const char32_t *)> {
    };
template<> struct is_class<const char32_t *const> : public integral_constant<bool, __is_class(const char32_t *const)> {
    };
    template <typename _Tp> struct is_function : public __bool_constant<!is_const<const _Tp>::value> {
    };
template<> struct is_function<const char *> : public __bool_constant<!is_const<const char *const>::value> {
    };
template<> struct is_function<char *> : public __bool_constant<!is_const<char *const>::value> {
    };
template<> struct is_function<const char> : public __bool_constant<!is_const<const const char>::value> {
    };
template<> struct is_function<char> : public __bool_constant<!is_const<const char>::value> {
    };
template<> struct is_function<const wchar_t *> : public __bool_constant<!is_const<const wchar_t *const>::value> {
    };
template<> struct is_function<wchar_t *> : public __bool_constant<!is_const<wchar_t *const>::value> {
    };
template<> struct is_function<const wchar_t> : public __bool_constant<!is_const<const const wchar_t>::value> {
    };
template<> struct is_function<wchar_t> : public __bool_constant<!is_const<const wchar_t>::value> {
    };
template<> struct is_function<const char8_t *> : public __bool_constant<!is_const<const char8_t *const>::value> {
    };
template<> struct is_function<char8_t *> : public __bool_constant<!is_const<char8_t *const>::value> {
    };
template<> struct is_function<const char8_t> : public __bool_constant<!is_const<const const char8_t>::value> {
    };
template<> struct is_function<char8_t> : public __bool_constant<!is_const<const char8_t>::value> {
    };
template<> struct is_function<const char16_t *> : public __bool_constant<!is_const<const char16_t *const>::value> {
    };
template<> struct is_function<char16_t *> : public __bool_constant<!is_const<char16_t *const>::value> {
    };
template<> struct is_function<const char16_t> : public __bool_constant<!is_const<const const char16_t>::value> {
    };
template<> struct is_function<char16_t> : public __bool_constant<!is_const<const char16_t>::value> {
    };
template<> struct is_function<const char32_t *> : public __bool_constant<!is_const<const char32_t *const>::value> {
    };
template<> struct is_function<char32_t *> : public __bool_constant<!is_const<char32_t *const>::value> {
    };
template<> struct is_function<const char32_t> : public __bool_constant<!is_const<const const char32_t>::value> {
    };
template<> struct is_function<char32_t> : public __bool_constant<!is_const<const char32_t>::value> {
    };
template<> struct is_function<const char *const &> : public std::false_type {
    };
template<> struct is_function<const char &> : public std::false_type {
    };
template<> struct is_function<const volatile std::input_iterator_tag *> : public __bool_constant<!is_const<const volatile input_iterator_tag *const>::value> {
    };
template<> struct is_function<const volatile std::forward_iterator_tag *> : public __bool_constant<!is_const<const volatile forward_iterator_tag *const>::value> {
    };
template<> struct is_function<bool> : public __bool_constant<!is_const<const bool>::value> {
    };
template<> struct is_function<const volatile std::bidirectional_iterator_tag *> : public __bool_constant<!is_const<const volatile bidirectional_iterator_tag *const>::value> {
    };
template<> struct is_function<const volatile std::random_access_iterator_tag *> : public __bool_constant<!is_const<const volatile random_access_iterator_tag *const>::value> {
    };
template<> struct is_function<const volatile std::contiguous_iterator_tag *> : public __bool_constant<!is_const<const volatile contiguous_iterator_tag *const>::value> {
    };
template<> struct is_function<unsigned long> : public __bool_constant<!is_const<const unsigned long>::value> {
    };
template<> struct is_function<const unsigned long &> : public std::false_type {
    };
template<> struct is_function<const wchar_t *const &> : public std::false_type {
    };
template<> struct is_function<const wchar_t &> : public std::false_type {
    };
template<> struct is_function<const char8_t *const &> : public std::false_type {
    };
template<> struct is_function<const char8_t &> : public std::false_type {
    };
template<> struct is_function<const char16_t *const &> : public std::false_type {
    };
template<> struct is_function<const char16_t &> : public std::false_type {
    };
template<> struct is_function<const char32_t *const &> : public std::false_type {
    };
template<> struct is_function<const char32_t &> : public std::false_type {
    };
    template <typename _Tp> struct is_function<_Tp &> : public std::false_type {
    };
    template <typename _Tp> struct is_function<_Tp &&> : public std::false_type {
    };
    template <typename> struct __is_null_pointer_helper : public std::false_type {
    };
    template<> struct __is_null_pointer_helper<std::nullptr_t> : public std::true_type {
    };
    template <typename _Tp> struct is_null_pointer : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename _Tp> struct __attribute__((deprecated("use 'std::is_null_pointer' instead"))) __is_nullptr_t : public is_null_pointer<_Tp> {
    };
    template <typename _Tp> struct is_reference : public __or_<is_lvalue_reference<_Tp>, is_rvalue_reference<_Tp>>::type {
    };
template<> struct is_reference<const char *> : public __or_<is_lvalue_reference<const char *>, is_rvalue_reference<const char *>>::type {
    };
template<> struct is_reference<char *> : public __or_<is_lvalue_reference<char *>, is_rvalue_reference<char *>>::type {
    };
template<> struct is_reference<const char> : public __or_<is_lvalue_reference<const char>, is_rvalue_reference<const char>>::type {
    };
template<> struct is_reference<char> : public __or_<is_lvalue_reference<char>, is_rvalue_reference<char>>::type {
    };
template<> struct is_reference<const wchar_t *> : public __or_<is_lvalue_reference<const wchar_t *>, is_rvalue_reference<const wchar_t *>>::type {
    };
template<> struct is_reference<wchar_t *> : public __or_<is_lvalue_reference<wchar_t *>, is_rvalue_reference<wchar_t *>>::type {
    };
template<> struct is_reference<const wchar_t> : public __or_<is_lvalue_reference<const wchar_t>, is_rvalue_reference<const wchar_t>>::type {
    };
template<> struct is_reference<wchar_t> : public __or_<is_lvalue_reference<wchar_t>, is_rvalue_reference<wchar_t>>::type {
    };
template<> struct is_reference<const char8_t *> : public __or_<is_lvalue_reference<const char8_t *>, is_rvalue_reference<const char8_t *>>::type {
    };
template<> struct is_reference<char8_t *> : public __or_<is_lvalue_reference<char8_t *>, is_rvalue_reference<char8_t *>>::type {
    };
template<> struct is_reference<const char8_t> : public __or_<is_lvalue_reference<const char8_t>, is_rvalue_reference<const char8_t>>::type {
    };
template<> struct is_reference<char8_t> : public __or_<is_lvalue_reference<char8_t>, is_rvalue_reference<char8_t>>::type {
    };
template<> struct is_reference<const char16_t *> : public __or_<is_lvalue_reference<const char16_t *>, is_rvalue_reference<const char16_t *>>::type {
    };
template<> struct is_reference<char16_t *> : public __or_<is_lvalue_reference<char16_t *>, is_rvalue_reference<char16_t *>>::type {
    };
template<> struct is_reference<const char16_t> : public __or_<is_lvalue_reference<const char16_t>, is_rvalue_reference<const char16_t>>::type {
    };
template<> struct is_reference<char16_t> : public __or_<is_lvalue_reference<char16_t>, is_rvalue_reference<char16_t>>::type {
    };
template<> struct is_reference<const char32_t *> : public __or_<is_lvalue_reference<const char32_t *>, is_rvalue_reference<const char32_t *>>::type {
    };
template<> struct is_reference<char32_t *> : public __or_<is_lvalue_reference<char32_t *>, is_rvalue_reference<char32_t *>>::type {
    };
template<> struct is_reference<const char32_t> : public __or_<is_lvalue_reference<const char32_t>, is_rvalue_reference<const char32_t>>::type {
    };
template<> struct is_reference<char32_t> : public __or_<is_lvalue_reference<char32_t>, is_rvalue_reference<char32_t>>::type {
    };
template<> struct is_reference<unsigned long> : public __or_<is_lvalue_reference<unsigned long>, is_rvalue_reference<unsigned long>>::type {
    };
    template <typename _Tp> struct is_arithmetic : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {
    };
template<> struct is_arithmetic<const char *> : public __or_<is_integral<const char *>, is_floating_point<const char *>>::type {
    };
template<> struct is_arithmetic<long> : public __or_<is_integral<long>, is_floating_point<long>>::type {
    };
template<> struct is_arithmetic<unsigned long> : public __or_<is_integral<unsigned long>, is_floating_point<unsigned long>>::type {
    };
template<> struct is_arithmetic<const wchar_t *> : public __or_<is_integral<const wchar_t *>, is_floating_point<const wchar_t *>>::type {
    };
template<> struct is_arithmetic<const char8_t *> : public __or_<is_integral<const char8_t *>, is_floating_point<const char8_t *>>::type {
    };
template<> struct is_arithmetic<const char16_t *> : public __or_<is_integral<const char16_t *>, is_floating_point<const char16_t *>>::type {
    };
template<> struct is_arithmetic<const char32_t *> : public __or_<is_integral<const char32_t *>, is_floating_point<const char32_t *>>::type {
    };
    template <typename _Tp> struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, is_null_pointer<_Tp>>::type {
    };
    template <typename _Tp> struct is_object : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {
    };
template<> struct is_object<const char> : public __not_<__or_<is_function<const char>, is_reference<const char>, is_void<const char>>>::type {
    };
template<> struct is_object<char> : public __not_<__or_<is_function<char>, is_reference<char>, is_void<char>>>::type {
    };
template<> struct is_object<const wchar_t> : public __not_<__or_<is_function<const wchar_t>, is_reference<const wchar_t>, is_void<const wchar_t>>>::type {
    };
template<> struct is_object<wchar_t> : public __not_<__or_<is_function<wchar_t>, is_reference<wchar_t>, is_void<wchar_t>>>::type {
    };
template<> struct is_object<const char8_t> : public __not_<__or_<is_function<const char8_t>, is_reference<const char8_t>, is_void<const char8_t>>>::type {
    };
template<> struct is_object<char8_t> : public __not_<__or_<is_function<char8_t>, is_reference<char8_t>, is_void<char8_t>>>::type {
    };
template<> struct is_object<const char16_t> : public __not_<__or_<is_function<const char16_t>, is_reference<const char16_t>, is_void<const char16_t>>>::type {
    };
template<> struct is_object<const char32_t> : public __not_<__or_<is_function<const char32_t>, is_reference<const char32_t>, is_void<const char32_t>>>::type {
    };
template<> struct is_object<const char *> : public __not_<__or_<is_function<const char *>, is_reference<const char *>, is_void<const char *>>>::type {
    };
template<> struct is_object<unsigned long> : public __not_<__or_<is_function<unsigned long>, is_reference<unsigned long>, is_void<unsigned long>>>::type {
    };
template<> struct is_object<const wchar_t *> : public __not_<__or_<is_function<const wchar_t *>, is_reference<const wchar_t *>, is_void<const wchar_t *>>>::type {
    };
template<> struct is_object<const char8_t *> : public __not_<__or_<is_function<const char8_t *>, is_reference<const char8_t *>, is_void<const char8_t *>>>::type {
    };
template<> struct is_object<const char16_t *> : public __not_<__or_<is_function<const char16_t *>, is_reference<const char16_t *>, is_void<const char16_t *>>>::type {
    };
template<> struct is_object<const char32_t *> : public __not_<__or_<is_function<const char32_t *>, is_reference<const char32_t *>, is_void<const char32_t *>>>::type {
    };
    template <typename> struct is_member_pointer;
    template <typename _Tp> struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>, is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {
    };
template<> struct is_scalar<const char *> : public __or_<is_arithmetic<const char *>, is_enum<const char *>, is_pointer<const char *>, is_member_pointer<const char *>, is_null_pointer<const char *>>::type {
    };
template<> struct is_scalar<unsigned long> : public __or_<is_arithmetic<unsigned long>, is_enum<unsigned long>, is_pointer<unsigned long>, is_member_pointer<unsigned long>, is_null_pointer<unsigned long>>::type {
    };
template<> struct is_scalar<const wchar_t *> : public __or_<is_arithmetic<const wchar_t *>, is_enum<const wchar_t *>, is_pointer<const wchar_t *>, is_member_pointer<const wchar_t *>, is_null_pointer<const wchar_t *>>::type {
    };
template<> struct is_scalar<const char8_t *> : public __or_<is_arithmetic<const char8_t *>, is_enum<const char8_t *>, is_pointer<const char8_t *>, is_member_pointer<const char8_t *>, is_null_pointer<const char8_t *>>::type {
    };
template<> struct is_scalar<const char16_t *> : public __or_<is_arithmetic<const char16_t *>, is_enum<const char16_t *>, is_pointer<const char16_t *>, is_member_pointer<const char16_t *>, is_null_pointer<const char16_t *>>::type {
    };
template<> struct is_scalar<const char32_t *> : public __or_<is_arithmetic<const char32_t *>, is_enum<const char32_t *>, is_pointer<const char32_t *>, is_member_pointer<const char32_t *>, is_null_pointer<const char32_t *>>::type {
    };
    template <typename _Tp> struct is_compound : public __not_<is_fundamental<_Tp>>::type {
    };
    template <typename _Tp> struct __is_member_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public std::true_type {
    };
    template <typename _Tp> struct is_member_pointer : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {
    };
    template <typename, typename> struct is_same
template<> struct is_same<list_start, list_start> : public integral_constant<bool, __is_same(list_start, list_start)> {
    }
template<> struct is_same<list_start, list_end> : public integral_constant<bool, __is_same(list_start, list_end)> {
    }
template<> struct is_same<plus, list_end> : public integral_constant<bool, __is_same(plus, list_end)> {
    }
template<> struct is_same<whitespace, list_end> : public integral_constant<bool, __is_same(whitespace, list_end)> {
    }
template<> struct is_same<integer<3>, list_end> : public integral_constant<bool, __is_same(integer<3>, list_end)> {
    }
template<> struct is_same<mul, list_end> : public integral_constant<bool, __is_same(mul, list_end)> {
    }
template<> struct is_same<integer<2>, list_end> : public integral_constant<bool, __is_same(integer<2>, list_end)> {
    }
template<> struct is_same<list_end, list_end> : public integral_constant<bool, __is_same(list_end, list_end)> {
    }
template<> struct is_same<plus, list_start> : public integral_constant<bool, __is_same(plus, list_start)> {
    }
template<> struct is_same<plus, whitespace> : public integral_constant<bool, __is_same(plus, whitespace)> {
    }
template<> struct is_same<whitespace, list_start> : public integral_constant<bool, __is_same(whitespace, list_start)> {
    }
template<> struct is_same<whitespace, whitespace> : public integral_constant<bool, __is_same(whitespace, whitespace)> {
    }
template<> struct is_same<integer<3>, list_start> : public integral_constant<bool, __is_same(integer<3>, list_start)> {
    }
template<> struct is_same<mul, list_start> : public integral_constant<bool, __is_same(mul, list_start)> {
    }
template<> struct is_same<mul, whitespace> : public integral_constant<bool, __is_same(mul, whitespace)> {
    }
template<> struct is_same<integer<2>, list_start> : public integral_constant<bool, __is_same(integer<2>, list_start)> {
    }
template<> struct is_same<list_end, list_start> : public integral_constant<bool, __is_same(list_end, list_start)> {
    }
template<> struct is_same<plus, plus> : public integral_constant<bool, __is_same(plus, plus)> {
    }
template<> struct is_same<mul, plus> : public integral_constant<bool, __is_same(mul, plus)> {
    }
template<> struct is_same<mul, minus> : public integral_constant<bool, __is_same(mul, minus)> {
    }
template<> struct is_same<mul, mul> : public integral_constant<bool, __is_same(mul, mul)> {
    };
    template <typename _Tp, typename ..._Types> using __is_one_of = __or_<is_same<_Tp, _Types>...>;
    template <typename _Tp> using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>, signed char, short, int, long, long long>;
    template <typename _Tp> using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
    template <typename _Tp> using __is_standard_integer = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;
    template <typename ...> using __void_t = void;
    template <typename _Tp, typename = void> struct __is_referenceable : public std::false_type {
    };
template<> struct __is_referenceable<const char *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<wchar_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<wchar_t, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char8_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char8_t, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char16_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char16_t, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char32_t *, void> : public std::true_type {
    };
template<> struct __is_referenceable<char32_t, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char *const &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char &, void> : public std::true_type {
    };
template<> struct __is_referenceable<char &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char &&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char *&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char *const, void> : public std::true_type {
    };
template<> struct __is_referenceable<bool, void> : public std::true_type {
    };
template<> struct __is_referenceable<unsigned long, void> : public std::true_type {
    };
template<> struct __is_referenceable<unsigned long &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const unsigned long &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const unsigned long, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t *const &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<wchar_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t &&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t *&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const wchar_t *const, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t *const &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<char8_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t &&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t *&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char8_t *const, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t *const &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<char16_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t &&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t *&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char16_t *const, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t *const &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<char32_t &, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t &&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t *&, void> : public std::true_type {
    };
template<> struct __is_referenceable<const char32_t *const, void> : public std::true_type {
    };
    template <typename _Tp> struct __is_referenceable<_Tp, __void_t<_Tp &>> : public std::true_type {
    };
    template <typename> struct is_const : public std::false_type {
    };
template<> struct is_const<wchar_t> : public std::false_type {
    };
template<> struct is_const<char8_t> : public std::false_type {
    };
template<> struct is_const<char16_t> : public std::false_type {
    };
template<> struct is_const<char32_t> : public std::false_type {
    };
template<> struct is_const<unsigned int> : public std::false_type {
    };
template<> struct is_const<unsigned char> : public std::false_type {
    };
template<> struct is_const<unsigned short> : public std::false_type {
    };
template<> struct is_const<const char *const> : public std::true_type {
    };
template<> struct is_const<char *const> : public std::true_type {
    };
template<> struct is_const<const char> : public std::true_type {
    };
template<> struct is_const<const wchar_t *const> : public std::true_type {
    };
template<> struct is_const<wchar_t *const> : public std::true_type {
    };
template<> struct is_const<const wchar_t> : public std::true_type {
    };
template<> struct is_const<const char8_t *const> : public std::true_type {
    };
template<> struct is_const<char8_t *const> : public std::true_type {
    };
template<> struct is_const<const char8_t> : public std::true_type {
    };
template<> struct is_const<const char16_t *const> : public std::true_type {
    };
template<> struct is_const<char16_t *const> : public std::true_type {
    };
template<> struct is_const<const char16_t> : public std::true_type {
    };
template<> struct is_const<const char32_t *const> : public std::true_type {
    };
template<> struct is_const<char32_t *const> : public std::true_type {
    };
template<> struct is_const<const char32_t> : public std::true_type {
    };
template<> struct is_const<char> : public std::false_type {
    };
template<> struct is_const<const volatile std::input_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const volatile std::forward_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const bool> : public std::true_type {
    };
template<> struct is_const<const volatile std::bidirectional_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const volatile std::random_access_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const volatile std::contiguous_iterator_tag *const> : public std::true_type {
    };
template<> struct is_const<const unsigned long> : public std::true_type {
    };
    template <typename _Tp> struct is_const<const _Tp> : public std::true_type {
    };
    template <typename> struct is_volatile : public std::false_type {
    };
template<> struct is_volatile<wchar_t> : public std::false_type {
    };
template<> struct is_volatile<char8_t> : public std::false_type {
    };
template<> struct is_volatile<char16_t> : public std::false_type {
    };
template<> struct is_volatile<char32_t> : public std::false_type {
    };
template<> struct is_volatile<unsigned int> : public std::false_type {
    };
template<> struct is_volatile<unsigned char> : public std::false_type {
    };
template<> struct is_volatile<unsigned short> : public std::false_type {
    };
template<> struct is_volatile<const char *const> : public std::false_type {
    };
template<> struct is_volatile<const char> : public std::false_type {
    };
template<> struct is_volatile<char> : public std::false_type {
    };
template<> struct is_volatile<const unsigned long> : public std::false_type {
    };
template<> struct is_volatile<const wchar_t *const> : public std::false_type {
    };
template<> struct is_volatile<const wchar_t> : public std::false_type {
    };
template<> struct is_volatile<const char8_t *const> : public std::false_type {
    };
template<> struct is_volatile<const char8_t> : public std::false_type {
    };
template<> struct is_volatile<const char16_t *const> : public std::false_type {
    };
template<> struct is_volatile<const char16_t> : public std::false_type {
    };
template<> struct is_volatile<const char32_t *const> : public std::false_type {
    };
template<> struct is_volatile<const char32_t> : public std::false_type {
    };
    template <typename _Tp> struct is_volatile<volatile _Tp> : public std::true_type {
    };
    template <typename _Tp> struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char> : public integral_constant<bool, __is_trivial(char)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<wchar_t> : public integral_constant<bool, __is_trivial(wchar_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char8_t> : public integral_constant<bool, __is_trivial(char8_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char8_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char16_t> : public integral_constant<bool, __is_trivial(char16_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_trivial<char32_t> : public integral_constant<bool, __is_trivial(char32_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char> : public integral_constant<bool, __is_standard_layout(char)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<wchar_t> : public integral_constant<bool, __is_standard_layout(wchar_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char8_t> : public integral_constant<bool, __is_standard_layout(char8_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char8_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char16_t> : public integral_constant<bool, __is_standard_layout(char16_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_standard_layout<char32_t> : public integral_constant<bool, __is_standard_layout(char32_t)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct [[deprecated("use is_standard_layout && is_trivial instead")]] is_pod : public integral_constant<bool, __is_pod(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {
    };
    template <typename _Tp> struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
    };
    template <typename _Tp> struct is_final : public integral_constant<bool, __is_final(_Tp)> {
    };
    template <typename _Tp> struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {
    };
    template <typename _Tp, bool = is_arithmetic<_Tp>::value> struct __is_signed_helper : public std::false_type {
    };
template<> struct __is_signed_helper<long, true> : public integral_constant<bool, long(-1) < long(0)> {
    };
    template <typename _Tp> struct __is_signed_helper<_Tp, true> : public integral_constant<bool, _Tp(-1) < _Tp(0)> {
    };
    template <typename _Tp> struct is_signed : public __is_signed_helper<_Tp>::type {
    };
template<> struct is_signed<long> : public __is_signed_helper<long>::type {
    };
    template <typename _Tp> struct is_unsigned : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>> {
    };
    template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);
    template<> const std::ranges::__cust_swap::_Swap &__declval<const std::ranges::__cust_swap::_Swap &, const std::ranges::__cust_swap::_Swap &>(int);
    template<> const char *const &__declval<const char *const &, const char *const &>(int);
    template<> char *const &__declval<char *const &, char *const &>(int);
    template<> const wchar_t *const &__declval<const wchar_t *const &, const wchar_t *const &>(int);
    template<> wchar_t *const &__declval<wchar_t *const &, wchar_t *const &>(int);
    template<> const char8_t *const &__declval<const char8_t *const &, const char8_t *const &>(int);
    template<> char8_t *const &__declval<char8_t *const &, char8_t *const &>(int);
    template<> const char16_t *const &__declval<const char16_t *const &, const char16_t *const &>(int);
    template<> char16_t *const &__declval<char16_t *const &, char16_t *const &>(int);
    template<> const char32_t *const &__declval<const char32_t *const &, const char32_t *const &>(int);
    template<> char32_t *const &__declval<char32_t *const &, char32_t *const &>(int);
    template<> const char *&&__declval<const char *, const char *&&>(int);
    template<> const char *const &(&__declval<const char *const &(&)(), const char *const &(&)()>(int))();
    template<> const char *&&__declval<const char *&&, const char *&&>(int);
    template<> const char *&__declval<const char *&, const char *&>(int);
    template<> const char &(&__declval<const char &(&)(), const char &(&)()>(int))();
    template<> const char &__declval<const char &, const char &>(int);
    template<> char &__declval<char &, char &>(int);
    template<> const char &&__declval<const char &&, const char &&>(int);
    template<> const volatile std::contiguous_iterator_tag *&&__declval<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *&&>(int);
    template<> const char *const &&__declval<const char *const, const char *const &&>(int);
    template<> bool &&__declval<bool, bool &&>(int);
    template<> unsigned long &&__declval<unsigned long, unsigned long &&>(int);
    template<> unsigned long &__declval<unsigned long &, unsigned long &>(int);
    template<> const unsigned long &__declval<const unsigned long &, const unsigned long &>(int);
    template<> const unsigned long &&__declval<const unsigned long, const unsigned long &&>(int);
    template<> const unsigned long &(&__declval<const unsigned long &(&)(), const unsigned long &(&)()>(int))();
    template<> unsigned long &&__declval<unsigned long &&, unsigned long &&>(int);
    template<> const wchar_t *&&__declval<const wchar_t *, const wchar_t *&&>(int);
    template<> const wchar_t *const &(&__declval<const wchar_t *const &(&)(), const wchar_t *const &(&)()>(int))();
    template<> const wchar_t *&&__declval<const wchar_t *&&, const wchar_t *&&>(int);
    template<> const wchar_t *&__declval<const wchar_t *&, const wchar_t *&>(int);
    template<> const wchar_t &(&__declval<const wchar_t &(&)(), const wchar_t &(&)()>(int))();
    template<> const wchar_t &__declval<const wchar_t &, const wchar_t &>(int);
    template<> wchar_t &__declval<wchar_t &, wchar_t &>(int);
    template<> const wchar_t &&__declval<const wchar_t &&, const wchar_t &&>(int);
    template<> const wchar_t *const &&__declval<const wchar_t *const, const wchar_t *const &&>(int);
    template<> const char8_t *&&__declval<const char8_t *, const char8_t *&&>(int);
    template<> const char8_t *const &(&__declval<const char8_t *const &(&)(), const char8_t *const &(&)()>(int))();
    template<> const char8_t *&&__declval<const char8_t *&&, const char8_t *&&>(int);
    template<> const char8_t *&__declval<const char8_t *&, const char8_t *&>(int);
    template<> const char8_t &(&__declval<const char8_t &(&)(), const char8_t &(&)()>(int))();
    template<> const char8_t &__declval<const char8_t &, const char8_t &>(int);
    template<> char8_t &__declval<char8_t &, char8_t &>(int);
    template<> const char8_t &&__declval<const char8_t &&, const char8_t &&>(int);
    template<> const char8_t *const &&__declval<const char8_t *const, const char8_t *const &&>(int);
    template<> const char16_t *&&__declval<const char16_t *, const char16_t *&&>(int);
    template<> const char16_t *const &(&__declval<const char16_t *const &(&)(), const char16_t *const &(&)()>(int))();
    template<> const char16_t *&&__declval<const char16_t *&&, const char16_t *&&>(int);
    template<> const char16_t *&__declval<const char16_t *&, const char16_t *&>(int);
    template<> const char16_t &(&__declval<const char16_t &(&)(), const char16_t &(&)()>(int))();
    template<> const char16_t &__declval<const char16_t &, const char16_t &>(int);
    template<> char16_t &__declval<char16_t &, char16_t &>(int);
    template<> const char16_t &&__declval<const char16_t &&, const char16_t &&>(int);
    template<> const char16_t *const &&__declval<const char16_t *const, const char16_t *const &&>(int);
    template<> const char32_t *&&__declval<const char32_t *, const char32_t *&&>(int);
    template<> const char32_t *const &(&__declval<const char32_t *const &(&)(), const char32_t *const &(&)()>(int))();
    template<> const char32_t *&&__declval<const char32_t *&&, const char32_t *&&>(int);
    template<> const char32_t *&__declval<const char32_t *&, const char32_t *&>(int);
    template<> const char32_t &(&__declval<const char32_t &(&)(), const char32_t &(&)()>(int))();
    template<> const char32_t &__declval<const char32_t &, const char32_t &>(int);
    template<> char32_t &__declval<char32_t &, char32_t &>(int);
    template<> const char32_t &&__declval<const char32_t &&, const char32_t &&>(int);
    template<> const char32_t *const &&__declval<const char32_t *const, const char32_t *const &&>(int);
    template <typename _Tp> _Tp __declval(long);
    template<> const std::ranges::__cust_swap::_Swap &__declval<const std::ranges::__cust_swap::_Swap &>(long);
    template<> const char *const &__declval<const char *const &>(long);
    template<> char *const &__declval<char *const &>(long);
    template<> const wchar_t *const &__declval<const wchar_t *const &>(long);
    template<> wchar_t *const &__declval<wchar_t *const &>(long);
    template<> const char8_t *const &__declval<const char8_t *const &>(long);
    template<> char8_t *const &__declval<char8_t *const &>(long);
    template<> const char16_t *const &__declval<const char16_t *const &>(long);
    template<> char16_t *const &__declval<char16_t *const &>(long);
    template<> const char32_t *const &__declval<const char32_t *const &>(long);
    template<> char32_t *const &__declval<char32_t *const &>(long);
    template<> const char *__declval<const char *>(long);
    template<> const char *const &(&__declval<const char *const &(&)()>(long))();
    template<> const char *&&__declval<const char *&&>(long);
    template<> const char *&__declval<const char *&>(long);
    template<> const char &(&__declval<const char &(&)()>(long))();
    template<> const char &__declval<const char &>(long);
    template<> char &__declval<char &>(long);
    template<> const char &&__declval<const char &&>(long);
    template<> const volatile std::contiguous_iterator_tag *__declval<const volatile std::contiguous_iterator_tag *>(long);
    template<> const char *const __declval<const char *const>(long);
    template<> bool __declval<bool>(long);
    template<> unsigned long __declval<unsigned long>(long);
    template<> unsigned long &__declval<unsigned long &>(long);
    template<> const unsigned long &__declval<const unsigned long &>(long);
    template<> const unsigned long __declval<const unsigned long>(long);
    template<> const unsigned long &(&__declval<const unsigned long &(&)()>(long))();
    template<> unsigned long &&__declval<unsigned long &&>(long);
    template<> const wchar_t *__declval<const wchar_t *>(long);
    template<> const wchar_t *const &(&__declval<const wchar_t *const &(&)()>(long))();
    template<> const wchar_t *&&__declval<const wchar_t *&&>(long);
    template<> const wchar_t *&__declval<const wchar_t *&>(long);
    template<> const wchar_t &(&__declval<const wchar_t &(&)()>(long))();
    template<> const wchar_t &__declval<const wchar_t &>(long);
    template<> wchar_t &__declval<wchar_t &>(long);
    template<> const wchar_t &&__declval<const wchar_t &&>(long);
    template<> const wchar_t *const __declval<const wchar_t *const>(long);
    template<> const char8_t *__declval<const char8_t *>(long);
    template<> const char8_t *const &(&__declval<const char8_t *const &(&)()>(long))();
    template<> const char8_t *&&__declval<const char8_t *&&>(long);
    template<> const char8_t *&__declval<const char8_t *&>(long);
    template<> const char8_t &(&__declval<const char8_t &(&)()>(long))();
    template<> const char8_t &__declval<const char8_t &>(long);
    template<> char8_t &__declval<char8_t &>(long);
    template<> const char8_t &&__declval<const char8_t &&>(long);
    template<> const char8_t *const __declval<const char8_t *const>(long);
    template<> const char16_t *__declval<const char16_t *>(long);
    template<> const char16_t *const &(&__declval<const char16_t *const &(&)()>(long))();
    template<> const char16_t *&&__declval<const char16_t *&&>(long);
    template<> const char16_t *&__declval<const char16_t *&>(long);
    template<> const char16_t &(&__declval<const char16_t &(&)()>(long))();
    template<> const char16_t &__declval<const char16_t &>(long);
    template<> char16_t &__declval<char16_t &>(long);
    template<> const char16_t &&__declval<const char16_t &&>(long);
    template<> const char16_t *const __declval<const char16_t *const>(long);
    template<> const char32_t *__declval<const char32_t *>(long);
    template<> const char32_t *const &(&__declval<const char32_t *const &(&)()>(long))();
    template<> const char32_t *&&__declval<const char32_t *&&>(long);
    template<> const char32_t *&__declval<const char32_t *&>(long);
    template<> const char32_t &(&__declval<const char32_t &(&)()>(long))();
    template<> const char32_t &__declval<const char32_t &>(long);
    template<> char32_t &__declval<char32_t &>(long);
    template<> const char32_t &&__declval<const char32_t &&>(long);
    template<> const char32_t *const __declval<const char32_t *const>(long);
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0));
    template <typename, unsigned int = 0> struct extent;
    template <typename> struct remove_all_extents;
    template <typename _Tp> struct __is_array_known_bounds : public integral_constant<bool, (extent<_Tp>::value > 0)> {
    };
    template <typename _Tp> struct __is_array_unknown_bounds : public __and_<is_array<_Tp>, __not_<extent<_Tp>>> {
    };
template<> struct __is_array_unknown_bounds<const char *> : public __and_<is_array<const char *>, __not_<extent<const char *>>> {
    };
template<> struct __is_array_unknown_bounds<char *> : public __and_<is_array<char *>, __not_<extent<char *>>> {
    };
template<> struct __is_array_unknown_bounds<char> : public __and_<is_array<char>, __not_<extent<char>>> {
    };
template<> struct __is_array_unknown_bounds<const wchar_t *> : public __and_<is_array<const wchar_t *>, __not_<extent<const wchar_t *>>> {
    };
template<> struct __is_array_unknown_bounds<wchar_t *> : public __and_<is_array<wchar_t *>, __not_<extent<wchar_t *>>> {
    };
template<> struct __is_array_unknown_bounds<wchar_t> : public __and_<is_array<wchar_t>, __not_<extent<wchar_t>>> {
    };
template<> struct __is_array_unknown_bounds<const char8_t *> : public __and_<is_array<const char8_t *>, __not_<extent<const char8_t *>>> {
    };
template<> struct __is_array_unknown_bounds<char8_t *> : public __and_<is_array<char8_t *>, __not_<extent<char8_t *>>> {
    };
template<> struct __is_array_unknown_bounds<char8_t> : public __and_<is_array<char8_t>, __not_<extent<char8_t>>> {
    };
template<> struct __is_array_unknown_bounds<const char16_t *> : public __and_<is_array<const char16_t *>, __not_<extent<const char16_t *>>> {
    };
template<> struct __is_array_unknown_bounds<char16_t *> : public __and_<is_array<char16_t *>, __not_<extent<char16_t *>>> {
    };
template<> struct __is_array_unknown_bounds<char16_t> : public __and_<is_array<char16_t>, __not_<extent<char16_t>>> {
    };
template<> struct __is_array_unknown_bounds<const char32_t *> : public __and_<is_array<const char32_t *>, __not_<extent<const char32_t *>>> {
    };
template<> struct __is_array_unknown_bounds<char32_t *> : public __and_<is_array<char32_t *>, __not_<extent<char32_t *>>> {
    };
template<> struct __is_array_unknown_bounds<char32_t> : public __and_<is_array<char32_t>, __not_<extent<char32_t>>> {
    };
template<> struct __is_array_unknown_bounds<unsigned long> : public __and_<is_array<unsigned long>, __not_<extent<unsigned long>>> {
    };
    struct __do_is_destructible_impl {
        template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())> static std::true_type __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_destructible_impl : public std::__do_is_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_destructible_safe;
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, false> : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_destructible : public __is_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_nt_destructible_impl {
        template <typename _Tp> static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_nt_destructible_impl : public std::__do_is_nt_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value> struct __is_nt_destructible_safe
template<> struct __is_nt_destructible_safe<const char *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<unsigned long, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const wchar_t *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const char8_t *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const char16_t *, false, true> : public std::true_type {
    }
template<> struct __is_nt_destructible_safe<const char32_t *, false, true> : public std::true_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, false> : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char *> : public __is_nt_destructible_safe<const char *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<unsigned long> : public __is_nt_destructible_safe<unsigned long>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const wchar_t *> : public __is_nt_destructible_safe<const wchar_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char8_t *> : public __is_nt_destructible_safe<const char8_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char16_t *> : public __is_nt_destructible_safe<const char16_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_destructible<const char32_t *> : public __is_nt_destructible_safe<const char32_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct __is_constructible_impl : public __bool_constant<__is_constructible(_Tp, _Args...)> {
    };
template<> struct __is_constructible_impl<const char *, <>> : public __bool_constant<__is_constructible(const char *)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *>> : public __bool_constant<__is_constructible(const char *, const char *)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *&>> : public __bool_constant<__is_constructible(const char *, const char *&)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *const &>> : public __bool_constant<__is_constructible(const char *, const char *const &)> {
    };
template<> struct __is_constructible_impl<const char *, <const char *const>> : public __bool_constant<__is_constructible(const char *, const char *const)> {
    };
template<> struct __is_constructible_impl<unsigned long, <unsigned long>> : public __bool_constant<__is_constructible(unsigned long, unsigned long)> {
    };
template<> struct __is_constructible_impl<unsigned long, <unsigned long &>> : public __bool_constant<__is_constructible(unsigned long, unsigned long &)> {
    };
template<> struct __is_constructible_impl<unsigned long, <const unsigned long &>> : public __bool_constant<__is_constructible(unsigned long, const unsigned long &)> {
    };
template<> struct __is_constructible_impl<unsigned long, <const unsigned long>> : public __bool_constant<__is_constructible(unsigned long, const unsigned long)> {
    };
template<> struct __is_constructible_impl<unsigned long, <>> : public __bool_constant<__is_constructible(unsigned long)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <>> : public __bool_constant<__is_constructible(const wchar_t *)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *&>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *&)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *const &>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *const &)> {
    };
template<> struct __is_constructible_impl<const wchar_t *, <const wchar_t *const>> : public __bool_constant<__is_constructible(const wchar_t *, const wchar_t *const)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <>> : public __bool_constant<__is_constructible(const char8_t *)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *&>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *&)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *const &>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *const &)> {
    };
template<> struct __is_constructible_impl<const char8_t *, <const char8_t *const>> : public __bool_constant<__is_constructible(const char8_t *, const char8_t *const)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <>> : public __bool_constant<__is_constructible(const char16_t *)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *&>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *&)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *const &>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *const &)> {
    };
template<> struct __is_constructible_impl<const char16_t *, <const char16_t *const>> : public __bool_constant<__is_constructible(const char16_t *, const char16_t *const)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <>> : public __bool_constant<__is_constructible(const char32_t *)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *&>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *&)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *const &>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *const &)> {
    };
template<> struct __is_constructible_impl<const char32_t *, <const char32_t *const>> : public __bool_constant<__is_constructible(const char32_t *, const char32_t *const)> {
    };
    template <typename _Tp, typename ..._Args> struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <>> : public __is_constructible_impl<const char *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *>> : public __is_constructible_impl<const char *, const char *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *&>> : public __is_constructible_impl<const char *, const char *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *const &>> : public __is_constructible_impl<const char *, const char *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char *, <const char *const>> : public __is_constructible_impl<const char *, const char *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <unsigned long>> : public __is_constructible_impl<unsigned long, unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <unsigned long &>> : public __is_constructible_impl<unsigned long, unsigned long &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <const unsigned long &>> : public __is_constructible_impl<unsigned long, const unsigned long &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <const unsigned long>> : public __is_constructible_impl<unsigned long, const unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<unsigned long, <>> : public __is_constructible_impl<unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <>> : public __is_constructible_impl<const wchar_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *>> : public __is_constructible_impl<const wchar_t *, const wchar_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *&>> : public __is_constructible_impl<const wchar_t *, const wchar_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *const &>> : public __is_constructible_impl<const wchar_t *, const wchar_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const wchar_t *, <const wchar_t *const>> : public __is_constructible_impl<const wchar_t *, const wchar_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <>> : public __is_constructible_impl<const char8_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *>> : public __is_constructible_impl<const char8_t *, const char8_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *&>> : public __is_constructible_impl<const char8_t *, const char8_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *const &>> : public __is_constructible_impl<const char8_t *, const char8_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char8_t *, <const char8_t *const>> : public __is_constructible_impl<const char8_t *, const char8_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <>> : public __is_constructible_impl<const char16_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *>> : public __is_constructible_impl<const char16_t *, const char16_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *&>> : public __is_constructible_impl<const char16_t *, const char16_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *const &>> : public __is_constructible_impl<const char16_t *, const char16_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char16_t *, <const char16_t *const>> : public __is_constructible_impl<const char16_t *, const char16_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <>> : public __is_constructible_impl<const char32_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *>> : public __is_constructible_impl<const char32_t *, const char32_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *&>> : public __is_constructible_impl<const char32_t *, const char32_t *&> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *const &>> : public __is_constructible_impl<const char32_t *, const char32_t *const &> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_constructible<const char32_t *, <const char32_t *const>> : public __is_constructible_impl<const char32_t *, const char32_t *const> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_default_constructible : public __is_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_constructible_impl;
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_copy_constructible : public __is_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_constructible_impl;
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, true> : public __is_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_move_constructible : public __is_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <bool, typename _Tp, typename ..._Args> struct __is_nt_constructible_impl : public std::false_type {
    };
template<> struct __is_nt_constructible_impl<true, const char *, <const char *const &>> : public __bool_constant<noexcept(static_cast<const char *>(std::declval<const char *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, char *, <char *const &>> : public __bool_constant<noexcept(static_cast<char *>(std::declval<char *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const wchar_t *, <const wchar_t *const &>> : public __bool_constant<noexcept(static_cast<const wchar_t *>(std::declval<const wchar_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, wchar_t *, <wchar_t *const &>> : public __bool_constant<noexcept(static_cast<wchar_t *>(std::declval<wchar_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const char8_t *, <const char8_t *const &>> : public __bool_constant<noexcept(static_cast<const char8_t *>(std::declval<const char8_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, char8_t *, <char8_t *const &>> : public __bool_constant<noexcept(static_cast<char8_t *>(std::declval<char8_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const char16_t *, <const char16_t *const &>> : public __bool_constant<noexcept(static_cast<const char16_t *>(std::declval<const char16_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, char16_t *, <char16_t *const &>> : public __bool_constant<noexcept(static_cast<char16_t *>(std::declval<char16_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const char32_t *, <const char32_t *const &>> : public __bool_constant<noexcept(static_cast<const char32_t *>(std::declval<const char32_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, char32_t *, <char32_t *const &>> : public __bool_constant<noexcept(static_cast<char32_t *>(std::declval<char32_t *const &>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const char *, <const char *&&>> : public __bool_constant<noexcept(static_cast<const char *>(std::declval<const char *&&>()))> {
    };
template<> struct __is_nt_constructible_impl<true, unsigned long, <unsigned long &&>> : public __bool_constant<noexcept(static_cast<unsigned long>(std::declval<unsigned long &&>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const wchar_t *, <const wchar_t *&&>> : public __bool_constant<noexcept(static_cast<const wchar_t *>(std::declval<const wchar_t *&&>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const char8_t *, <const char8_t *&&>> : public __bool_constant<noexcept(static_cast<const char8_t *>(std::declval<const char8_t *&&>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const char16_t *, <const char16_t *&&>> : public __bool_constant<noexcept(static_cast<const char16_t *>(std::declval<const char16_t *&&>()))> {
    };
template<> struct __is_nt_constructible_impl<true, const char32_t *, <const char32_t *&&>> : public __bool_constant<noexcept(static_cast<const char32_t *>(std::declval<const char32_t *&&>()))> {
    };
    template <typename _Tp, typename ..._Args> struct __is_nt_constructible_impl<true, _Tp, _Args...> : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))> {
    };
    template <typename _Tp, typename _Arg> struct __is_nt_constructible_impl<true, _Tp, _Arg> : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))> {
    };
    template <typename _Tp> struct __is_nt_constructible_impl<true, _Tp> : public __bool_constant<noexcept(_Tp())> {
    };
    template <typename _Tp, std::size_t _Num> struct __is_nt_constructible_impl<true, _Tp [_Num]> : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())> {
    };
    template <typename _Tp, typename ..._Args> using __is_nothrow_constructible_impl = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...), _Tp, _Args...>;
    template <typename _Tp, typename ..._Args> struct is_nothrow_constructible : public __is_nothrow_constructible_impl<_Tp, _Args...>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_default_constructible : public __is_nothrow_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_copy_constructible_impl
template<> struct __is_nothrow_copy_constructible_impl<const char *, true> : public __is_nothrow_constructible_impl<const char *, const char *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<char *, true> : public __is_nothrow_constructible_impl<char *, char *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<const wchar_t *, true> : public __is_nothrow_constructible_impl<const wchar_t *, const wchar_t *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<wchar_t *, true> : public __is_nothrow_constructible_impl<wchar_t *, wchar_t *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<const char8_t *, true> : public __is_nothrow_constructible_impl<const char8_t *, const char8_t *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<char8_t *, true> : public __is_nothrow_constructible_impl<char8_t *, char8_t *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<const char16_t *, true> : public __is_nothrow_constructible_impl<const char16_t *, const char16_t *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<char16_t *, true> : public __is_nothrow_constructible_impl<char16_t *, char16_t *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<const char32_t *, true> : public __is_nothrow_constructible_impl<const char32_t *, const char32_t *const &> {
    }
template<> struct __is_nothrow_copy_constructible_impl<char32_t *, true> : public __is_nothrow_constructible_impl<char32_t *, char32_t *const &> {
    };
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_constructible : public __is_nothrow_copy_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<const char *> : public __is_nothrow_copy_constructible_impl<const char *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<char *> : public __is_nothrow_copy_constructible_impl<char *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<const wchar_t *> : public __is_nothrow_copy_constructible_impl<const wchar_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<wchar_t *> : public __is_nothrow_copy_constructible_impl<wchar_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<const char8_t *> : public __is_nothrow_copy_constructible_impl<const char8_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<char8_t *> : public __is_nothrow_copy_constructible_impl<char8_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<const char16_t *> : public __is_nothrow_copy_constructible_impl<const char16_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<char16_t *> : public __is_nothrow_copy_constructible_impl<char16_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<const char32_t *> : public __is_nothrow_copy_constructible_impl<const char32_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_copy_constructible<char32_t *> : public __is_nothrow_copy_constructible_impl<char32_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_move_constructible_impl
template<> struct __is_nothrow_move_constructible_impl<const char *, true> : public __is_nothrow_constructible_impl<const char *, const char *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<unsigned long, true> : public __is_nothrow_constructible_impl<unsigned long, unsigned long &&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const wchar_t *, true> : public __is_nothrow_constructible_impl<const wchar_t *, const wchar_t *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const char8_t *, true> : public __is_nothrow_constructible_impl<const char8_t *, const char8_t *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const char16_t *, true> : public __is_nothrow_constructible_impl<const char16_t *, const char16_t *&&> {
    }
template<> struct __is_nothrow_move_constructible_impl<const char32_t *, true> : public __is_nothrow_constructible_impl<const char32_t *, const char32_t *&&> {
    };
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, true> : public __is_nothrow_constructible_impl<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_constructible : public __is_nothrow_move_constructible_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char *> : public __is_nothrow_move_constructible_impl<const char *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<unsigned long> : public __is_nothrow_move_constructible_impl<unsigned long>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const wchar_t *> : public __is_nothrow_move_constructible_impl<const wchar_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char8_t *> : public __is_nothrow_move_constructible_impl<const char8_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char16_t *> : public __is_nothrow_move_constructible_impl<const char16_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_constructible<const char32_t *> : public __is_nothrow_move_constructible_impl<const char32_t *>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_assignable : public __bool_constant<__is_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_assignable_impl
template<> struct __is_copy_assignable_impl<char, true> : public __bool_constant<__is_assignable(char &, const char &)> {
    }
template<> struct __is_copy_assignable_impl<wchar_t, true> : public __bool_constant<__is_assignable(wchar_t &, const wchar_t &)> {
    }
template<> struct __is_copy_assignable_impl<char8_t, true> : public __bool_constant<__is_assignable(char8_t &, const char8_t &)> {
    }
template<> struct __is_copy_assignable_impl<char16_t, true> : public __bool_constant<__is_assignable(char16_t &, const char16_t &)> {
    }
template<> struct __is_copy_assignable_impl<char32_t, true> : public __bool_constant<__is_assignable(char32_t &, const char32_t &)> {
    };
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_copy_assignable : public __is_copy_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<char> : public __is_copy_assignable_impl<char>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<wchar_t> : public __is_copy_assignable_impl<wchar_t>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<wchar_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<char8_t> : public __is_copy_assignable_impl<char8_t>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char8_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<char16_t> : public __is_copy_assignable_impl<char16_t>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char16_t>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_copy_assignable<char32_t> : public __is_copy_assignable_impl<char32_t>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<char32_t>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_assignable_impl;
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, true> : public __bool_constant<__is_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_move_assignable : public __is_move_assignable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct __is_nt_assignable_impl : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())> {
    };
template<> struct __is_nt_assignable_impl<const char *&, const char *&&> : public integral_constant<bool, noexcept(declval<const char *&>() = declval<const char *&&>())> {
    };
template<> struct __is_nt_assignable_impl<unsigned long &, unsigned long &&> : public integral_constant<bool, noexcept(declval<unsigned long &>() = declval<unsigned long &&>())> {
    };
template<> struct __is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&> : public integral_constant<bool, noexcept(declval<const wchar_t *&>() = declval<const wchar_t *&&>())> {
    };
template<> struct __is_nt_assignable_impl<const char8_t *&, const char8_t *&&> : public integral_constant<bool, noexcept(declval<const char8_t *&>() = declval<const char8_t *&&>())> {
    };
template<> struct __is_nt_assignable_impl<const char16_t *&, const char16_t *&&> : public integral_constant<bool, noexcept(declval<const char16_t *&>() = declval<const char16_t *&&>())> {
    };
template<> struct __is_nt_assignable_impl<const char32_t *&, const char32_t *&&> : public integral_constant<bool, noexcept(declval<const char32_t *&>() = declval<const char32_t *&&>())> {
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_assignable_impl : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>, __is_nt_assignable_impl<_Tp, _Up>> {
    };
template<> struct __is_nothrow_assignable_impl<const char *&, const char *&&> : public __and_<__bool_constant<__is_assignable(const char *&, const char *&&)>, __is_nt_assignable_impl<const char *&, const char *&&>> {
    };
template<> struct __is_nothrow_assignable_impl<unsigned long &, unsigned long &&> : public __and_<__bool_constant<__is_assignable(unsigned long &, unsigned long &&)>, __is_nt_assignable_impl<unsigned long &, unsigned long &&>> {
    };
template<> struct __is_nothrow_assignable_impl<const wchar_t *&, const wchar_t *&&> : public __and_<__bool_constant<__is_assignable(const wchar_t *&, const wchar_t *&&)>, __is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&>> {
    };
template<> struct __is_nothrow_assignable_impl<const char8_t *&, const char8_t *&&> : public __and_<__bool_constant<__is_assignable(const char8_t *&, const char8_t *&&)>, __is_nt_assignable_impl<const char8_t *&, const char8_t *&&>> {
    };
template<> struct __is_nothrow_assignable_impl<const char16_t *&, const char16_t *&&> : public __and_<__bool_constant<__is_assignable(const char16_t *&, const char16_t *&&)>, __is_nt_assignable_impl<const char16_t *&, const char16_t *&&>> {
    };
template<> struct __is_nothrow_assignable_impl<const char32_t *&, const char32_t *&&> : public __and_<__bool_constant<__is_assignable(const char32_t *&, const char32_t *&&)>, __is_nt_assignable_impl<const char32_t *&, const char32_t *&&>> {
    };
    template <typename _Tp, typename _Up> struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_copy_assignable_impl;
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_move_assignable_impl
template<> struct __is_nt_move_assignable_impl<const char *, true> : public __is_nothrow_assignable_impl<const char *&, const char *&&> {
    }
template<> struct __is_nt_move_assignable_impl<unsigned long, true> : public __is_nothrow_assignable_impl<unsigned long &, unsigned long &&> {
    }
template<> struct __is_nt_move_assignable_impl<const wchar_t *, true> : public __is_nothrow_assignable_impl<const wchar_t *&, const wchar_t *&&> {
    }
template<> struct __is_nt_move_assignable_impl<const char8_t *, true> : public __is_nothrow_assignable_impl<const char8_t *&, const char8_t *&&> {
    }
template<> struct __is_nt_move_assignable_impl<const char16_t *, true> : public __is_nothrow_assignable_impl<const char16_t *&, const char16_t *&&> {
    }
template<> struct __is_nt_move_assignable_impl<const char32_t *, true> : public __is_nothrow_assignable_impl<const char32_t *&, const char32_t *&&> {
    };
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, true> : public __is_nothrow_assignable_impl<_Tp &, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char *> : public __is_nt_move_assignable_impl<const char *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<unsigned long> : public __is_nt_move_assignable_impl<unsigned long> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<unsigned long>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const wchar_t *> : public __is_nt_move_assignable_impl<const wchar_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const wchar_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char8_t *> : public __is_nt_move_assignable_impl<const char8_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char8_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char16_t *> : public __is_nt_move_assignable_impl<const char16_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char16_t *>{}), "template argument must be a complete class or an unbounded array");
    };
template<> struct is_nothrow_move_assignable<const char32_t *> : public __is_nt_move_assignable_impl<const char32_t *> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<const char32_t *>{}), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename ..._Args> struct is_trivially_constructible : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_default_constructible : public __bool_constant<__is_trivially_constructible(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    struct __do_is_implicitly_default_constructible_impl {
        template <typename _Tp> static void __helper(const _Tp &);
        template <typename _Tp> static std::true_type __test(const _Tp &, decltype(__helper<const _Tp &>({})) * = 0);
        static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_impl : public std::__do_is_implicitly_default_constructible_impl {
        typedef decltype(__test(declval<_Tp>())) type;
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_implicitly_default_constructible : public __and_<__is_constructible_impl<_Tp>, __is_implicitly_default_constructible_safe<_Tp>> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_constructible_impl;
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, true> : public __and_<__is_copy_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp &)>> {
    };
    template <typename _Tp> struct is_trivially_copy_constructible : public __is_trivially_copy_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_constructible_impl;
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, true> : public __and_<__is_move_constructible_impl<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, _Tp &&)>> {
    };
    template <typename _Tp> struct is_trivially_move_constructible : public __is_trivially_move_constructible_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, typename _Up> struct is_trivially_assignable : public __bool_constant<__is_trivially_assignable(_Tp, _Up)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_assignable_impl;
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_trivially_copy_assignable : public __is_trivially_copy_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_assignable_impl;
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_trivially_move_assignable : public __is_trivially_move_assignable_impl<_Tp> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_trivially_destructible : public __and_<__is_destructible_safe<_Tp>, __bool_constant<__has_trivial_destructor(_Tp)>> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename> struct rank : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, std::size_t _Size> struct rank<_Tp [_Size]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename _Tp> struct rank<_Tp []> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename, unsigned int _Uint = 0> struct extent : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, unsigned int _Uint, std::size_t _Size> struct extent<_Tp [_Size], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, unsigned int _Uint> struct extent<_Tp [], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, typename _Up> struct is_same : public integral_constant<bool, __is_same(_Tp, _Up)> {
    };
template<> struct is_same<list_start, list_start> : public integral_constant<bool, __is_same(list_start, list_start)> {
    };
template<> struct is_same<list_start, list_end> : public integral_constant<bool, __is_same(list_start, list_end)> {
    };
template<> struct is_same<plus, list_end> : public integral_constant<bool, __is_same(plus, list_end)> {
    };
template<> struct is_same<whitespace, list_end> : public integral_constant<bool, __is_same(whitespace, list_end)> {
    };
template<> struct is_same<integer<3>, list_end> : public integral_constant<bool, __is_same(integer<3>, list_end)> {
    };
template<> struct is_same<mul, list_end> : public integral_constant<bool, __is_same(mul, list_end)> {
    };
template<> struct is_same<integer<2>, list_end> : public integral_constant<bool, __is_same(integer<2>, list_end)> {
    };
template<> struct is_same<list_end, list_end> : public integral_constant<bool, __is_same(list_end, list_end)> {
    };
template<> struct is_same<plus, list_start> : public integral_constant<bool, __is_same(plus, list_start)> {
    };
template<> struct is_same<plus, whitespace> : public integral_constant<bool, __is_same(plus, whitespace)> {
    };
template<> struct is_same<whitespace, list_start> : public integral_constant<bool, __is_same(whitespace, list_start)> {
    };
template<> struct is_same<whitespace, whitespace> : public integral_constant<bool, __is_same(whitespace, whitespace)> {
    };
template<> struct is_same<integer<3>, list_start> : public integral_constant<bool, __is_same(integer<3>, list_start)> {
    };
template<> struct is_same<mul, list_start> : public integral_constant<bool, __is_same(mul, list_start)> {
    };
template<> struct is_same<mul, whitespace> : public integral_constant<bool, __is_same(mul, whitespace)> {
    };
template<> struct is_same<integer<2>, list_start> : public integral_constant<bool, __is_same(integer<2>, list_start)> {
    };
template<> struct is_same<list_end, list_start> : public integral_constant<bool, __is_same(list_end, list_start)> {
    };
template<> struct is_same<plus, plus> : public integral_constant<bool, __is_same(plus, plus)> {
    };
template<> struct is_same<mul, plus> : public integral_constant<bool, __is_same(mul, plus)> {
    };
template<> struct is_same<mul, minus> : public integral_constant<bool, __is_same(mul, minus)> {
    };
template<> struct is_same<mul, mul> : public integral_constant<bool, __is_same(mul, mul)> {
    };
    template <typename _Base, typename _Derived> struct is_base_of : public integral_constant<bool, __is_base_of(_Base, _Derived)> {
    };
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_convertible_helper {
        typedef typename is_void<_To>::type type;
    };
template<> class __is_convertible_helper<const char *, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *, const char *>(...);
    public:
        typedef decltype(__test<const char *, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const char *const &, const char *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *const &>(const char *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const &, const char *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const &, const char *const &>(...);
    public:
        typedef decltype(__test<const char *const &, const char *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char &, const char &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char &>(const char &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char &, const char &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char &, const char &>(...);
    public:
        typedef decltype(__test<const char &, const char &>(0)) type;
    };
template<> class __is_convertible_helper<char &, const char &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char &>(const char &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char &, const char &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char &, const char &>(...);
    public:
        typedef decltype(__test<char &, const char &>(0)) type;
    };
template<> class __is_convertible_helper<const char &&, const char &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char &>(const char &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char &&, const char &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char &&, const char &>(...);
    public:
        typedef decltype(__test<const char &&, const char &>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::input_iterator_tag *>(const volatile std::input_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::forward_iterator_tag *>(const volatile std::forward_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const char *&, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *&, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *&, const char *>(...);
    public:
        typedef decltype(__test<const char *&, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const char *const &, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const &, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const &, const char *>(...);
    public:
        typedef decltype(__test<const char *const &, const char *>(0)) type;
    };
template<> class __is_convertible_helper<const char *const, const char *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char *>(const char *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char *const, const char *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char *const, const char *>(...);
    public:
        typedef decltype(__test<const char *const, const char *>(0)) type;
    };
template<> class __is_convertible_helper<bool, bool, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<bool>(bool) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<bool, bool, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<bool, bool>(...);
    public:
        typedef decltype(__test<bool, bool>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::bidirectional_iterator_tag *>(const volatile std::bidirectional_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::random_access_iterator_tag *>(const volatile std::random_access_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const volatile std::contiguous_iterator_tag *>(const volatile std::contiguous_iterator_tag *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *>(...);
    public:
        typedef decltype(__test<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *>(0)) type;
    };
template<> class __is_convertible_helper<unsigned long, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<unsigned long, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<unsigned long, unsigned long>(...);
    public:
        typedef decltype(__test<unsigned long, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<unsigned long &, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<unsigned long &, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<unsigned long &, unsigned long>(...);
    public:
        typedef decltype(__test<unsigned long &, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned long &, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const unsigned long &, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned long &, unsigned long>(...);
    public:
        typedef decltype(__test<const unsigned long &, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned long, unsigned long, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<unsigned long>(unsigned long) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const unsigned long, unsigned long, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned long, unsigned long>(...);
    public:
        typedef decltype(__test<const unsigned long, unsigned long>(0)) type;
    };
template<> class __is_convertible_helper<const unsigned long &, const unsigned long &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const unsigned long &>(const unsigned long &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const unsigned long &, const unsigned long &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const unsigned long &, const unsigned long &>(...);
    public:
        typedef decltype(__test<const unsigned long &, const unsigned long &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const &, const wchar_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *const &>(const wchar_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const &, const wchar_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const &, const wchar_t *const &>(...);
    public:
        typedef decltype(__test<const wchar_t *const &, const wchar_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t &, const wchar_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t &>(const wchar_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t &, const wchar_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t &, const wchar_t &>(...);
    public:
        typedef decltype(__test<const wchar_t &, const wchar_t &>(0)) type;
    };
template<> class __is_convertible_helper<wchar_t &, const wchar_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t &>(const wchar_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<wchar_t &, const wchar_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<wchar_t &, const wchar_t &>(...);
    public:
        typedef decltype(__test<wchar_t &, const wchar_t &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t &&, const wchar_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t &>(const wchar_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t &&, const wchar_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t &&, const wchar_t &>(...);
    public:
        typedef decltype(__test<const wchar_t &&, const wchar_t &>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *&, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *&, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *&, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *&, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const &, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const &, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const &, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *const &, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const wchar_t *const, const wchar_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const wchar_t *>(const wchar_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const wchar_t *const, const wchar_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const wchar_t *const, const wchar_t *>(...);
    public:
        typedef decltype(__test<const wchar_t *const, const wchar_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const &, const char8_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *const &>(const char8_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *const &, const char8_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const &, const char8_t *const &>(...);
    public:
        typedef decltype(__test<const char8_t *const &, const char8_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t &, const char8_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t &>(const char8_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t &, const char8_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t &, const char8_t &>(...);
    public:
        typedef decltype(__test<const char8_t &, const char8_t &>(0)) type;
    };
template<> class __is_convertible_helper<char8_t &, const char8_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t &>(const char8_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char8_t &, const char8_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char8_t &, const char8_t &>(...);
    public:
        typedef decltype(__test<char8_t &, const char8_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t &&, const char8_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t &>(const char8_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t &&, const char8_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t &&, const char8_t &>(...);
    public:
        typedef decltype(__test<const char8_t &&, const char8_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *&, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *&, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *&, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *&, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const &, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *const &, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const &, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *const &, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char8_t *const, const char8_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char8_t *>(const char8_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char8_t *const, const char8_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char8_t *const, const char8_t *>(...);
    public:
        typedef decltype(__test<const char8_t *const, const char8_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const &, const char16_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *const &>(const char16_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const &, const char16_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const &, const char16_t *const &>(...);
    public:
        typedef decltype(__test<const char16_t *const &, const char16_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t &, const char16_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t &>(const char16_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t &, const char16_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t &, const char16_t &>(...);
    public:
        typedef decltype(__test<const char16_t &, const char16_t &>(0)) type;
    };
template<> class __is_convertible_helper<char16_t &, const char16_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t &>(const char16_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char16_t &, const char16_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char16_t &, const char16_t &>(...);
    public:
        typedef decltype(__test<char16_t &, const char16_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t &&, const char16_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t &>(const char16_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t &&, const char16_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t &&, const char16_t &>(...);
    public:
        typedef decltype(__test<const char16_t &&, const char16_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *&, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *&, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *&, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *&, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const &, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const &, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const &, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *const &, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char16_t *const, const char16_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char16_t *>(const char16_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char16_t *const, const char16_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char16_t *const, const char16_t *>(...);
    public:
        typedef decltype(__test<const char16_t *const, const char16_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const &, const char32_t *const &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *const &>(const char32_t *const &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const &, const char32_t *const &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const &, const char32_t *const &>(...);
    public:
        typedef decltype(__test<const char32_t *const &, const char32_t *const &>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t &, const char32_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t &>(const char32_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t &, const char32_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t &, const char32_t &>(...);
    public:
        typedef decltype(__test<const char32_t &, const char32_t &>(0)) type;
    };
template<> class __is_convertible_helper<char32_t &, const char32_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t &>(const char32_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<char32_t &, const char32_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<char32_t &, const char32_t &>(...);
    public:
        typedef decltype(__test<char32_t &, const char32_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t &&, const char32_t &, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t &>(const char32_t &) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t &&, const char32_t &, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t &&, const char32_t &>(...);
    public:
        typedef decltype(__test<const char32_t &&, const char32_t &>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *&, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *&, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *&, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *&, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const &, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const &, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const &, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *const &, const char32_t *>(0)) type;
    };
template<> class __is_convertible_helper<const char32_t *const, const char32_t *, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<const char32_t *>(const char32_t *) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<const char32_t *const, const char32_t *, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<const char32_t *const, const char32_t *>(...);
    public:
        typedef decltype(__test<const char32_t *const, const char32_t *>(0)) type;
    };
    template <typename _From, typename _To> class __is_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        typedef decltype(__test<_From, _To>(0)) type;
    };
    template <typename _From, typename _To> struct is_convertible : public __is_convertible_helper<_From, _To>::type {
    };
template<> struct is_convertible<const char *, const char *> : public __is_convertible_helper<const char *, const char *>::type {
    };
template<> struct is_convertible<const char *const &, const char *const &> : public __is_convertible_helper<const char *const &, const char *const &>::type {
    };
template<> struct is_convertible<const char &, const char &> : public __is_convertible_helper<const char &, const char &>::type {
    };
template<> struct is_convertible<char &, const char &> : public __is_convertible_helper<char &, const char &>::type {
    };
template<> struct is_convertible<const char &&, const char &> : public __is_convertible_helper<const char &&, const char &>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::input_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile input_iterator_tag *>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::forward_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile forward_iterator_tag *>::type {
    };
template<> struct is_convertible<const char *&, const char *> : public __is_convertible_helper<const char *&, const char *>::type {
    };
template<> struct is_convertible<const char *const &, const char *> : public __is_convertible_helper<const char *const &, const char *>::type {
    };
template<> struct is_convertible<const char *const, const char *> : public __is_convertible_helper<const char *const, const char *>::type {
    };
template<> struct is_convertible<bool, bool> : public __is_convertible_helper<bool, bool>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::bidirectional_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile bidirectional_iterator_tag *>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::random_access_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile random_access_iterator_tag *>::type {
    };
template<> struct is_convertible<const volatile std::contiguous_iterator_tag *, const volatile std::contiguous_iterator_tag *> : public __is_convertible_helper<const volatile contiguous_iterator_tag *, const volatile contiguous_iterator_tag *>::type {
    };
template<> struct is_convertible<unsigned long, unsigned long> : public __is_convertible_helper<unsigned long, unsigned long>::type {
    };
template<> struct is_convertible<unsigned long &, unsigned long> : public __is_convertible_helper<unsigned long &, unsigned long>::type {
    };
template<> struct is_convertible<const unsigned long &, unsigned long> : public __is_convertible_helper<const unsigned long &, unsigned long>::type {
    };
template<> struct is_convertible<const unsigned long, unsigned long> : public __is_convertible_helper<const unsigned long, unsigned long>::type {
    };
template<> struct is_convertible<const unsigned long &, const unsigned long &> : public __is_convertible_helper<const unsigned long &, const unsigned long &>::type {
    };
template<> struct is_convertible<const wchar_t *, const wchar_t *> : public __is_convertible_helper<const wchar_t *, const wchar_t *>::type {
    };
template<> struct is_convertible<const wchar_t *const &, const wchar_t *const &> : public __is_convertible_helper<const wchar_t *const &, const wchar_t *const &>::type {
    };
template<> struct is_convertible<const wchar_t &, const wchar_t &> : public __is_convertible_helper<const wchar_t &, const wchar_t &>::type {
    };
template<> struct is_convertible<wchar_t &, const wchar_t &> : public __is_convertible_helper<wchar_t &, const wchar_t &>::type {
    };
template<> struct is_convertible<const wchar_t &&, const wchar_t &> : public __is_convertible_helper<const wchar_t &&, const wchar_t &>::type {
    };
template<> struct is_convertible<const wchar_t *&, const wchar_t *> : public __is_convertible_helper<const wchar_t *&, const wchar_t *>::type {
    };
template<> struct is_convertible<const wchar_t *const &, const wchar_t *> : public __is_convertible_helper<const wchar_t *const &, const wchar_t *>::type {
    };
template<> struct is_convertible<const wchar_t *const, const wchar_t *> : public __is_convertible_helper<const wchar_t *const, const wchar_t *>::type {
    };
template<> struct is_convertible<const char8_t *, const char8_t *> : public __is_convertible_helper<const char8_t *, const char8_t *>::type {
    };
template<> struct is_convertible<const char8_t *const &, const char8_t *const &> : public __is_convertible_helper<const char8_t *const &, const char8_t *const &>::type {
    };
template<> struct is_convertible<const char8_t &, const char8_t &> : public __is_convertible_helper<const char8_t &, const char8_t &>::type {
    };
template<> struct is_convertible<char8_t &, const char8_t &> : public __is_convertible_helper<char8_t &, const char8_t &>::type {
    };
template<> struct is_convertible<const char8_t &&, const char8_t &> : public __is_convertible_helper<const char8_t &&, const char8_t &>::type {
    };
template<> struct is_convertible<const char8_t *&, const char8_t *> : public __is_convertible_helper<const char8_t *&, const char8_t *>::type {
    };
template<> struct is_convertible<const char8_t *const &, const char8_t *> : public __is_convertible_helper<const char8_t *const &, const char8_t *>::type {
    };
template<> struct is_convertible<const char8_t *const, const char8_t *> : public __is_convertible_helper<const char8_t *const, const char8_t *>::type {
    };
template<> struct is_convertible<const char16_t *, const char16_t *> : public __is_convertible_helper<const char16_t *, const char16_t *>::type {
    };
template<> struct is_convertible<const char16_t *const &, const char16_t *const &> : public __is_convertible_helper<const char16_t *const &, const char16_t *const &>::type {
    };
template<> struct is_convertible<const char16_t &, const char16_t &> : public __is_convertible_helper<const char16_t &, const char16_t &>::type {
    };
template<> struct is_convertible<char16_t &, const char16_t &> : public __is_convertible_helper<char16_t &, const char16_t &>::type {
    };
template<> struct is_convertible<const char16_t &&, const char16_t &> : public __is_convertible_helper<const char16_t &&, const char16_t &>::type {
    };
template<> struct is_convertible<const char16_t *&, const char16_t *> : public __is_convertible_helper<const char16_t *&, const char16_t *>::type {
    };
template<> struct is_convertible<const char16_t *const &, const char16_t *> : public __is_convertible_helper<const char16_t *const &, const char16_t *>::type {
    };
template<> struct is_convertible<const char16_t *const, const char16_t *> : public __is_convertible_helper<const char16_t *const, const char16_t *>::type {
    };
template<> struct is_convertible<const char32_t *, const char32_t *> : public __is_convertible_helper<const char32_t *, const char32_t *>::type {
    };
template<> struct is_convertible<const char32_t *const &, const char32_t *const &> : public __is_convertible_helper<const char32_t *const &, const char32_t *const &>::type {
    };
template<> struct is_convertible<const char32_t &, const char32_t &> : public __is_convertible_helper<const char32_t &, const char32_t &>::type {
    };
template<> struct is_convertible<char32_t &, const char32_t &> : public __is_convertible_helper<char32_t &, const char32_t &>::type {
    };
template<> struct is_convertible<const char32_t &&, const char32_t &> : public __is_convertible_helper<const char32_t &&, const char32_t &>::type {
    };
template<> struct is_convertible<const char32_t *&, const char32_t *> : public __is_convertible_helper<const char32_t *&, const char32_t *>::type {
    };
template<> struct is_convertible<const char32_t *const &, const char32_t *> : public __is_convertible_helper<const char32_t *const &, const char32_t *>::type {
    };
template<> struct is_convertible<const char32_t *const, const char32_t *> : public __is_convertible_helper<const char32_t *const, const char32_t *>::type {
    };
    template <typename _ToElementType, typename _FromElementType> using __is_array_convertible = is_convertible<_FromElementType (*)[], _ToElementType (*)[]>;
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value> struct __is_nt_convertible_helper : is_void<_To> {
    };
    template <typename _From, typename _To> class __is_nt_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1> static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))> __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        using type = decltype(__test<_From, _To>(0));
    };
    template <typename _From, typename _To> struct __is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {
    };
    template <typename _From, typename _To> struct is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {
    };
    template <typename _From, typename _To> constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_From, _To>::value;
    template <typename _Tp> struct remove_const {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_const<const _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile<volatile _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_cv {
        using type = _Tp;
    };
template<> struct remove_cv<wchar_t> {
        using type = wchar_t;
    };
template<> struct remove_cv<unsigned int> {
        using type = unsigned int;
    };
template<> struct remove_cv<char8_t> {
        using type = char8_t;
    };
template<> struct remove_cv<unsigned char> {
        using type = unsigned char;
    };
template<> struct remove_cv<char16_t> {
        using type = char16_t;
    };
template<> struct remove_cv<unsigned short> {
        using type = unsigned short;
    };
template<> struct remove_cv<char32_t> {
        using type = char32_t;
    };
template<> struct remove_cv<void> {
        using type = void;
    };
template<> struct remove_cv<const char *> {
        using type = const char *;
    };
template<> struct remove_cv<char *> {
        using type = char *;
    };
template<> struct remove_cv<const char> {
        using type = char;
    };
template<> struct remove_cv<char> {
        using type = char;
    };
template<> struct remove_cv<unsigned long> {
        using type = unsigned long;
    };
template<> struct remove_cv<const wchar_t *> {
        using type = const wchar_t *;
    };
template<> struct remove_cv<wchar_t *> {
        using type = wchar_t *;
    };
template<> struct remove_cv<const wchar_t> {
        using type = wchar_t;
    };
template<> struct remove_cv<const char8_t *> {
        using type = const char8_t *;
    };
template<> struct remove_cv<char8_t *> {
        using type = char8_t *;
    };
template<> struct remove_cv<const char8_t> {
        using type = char8_t;
    };
template<> struct remove_cv<const char16_t *> {
        using type = const char16_t *;
    };
template<> struct remove_cv<char16_t *> {
        using type = char16_t *;
    };
template<> struct remove_cv<const char16_t> {
        using type = char16_t;
    };
template<> struct remove_cv<const char32_t *> {
        using type = const char32_t *;
    };
template<> struct remove_cv<char32_t *> {
        using type = char32_t *;
    };
template<> struct remove_cv<const char32_t> {
        using type = char32_t;
    };
template<> struct remove_cv<const char *const &> {
        using type = const char *const &;
    };
template<> struct remove_cv<long> {
        using type = long;
    };
template<> struct remove_cv<const char &> {
        using type = const char &;
    };
template<> struct remove_cv<char &> {
        using type = char &;
    };
template<> struct remove_cv<const char &&> {
        using type = const char &&;
    };
template<> struct remove_cv<const volatile std::contiguous_iterator_tag *> {
        using type = const volatile std::contiguous_iterator_tag *;
    };
template<> struct remove_cv<const char *&> {
        using type = const char *&;
    };
template<> struct remove_cv<const char *const> {
        using type = const char *;
    };
template<> struct remove_cv<bool> {
        using type = bool;
    };
template<> struct remove_cv<unsigned long &> {
        using type = unsigned long &;
    };
template<> struct remove_cv<const unsigned long &> {
        using type = const unsigned long &;
    };
template<> struct remove_cv<const unsigned long> {
        using type = unsigned long;
    };
template<> struct remove_cv<const wchar_t *const &> {
        using type = const wchar_t *const &;
    };
template<> struct remove_cv<const wchar_t &> {
        using type = const wchar_t &;
    };
template<> struct remove_cv<wchar_t &> {
        using type = wchar_t &;
    };
template<> struct remove_cv<const wchar_t &&> {
        using type = const wchar_t &&;
    };
template<> struct remove_cv<const wchar_t *&> {
        using type = const wchar_t *&;
    };
template<> struct remove_cv<const wchar_t *const> {
        using type = const wchar_t *;
    };
template<> struct remove_cv<const char8_t *const &> {
        using type = const char8_t *const &;
    };
template<> struct remove_cv<const char8_t &> {
        using type = const char8_t &;
    };
template<> struct remove_cv<char8_t &> {
        using type = char8_t &;
    };
template<> struct remove_cv<const char8_t &&> {
        using type = const char8_t &&;
    };
template<> struct remove_cv<const char8_t *&> {
        using type = const char8_t *&;
    };
template<> struct remove_cv<const char8_t *const> {
        using type = const char8_t *;
    };
template<> struct remove_cv<const char16_t *const &> {
        using type = const char16_t *const &;
    };
template<> struct remove_cv<const char16_t &> {
        using type = const char16_t &;
    };
template<> struct remove_cv<char16_t &> {
        using type = char16_t &;
    };
template<> struct remove_cv<const char16_t &&> {
        using type = const char16_t &&;
    };
template<> struct remove_cv<const char16_t *&> {
        using type = const char16_t *&;
    };
template<> struct remove_cv<const char16_t *const> {
        using type = const char16_t *;
    };
template<> struct remove_cv<const char32_t *const &> {
        using type = const char32_t *const &;
    };
template<> struct remove_cv<const char32_t &> {
        using type = const char32_t &;
    };
template<> struct remove_cv<char32_t &> {
        using type = char32_t &;
    };
template<> struct remove_cv<const char32_t &&> {
        using type = const char32_t &&;
    };
template<> struct remove_cv<const char32_t *&> {
        using type = const char32_t *&;
    };
template<> struct remove_cv<const char32_t *const> {
        using type = const char32_t *;
    };
    template <typename _Tp> struct remove_cv<const _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct remove_cv<const volatile _Tp> {
        using type = _Tp;
    };
    template <typename _Tp> struct add_const {
        typedef const _Tp type;
    };
    template <typename _Tp> struct add_volatile {
        typedef volatile _Tp type;
    };
    template <typename _Tp> struct add_cv {
        typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
    };
    template <typename _Tp> using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;
    template <typename _Tp> struct remove_reference {
        typedef _Tp type;
    };
template<> struct remove_reference<const char *&> {
        typedef const char *type;
    };
template<> struct remove_reference<const char *> {
        typedef const char *type;
    };
template<> struct remove_reference<const char &> {
        typedef const char type;
    };
template<> struct remove_reference<const char *const &> {
        typedef const char *const type;
    };
template<> struct remove_reference<const char *const> {
        typedef const char *const type;
    };
template<> struct remove_reference<unsigned long &> {
        typedef unsigned long type;
    };
template<> struct remove_reference<unsigned long> {
        typedef unsigned long type;
    };
template<> struct remove_reference<const unsigned long &> {
        typedef const unsigned long type;
    };
template<> struct remove_reference<const unsigned long> {
        typedef const unsigned long type;
    };
template<> struct remove_reference<const wchar_t *&> {
        typedef const wchar_t *type;
    };
template<> struct remove_reference<const wchar_t *> {
        typedef const wchar_t *type;
    };
template<> struct remove_reference<const wchar_t &> {
        typedef const wchar_t type;
    };
template<> struct remove_reference<const wchar_t *const &> {
        typedef const wchar_t *const type;
    };
template<> struct remove_reference<const wchar_t *const> {
        typedef const wchar_t *const type;
    };
template<> struct remove_reference<const char8_t *&> {
        typedef const char8_t *type;
    };
template<> struct remove_reference<const char8_t *> {
        typedef const char8_t *type;
    };
template<> struct remove_reference<const char8_t &> {
        typedef const char8_t type;
    };
template<> struct remove_reference<const char8_t *const &> {
        typedef const char8_t *const type;
    };
template<> struct remove_reference<const char8_t *const> {
        typedef const char8_t *const type;
    };
template<> struct remove_reference<const char16_t *&> {
        typedef const char16_t *type;
    };
template<> struct remove_reference<const char16_t *> {
        typedef const char16_t *type;
    };
template<> struct remove_reference<const char16_t &> {
        typedef const char16_t type;
    };
template<> struct remove_reference<const char16_t *const &> {
        typedef const char16_t *const type;
    };
template<> struct remove_reference<const char16_t *const> {
        typedef const char16_t *const type;
    };
template<> struct remove_reference<const char32_t *&> {
        typedef const char32_t *type;
    };
template<> struct remove_reference<const char32_t *> {
        typedef const char32_t *type;
    };
template<> struct remove_reference<const char32_t &> {
        typedef const char32_t type;
    };
template<> struct remove_reference<const char32_t *const &> {
        typedef const char32_t *const type;
    };
template<> struct remove_reference<const char32_t *const> {
        typedef const char32_t *const type;
    };
    template <typename _Tp> struct remove_reference<_Tp &> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_reference<_Tp &&> {
        typedef _Tp type;
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_lvalue_reference_helper<_Tp, true> {
        typedef _Tp &type;
    };
    template <typename _Tp> struct add_lvalue_reference : public __add_lvalue_reference_helper<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_helper {
        typedef _Tp type;
    };
template<> struct __add_rvalue_reference_helper<const char *, true> {
        typedef const char *&&type;
    };
template<> struct __add_rvalue_reference_helper<const char *const &, true> {
        typedef const char *const &type;
    };
template<> struct __add_rvalue_reference_helper<const char &, true> {
        typedef const char &type;
    };
template<> struct __add_rvalue_reference_helper<char &, true> {
        typedef char &type;
    };
template<> struct __add_rvalue_reference_helper<const char &&, true> {
        typedef const char &&type;
    };
template<> struct __add_rvalue_reference_helper<const char *&, true> {
        typedef const char *&type;
    };
template<> struct __add_rvalue_reference_helper<const char *const, true> {
        typedef const char *const &&type;
    };
template<> struct __add_rvalue_reference_helper<bool, true> {
        typedef bool &&type;
    };
template<> struct __add_rvalue_reference_helper<unsigned long, true> {
        typedef unsigned long &&type;
    };
template<> struct __add_rvalue_reference_helper<unsigned long &, true> {
        typedef unsigned long &type;
    };
template<> struct __add_rvalue_reference_helper<const unsigned long &, true> {
        typedef const unsigned long &type;
    };
template<> struct __add_rvalue_reference_helper<const unsigned long, true> {
        typedef const unsigned long &&type;
    };
template<> struct __add_rvalue_reference_helper<const wchar_t *, true> {
        typedef const wchar_t *&&type;
    };
template<> struct __add_rvalue_reference_helper<const wchar_t *const &, true> {
        typedef const wchar_t *const &type;
    };
template<> struct __add_rvalue_reference_helper<const wchar_t &, true> {
        typedef const wchar_t &type;
    };
template<> struct __add_rvalue_reference_helper<wchar_t &, true> {
        typedef wchar_t &type;
    };
template<> struct __add_rvalue_reference_helper<const wchar_t &&, true> {
        typedef const wchar_t &&type;
    };
template<> struct __add_rvalue_reference_helper<const wchar_t *&, true> {
        typedef const wchar_t *&type;
    };
template<> struct __add_rvalue_reference_helper<const wchar_t *const, true> {
        typedef const wchar_t *const &&type;
    };
template<> struct __add_rvalue_reference_helper<const char8_t *, true> {
        typedef const char8_t *&&type;
    };
template<> struct __add_rvalue_reference_helper<const char8_t *const &, true> {
        typedef const char8_t *const &type;
    };
template<> struct __add_rvalue_reference_helper<const char8_t &, true> {
        typedef const char8_t &type;
    };
template<> struct __add_rvalue_reference_helper<char8_t &, true> {
        typedef char8_t &type;
    };
template<> struct __add_rvalue_reference_helper<const char8_t &&, true> {
        typedef const char8_t &&type;
    };
template<> struct __add_rvalue_reference_helper<const char8_t *&, true> {
        typedef const char8_t *&type;
    };
template<> struct __add_rvalue_reference_helper<const char8_t *const, true> {
        typedef const char8_t *const &&type;
    };
template<> struct __add_rvalue_reference_helper<const char16_t *, true> {
        typedef const char16_t *&&type;
    };
template<> struct __add_rvalue_reference_helper<const char16_t *const &, true> {
        typedef const char16_t *const &type;
    };
template<> struct __add_rvalue_reference_helper<const char16_t &, true> {
        typedef const char16_t &type;
    };
template<> struct __add_rvalue_reference_helper<char16_t &, true> {
        typedef char16_t &type;
    };
template<> struct __add_rvalue_reference_helper<const char16_t &&, true> {
        typedef const char16_t &&type;
    };
template<> struct __add_rvalue_reference_helper<const char16_t *&, true> {
        typedef const char16_t *&type;
    };
template<> struct __add_rvalue_reference_helper<const char16_t *const, true> {
        typedef const char16_t *const &&type;
    };
template<> struct __add_rvalue_reference_helper<const char32_t *, true> {
        typedef const char32_t *&&type;
    };
template<> struct __add_rvalue_reference_helper<const char32_t *const &, true> {
        typedef const char32_t *const &type;
    };
template<> struct __add_rvalue_reference_helper<const char32_t &, true> {
        typedef const char32_t &type;
    };
template<> struct __add_rvalue_reference_helper<char32_t &, true> {
        typedef char32_t &type;
    };
template<> struct __add_rvalue_reference_helper<const char32_t &&, true> {
        typedef const char32_t &&type;
    };
template<> struct __add_rvalue_reference_helper<const char32_t *&, true> {
        typedef const char32_t *&type;
    };
template<> struct __add_rvalue_reference_helper<const char32_t *const, true> {
        typedef const char32_t *const &&type;
    };
    template <typename _Tp> struct __add_rvalue_reference_helper<_Tp, true> {
        typedef _Tp &&type;
    };
    template <typename _Tp> struct add_rvalue_reference : public __add_rvalue_reference_helper<_Tp> {
    };
template<> struct add_rvalue_reference<const char *> : public __add_rvalue_reference_helper<const char *> {
    };
template<> struct add_rvalue_reference<const char *const &> : public __add_rvalue_reference_helper<const char *const &> {
    };
template<> struct add_rvalue_reference<const char &> : public __add_rvalue_reference_helper<const char &> {
    };
template<> struct add_rvalue_reference<char &> : public __add_rvalue_reference_helper<char &> {
    };
template<> struct add_rvalue_reference<const char &&> : public __add_rvalue_reference_helper<const char &&> {
    };
template<> struct add_rvalue_reference<const char *&> : public __add_rvalue_reference_helper<const char *&> {
    };
template<> struct add_rvalue_reference<const char *const> : public __add_rvalue_reference_helper<const char *const> {
    };
template<> struct add_rvalue_reference<bool> : public __add_rvalue_reference_helper<bool> {
    };
template<> struct add_rvalue_reference<unsigned long> : public __add_rvalue_reference_helper<unsigned long> {
    };
template<> struct add_rvalue_reference<unsigned long &> : public __add_rvalue_reference_helper<unsigned long &> {
    };
template<> struct add_rvalue_reference<const unsigned long &> : public __add_rvalue_reference_helper<const unsigned long &> {
    };
template<> struct add_rvalue_reference<const unsigned long> : public __add_rvalue_reference_helper<const unsigned long> {
    };
template<> struct add_rvalue_reference<const wchar_t *> : public __add_rvalue_reference_helper<const wchar_t *> {
    };
template<> struct add_rvalue_reference<const wchar_t *const &> : public __add_rvalue_reference_helper<const wchar_t *const &> {
    };
template<> struct add_rvalue_reference<const wchar_t &> : public __add_rvalue_reference_helper<const wchar_t &> {
    };
template<> struct add_rvalue_reference<wchar_t &> : public __add_rvalue_reference_helper<wchar_t &> {
    };
template<> struct add_rvalue_reference<const wchar_t &&> : public __add_rvalue_reference_helper<const wchar_t &&> {
    };
template<> struct add_rvalue_reference<const wchar_t *&> : public __add_rvalue_reference_helper<const wchar_t *&> {
    };
template<> struct add_rvalue_reference<const wchar_t *const> : public __add_rvalue_reference_helper<const wchar_t *const> {
    };
template<> struct add_rvalue_reference<const char8_t *> : public __add_rvalue_reference_helper<const char8_t *> {
    };
template<> struct add_rvalue_reference<const char8_t *const &> : public __add_rvalue_reference_helper<const char8_t *const &> {
    };
template<> struct add_rvalue_reference<const char8_t &> : public __add_rvalue_reference_helper<const char8_t &> {
    };
template<> struct add_rvalue_reference<char8_t &> : public __add_rvalue_reference_helper<char8_t &> {
    };
template<> struct add_rvalue_reference<const char8_t &&> : public __add_rvalue_reference_helper<const char8_t &&> {
    };
template<> struct add_rvalue_reference<const char8_t *&> : public __add_rvalue_reference_helper<const char8_t *&> {
    };
template<> struct add_rvalue_reference<const char8_t *const> : public __add_rvalue_reference_helper<const char8_t *const> {
    };
template<> struct add_rvalue_reference<const char16_t *> : public __add_rvalue_reference_helper<const char16_t *> {
    };
template<> struct add_rvalue_reference<const char16_t *const &> : public __add_rvalue_reference_helper<const char16_t *const &> {
    };
template<> struct add_rvalue_reference<const char16_t &> : public __add_rvalue_reference_helper<const char16_t &> {
    };
template<> struct add_rvalue_reference<char16_t &> : public __add_rvalue_reference_helper<char16_t &> {
    };
template<> struct add_rvalue_reference<const char16_t &&> : public __add_rvalue_reference_helper<const char16_t &&> {
    };
template<> struct add_rvalue_reference<const char16_t *&> : public __add_rvalue_reference_helper<const char16_t *&> {
    };
template<> struct add_rvalue_reference<const char16_t *const> : public __add_rvalue_reference_helper<const char16_t *const> {
    };
template<> struct add_rvalue_reference<const char32_t *> : public __add_rvalue_reference_helper<const char32_t *> {
    };
template<> struct add_rvalue_reference<const char32_t *const &> : public __add_rvalue_reference_helper<const char32_t *const &> {
    };
template<> struct add_rvalue_reference<const char32_t &> : public __add_rvalue_reference_helper<const char32_t &> {
    };
template<> struct add_rvalue_reference<char32_t &> : public __add_rvalue_reference_helper<char32_t &> {
    };
template<> struct add_rvalue_reference<const char32_t &&> : public __add_rvalue_reference_helper<const char32_t &&> {
    };
template<> struct add_rvalue_reference<const char32_t *&> : public __add_rvalue_reference_helper<const char32_t *&> {
    };
template<> struct add_rvalue_reference<const char32_t *const> : public __add_rvalue_reference_helper<const char32_t *const> {
    };
    template <typename _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
    template <typename _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
    template <typename _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
    template <typename _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector
template<> struct __cv_selector<unsigned int, false, false> {
        typedef unsigned int __type;
    }
template<> struct __cv_selector<unsigned char, false, false> {
        typedef unsigned char __type;
    }
template<> struct __cv_selector<unsigned short, false, false> {
        typedef unsigned short __type;
    }
template<> struct __cv_selector<int, false, false> {
        typedef int __type;
    }
template<> struct __cv_selector<signed char, false, false> {
        typedef signed char __type;
    }
template<> struct __cv_selector<short, false, false> {
        typedef short __type;
    }
template<> struct __cv_selector<const char *const, true, false> {
        typedef const char *const const __type;
    }
template<> struct __cv_selector<char, true, false> {
        typedef const char __type;
    }
template<> struct __cv_selector<const char, false, false> {
        typedef const char __type;
    }
template<> struct __cv_selector<const char, true, false> {
        typedef const const char __type;
    }
template<> struct __cv_selector<const unsigned long, true, false> {
        typedef const const unsigned long __type;
    }
template<> struct __cv_selector<const wchar_t *const, true, false> {
        typedef const wchar_t *const const __type;
    }
template<> struct __cv_selector<wchar_t, true, false> {
        typedef const wchar_t __type;
    }
template<> struct __cv_selector<const wchar_t, false, false> {
        typedef const wchar_t __type;
    }
template<> struct __cv_selector<const wchar_t, true, false> {
        typedef const const wchar_t __type;
    }
template<> struct __cv_selector<const char8_t *const, true, false> {
        typedef const char8_t *const const __type;
    }
template<> struct __cv_selector<char8_t, true, false> {
        typedef const char8_t __type;
    }
template<> struct __cv_selector<const char8_t, false, false> {
        typedef const char8_t __type;
    }
template<> struct __cv_selector<const char8_t, true, false> {
        typedef const const char8_t __type;
    }
template<> struct __cv_selector<const char16_t *const, true, false> {
        typedef const char16_t *const const __type;
    }
template<> struct __cv_selector<char16_t, true, false> {
        typedef const char16_t __type;
    }
template<> struct __cv_selector<const char16_t, false, false> {
        typedef const char16_t __type;
    }
template<> struct __cv_selector<const char16_t, true, false> {
        typedef const const char16_t __type;
    }
template<> struct __cv_selector<const char32_t *const, true, false> {
        typedef const char32_t *const const __type;
    }
template<> struct __cv_selector<char32_t, true, false> {
        typedef const char32_t __type;
    }
template<> struct __cv_selector<const char32_t, false, false> {
        typedef const char32_t __type;
    }
template<> struct __cv_selector<const char32_t, true, false> {
        typedef const const char32_t __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, false> {
        typedef _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, true> {
        typedef volatile _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, false> {
        typedef const _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, true> {
        typedef const volatile _Unqualified __type;
    };
    template <typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value> class __match_cv_qualifiers {
        typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<wchar_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char8_t, unsigned char, false, false> {
        typedef __cv_selector<unsigned char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char16_t, unsigned short, false, false> {
        typedef __cv_selector<unsigned short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char32_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned int, int, false, false> {
        typedef __cv_selector<int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned char, signed char, false, false> {
        typedef __cv_selector<signed char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned short, short, false, false> {
        typedef __cv_selector<short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char *const, const char *const, true, false> {
        typedef __cv_selector<const char *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char, char, true, false> {
        typedef __cv_selector<char, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char, const char, false, false> {
        typedef __cv_selector<const char, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char, const char, true, false> {
        typedef __cv_selector<const char, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const unsigned long, const unsigned long, true, false> {
        typedef __cv_selector<const unsigned long, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const wchar_t *const, const wchar_t *const, true, false> {
        typedef __cv_selector<const wchar_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const wchar_t, wchar_t, true, false> {
        typedef __cv_selector<wchar_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<wchar_t, const wchar_t, false, false> {
        typedef __cv_selector<const wchar_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const wchar_t, const wchar_t, true, false> {
        typedef __cv_selector<const wchar_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char8_t *const, const char8_t *const, true, false> {
        typedef __cv_selector<const char8_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char8_t, char8_t, true, false> {
        typedef __cv_selector<char8_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char8_t, const char8_t, false, false> {
        typedef __cv_selector<const char8_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char8_t, const char8_t, true, false> {
        typedef __cv_selector<const char8_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char16_t *const, const char16_t *const, true, false> {
        typedef __cv_selector<const char16_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char16_t, char16_t, true, false> {
        typedef __cv_selector<char16_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char16_t, const char16_t, false, false> {
        typedef __cv_selector<const char16_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char16_t, const char16_t, true, false> {
        typedef __cv_selector<const char16_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char32_t *const, const char32_t *const, true, false> {
        typedef __cv_selector<const char32_t *const, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char32_t, char32_t, true, false> {
        typedef __cv_selector<char32_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char32_t, const char32_t, false, false> {
        typedef __cv_selector<const char32_t, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<const char32_t, const char32_t, true, false> {
        typedef __cv_selector<const char32_t, true, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template <typename _Tp> struct __make_unsigned {
        typedef _Tp __type;
    };
    template<> struct __make_unsigned<char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<signed char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<short> {
        typedef unsigned short __type;
    };
    template<> struct __make_unsigned<int> {
        typedef unsigned int __type;
    };
    template<> struct __make_unsigned<long> {
        typedef unsigned long __type;
    };
    template<> struct __make_unsigned<long long> {
        typedef unsigned long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_unsigned_selector
template<> class __make_unsigned_selector<wchar_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(wchar_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char8_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char8_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char8_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char16_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char32_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<wchar_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<wchar_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char8_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char8_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char8_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char16_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<char32_t>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
        using __unsigned_type = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    class __make_unsigned_selector_base {
    protected:
        template <typename ...> struct _List {
        };
template<> struct _List<<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned short, unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned char);
        };
template<> struct _List<<unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned short);
        };
template<> struct _List<<unsigned int, unsigned long, unsigned long long>> : _List<unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned int);
        };
template<> struct _List<<unsigned long, unsigned long long>> : _List<unsigned long long> {
            static constexpr std::size_t __size;
        };
template<> struct _List<<unsigned long long>> : _List<> {
            static constexpr std::size_t __size;
        };
template<> struct _List<<>> {
        };
        template <typename _Tp, typename ..._Up> struct _List<_Tp, _Up...> : _List<_Up...> {
            static constexpr std::size_t __size = sizeof(_Tp);
        };
        template <std::size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)> struct __select
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned int;
        }
template<> struct __select<1, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned char;
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long>> {
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned short;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, true> {
            using __type = _Uint;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, false> : __select<_Sz, _List<_UInts...>> {
        };
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    template<> struct __make_unsigned<wchar_t> {
        using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char8_t> {
        using __type = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char16_t> {
        using __type = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char32_t> {
        using __type = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_unsigned {
        typedef typename __make_unsigned_selector<_Tp>::__type type;
    };
    template<> struct make_unsigned<bool>;
    template <typename _Tp> struct __make_signed {
        typedef _Tp __type;
    };
    template<> struct __make_signed<char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned short> {
        typedef short __type;
    };
    template<> struct __make_signed<unsigned int> {
        typedef int __type;
    };
    template<> struct __make_signed<unsigned long> {
        typedef long __type;
    };
    template<> struct __make_signed<unsigned long long> {
        typedef long long __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_signed_selector
template<> class __make_signed_selector<wchar_t, false, true> {
        typedef typename __make_unsigned_selector<wchar_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned int, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned int>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned int, __signed_type>::__type;
    }
template<> class __make_signed_selector<char8_t, false, true> {
        typedef typename __make_unsigned_selector<char8_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned char, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned char>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned char, __signed_type>::__type;
    }
template<> class __make_signed_selector<char16_t, false, true> {
        typedef typename __make_unsigned_selector<char16_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned short, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<unsigned short>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned short, __signed_type>::__type;
    }
template<> class __make_signed_selector<char32_t, false, true> {
        typedef typename __make_unsigned_selector<char32_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
        using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
        typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template<> struct __make_signed<wchar_t> {
        using __type = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
    template<> struct __make_signed<char8_t> {
        using __type = typename __make_signed_selector<char8_t, false, true>::__type;
    };
    template<> struct __make_signed<char16_t> {
        using __type = typename __make_signed_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_signed<char32_t> {
        using __type = typename __make_signed_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_signed {
        typedef typename __make_signed_selector<_Tp>::__type type;
    };
    template<> struct make_signed<bool>;
    template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;
    template <typename _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
    template <typename _Tp> struct remove_extent {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp [_Size]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_extent<_Tp []> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_all_extents {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_all_extents<_Tp [_Size]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> struct remove_all_extents<_Tp []> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
    template <typename _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
    template <typename _Tp, typename> struct __remove_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp, typename _Up> struct __remove_pointer_helper<_Tp, _Up *> {
        typedef _Up type;
    };
    template <typename _Tp> struct remove_pointer : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {
    };
    template <typename _Tp, bool = __or_<__is_referenceable<_Tp>, is_void<_Tp>>::value> struct __add_pointer_helper {
        typedef _Tp type;
    };
template<> struct __add_pointer_helper<const char &, true> {
        typedef typename remove_reference<const char &>::type *type;
    };
template<> struct __add_pointer_helper<const wchar_t &, true> {
        typedef typename remove_reference<const wchar_t &>::type *type;
    };
template<> struct __add_pointer_helper<const char8_t &, true> {
        typedef typename remove_reference<const char8_t &>::type *type;
    };
template<> struct __add_pointer_helper<const char16_t &, true> {
        typedef typename remove_reference<const char16_t &>::type *type;
    };
template<> struct __add_pointer_helper<const char32_t &, true> {
        typedef typename remove_reference<const char32_t &>::type *type;
    };
    template <typename _Tp> struct __add_pointer_helper<_Tp, true> {
        typedef typename remove_reference<_Tp>::type *type;
    };
    template <typename _Tp> struct add_pointer : public __add_pointer_helper<_Tp> {
    };
template<> struct add_pointer<const char &> : public __add_pointer_helper<const char &> {
    };
template<> struct add_pointer<const wchar_t &> : public __add_pointer_helper<const wchar_t &> {
    };
template<> struct add_pointer<const char8_t &> : public __add_pointer_helper<const char8_t &> {
    };
template<> struct add_pointer<const char16_t &> : public __add_pointer_helper<const char16_t &> {
    };
template<> struct add_pointer<const char32_t &> : public __add_pointer_helper<const char32_t &> {
    };
    template <typename _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
    template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
    template <std::size_t _Len> struct __aligned_storage_msa {
        union __type {
            unsigned char __data[_Len];
            struct __attribute__((aligned)) {
            } __align;
        };
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> struct aligned_storage {
        union type {
            unsigned char __data[_Len];
            struct __attribute__((aligned((_Align)))) {
            } __align;
        };
    };
    template <typename ..._Types> struct __strictest_alignment {
        static const std::size_t _S_alignment = 0;
        static const std::size_t _S_size = 0;
    };
    template <typename _Tp, typename ..._Types> struct __strictest_alignment<_Tp, _Types...> {
        static const std::size_t _S_alignment = alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
        static const std::size_t _S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
    template <std::size_t _Len, typename ..._Types> struct aligned_union {
    private:
        static_assert(sizeof...(_Types) != 0, "At least one type is required");
        using __strictest = __strictest_alignment<_Types...>;
        static const std::size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;
    public:
        static const std::size_t alignment_value = __strictest::_S_alignment;
        typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };
    const std::size_t alignment_value;
    template <typename _Up, bool _IsArray = is_array<_Up>::value, bool _IsFunction = is_function<_Up>::value> struct __decay_selector;
    template <typename _Up> struct __decay_selector<_Up, false, false> {
        typedef __remove_cv_t<_Up> __type;
    };
    template <typename _Up> struct __decay_selector<_Up, true, false> {
        typedef typename remove_extent<_Up>::type *__type;
    };
    template <typename _Up> struct __decay_selector<_Up, false, true> {
        typedef typename add_pointer<_Up>::type __type;
    };
    template <typename _Tp> class decay {
        typedef typename remove_reference<_Tp>::type __remove_type;
    public:
        typedef typename __decay_selector<__remove_type>::__type type;
    };
    template <typename _Tp> using __decay_t = typename decay<_Tp>::type;
    template <typename _Tp> class reference_wrapper;
    template <typename _Tp> struct __strip_reference_wrapper {
        typedef _Tp __type;
    };
    template <typename _Tp> struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
        typedef _Tp &__type;
    };
    template <typename _Tp> using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;
    template <bool, typename _Tp = void> struct enable_if {
    };
template<> struct enable_if<true, void> {
        typedef void type;
    };
    template <typename _Tp> struct enable_if<true, _Tp> {
        typedef _Tp type;
    };
    template <bool _Cond, typename _Tp = void> using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <typename ..._Cond> using _Require = __enable_if_t<__and_<_Cond...>::value>;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> struct conditional {
        typedef _Iftrue type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char *>, std::is_rvalue_reference<const char *>> {
        typedef std::is_rvalue_reference<const char *> type;
    };
template<> struct conditional<false, std::is_reference<const char *>, std::__or_<std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>> type;
    };
template<> struct conditional<false, std::is_function<const char *>, std::__or_<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>>> {
        typedef std::__or_<std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>> type;
    };
template<> struct conditional<false, std::is_void<const char *>, std::__is_array_unknown_bounds<const char *>> {
        typedef std::__is_array_unknown_bounds<const char *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<const char *, 0>>, std::is_array<const char *>> {
        typedef std::is_array<const char *> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char *>, std::is_rvalue_reference<char *>> {
        typedef std::is_rvalue_reference<char *> type;
    };
template<> struct conditional<false, std::is_reference<char *>, std::__or_<std::is_function<char *>, std::is_void<char *>, std::__is_array_unknown_bounds<char *>>> {
        typedef std::__or_<std::is_function<char *>, std::is_void<char *>, std::__is_array_unknown_bounds<char *>> type;
    };
template<> struct conditional<false, std::is_function<char *>, std::__or_<std::is_void<char *>, std::__is_array_unknown_bounds<char *>>> {
        typedef std::__or_<std::is_void<char *>, std::__is_array_unknown_bounds<char *>> type;
    };
template<> struct conditional<false, std::is_void<char *>, std::__is_array_unknown_bounds<char *>> {
        typedef std::__is_array_unknown_bounds<char *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char *, 0>>, std::is_array<char *>> {
        typedef std::is_array<char *> type;
    };
template<> struct conditional<false, std::is_function<const char>, std::__or_<std::is_reference<const char>, std::is_void<const char>>> {
        typedef std::__or_<std::is_reference<const char>, std::is_void<const char>> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char>, std::is_rvalue_reference<const char>> {
        typedef std::is_rvalue_reference<const char> type;
    };
template<> struct conditional<false, std::is_reference<const char>, std::is_void<const char>> {
        typedef std::is_void<const char> type;
    };
template<> struct conditional<false, std::is_move_assignable<char>, std::is_copy_assignable<char>> {
        typedef std::is_copy_assignable<char> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char>, std::is_rvalue_reference<char>> {
        typedef std::is_rvalue_reference<char> type;
    };
template<> struct conditional<false, std::is_reference<char>, std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_function<char>, std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    };
template<> struct conditional<false, std::is_function<char>, std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>>> {
        typedef std::__or_<std::is_void<char>, std::__is_array_unknown_bounds<char>> type;
    };
template<> struct conditional<false, std::is_void<char>, std::__is_array_unknown_bounds<char>> {
        typedef std::__is_array_unknown_bounds<char> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char, 0>>, std::is_array<char>> {
        typedef std::is_array<char> type;
    };
template<> struct conditional<false, std::is_function<char>, std::__or_<std::is_reference<char>, std::is_void<char>>> {
        typedef std::__or_<std::is_reference<char>, std::is_void<char>> type;
    };
template<> struct conditional<false, std::is_reference<char>, std::is_void<char>> {
        typedef std::is_void<char> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const wchar_t *>, std::is_rvalue_reference<const wchar_t *>> {
        typedef std::is_rvalue_reference<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_reference<const wchar_t *>, std::__or_<std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_function<const wchar_t *>, std::__or_<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>>> {
        typedef std::__or_<std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *>, std::__is_array_unknown_bounds<const wchar_t *>> {
        typedef std::__is_array_unknown_bounds<const wchar_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<const wchar_t *, 0>>, std::is_array<const wchar_t *>> {
        typedef std::is_array<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<wchar_t *>, std::is_rvalue_reference<wchar_t *>> {
        typedef std::is_rvalue_reference<wchar_t *> type;
    };
template<> struct conditional<false, std::is_reference<wchar_t *>, std::__or_<std::is_function<wchar_t *>, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>>> {
        typedef std::__or_<std::is_function<wchar_t *>, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>> type;
    };
template<> struct conditional<false, std::is_function<wchar_t *>, std::__or_<std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>>> {
        typedef std::__or_<std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>> type;
    };
template<> struct conditional<false, std::is_void<wchar_t *>, std::__is_array_unknown_bounds<wchar_t *>> {
        typedef std::__is_array_unknown_bounds<wchar_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<wchar_t *, 0>>, std::is_array<wchar_t *>> {
        typedef std::is_array<wchar_t *> type;
    };
template<> struct conditional<false, std::is_function<const wchar_t>, std::__or_<std::is_reference<const wchar_t>, std::is_void<const wchar_t>>> {
        typedef std::__or_<std::is_reference<const wchar_t>, std::is_void<const wchar_t>> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const wchar_t>, std::is_rvalue_reference<const wchar_t>> {
        typedef std::is_rvalue_reference<const wchar_t> type;
    };
template<> struct conditional<false, std::is_reference<const wchar_t>, std::is_void<const wchar_t>> {
        typedef std::is_void<const wchar_t> type;
    };
template<> struct conditional<false, std::is_move_assignable<wchar_t>, std::is_copy_assignable<wchar_t>> {
        typedef std::is_copy_assignable<wchar_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<wchar_t>, std::is_rvalue_reference<wchar_t>> {
        typedef std::is_rvalue_reference<wchar_t> type;
    };
template<> struct conditional<false, std::is_reference<wchar_t>, std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_function<wchar_t>, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    };
template<> struct conditional<false, std::is_function<wchar_t>, std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>>> {
        typedef std::__or_<std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> type;
    };
template<> struct conditional<false, std::is_void<wchar_t>, std::__is_array_unknown_bounds<wchar_t>> {
        typedef std::__is_array_unknown_bounds<wchar_t> type;
    };
template<> struct conditional<false, std::__not_<std::extent<wchar_t, 0>>, std::is_array<wchar_t>> {
        typedef std::is_array<wchar_t> type;
    };
template<> struct conditional<false, std::is_function<wchar_t>, std::__or_<std::is_reference<wchar_t>, std::is_void<wchar_t>>> {
        typedef std::__or_<std::is_reference<wchar_t>, std::is_void<wchar_t>> type;
    };
template<> struct conditional<false, std::is_reference<wchar_t>, std::is_void<wchar_t>> {
        typedef std::is_void<wchar_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char8_t *>, std::is_rvalue_reference<const char8_t *>> {
        typedef std::is_rvalue_reference<const char8_t *> type;
    };
template<> struct conditional<false, std::is_reference<const char8_t *>, std::__or_<std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char8_t *>, std::__or_<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>>> {
        typedef std::__or_<std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char8_t *>, std::__is_array_unknown_bounds<const char8_t *>> {
        typedef std::__is_array_unknown_bounds<const char8_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<const char8_t *, 0>>, std::is_array<const char8_t *>> {
        typedef std::is_array<const char8_t *> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char8_t *>, std::is_rvalue_reference<char8_t *>> {
        typedef std::is_rvalue_reference<char8_t *> type;
    };
template<> struct conditional<false, std::is_reference<char8_t *>, std::__or_<std::is_function<char8_t *>, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>>> {
        typedef std::__or_<std::is_function<char8_t *>, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>> type;
    };
template<> struct conditional<false, std::is_function<char8_t *>, std::__or_<std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>>> {
        typedef std::__or_<std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>> type;
    };
template<> struct conditional<false, std::is_void<char8_t *>, std::__is_array_unknown_bounds<char8_t *>> {
        typedef std::__is_array_unknown_bounds<char8_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char8_t *, 0>>, std::is_array<char8_t *>> {
        typedef std::is_array<char8_t *> type;
    };
template<> struct conditional<false, std::is_function<const char8_t>, std::__or_<std::is_reference<const char8_t>, std::is_void<const char8_t>>> {
        typedef std::__or_<std::is_reference<const char8_t>, std::is_void<const char8_t>> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char8_t>, std::is_rvalue_reference<const char8_t>> {
        typedef std::is_rvalue_reference<const char8_t> type;
    };
template<> struct conditional<false, std::is_reference<const char8_t>, std::is_void<const char8_t>> {
        typedef std::is_void<const char8_t> type;
    };
template<> struct conditional<false, std::is_move_assignable<char8_t>, std::is_copy_assignable<char8_t>> {
        typedef std::is_copy_assignable<char8_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char8_t>, std::is_rvalue_reference<char8_t>> {
        typedef std::is_rvalue_reference<char8_t> type;
    };
template<> struct conditional<false, std::is_reference<char8_t>, std::__or_<std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> {
        typedef std::__or_<std::is_function<char8_t>, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>> type;
    };
template<> struct conditional<false, std::is_function<char8_t>, std::__or_<std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>>> {
        typedef std::__or_<std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>> type;
    };
template<> struct conditional<false, std::is_void<char8_t>, std::__is_array_unknown_bounds<char8_t>> {
        typedef std::__is_array_unknown_bounds<char8_t> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char8_t, 0>>, std::is_array<char8_t>> {
        typedef std::is_array<char8_t> type;
    };
template<> struct conditional<false, std::is_function<char8_t>, std::__or_<std::is_reference<char8_t>, std::is_void<char8_t>>> {
        typedef std::__or_<std::is_reference<char8_t>, std::is_void<char8_t>> type;
    };
template<> struct conditional<false, std::is_reference<char8_t>, std::is_void<char8_t>> {
        typedef std::is_void<char8_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char16_t *>, std::is_rvalue_reference<const char16_t *>> {
        typedef std::is_rvalue_reference<const char16_t *> type;
    };
template<> struct conditional<false, std::is_reference<const char16_t *>, std::__or_<std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char16_t *>, std::__or_<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>>> {
        typedef std::__or_<std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *>, std::__is_array_unknown_bounds<const char16_t *>> {
        typedef std::__is_array_unknown_bounds<const char16_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<const char16_t *, 0>>, std::is_array<const char16_t *>> {
        typedef std::is_array<const char16_t *> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char16_t *>, std::is_rvalue_reference<char16_t *>> {
        typedef std::is_rvalue_reference<char16_t *> type;
    };
template<> struct conditional<false, std::is_reference<char16_t *>, std::__or_<std::is_function<char16_t *>, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>>> {
        typedef std::__or_<std::is_function<char16_t *>, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>> type;
    };
template<> struct conditional<false, std::is_function<char16_t *>, std::__or_<std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>>> {
        typedef std::__or_<std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>> type;
    };
template<> struct conditional<false, std::is_void<char16_t *>, std::__is_array_unknown_bounds<char16_t *>> {
        typedef std::__is_array_unknown_bounds<char16_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char16_t *, 0>>, std::is_array<char16_t *>> {
        typedef std::is_array<char16_t *> type;
    };
template<> struct conditional<false, std::is_function<const char16_t>, std::__or_<std::is_reference<const char16_t>, std::is_void<const char16_t>>> {
        typedef std::__or_<std::is_reference<const char16_t>, std::is_void<const char16_t>> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char16_t>, std::is_rvalue_reference<const char16_t>> {
        typedef std::is_rvalue_reference<const char16_t> type;
    };
template<> struct conditional<false, std::is_reference<const char16_t>, std::is_void<const char16_t>> {
        typedef std::is_void<const char16_t> type;
    };
template<> struct conditional<false, std::is_move_assignable<char16_t>, std::is_copy_assignable<char16_t>> {
        typedef std::is_copy_assignable<char16_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char16_t>, std::is_rvalue_reference<char16_t>> {
        typedef std::is_rvalue_reference<char16_t> type;
    };
template<> struct conditional<false, std::is_reference<char16_t>, std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_function<char16_t>, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    };
template<> struct conditional<false, std::is_function<char16_t>, std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>>> {
        typedef std::__or_<std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> type;
    };
template<> struct conditional<false, std::is_void<char16_t>, std::__is_array_unknown_bounds<char16_t>> {
        typedef std::__is_array_unknown_bounds<char16_t> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char16_t, 0>>, std::is_array<char16_t>> {
        typedef std::is_array<char16_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char32_t *>, std::is_rvalue_reference<const char32_t *>> {
        typedef std::is_rvalue_reference<const char32_t *> type;
    };
template<> struct conditional<false, std::is_reference<const char32_t *>, std::__or_<std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char32_t *>, std::__or_<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>>> {
        typedef std::__or_<std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *>, std::__is_array_unknown_bounds<const char32_t *>> {
        typedef std::__is_array_unknown_bounds<const char32_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<const char32_t *, 0>>, std::is_array<const char32_t *>> {
        typedef std::is_array<const char32_t *> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char32_t *>, std::is_rvalue_reference<char32_t *>> {
        typedef std::is_rvalue_reference<char32_t *> type;
    };
template<> struct conditional<false, std::is_reference<char32_t *>, std::__or_<std::is_function<char32_t *>, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>>> {
        typedef std::__or_<std::is_function<char32_t *>, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>> type;
    };
template<> struct conditional<false, std::is_function<char32_t *>, std::__or_<std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>>> {
        typedef std::__or_<std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>> type;
    };
template<> struct conditional<false, std::is_void<char32_t *>, std::__is_array_unknown_bounds<char32_t *>> {
        typedef std::__is_array_unknown_bounds<char32_t *> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char32_t *, 0>>, std::is_array<char32_t *>> {
        typedef std::is_array<char32_t *> type;
    };
template<> struct conditional<false, std::is_function<const char32_t>, std::__or_<std::is_reference<const char32_t>, std::is_void<const char32_t>>> {
        typedef std::__or_<std::is_reference<const char32_t>, std::is_void<const char32_t>> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<const char32_t>, std::is_rvalue_reference<const char32_t>> {
        typedef std::is_rvalue_reference<const char32_t> type;
    };
template<> struct conditional<false, std::is_reference<const char32_t>, std::is_void<const char32_t>> {
        typedef std::is_void<const char32_t> type;
    };
template<> struct conditional<false, std::is_move_assignable<char32_t>, std::is_copy_assignable<char32_t>> {
        typedef std::is_copy_assignable<char32_t> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<char32_t>, std::is_rvalue_reference<char32_t>> {
        typedef std::is_rvalue_reference<char32_t> type;
    };
template<> struct conditional<false, std::is_reference<char32_t>, std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_function<char32_t>, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    };
template<> struct conditional<false, std::is_function<char32_t>, std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>>> {
        typedef std::__or_<std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> type;
    };
template<> struct conditional<false, std::is_void<char32_t>, std::__is_array_unknown_bounds<char32_t>> {
        typedef std::__is_array_unknown_bounds<char32_t> type;
    };
template<> struct conditional<false, std::__not_<std::extent<char32_t, 0>>, std::is_array<char32_t>> {
        typedef std::is_array<char32_t> type;
    };
template<> struct conditional<false, std::is_void<const char *>, std::__or_<std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>> type;
    };
template<> struct conditional<false, std::__is_array_unknown_bounds<const char *>, std::is_function<const char *>> {
        typedef std::is_function<const char *> type;
    };
template<> struct conditional<false, std::is_reference<const char *>, std::is_scalar<const char *>> {
        typedef std::is_scalar<const char *> type;
    };
template<> struct conditional<false, std::is_integral<const char *>, std::is_floating_point<const char *>> {
        typedef std::is_floating_point<const char *> type;
    };
template<> struct conditional<false, std::is_arithmetic<const char *>, std::__or_<std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
        typedef std::__or_<std::is_enum<const char *>, std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>> type;
    };
template<> struct conditional<false, std::is_enum<const char *>, std::__or_<std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
        typedef std::__or_<std::is_pointer<const char *>, std::is_member_pointer<const char *>, std::is_null_pointer<const char *>> type;
    };
template<> struct conditional<true, std::is_pointer<const char *>, std::__or_<std::is_member_pointer<const char *>, std::is_null_pointer<const char *>>> {
        typedef std::is_pointer<const char *> type;
    };
template<> struct conditional<false, std::is_function<const char *>, std::__or_<std::is_reference<const char *>, std::is_void<const char *>>> {
        typedef std::__or_<std::is_reference<const char *>, std::is_void<const char *>> type;
    };
template<> struct conditional<false, std::is_reference<const char *>, std::is_void<const char *>> {
        typedef std::is_void<const char *> type;
    };
template<> struct conditional<false, std::is_void<const char *>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    };
template<> struct conditional<false, std::is_function<const char *>, std::is_array<const char *>> {
        typedef std::is_array<const char *> type;
    };
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<const char *const &>, std::is_array<const char *const &>>> {
        typedef std::__or_<std::is_function<const char *const &>, std::is_array<const char *const &>> type;
    };
template<> struct conditional<false, std::is_function<const char *const &>, std::is_array<const char *const &>> {
        typedef std::is_array<const char *const &> type;
    };
template<> struct conditional<true, std::__is_nt_assignable_impl<const char *&, const char *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char *&, const char *&&> type;
    };
template<> struct conditional<true, std::is_integral<long>, std::is_floating_point<long>> {
        typedef std::is_integral<long> type;
    };
template<> struct conditional<false, std::is_void<const char &>, std::__or_<std::is_function<const char &>, std::is_array<const char &>>> {
        typedef std::__or_<std::is_function<const char &>, std::is_array<const char &>> type;
    };
template<> struct conditional<false, std::is_function<const char &>, std::is_array<const char &>> {
        typedef std::is_array<const char &> type;
    };
template<> struct conditional<false, std::is_void<char &>, std::__or_<std::is_function<const char &>, std::is_array<const char &>>> {
        typedef std::__or_<std::is_function<const char &>, std::is_array<const char &>> type;
    };
template<> struct conditional<false, std::is_void<const char &&>, std::__or_<std::is_function<const char &>, std::is_array<const char &>>> {
        typedef std::__or_<std::is_function<const char &>, std::is_array<const char &>> type;
    };
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>> type;
    };
template<> struct conditional<false, std::is_function<const volatile std::input_iterator_tag *>, std::is_array<const volatile std::input_iterator_tag *>> {
        typedef std::is_array<const volatile std::input_iterator_tag *> type;
    };
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>> type;
    };
template<> struct conditional<false, std::is_function<const volatile std::forward_iterator_tag *>, std::is_array<const volatile std::forward_iterator_tag *>> {
        typedef std::is_array<const volatile std::forward_iterator_tag *> type;
    };
template<> struct conditional<false, std::is_void<const char *&>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    };
template<> struct conditional<false, std::is_void<const char *const &>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    };
template<> struct conditional<false, std::is_void<const char *const>, std::__or_<std::is_function<const char *>, std::is_array<const char *>>> {
        typedef std::__or_<std::is_function<const char *>, std::is_array<const char *>> type;
    };
template<> struct conditional<false, std::is_void<bool>, std::__or_<std::is_function<bool>, std::is_array<bool>>> {
        typedef std::__or_<std::is_function<bool>, std::is_array<bool>> type;
    };
template<> struct conditional<false, std::is_function<bool>, std::is_array<bool>> {
        typedef std::is_array<bool> type;
    };
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>> type;
    };
template<> struct conditional<false, std::is_function<const volatile std::bidirectional_iterator_tag *>, std::is_array<const volatile std::bidirectional_iterator_tag *>> {
        typedef std::is_array<const volatile std::bidirectional_iterator_tag *> type;
    };
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>> type;
    };
template<> struct conditional<false, std::is_function<const volatile std::random_access_iterator_tag *>, std::is_array<const volatile std::random_access_iterator_tag *>> {
        typedef std::is_array<const volatile std::random_access_iterator_tag *> type;
    };
template<> struct conditional<false, std::is_void<const volatile std::contiguous_iterator_tag *>, std::__or_<std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>>> {
        typedef std::__or_<std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>> type;
    };
template<> struct conditional<false, std::is_function<const volatile std::contiguous_iterator_tag *>, std::is_array<const volatile std::contiguous_iterator_tag *>> {
        typedef std::is_array<const volatile std::contiguous_iterator_tag *> type;
    };
template<> struct conditional<true, std::__is_referenceable<const char &, void>, std::is_void<const char &>> {
        typedef std::__is_referenceable<const char &, void> type;
    };
template<> struct conditional<false, std::is_void<unsigned long>, std::__or_<std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>> type;
    };
template<> struct conditional<false, std::__not_<std::extent<unsigned long, 0>>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    };
template<> struct conditional<false, std::__is_array_unknown_bounds<unsigned long>, std::is_function<unsigned long>> {
        typedef std::is_function<unsigned long> type;
    };
template<> struct conditional<false, std::is_lvalue_reference<unsigned long>, std::is_rvalue_reference<unsigned long>> {
        typedef std::is_rvalue_reference<unsigned long> type;
    };
template<> struct conditional<false, std::is_reference<unsigned long>, std::is_scalar<unsigned long>> {
        typedef std::is_scalar<unsigned long> type;
    };
template<> struct conditional<true, std::is_integral<unsigned long>, std::is_floating_point<unsigned long>> {
        typedef std::is_integral<unsigned long> type;
    };
template<> struct conditional<true, std::is_arithmetic<unsigned long>, std::__or_<std::is_enum<unsigned long>, std::is_pointer<unsigned long>, std::is_member_pointer<unsigned long>, std::is_null_pointer<unsigned long>>> {
        typedef std::is_arithmetic<unsigned long> type;
    };
template<> struct conditional<false, std::is_reference<unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    };
template<> struct conditional<false, std::is_function<unsigned long>, std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>>> {
        typedef std::__or_<std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> type;
    };
template<> struct conditional<false, std::is_void<unsigned long>, std::__is_array_unknown_bounds<unsigned long>> {
        typedef std::__is_array_unknown_bounds<unsigned long> type;
    };
template<> struct conditional<false, std::is_void<unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    };
template<> struct conditional<false, std::is_function<unsigned long>, std::is_array<unsigned long>> {
        typedef std::is_array<unsigned long> type;
    };
template<> struct conditional<false, std::is_void<unsigned long &>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    };
template<> struct conditional<false, std::is_void<const unsigned long &>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    };
template<> struct conditional<false, std::is_void<const unsigned long>, std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>>> {
        typedef std::__or_<std::is_function<unsigned long>, std::is_array<unsigned long>> type;
    };
template<> struct conditional<false, std::is_function<unsigned long>, std::__or_<std::is_reference<unsigned long>, std::is_void<unsigned long>>> {
        typedef std::__or_<std::is_reference<unsigned long>, std::is_void<unsigned long>> type;
    };
template<> struct conditional<false, std::is_reference<unsigned long>, std::is_void<unsigned long>> {
        typedef std::is_void<unsigned long> type;
    };
template<> struct conditional<false, std::is_void<const unsigned long &>, std::__or_<std::is_function<const unsigned long &>, std::is_array<const unsigned long &>>> {
        typedef std::__or_<std::is_function<const unsigned long &>, std::is_array<const unsigned long &>> type;
    };
template<> struct conditional<false, std::is_function<const unsigned long &>, std::is_array<const unsigned long &>> {
        typedef std::is_array<const unsigned long &> type;
    };
template<> struct conditional<true, std::__is_nt_assignable_impl<unsigned long &, unsigned long &&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<unsigned long &, unsigned long &&> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *>, std::__or_<std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>> type;
    };
template<> struct conditional<false, std::__is_array_unknown_bounds<const wchar_t *>, std::is_function<const wchar_t *>> {
        typedef std::is_function<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_reference<const wchar_t *>, std::is_scalar<const wchar_t *>> {
        typedef std::is_scalar<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_integral<const wchar_t *>, std::is_floating_point<const wchar_t *>> {
        typedef std::is_floating_point<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_arithmetic<const wchar_t *>, std::__or_<std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
        typedef std::__or_<std::is_enum<const wchar_t *>, std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_enum<const wchar_t *>, std::__or_<std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
        typedef std::__or_<std::is_pointer<const wchar_t *>, std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>> type;
    };
template<> struct conditional<true, std::is_pointer<const wchar_t *>, std::__or_<std::is_member_pointer<const wchar_t *>, std::is_null_pointer<const wchar_t *>>> {
        typedef std::is_pointer<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_function<const wchar_t *>, std::__or_<std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>>> {
        typedef std::__or_<std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_reference<const wchar_t *>, std::is_void<const wchar_t *>> {
        typedef std::is_void<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> {
        typedef std::is_array<const wchar_t *> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>>> {
        typedef std::__or_<std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>> type;
    };
template<> struct conditional<false, std::is_function<const wchar_t *const &>, std::is_array<const wchar_t *const &>> {
        typedef std::is_array<const wchar_t *const &> type;
    };
template<> struct conditional<true, std::__is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const wchar_t *&, const wchar_t *&&> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t &>, std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
        typedef std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> type;
    };
template<> struct conditional<false, std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> {
        typedef std::is_array<const wchar_t &> type;
    };
template<> struct conditional<false, std::is_void<wchar_t &>, std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
        typedef std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t &&>, std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>>> {
        typedef std::__or_<std::is_function<const wchar_t &>, std::is_array<const wchar_t &>> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *&>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *const &>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    };
template<> struct conditional<false, std::is_void<const wchar_t *const>, std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>>> {
        typedef std::__or_<std::is_function<const wchar_t *>, std::is_array<const wchar_t *>> type;
    };
template<> struct conditional<true, std::__is_referenceable<const wchar_t &, void>, std::is_void<const wchar_t &>> {
        typedef std::__is_referenceable<const wchar_t &, void> type;
    };
template<> struct conditional<false, std::is_void<const char8_t *>, std::__or_<std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>> type;
    };
template<> struct conditional<false, std::__is_array_unknown_bounds<const char8_t *>, std::is_function<const char8_t *>> {
        typedef std::is_function<const char8_t *> type;
    };
template<> struct conditional<false, std::is_reference<const char8_t *>, std::is_scalar<const char8_t *>> {
        typedef std::is_scalar<const char8_t *> type;
    };
template<> struct conditional<false, std::is_integral<const char8_t *>, std::is_floating_point<const char8_t *>> {
        typedef std::is_floating_point<const char8_t *> type;
    };
template<> struct conditional<false, std::is_arithmetic<const char8_t *>, std::__or_<std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
        typedef std::__or_<std::is_enum<const char8_t *>, std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>> type;
    };
template<> struct conditional<false, std::is_enum<const char8_t *>, std::__or_<std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
        typedef std::__or_<std::is_pointer<const char8_t *>, std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>> type;
    };
template<> struct conditional<true, std::is_pointer<const char8_t *>, std::__or_<std::is_member_pointer<const char8_t *>, std::is_null_pointer<const char8_t *>>> {
        typedef std::is_pointer<const char8_t *> type;
    };
template<> struct conditional<false, std::is_function<const char8_t *>, std::__or_<std::is_reference<const char8_t *>, std::is_void<const char8_t *>>> {
        typedef std::__or_<std::is_reference<const char8_t *>, std::is_void<const char8_t *>> type;
    };
template<> struct conditional<false, std::is_reference<const char8_t *>, std::is_void<const char8_t *>> {
        typedef std::is_void<const char8_t *> type;
    };
template<> struct conditional<false, std::is_void<const char8_t *>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char8_t *>, std::is_array<const char8_t *>> {
        typedef std::is_array<const char8_t *> type;
    };
template<> struct conditional<false, std::is_void<const char8_t *const &>, std::__or_<std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>>> {
        typedef std::__or_<std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>> type;
    };
template<> struct conditional<false, std::is_function<const char8_t *const &>, std::is_array<const char8_t *const &>> {
        typedef std::is_array<const char8_t *const &> type;
    };
template<> struct conditional<true, std::__is_nt_assignable_impl<const char8_t *&, const char8_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char8_t *&, const char8_t *&&> type;
    };
template<> struct conditional<false, std::is_void<const char8_t &>, std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
        typedef std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>> type;
    };
template<> struct conditional<false, std::is_function<const char8_t &>, std::is_array<const char8_t &>> {
        typedef std::is_array<const char8_t &> type;
    };
template<> struct conditional<false, std::is_void<char8_t &>, std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
        typedef std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>> type;
    };
template<> struct conditional<false, std::is_void<const char8_t &&>, std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>>> {
        typedef std::__or_<std::is_function<const char8_t &>, std::is_array<const char8_t &>> type;
    };
template<> struct conditional<false, std::is_void<const char8_t *&>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char8_t *const &>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char8_t *const>, std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>>> {
        typedef std::__or_<std::is_function<const char8_t *>, std::is_array<const char8_t *>> type;
    };
template<> struct conditional<true, std::__is_referenceable<const char8_t &, void>, std::is_void<const char8_t &>> {
        typedef std::__is_referenceable<const char8_t &, void> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *>, std::__or_<std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>> type;
    };
template<> struct conditional<false, std::__is_array_unknown_bounds<const char16_t *>, std::is_function<const char16_t *>> {
        typedef std::is_function<const char16_t *> type;
    };
template<> struct conditional<false, std::is_reference<const char16_t *>, std::is_scalar<const char16_t *>> {
        typedef std::is_scalar<const char16_t *> type;
    };
template<> struct conditional<false, std::is_integral<const char16_t *>, std::is_floating_point<const char16_t *>> {
        typedef std::is_floating_point<const char16_t *> type;
    };
template<> struct conditional<false, std::is_arithmetic<const char16_t *>, std::__or_<std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
        typedef std::__or_<std::is_enum<const char16_t *>, std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_enum<const char16_t *>, std::__or_<std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
        typedef std::__or_<std::is_pointer<const char16_t *>, std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>> type;
    };
template<> struct conditional<true, std::is_pointer<const char16_t *>, std::__or_<std::is_member_pointer<const char16_t *>, std::is_null_pointer<const char16_t *>>> {
        typedef std::is_pointer<const char16_t *> type;
    };
template<> struct conditional<false, std::is_function<const char16_t *>, std::__or_<std::is_reference<const char16_t *>, std::is_void<const char16_t *>>> {
        typedef std::__or_<std::is_reference<const char16_t *>, std::is_void<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_reference<const char16_t *>, std::is_void<const char16_t *>> {
        typedef std::is_void<const char16_t *> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char16_t *>, std::is_array<const char16_t *>> {
        typedef std::is_array<const char16_t *> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>>> {
        typedef std::__or_<std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>> type;
    };
template<> struct conditional<false, std::is_function<const char16_t *const &>, std::is_array<const char16_t *const &>> {
        typedef std::is_array<const char16_t *const &> type;
    };
template<> struct conditional<true, std::__is_nt_assignable_impl<const char16_t *&, const char16_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char16_t *&, const char16_t *&&> type;
    };
template<> struct conditional<false, std::is_void<const char16_t &>, std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
        typedef std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>> type;
    };
template<> struct conditional<false, std::is_function<const char16_t &>, std::is_array<const char16_t &>> {
        typedef std::is_array<const char16_t &> type;
    };
template<> struct conditional<false, std::is_void<char16_t &>, std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
        typedef std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>> type;
    };
template<> struct conditional<false, std::is_void<const char16_t &&>, std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>>> {
        typedef std::__or_<std::is_function<const char16_t &>, std::is_array<const char16_t &>> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *&>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *const &>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char16_t *const>, std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>>> {
        typedef std::__or_<std::is_function<const char16_t *>, std::is_array<const char16_t *>> type;
    };
template<> struct conditional<true, std::__is_referenceable<const char16_t &, void>, std::is_void<const char16_t &>> {
        typedef std::__is_referenceable<const char16_t &, void> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *>, std::__or_<std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>>> {
        typedef std::__or_<std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>> type;
    };
template<> struct conditional<false, std::__is_array_unknown_bounds<const char32_t *>, std::is_function<const char32_t *>> {
        typedef std::is_function<const char32_t *> type;
    };
template<> struct conditional<false, std::is_reference<const char32_t *>, std::is_scalar<const char32_t *>> {
        typedef std::is_scalar<const char32_t *> type;
    };
template<> struct conditional<false, std::is_integral<const char32_t *>, std::is_floating_point<const char32_t *>> {
        typedef std::is_floating_point<const char32_t *> type;
    };
template<> struct conditional<false, std::is_arithmetic<const char32_t *>, std::__or_<std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
        typedef std::__or_<std::is_enum<const char32_t *>, std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_enum<const char32_t *>, std::__or_<std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
        typedef std::__or_<std::is_pointer<const char32_t *>, std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>> type;
    };
template<> struct conditional<true, std::is_pointer<const char32_t *>, std::__or_<std::is_member_pointer<const char32_t *>, std::is_null_pointer<const char32_t *>>> {
        typedef std::is_pointer<const char32_t *> type;
    };
template<> struct conditional<false, std::is_function<const char32_t *>, std::__or_<std::is_reference<const char32_t *>, std::is_void<const char32_t *>>> {
        typedef std::__or_<std::is_reference<const char32_t *>, std::is_void<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_reference<const char32_t *>, std::is_void<const char32_t *>> {
        typedef std::is_void<const char32_t *> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_function<const char32_t *>, std::is_array<const char32_t *>> {
        typedef std::is_array<const char32_t *> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>>> {
        typedef std::__or_<std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>> type;
    };
template<> struct conditional<false, std::is_function<const char32_t *const &>, std::is_array<const char32_t *const &>> {
        typedef std::is_array<const char32_t *const &> type;
    };
template<> struct conditional<true, std::__is_nt_assignable_impl<const char32_t *&, const char32_t *&&>, std::integral_constant<bool, true>> {
        typedef std::__is_nt_assignable_impl<const char32_t *&, const char32_t *&&> type;
    };
template<> struct conditional<false, std::is_void<const char32_t &>, std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
        typedef std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>> type;
    };
template<> struct conditional<false, std::is_function<const char32_t &>, std::is_array<const char32_t &>> {
        typedef std::is_array<const char32_t &> type;
    };
template<> struct conditional<false, std::is_void<char32_t &>, std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
        typedef std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>> type;
    };
template<> struct conditional<false, std::is_void<const char32_t &&>, std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>>> {
        typedef std::__or_<std::is_function<const char32_t &>, std::is_array<const char32_t &>> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *&>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *const &>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    };
template<> struct conditional<false, std::is_void<const char32_t *const>, std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>>> {
        typedef std::__or_<std::is_function<const char32_t *>, std::is_array<const char32_t *>> type;
    };
template<> struct conditional<true, std::__is_referenceable<const char32_t &, void>, std::is_void<const char32_t &>> {
        typedef std::__is_referenceable<const char32_t &, void> type;
    };
    template <typename _Iftrue, typename _Iffalse> struct conditional<false, _Iftrue, _Iffalse> {
        typedef _Iffalse type;
    };
    template <typename _Tp> using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    template <typename ..._Tp> struct common_type;
    struct __do_common_type_impl {
        template <typename _Tp, typename _Up> using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());
        template <typename _Tp, typename _Up> static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);
        template <typename _Tp, typename _Up> static __success_type<__remove_cvref_t<__cond_t<const _Tp &, const _Up &>>> _S_test_2(int);
        template <typename, typename> static std::__failure_type _S_test_2(...);
        template <typename _Tp, typename _Up> static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
    };
    template<> struct common_type<> {
    };
    template <typename _Tp0> struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {
    };
    template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>> struct __common_type_impl {
        using type = common_type<_Dp1, _Dp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2> : private std::__do_common_type_impl {
        using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };
    template <typename _Tp1, typename _Tp2> struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {
    };
    template <typename ...> struct __common_type_pack {
    };
    template <typename, typename, typename = void> struct __common_type_fold;
    template <typename _Tp1, typename _Tp2, typename ..._Rp> struct common_type<_Tp1, _Tp2, _Rp...> : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>> {
    };
    template <typename _CTp, typename ..._Rp> struct __common_type_fold<_CTp, __common_type_pack<_Rp...>, __void_t<typename _CTp::type>> : public common_type<typename _CTp::type, _Rp...> {
    };
    template <typename _CTp, typename _Rp> struct __common_type_fold<_CTp, _Rp, void> {
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl {
        using type = __underlying_type(_Tp);
    };
    template <typename _Tp> struct __underlying_type_impl<_Tp, false> {
    };
    template <typename _Tp> struct underlying_type : public __underlying_type_impl<_Tp> {
    };
    template <typename _Tp> struct __declval_protector {
        static const bool __stop = false;
    };
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0))     {
        static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
        return __declval<_Tp>(0);
    }
    template<> auto declval<const std::ranges::__cust_swap::_Swap &>() noexcept -> decltype(__declval<const std::ranges::__cust_swap::_Swap &>(0))    template<> auto declval<const char *const &>() noexcept -> decltype(__declval<const char *const &>(0))    template<> auto declval<char *const &>() noexcept -> decltype(__declval<char *const &>(0))    template<> auto declval<const wchar_t *const &>() noexcept -> decltype(__declval<const wchar_t *const &>(0))    template<> auto declval<wchar_t *const &>() noexcept -> decltype(__declval<wchar_t *const &>(0))    template<> auto declval<const char8_t *const &>() noexcept -> decltype(__declval<const char8_t *const &>(0))    template<> auto declval<char8_t *const &>() noexcept -> decltype(__declval<char8_t *const &>(0))    template<> auto declval<const char16_t *const &>() noexcept -> decltype(__declval<const char16_t *const &>(0))    template<> auto declval<char16_t *const &>() noexcept -> decltype(__declval<char16_t *const &>(0))    template<> auto declval<const char32_t *const &>() noexcept -> decltype(__declval<const char32_t *const &>(0))    template<> auto declval<char32_t *const &>() noexcept -> decltype(__declval<char32_t *const &>(0))    template<> auto declval<const char *>() noexcept -> decltype(__declval<const char *>(0))    template<> auto declval<const char *const &(&)()>() noexcept -> decltype(__declval<const char *const &(&)()>(0))    template<> auto declval<const char *&&>() noexcept -> decltype(__declval<const char *&&>(0))    template<> auto declval<const char *&>() noexcept -> decltype(__declval<const char *&>(0))    template<> auto declval<const char &(&)()>() noexcept -> decltype(__declval<const char &(&)()>(0))    template<> auto declval<const char &>() noexcept -> decltype(__declval<const char &>(0))    template<> auto declval<char &>() noexcept -> decltype(__declval<char &>(0))    template<> auto declval<const char &&>() noexcept -> decltype(__declval<const char &&>(0))    template<> auto declval<const volatile std::contiguous_iterator_tag *>() noexcept -> decltype(__declval<const volatile std::contiguous_iterator_tag *>(0))    template<> auto declval<const char *const>() noexcept -> decltype(__declval<const char *const>(0))    template<> auto declval<bool>() noexcept -> decltype(__declval<bool>(0))    template<> auto declval<unsigned long>() noexcept -> decltype(__declval<unsigned long>(0))    template<> auto declval<unsigned long &>() noexcept -> decltype(__declval<unsigned long &>(0))    template<> auto declval<const unsigned long &>() noexcept -> decltype(__declval<const unsigned long &>(0))    template<> auto declval<const unsigned long>() noexcept -> decltype(__declval<const unsigned long>(0))    template<> auto declval<const unsigned long &(&)()>() noexcept -> decltype(__declval<const unsigned long &(&)()>(0))    template<> auto declval<unsigned long &&>() noexcept -> decltype(__declval<unsigned long &&>(0))    template<> auto declval<const wchar_t *>() noexcept -> decltype(__declval<const wchar_t *>(0))    template<> auto declval<const wchar_t *const &(&)()>() noexcept -> decltype(__declval<const wchar_t *const &(&)()>(0))    template<> auto declval<const wchar_t *&&>() noexcept -> decltype(__declval<const wchar_t *&&>(0))    template<> auto declval<const wchar_t *&>() noexcept -> decltype(__declval<const wchar_t *&>(0))    template<> auto declval<const wchar_t &(&)()>() noexcept -> decltype(__declval<const wchar_t &(&)()>(0))    template<> auto declval<const wchar_t &>() noexcept -> decltype(__declval<const wchar_t &>(0))    template<> auto declval<wchar_t &>() noexcept -> decltype(__declval<wchar_t &>(0))    template<> auto declval<const wchar_t &&>() noexcept -> decltype(__declval<const wchar_t &&>(0))    template<> auto declval<const wchar_t *const>() noexcept -> decltype(__declval<const wchar_t *const>(0))    template<> auto declval<const char8_t *>() noexcept -> decltype(__declval<const char8_t *>(0))    template<> auto declval<const char8_t *const &(&)()>() noexcept -> decltype(__declval<const char8_t *const &(&)()>(0))    template<> auto declval<const char8_t *&&>() noexcept -> decltype(__declval<const char8_t *&&>(0))    template<> auto declval<const char8_t *&>() noexcept -> decltype(__declval<const char8_t *&>(0))    template<> auto declval<const char8_t &(&)()>() noexcept -> decltype(__declval<const char8_t &(&)()>(0))    template<> auto declval<const char8_t &>() noexcept -> decltype(__declval<const char8_t &>(0))    template<> auto declval<char8_t &>() noexcept -> decltype(__declval<char8_t &>(0))    template<> auto declval<const char8_t &&>() noexcept -> decltype(__declval<const char8_t &&>(0))    template<> auto declval<const char8_t *const>() noexcept -> decltype(__declval<const char8_t *const>(0))    template<> auto declval<const char16_t *>() noexcept -> decltype(__declval<const char16_t *>(0))    template<> auto declval<const char16_t *const &(&)()>() noexcept -> decltype(__declval<const char16_t *const &(&)()>(0))    template<> auto declval<const char16_t *&&>() noexcept -> decltype(__declval<const char16_t *&&>(0))    template<> auto declval<const char16_t *&>() noexcept -> decltype(__declval<const char16_t *&>(0))    template<> auto declval<const char16_t &(&)()>() noexcept -> decltype(__declval<const char16_t &(&)()>(0))    template<> auto declval<const char16_t &>() noexcept -> decltype(__declval<const char16_t &>(0))    template<> auto declval<char16_t &>() noexcept -> decltype(__declval<char16_t &>(0))    template<> auto declval<const char16_t &&>() noexcept -> decltype(__declval<const char16_t &&>(0))    template<> auto declval<const char16_t *const>() noexcept -> decltype(__declval<const char16_t *const>(0))    template<> auto declval<const char32_t *>() noexcept -> decltype(__declval<const char32_t *>(0))    template<> auto declval<const char32_t *const &(&)()>() noexcept -> decltype(__declval<const char32_t *const &(&)()>(0))    template<> auto declval<const char32_t *&&>() noexcept -> decltype(__declval<const char32_t *&&>(0))    template<> auto declval<const char32_t *&>() noexcept -> decltype(__declval<const char32_t *&>(0))    template<> auto declval<const char32_t &(&)()>() noexcept -> decltype(__declval<const char32_t &(&)()>(0))    template<> auto declval<const char32_t &>() noexcept -> decltype(__declval<const char32_t &>(0))    template<> auto declval<char32_t &>() noexcept -> decltype(__declval<char32_t &>(0))    template<> auto declval<const char32_t &&>() noexcept -> decltype(__declval<const char32_t &&>(0))    template<> auto declval<const char32_t *const>() noexcept -> decltype(__declval<const char32_t *const>(0))    template <typename _Signature> class result_of;
    struct __invoke_memfun_ref {
    };
    struct __invoke_memfun_deref {
    };
    struct __invoke_memobj_ref {
    };
    struct __invoke_memobj_deref {
    };
    struct __invoke_other {
    };
    template <typename _Tp, typename _Tag> struct __result_of_success : __success_type<_Tp> {
        using __invoke_type = _Tag;
    };
    struct __result_of_memfun_ref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype((std::declval<_Tp1>() .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_ref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_ref : private std::__result_of_memfun_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memfun_deref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype(((*std::declval<_Tp1>()) .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_deref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_deref : private std::__result_of_memfun_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memobj_ref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype(std::declval<_Tp1>() .* std::declval<_Fp>()), std::__invoke_memobj_ref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_ref : private std::__result_of_memobj_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    struct __result_of_memobj_deref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype((*std::declval<_Tp1>()) .* std::declval<_Fp>()), std::__invoke_memobj_deref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_deref : private std::__result_of_memobj_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj;
    template <typename _Res, typename _Class, typename _Arg> struct __result_of_memobj<_Res _Class::*, _Arg> {
        typedef __remove_cvref_t<_Arg> _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename conditional<__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value, __result_of_memobj_ref<_MemPtr, _Arg>, __result_of_memobj_deref<_MemPtr, _Arg>>::type::type type;
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun;
    template <typename _Res, typename _Class, typename _Arg, typename ..._Args> struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
        typedef typename remove_reference<_Arg>::type _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename conditional<is_base_of<_Class, _Argval>::value, __result_of_memfun_ref<_MemPtr, _Arg, _Args...>, __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type::type type;
    };
    template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>> struct __inv_unwrap {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
        using type = _Up &;
    };
    template <bool, bool, typename _Functor, typename ..._ArgTypes> struct __result_of_impl {
        typedef std::__failure_type type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_impl<true, false, _MemPtr, _Arg> : public __result_of_memobj<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type> {
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...> : public __result_of_memfun<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type, _Args...> {
    };
    struct __result_of_other_impl {
        template <typename _Fn, typename ..._Args> static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)), std::__invoke_other> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _Functor, typename ..._ArgTypes> struct __result_of_impl<false, false, _Functor, _ArgTypes...> : private std::__result_of_other_impl {
        typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };
    template <typename _Functor, typename ..._ArgTypes> struct __invoke_result : public __result_of_impl<is_member_object_pointer<typename remove_reference<_Functor>::type>::value, is_member_function_pointer<typename remove_reference<_Functor>::type>::value, _Functor, _ArgTypes...>::type {
    };
    template <typename _Functor, typename ..._ArgTypes> struct result_of<_Functor (_ArgTypes...)> : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <std::size_t _Len, typename ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <typename _Tp> using decay_t = typename decay<_Tp>::type;
    template <bool _Cond, typename _Tp = void> using enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
    template <typename ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
    template <typename _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
    template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;
    template <typename ...> using void_t = void;
    template <typename _Default, typename _AlwaysVoid, template <typename ...> class _Op, typename ..._Args> struct __detector {
        using value_t = std::false_type;
        using type = _Default;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {
        using value_t = std::true_type;
        using type = _Op<_Args...>;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or = __detector<_Default, void, _Op, _Args...>;
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
    template <typename _Tp> struct __is_swappable;
    template <typename _Tp> struct __is_nothrow_swappable;
    template <typename ..._Elements> class tuple;
    template <typename> struct __is_tuple_like_impl : std::false_type {
    };
    template <typename ..._Tps> struct __is_tuple_like_impl<tuple<_Tps...>> : std::true_type {
    };
    template <typename _Tp> struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {
    };
    template <typename _Tp> inline constexpr _Require<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>> swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::valueswap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value);
    template <typename _Tp, std::size_t _Nm> inline constexpr __enable_if_t<__is_swappable<_Tp>::value> swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);
    namespace __swappable_details {
        using std::swap;
        struct __do_is_swappable_impl {
            template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_impl {
            template <typename _Tp> static __bool_constant<noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> __test(int);
            template <typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp> struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_swappable : public __is_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct is_swappable : public __is_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool is_swappable_v = is_swappable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
    namespace __swappable_with_details {
        using std::swap;
        struct __do_is_swappable_with_impl {
            template <typename _Tp, typename _Up, typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())), typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))> static std::true_type __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_with_impl {
            template <typename _Tp, typename _Up> static __bool_constant<noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) && noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))> __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp, typename _Up> struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
    };
    template <typename _Tp, typename _Up> struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
    };
    template <typename _Tp, typename _Up> constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
    template <typename _Result, typename _Ret, bool = is_void<_Ret>::value, typename = void> struct __is_invocable_impl : std::false_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, true, __void_t<typename _Result::type>> : std::true_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, false, __void_t<typename _Result::type>> {
    private:
        static typename _Result::type _S_get();
        template <typename _Tp> static void _S_conv(_Tp);
        template <typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))> static std::true_type _S_test(int);
        template <typename _Tp> static std::false_type _S_test(...);
    public:
        using type = decltype(_S_test<_Ret>(1));
    };
    template <typename _Fn, typename ..._ArgTypes> struct __is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
    };
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept((std::declval<_Up>() .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_deref)     {
        return noexcept(((*std::declval<_Tp>()) .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept(std::declval<_Up>() .* std::declval<_Fn>());
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_deref)     {
        return noexcept((*std::declval<_Tp>()) .* std::declval<_Fn>());
    }
    template <typename _Fn, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_other)     {
        return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }
    template <typename _Result, typename _Fn, typename ..._Args> struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type({}))> {
    };
    template <typename _Fn, typename ..._Args> using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
    template <typename _Fn, typename ..._Args> struct __is_nothrow_invocable : __and_<__is_invocable<_Fn, _Args...>, __call_is_nothrow_<_Fn, _Args...>>::type {
    };
    struct __nonesuchbase {
    };
    struct __nonesuch : private std::__nonesuchbase {
        ~__nonesuch() = delete
        __nonesuch(const std::__nonesuch &) = delete
        void operator=(const std::__nonesuch &) = delete
    };
    template <typename _Functor, typename ..._ArgTypes> struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <typename _Fn, typename ..._Args> using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
    template <typename _Fn, typename ..._ArgTypes> struct is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
    };
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_invocable_r : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
    };
    template <typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>({})), "_Fn must be a complete class or an unbounded array");
    };
    template <typename _Result, typename _Ret, typename = void> struct __is_nt_invocable_impl : std::false_type {
    };
    template <typename _Result, typename _Ret> struct __is_nt_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>> : __or_<is_void<_Ret>, __is_nothrow_convertible<typename _Result::type, _Ret>> {
    };
    template <typename _Ret, typename _Fn, typename ..._ArgTypes> struct is_nothrow_invocable_r : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>, __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
    };
    template <typename _Fn, typename ..._Args> constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
    template <typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Ret, typename _Fn, typename ..._Args> constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
    template <typename _Tp> constexpr bool is_void_v = is_void<_Tp>::value;
    template <typename _Tp> constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_integral_v = is_integral<_Tp>::value;
    template <typename _Tp> constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
    template <typename _Tp> constexpr bool is_array_v = is_array<_Tp>::value;
    template <typename _Tp> constexpr bool is_pointer_v = is_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_enum_v = is_enum<_Tp>::value;
    template <typename _Tp> constexpr bool is_union_v = is_union<_Tp>::value;
    template <typename _Tp> constexpr bool is_class_v = is_class<_Tp>::value;
    template <typename _Tp> constexpr bool is_function_v = is_function<_Tp>::value;
    template <typename _Tp> constexpr bool is_reference_v = is_reference<_Tp>::value;
    template <typename _Tp> constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
    template <typename _Tp> constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
    template <typename _Tp> constexpr bool is_object_v = is_object<_Tp>::value;
    template <typename _Tp> constexpr bool is_scalar_v = is_scalar<_Tp>::value;
    template <typename _Tp> constexpr bool is_compound_v = is_compound<_Tp>::value;
    template <typename _Tp> constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
    template <typename _Tp> constexpr bool is_const_v = is_const<_Tp>::value;
    template <typename _Tp> constexpr bool is_volatile_v = is_volatile<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivial_v = is_trivial<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Tp>::value;
    template <typename _Tp> constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
    template <typename _Tp> constexpr bool is_pod_v = is_pod<_Tp>::value [[deprecated("use is_standard_layout_v && is_trivial_v instead")]];
    template <typename _Tp> constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;
    template <typename _Tp> constexpr bool is_empty_v = is_empty<_Tp>::value;
    template <typename _Tp> constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
    template <typename _Tp> constexpr bool is_abstract_v = is_abstract<_Tp>::value;
    template <typename _Tp> constexpr bool is_final_v = is_final<_Tp>::value;
    template <typename _Tp> constexpr bool is_signed_v = is_signed<_Tp>::value;
    template <typename _Tp> constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_constructible_v = is_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_default_constructible_v = is_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_destructible_v = is_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;
    template <typename _Tp, typename ..._Args> constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Tp, _Args...>::value;
    template <typename _Tp> constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Tp>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Tp, _Up>::value;
    template <typename _Tp> constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;
    template <typename _Tp> constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Tp>::value;
    template <typename _Tp> constexpr std::size_t alignment_of_v = alignment_of<_Tp>::value;
    template <typename _Tp> constexpr std::size_t rank_v = rank<_Tp>::value;
    template <typename _Tp, unsigned int _Idx = 0> constexpr std::size_t extent_v = extent<_Tp, _Idx>::value;
    template <typename _Tp, typename _Up> constexpr bool is_same_v = __is_same(_Tp, _Up);
    template <typename _Base, typename _Derived> constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
    template <typename _From, typename _To> constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
    template <typename _Tp> struct has_unique_object_representations : bool_constant<__has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {
        static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>({})), "template argument must be a complete class or an unbounded array");
    };
    template <typename _Tp> constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Tp>::value;
    template <typename _Tp> struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {
    };
    template <typename _Tp> constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
    template <typename _Tp> struct remove_cvref {
        using type = __remove_cvref_t<_Tp>;
    };
    template <typename _Tp> using remove_cvref_t = __remove_cvref_t<_Tp>;
    template <typename _Tp> struct type_identity {
        using type = _Tp;
    };
    template <typename _Tp> using type_identity_t = typename type_identity<_Tp>::type;
    template <typename _Tp> struct unwrap_reference {
        using type = _Tp;
    };
    template <typename _Tp> struct unwrap_reference<reference_wrapper<_Tp>> {
        using type = _Tp &;
    };
    template <typename _Tp> using unwrap_reference_t = typename unwrap_reference<_Tp>::type;
    template <typename _Tp> struct unwrap_ref_decay {
        using type = unwrap_reference_t<decay_t<_Tp>>;
    };
    template <typename _Tp> using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
    template <typename _Tp> struct is_bounded_array : public __is_array_known_bounds<_Tp> {
    };
    template <typename _Tp> struct is_unbounded_array : public __is_array_unknown_bounds<_Tp> {
    };
    template <typename _Tp> constexpr bool is_bounded_array_v = is_bounded_array<_Tp>::value;
    template <typename _Tp> constexpr bool is_unbounded_array_v = is_unbounded_array<_Tp>::value;
    inline constexpr bool is_constant_evaluated() noexcept     {
        return __builtin_is_constant_evaluated();
    }
    template <typename _From, typename _To> using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;
    template <typename _Xp, typename _Yp> using __cond_res = decltype(false ? declval<_Xp (&)()>()() : declval<_Yp (&)()>()());
    template <typename _Ap, typename _Bp, typename = void> struct __common_ref_impl {
    };
template<> struct __common_ref_impl<const char *const &, const char *const &, void> {
        using type = __cond_res<__copy_cv<const char *const, const char *const> &, __copy_cv<const char *const, const char *const> &>;
    };
template<> struct __common_ref_impl<const char &, char &, void> {
        using type = __cond_res<__copy_cv<const char, char> &, __copy_cv<char, const char> &>;
    };
template<> struct __common_ref_impl<char &, const char &, void> {
        using type = __cond_res<__copy_cv<char, const char> &, __copy_cv<const char, char> &>;
    };
template<> struct __common_ref_impl<const char &, const char &&, void> : __common_ref_impl<const char &&, const char &> {
    };
template<> struct __common_ref_impl<const char &&, const char &, void> {
        using type = __common_ref_D<const char, const char>;
    };
template<> struct __common_ref_impl<const char &, const char &, void> {
        using type = __cond_res<__copy_cv<const char, const char> &, __copy_cv<const char, const char> &>;
    };
template<> struct __common_ref_impl<const unsigned long &, const unsigned long &, void> {
        using type = __cond_res<__copy_cv<const unsigned long, const unsigned long> &, __copy_cv<const unsigned long, const unsigned long> &>;
    };
template<> struct __common_ref_impl<const wchar_t *const &, const wchar_t *const &, void> {
        using type = __cond_res<__copy_cv<const wchar_t *const, const wchar_t *const> &, __copy_cv<const wchar_t *const, const wchar_t *const> &>;
    };
template<> struct __common_ref_impl<const wchar_t &, wchar_t &, void> {
        using type = __cond_res<__copy_cv<const wchar_t, wchar_t> &, __copy_cv<wchar_t, const wchar_t> &>;
    };
template<> struct __common_ref_impl<wchar_t &, const wchar_t &, void> {
        using type = __cond_res<__copy_cv<wchar_t, const wchar_t> &, __copy_cv<const wchar_t, wchar_t> &>;
    };
template<> struct __common_ref_impl<const wchar_t &, const wchar_t &&, void> : __common_ref_impl<const wchar_t &&, const wchar_t &> {
    };
template<> struct __common_ref_impl<const wchar_t &&, const wchar_t &, void> {
        using type = __common_ref_D<const wchar_t, const wchar_t>;
    };
template<> struct __common_ref_impl<const wchar_t &, const wchar_t &, void> {
        using type = __cond_res<__copy_cv<const wchar_t, const wchar_t> &, __copy_cv<const wchar_t, const wchar_t> &>;
    };
template<> struct __common_ref_impl<const char8_t *const &, const char8_t *const &, void> {
        using type = __cond_res<__copy_cv<const char8_t *const, const char8_t *const> &, __copy_cv<const char8_t *const, const char8_t *const> &>;
    };
template<> struct __common_ref_impl<const char8_t &, char8_t &, void> {
        using type = __cond_res<__copy_cv<const char8_t, char8_t> &, __copy_cv<char8_t, const char8_t> &>;
    };
template<> struct __common_ref_impl<char8_t &, const char8_t &, void> {
        using type = __cond_res<__copy_cv<char8_t, const char8_t> &, __copy_cv<const char8_t, char8_t> &>;
    };
template<> struct __common_ref_impl<const char8_t &, const char8_t &&, void> : __common_ref_impl<const char8_t &&, const char8_t &> {
    };
template<> struct __common_ref_impl<const char8_t &&, const char8_t &, void> {
        using type = __common_ref_D<const char8_t, const char8_t>;
    };
template<> struct __common_ref_impl<const char8_t &, const char8_t &, void> {
        using type = __cond_res<__copy_cv<const char8_t, const char8_t> &, __copy_cv<const char8_t, const char8_t> &>;
    };
template<> struct __common_ref_impl<const char16_t *const &, const char16_t *const &, void> {
        using type = __cond_res<__copy_cv<const char16_t *const, const char16_t *const> &, __copy_cv<const char16_t *const, const char16_t *const> &>;
    };
template<> struct __common_ref_impl<const char16_t &, char16_t &, void> {
        using type = __cond_res<__copy_cv<const char16_t, char16_t> &, __copy_cv<char16_t, const char16_t> &>;
    };
template<> struct __common_ref_impl<char16_t &, const char16_t &, void> {
        using type = __cond_res<__copy_cv<char16_t, const char16_t> &, __copy_cv<const char16_t, char16_t> &>;
    };
template<> struct __common_ref_impl<const char16_t &, const char16_t &&, void> : __common_ref_impl<const char16_t &&, const char16_t &> {
    };
template<> struct __common_ref_impl<const char16_t &&, const char16_t &, void> {
        using type = __common_ref_D<const char16_t, const char16_t>;
    };
template<> struct __common_ref_impl<const char16_t &, const char16_t &, void> {
        using type = __cond_res<__copy_cv<const char16_t, const char16_t> &, __copy_cv<const char16_t, const char16_t> &>;
    };
template<> struct __common_ref_impl<const char32_t *const &, const char32_t *const &, void> {
        using type = __cond_res<__copy_cv<const char32_t *const, const char32_t *const> &, __copy_cv<const char32_t *const, const char32_t *const> &>;
    };
template<> struct __common_ref_impl<const char32_t &, char32_t &, void> {
        using type = __cond_res<__copy_cv<const char32_t, char32_t> &, __copy_cv<char32_t, const char32_t> &>;
    };
template<> struct __common_ref_impl<char32_t &, const char32_t &, void> {
        using type = __cond_res<__copy_cv<char32_t, const char32_t> &, __copy_cv<const char32_t, char32_t> &>;
    };
template<> struct __common_ref_impl<const char32_t &, const char32_t &&, void> : __common_ref_impl<const char32_t &&, const char32_t &> {
    };
template<> struct __common_ref_impl<const char32_t &&, const char32_t &, void> {
        using type = __common_ref_D<const char32_t, const char32_t>;
    };
template<> struct __common_ref_impl<const char32_t &, const char32_t &, void> {
        using type = __cond_res<__copy_cv<const char32_t, const char32_t> &, __copy_cv<const char32_t, const char32_t> &>;
    };
    template <typename _Ap, typename _Bp> using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &, _Yp &, __void_t<__cond_res<__copy_cv<_Xp, _Yp> &, __copy_cv<_Yp, _Xp> &>>> {
        using type = __cond_res<__copy_cv<_Xp, _Yp> &, __copy_cv<_Yp, _Xp> &>;
    };
    template <typename _Xp, typename _Yp> using __common_ref_C = remove_reference_t<__common_ref<_Xp &, _Yp &>> &&;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &&, _Yp &&, _Require<is_convertible<_Xp &&, __common_ref_C<_Xp, _Yp>>, is_convertible<_Yp &&, __common_ref_C<_Xp, _Yp>>>> {
        using type = __common_ref_C<_Xp, _Yp>;
    };
    template <typename _Xp, typename _Yp> using __common_ref_D = __common_ref<const _Xp &, _Yp &>;
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &&, _Yp &, _Require<is_convertible<_Xp &&, __common_ref_D<_Xp, _Yp>>>> {
        using type = __common_ref_D<_Xp, _Yp>;
    };
    template <typename _Xp, typename _Yp> struct __common_ref_impl<_Xp &, _Yp &&> : __common_ref_impl<_Yp &&, _Xp &> {
    };
    template <typename _Tp, typename _Up, template <typename> class _TQual, template <typename> class _UQual> struct basic_common_reference {
    };
    template <typename _Tp> struct __xref {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up>;
    };
    template <typename _Tp> struct __xref<_Tp &> {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up> &;
    };
    template <typename _Tp> struct __xref<_Tp &&> {
        template <typename _Up> using __type = __copy_cv<_Tp, _Up> &&;
    };
    template <typename _Tp1, typename _Tp2> using __basic_common_ref = typename basic_common_reference<remove_cvref_t<_Tp1>, remove_cvref_t<_Tp2>, __xref<_Tp1>::template __type, __xref<_Tp2>::template __type>::type;
    template <typename ..._Tp> struct common_reference
template<> struct common_reference<<const char *const &, const char *const &>> : __common_reference_impl<const char *const &, const char *const &> {
    }
template<> struct common_reference<<const char &, char &>> : __common_reference_impl<const char &, char &> {
    }
template<> struct common_reference<<char &, const char &>> : __common_reference_impl<char &, const char &> {
    }
template<> struct common_reference<<const char &, const char &&>> : __common_reference_impl<const char &, const char &&> {
    }
template<> struct common_reference<<const char &&, const char &>> : __common_reference_impl<const char &&, const char &> {
    }
template<> struct common_reference<<const unsigned long &, const unsigned long &>> : __common_reference_impl<const unsigned long &, const unsigned long &> {
    }
template<> struct common_reference<<const wchar_t *const &, const wchar_t *const &>> : __common_reference_impl<const wchar_t *const &, const wchar_t *const &> {
    }
template<> struct common_reference<<const wchar_t &, wchar_t &>> : __common_reference_impl<const wchar_t &, wchar_t &> {
    }
template<> struct common_reference<<wchar_t &, const wchar_t &>> : __common_reference_impl<wchar_t &, const wchar_t &> {
    }
template<> struct common_reference<<const wchar_t &, const wchar_t &&>> : __common_reference_impl<const wchar_t &, const wchar_t &&> {
    }
template<> struct common_reference<<const wchar_t &&, const wchar_t &>> : __common_reference_impl<const wchar_t &&, const wchar_t &> {
    }
template<> struct common_reference<<const char8_t *const &, const char8_t *const &>> : __common_reference_impl<const char8_t *const &, const char8_t *const &> {
    }
template<> struct common_reference<<const char8_t &, char8_t &>> : __common_reference_impl<const char8_t &, char8_t &> {
    }
template<> struct common_reference<<char8_t &, const char8_t &>> : __common_reference_impl<char8_t &, const char8_t &> {
    }
template<> struct common_reference<<const char8_t &, const char8_t &&>> : __common_reference_impl<const char8_t &, const char8_t &&> {
    }
template<> struct common_reference<<const char8_t &&, const char8_t &>> : __common_reference_impl<const char8_t &&, const char8_t &> {
    }
template<> struct common_reference<<const char16_t *const &, const char16_t *const &>> : __common_reference_impl<const char16_t *const &, const char16_t *const &> {
    }
template<> struct common_reference<<const char16_t &, char16_t &>> : __common_reference_impl<const char16_t &, char16_t &> {
    }
template<> struct common_reference<<char16_t &, const char16_t &>> : __common_reference_impl<char16_t &, const char16_t &> {
    }
template<> struct common_reference<<const char16_t &, const char16_t &&>> : __common_reference_impl<const char16_t &, const char16_t &&> {
    }
template<> struct common_reference<<const char16_t &&, const char16_t &>> : __common_reference_impl<const char16_t &&, const char16_t &> {
    }
template<> struct common_reference<<const char32_t *const &, const char32_t *const &>> : __common_reference_impl<const char32_t *const &, const char32_t *const &> {
    }
template<> struct common_reference<<const char32_t &, char32_t &>> : __common_reference_impl<const char32_t &, char32_t &> {
    }
template<> struct common_reference<<char32_t &, const char32_t &>> : __common_reference_impl<char32_t &, const char32_t &> {
    }
template<> struct common_reference<<const char32_t &, const char32_t &&>> : __common_reference_impl<const char32_t &, const char32_t &&> {
    }
template<> struct common_reference<<const char32_t &&, const char32_t &>> : __common_reference_impl<const char32_t &&, const char32_t &> {
    };
    template <typename ..._Tp> using common_reference_t = typename common_reference<_Tp...>::type;
    template<> struct common_reference<> {
    };
    template <typename _Tp0> struct common_reference<_Tp0> {
        using type = _Tp0;
    };
    template <typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void> struct __common_reference_impl : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1> {
    };
template<> struct __common_reference_impl<const char *const &, const char *const &, 1, void> {
        using type = __common_ref<const char *const &, const char *const &>;
    };
template<> struct __common_reference_impl<const char &, char &, 1, void> {
        using type = __common_ref<const char &, char &>;
    };
template<> struct __common_reference_impl<char &, const char &, 1, void> {
        using type = __common_ref<char &, const char &>;
    };
template<> struct __common_reference_impl<const char &, const char &&, 1, void> {
        using type = __common_ref<const char &, const char &&>;
    };
template<> struct __common_reference_impl<const char &&, const char &, 1, void> {
        using type = __common_ref<const char &&, const char &>;
    };
template<> struct __common_reference_impl<const unsigned long &, const unsigned long &, 1, void> {
        using type = __common_ref<const unsigned long &, const unsigned long &>;
    };
template<> struct __common_reference_impl<const wchar_t *const &, const wchar_t *const &, 1, void> {
        using type = __common_ref<const wchar_t *const &, const wchar_t *const &>;
    };
template<> struct __common_reference_impl<const wchar_t &, wchar_t &, 1, void> {
        using type = __common_ref<const wchar_t &, wchar_t &>;
    };
template<> struct __common_reference_impl<wchar_t &, const wchar_t &, 1, void> {
        using type = __common_ref<wchar_t &, const wchar_t &>;
    };
template<> struct __common_reference_impl<const wchar_t &, const wchar_t &&, 1, void> {
        using type = __common_ref<const wchar_t &, const wchar_t &&>;
    };
template<> struct __common_reference_impl<const wchar_t &&, const wchar_t &, 1, void> {
        using type = __common_ref<const wchar_t &&, const wchar_t &>;
    };
template<> struct __common_reference_impl<const char8_t *const &, const char8_t *const &, 1, void> {
        using type = __common_ref<const char8_t *const &, const char8_t *const &>;
    };
template<> struct __common_reference_impl<const char8_t &, char8_t &, 1, void> {
        using type = __common_ref<const char8_t &, char8_t &>;
    };
template<> struct __common_reference_impl<char8_t &, const char8_t &, 1, void> {
        using type = __common_ref<char8_t &, const char8_t &>;
    };
template<> struct __common_reference_impl<const char8_t &, const char8_t &&, 1, void> {
        using type = __common_ref<const char8_t &, const char8_t &&>;
    };
template<> struct __common_reference_impl<const char8_t &&, const char8_t &, 1, void> {
        using type = __common_ref<const char8_t &&, const char8_t &>;
    };
template<> struct __common_reference_impl<const char16_t *const &, const char16_t *const &, 1, void> {
        using type = __common_ref<const char16_t *const &, const char16_t *const &>;
    };
template<> struct __common_reference_impl<const char16_t &, char16_t &, 1, void> {
        using type = __common_ref<const char16_t &, char16_t &>;
    };
template<> struct __common_reference_impl<char16_t &, const char16_t &, 1, void> {
        using type = __common_ref<char16_t &, const char16_t &>;
    };
template<> struct __common_reference_impl<const char16_t &, const char16_t &&, 1, void> {
        using type = __common_ref<const char16_t &, const char16_t &&>;
    };
template<> struct __common_reference_impl<const char16_t &&, const char16_t &, 1, void> {
        using type = __common_ref<const char16_t &&, const char16_t &>;
    };
template<> struct __common_reference_impl<const char32_t *const &, const char32_t *const &, 1, void> {
        using type = __common_ref<const char32_t *const &, const char32_t *const &>;
    };
template<> struct __common_reference_impl<const char32_t &, char32_t &, 1, void> {
        using type = __common_ref<const char32_t &, char32_t &>;
    };
template<> struct __common_reference_impl<char32_t &, const char32_t &, 1, void> {
        using type = __common_ref<char32_t &, const char32_t &>;
    };
template<> struct __common_reference_impl<const char32_t &, const char32_t &&, 1, void> {
        using type = __common_ref<const char32_t &, const char32_t &&>;
    };
template<> struct __common_reference_impl<const char32_t &&, const char32_t &, 1, void> {
        using type = __common_ref<const char32_t &&, const char32_t &>;
    };
    template <typename _Tp1, typename _Tp2> struct common_reference<_Tp1, _Tp2> : __common_reference_impl<_Tp1, _Tp2> {
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &, _Tp2 &, 1, void_t<__common_ref<_Tp1 &, _Tp2 &>>> {
        using type = __common_ref<_Tp1 &, _Tp2 &>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &&, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &&>>> {
        using type = __common_ref<_Tp1 &&, _Tp2 &&>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &, _Tp2 &&>>> {
        using type = __common_ref<_Tp1 &, _Tp2 &&>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1 &&, _Tp2 &, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &>>> {
        using type = __common_ref<_Tp1 &&, _Tp2 &>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 2, void_t<__basic_common_ref<_Tp1, _Tp2>>> {
        using type = __basic_common_ref<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 3, void_t<__cond_res<_Tp1, _Tp2>>> {
        using type = __cond_res<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 4, void_t<common_type_t<_Tp1, _Tp2>>> {
        using type = common_type_t<_Tp1, _Tp2>;
    };
    template <typename _Tp1, typename _Tp2> struct __common_reference_impl<_Tp1, _Tp2, 5, void> {
    };
    template <typename _Tp1, typename _Tp2, typename ..._Rest> struct common_reference<_Tp1, _Tp2, _Rest...> : __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>> {
    };
    template <typename _Tp1, typename _Tp2, typename ..._Rest> struct __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>, void_t<common_reference_t<_Tp1, _Tp2>>> : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...> {
    };
    constexpr bool is_object_v = is_object<const char>::value;
    constexpr bool is_object_v = is_object<char>::value;
    constexpr bool is_object_v = is_object<const wchar_t>::value;
    constexpr bool is_object_v = is_object<wchar_t>::value;
    constexpr bool is_object_v = is_object<const char8_t>::value;
    constexpr bool is_object_v = is_object<char8_t>::value;
    constexpr bool is_object_v = is_object<const char16_t>::value;
    constexpr bool is_object_v = is_object<const char32_t>::value;
    constexpr bool is_array_v = is_array<char>::value;
    constexpr bool is_trivial_v = is_trivial<char>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char>::value;
    constexpr bool is_same_v = __is_same(char, char);
    constexpr bool is_array_v = is_array<wchar_t>::value;
    constexpr bool is_trivial_v = is_trivial<wchar_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<wchar_t>::value;
    constexpr bool is_same_v = __is_same(wchar_t, wchar_t);
    constexpr bool is_array_v = is_array<char8_t>::value;
    constexpr bool is_trivial_v = is_trivial<char8_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char8_t>::value;
    constexpr bool is_same_v = __is_same(char8_t, char8_t);
    constexpr bool is_array_v = is_array<char16_t>::value;
    constexpr bool is_trivial_v = is_trivial<char16_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char16_t>::value;
    constexpr bool is_same_v = __is_same(char16_t, char16_t);
    constexpr bool is_array_v = is_array<char32_t>::value;
    constexpr bool is_trivial_v = is_trivial<char32_t>::value;
    constexpr bool is_standard_layout_v = is_standard_layout<char32_t>::value;
    constexpr bool is_same_v = __is_same(char32_t, char32_t);
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *>::value;
    constexpr bool is_object_v = is_object<const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *>::value;
    constexpr bool is_convertible_v = is_convertible<const char *, const char *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char *&>::value;
    constexpr bool is_same_v = __is_same(const char *const &, const char *const &);
    constexpr bool is_convertible_v = is_convertible<const char *const &, const char *const &>::value;
    constexpr bool is_same_v = __is_same(const char *&, const char *&);
    constexpr bool is_class_v = is_class<const char *>::value;
    constexpr bool is_union_v = is_union<const char *>::value;
    constexpr bool is_enum_v = is_enum<const char *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char *>::value;
    constexpr bool is_integral_v = is_integral<long>::value;
    constexpr bool is_signed_v = is_signed<long>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char &>::value;
    constexpr bool is_same_v = __is_same(const char &, const char &);
    constexpr bool is_class_v = is_class<const char *const>::value;
    constexpr bool is_union_v = is_union<const char *const>::value;
    constexpr bool is_enum_v = is_enum<const char *const>::value;
    constexpr bool is_same_v = __is_same(const char &&, const char &&);
    constexpr bool is_convertible_v = is_convertible<const char &, const char &>::value;
    constexpr bool is_convertible_v = is_convertible<char &, const char &>::value;
    constexpr bool is_convertible_v = is_convertible<const char &&, const char &>::value;
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile input_iterator_tag *>::value;
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile forward_iterator_tag *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char *&, const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char *const &, const char *>::value;
    constexpr bool is_constructible_v = is_constructible<const char *, const char *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char *const, const char *>::value;
    constexpr bool is_convertible_v = is_convertible<bool, bool>::value;
    constexpr bool is_same_v = __is_same(const char *, const char *);
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile bidirectional_iterator_tag *>::value;
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile random_access_iterator_tag *>::value;
    constexpr bool is_same_v = __is_same(long, long);
    constexpr bool is_convertible_v = is_convertible<const volatile contiguous_iterator_tag *, const volatile contiguous_iterator_tag *>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, unsigned long>::value;
    constexpr bool is_convertible_v = is_convertible<unsigned long, unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, unsigned long &>::value;
    constexpr bool is_convertible_v = is_convertible<unsigned long &, unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, const unsigned long &>::value;
    constexpr bool is_convertible_v = is_convertible<const unsigned long &, unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long, const unsigned long>::value;
    constexpr bool is_convertible_v = is_convertible<const unsigned long, unsigned long>::value;
    constexpr bool is_object_v = is_object<unsigned long>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<unsigned long &>::value;
    constexpr bool is_same_v = __is_same(const unsigned long &, const unsigned long &);
    constexpr bool is_convertible_v = is_convertible<const unsigned long &, const unsigned long &>::value;
    constexpr bool is_same_v = __is_same(unsigned long &, unsigned long &);
    constexpr bool is_class_v = is_class<unsigned long>::value;
    constexpr bool is_union_v = is_union<unsigned long>::value;
    constexpr bool is_enum_v = is_enum<unsigned long>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<unsigned long>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<unsigned long>::value;
    constexpr bool is_constructible_v = is_constructible<unsigned long>::value;
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *>::value;
    constexpr bool is_object_v = is_object<const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *, const wchar_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const wchar_t *&>::value;
    constexpr bool is_same_v = __is_same(const wchar_t *const &, const wchar_t *const &);
    constexpr bool is_convertible_v = is_convertible<const wchar_t *const &, const wchar_t *const &>::value;
    constexpr bool is_same_v = __is_same(const wchar_t *&, const wchar_t *&);
    constexpr bool is_class_v = is_class<const wchar_t *>::value;
    constexpr bool is_union_v = is_union<const wchar_t *>::value;
    constexpr bool is_enum_v = is_enum<const wchar_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const wchar_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const wchar_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const wchar_t &>::value;
    constexpr bool is_same_v = __is_same(const wchar_t &, const wchar_t &);
    constexpr bool is_class_v = is_class<const wchar_t *const>::value;
    constexpr bool is_union_v = is_union<const wchar_t *const>::value;
    constexpr bool is_enum_v = is_enum<const wchar_t *const>::value;
    constexpr bool is_same_v = __is_same(const wchar_t &&, const wchar_t &&);
    constexpr bool is_convertible_v = is_convertible<const wchar_t &, const wchar_t &>::value;
    constexpr bool is_convertible_v = is_convertible<wchar_t &, const wchar_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t &&, const wchar_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *&, const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *const &, const wchar_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const wchar_t *, const wchar_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const wchar_t *const, const wchar_t *>::value;
    constexpr bool is_same_v = __is_same(const wchar_t *, const wchar_t *);
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *>::value;
    constexpr bool is_object_v = is_object<const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *, const char8_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char8_t *&>::value;
    constexpr bool is_same_v = __is_same(const char8_t *const &, const char8_t *const &);
    constexpr bool is_convertible_v = is_convertible<const char8_t *const &, const char8_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char8_t *&, const char8_t *&);
    constexpr bool is_class_v = is_class<const char8_t *>::value;
    constexpr bool is_union_v = is_union<const char8_t *>::value;
    constexpr bool is_enum_v = is_enum<const char8_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char8_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char8_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char8_t &>::value;
    constexpr bool is_same_v = __is_same(const char8_t &, const char8_t &);
    constexpr bool is_class_v = is_class<const char8_t *const>::value;
    constexpr bool is_union_v = is_union<const char8_t *const>::value;
    constexpr bool is_enum_v = is_enum<const char8_t *const>::value;
    constexpr bool is_same_v = __is_same(const char8_t &&, const char8_t &&);
    constexpr bool is_convertible_v = is_convertible<const char8_t &, const char8_t &>::value;
    constexpr bool is_convertible_v = is_convertible<char8_t &, const char8_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t &&, const char8_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *&, const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *const &, const char8_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char8_t *, const char8_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char8_t *const, const char8_t *>::value;
    constexpr bool is_same_v = __is_same(const char8_t *, const char8_t *);
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *>::value;
    constexpr bool is_object_v = is_object<const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *, const char16_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char16_t *&>::value;
    constexpr bool is_same_v = __is_same(const char16_t *const &, const char16_t *const &);
    constexpr bool is_convertible_v = is_convertible<const char16_t *const &, const char16_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char16_t *&, const char16_t *&);
    constexpr bool is_class_v = is_class<const char16_t *>::value;
    constexpr bool is_union_v = is_union<const char16_t *>::value;
    constexpr bool is_enum_v = is_enum<const char16_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char16_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char16_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char16_t &>::value;
    constexpr bool is_same_v = __is_same(const char16_t &, const char16_t &);
    constexpr bool is_class_v = is_class<const char16_t *const>::value;
    constexpr bool is_union_v = is_union<const char16_t *const>::value;
    constexpr bool is_enum_v = is_enum<const char16_t *const>::value;
    constexpr bool is_same_v = __is_same(const char16_t &&, const char16_t &&);
    constexpr bool is_convertible_v = is_convertible<const char16_t &, const char16_t &>::value;
    constexpr bool is_convertible_v = is_convertible<char16_t &, const char16_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t &&, const char16_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *&, const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *const &, const char16_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char16_t *, const char16_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char16_t *const, const char16_t *>::value;
    constexpr bool is_same_v = __is_same(const char16_t *, const char16_t *);
    constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *>::value;
    constexpr bool is_object_v = is_object<const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *, const char32_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char32_t *&>::value;
    constexpr bool is_same_v = __is_same(const char32_t *const &, const char32_t *const &);
    constexpr bool is_convertible_v = is_convertible<const char32_t *const &, const char32_t *const &>::value;
    constexpr bool is_same_v = __is_same(const char32_t *&, const char32_t *&);
    constexpr bool is_class_v = is_class<const char32_t *>::value;
    constexpr bool is_union_v = is_union<const char32_t *>::value;
    constexpr bool is_enum_v = is_enum<const char32_t *>::value;
    constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<const char32_t *>::value;
    constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<const char32_t *>::value;
    constexpr bool is_lvalue_reference_v = is_lvalue_reference<const char32_t &>::value;
    constexpr bool is_same_v = __is_same(const char32_t &, const char32_t &);
    constexpr bool is_class_v = is_class<const char32_t *const>::value;
    constexpr bool is_union_v = is_union<const char32_t *const>::value;
    constexpr bool is_enum_v = is_enum<const char32_t *const>::value;
    constexpr bool is_same_v = __is_same(const char32_t &&, const char32_t &&);
    constexpr bool is_convertible_v = is_convertible<const char32_t &, const char32_t &>::value;
    constexpr bool is_convertible_v = is_convertible<char32_t &, const char32_t &>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t &&, const char32_t &>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *&>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *&, const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *const &>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *const &, const char32_t *>::value;
    constexpr bool is_constructible_v = is_constructible<const char32_t *, const char32_t *const>::value;
    constexpr bool is_convertible_v = is_convertible<const char32_t *const, const char32_t *>::value;
    constexpr bool is_same_v = __is_same(const char32_t *, const char32_t *);
}
namespace std {
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept     {
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &&__t) noexcept     {
        static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument substituting _Tp is an lvalue reference type");
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept     {
        return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
    }
    template <typename _Tp> struct __move_if_noexcept_cond : public __and_<__not_<is_nothrow_move_constructible<_Tp>>, is_copy_constructible<_Tp>>::type {
    };
    template <typename _Tp> constexpr typename conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept     {
        return std::move(__x);
    }
    template <typename _Tp> inline constexpr _Tp *addressof(_Tp &__r) noexcept     {
        return std::__addressof(__r);
    }
    template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete
    template <typename _Tp, typename _Up = _Tp> inline constexpr _Tp __exchange(_Tp &__obj, _Up &&__new_val)     {
        _Tp __old_val = std::move(__obj);
        __obj = std::forward<_Up>(__new_val);
        return __old_val;
    }
    template <typename _Tp> inline constexpr typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value>::type swap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::valueswap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)     {
        _Tp __tmp = std::move(__a);
        __a = std::move(__b);
        __b = std::move(__tmp);
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value)     {
        for (std::size_t __n = 0; __n < _Nm; ++__n)
            swap(__a[__n], __b[__n]);
    }
}
namespace std {
    namespace __detail {
        template <typename _Tp, typename _Up> concept __same_as = std::is_same_v<_Tp, _Up>;;
    }
    template <typename _Tp, typename _Up> concept same_as = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;;
    template <typename _Derived, typename _Base> concept derived_from = __is_base_of(_Base, _Derived) && is_convertible_v<const volatile _Derived *, const volatile _Base *>;;
    template <typename _From, typename _To> concept convertible_to = is_convertible_v<_From, _To> && requires (add_rvalue_reference_t<_From> (&__f)()) { static_cast<_To>(__f()); };;
    template <typename _Tp, typename _Up> concept common_reference_with = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> && convertible_to<_Tp, common_reference_t<_Tp, _Up>> && convertible_to<_Up, common_reference_t<_Tp, _Up>>;;
    template <typename _Tp, typename _Up> concept common_with = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>> && requires { static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>()); static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>()); } && common_reference_with<add_lvalue_reference_t<const _Tp>, add_lvalue_reference_t<const _Up>> && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>, common_reference_t<add_lvalue_reference_t<const _Tp>, add_lvalue_reference_t<const _Up>>>;;
    template <typename _Tp> concept integral = is_integral_v<_Tp>;;
    template <typename _Tp> concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;;
    template <typename _Tp> concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;;
    template <typename _Tp> concept floating_point = is_floating_point_v<_Tp>;;
    namespace __detail {
        template <typename _Tp> using __cref = const remove_reference_t<_Tp> &;
        template <typename _Tp> concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;;
    }
    template <typename _Lhs, typename _Rhs> concept assignable_from = is_lvalue_reference_v<_Lhs> && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>> && requires (_Lhs __lhs, _Rhs &&__rhs) { { __lhs = static_cast<_Rhs &&>(__rhs) } -> same_as<_Lhs>; };;
    template <typename _Tp> concept destructible = is_nothrow_destructible_v<_Tp>;;
    template <typename _Tp, typename ..._Args> concept constructible_from = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;;
    template <typename _Tp> concept default_initializable = constructible_from<_Tp> && requires { _Tp({}); (void)::new _Tp; };;
    template <typename _Tp> concept move_constructible = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;;
    template <typename _Tp> concept copy_constructible = move_constructible<_Tp> && constructible_from<_Tp, _Tp &> && convertible_to<_Tp &, _Tp> && constructible_from<_Tp, const _Tp &> && convertible_to<const _Tp &, _Tp> && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;;
    namespace ranges {
        namespace __cust_swap {
            template <typename _Tp> void swap(_Tp &, _Tp &) = delete
            template <typename _Tp, typename _Up> concept __adl_swap = (__detail::__class_or_enum<remove_reference_t<_Tp>> || __detail::__class_or_enum<remove_reference_t<_Up>>) && requires (_Tp &&__t, _Up &&__u) { swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); };;
            struct _Swap {
            private:
                template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()                 {
                    if (__adl_swap<_Tp, _Up>)
                        return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<_Tp>> && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
                }
                template<> static constexpr bool _S_noexcept<const char *&, const char *&>()                 {
                    if (__adl_swap<const char *&, const char *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char *&>>;
                }
                template<> static constexpr bool _S_noexcept<unsigned long &, unsigned long &>()                 {
                    if (__adl_swap<unsigned long &, unsigned long &>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<unsigned long &>> && is_nothrow_move_assignable_v<remove_reference_t<unsigned long &>>;
                }
                template<> static constexpr bool _S_noexcept<const wchar_t *&, const wchar_t *&>()                 {
                    if (__adl_swap<const wchar_t *&, const wchar_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const wchar_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const wchar_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char8_t *&, const char8_t *&>()                 {
                    if (__adl_swap<const char8_t *&, const char8_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char8_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char8_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char16_t *&, const char16_t *&>()                 {
                    if (__adl_swap<const char16_t *&, const char16_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char16_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char16_t *&>>;
                }
                template<> static constexpr bool _S_noexcept<const char32_t *&, const char32_t *&>()                 {
                    if (__adl_swap<const char32_t *&, const char32_t *&>)
                        ;
                    else
                        return is_nothrow_move_constructible_v<remove_reference_t<const char32_t *&>> && is_nothrow_move_assignable_v<remove_reference_t<const char32_t *&>>;
                }
            public:
                template <typename _Tp, typename _Up> constexpr void operator()(_Tp &&__t, _Up &&__u) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__t, _Up &&__u) const noexcept(_S_noexcept<_Tp, _Up>())                 {
                    if (__adl_swap<_Tp, _Up>)
                        swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
                    else {
                        auto __tmp = static_cast<remove_reference_t<_Tp> &&>(__t);
                        __t = static_cast<remove_reference_t<_Tp> &&>(__u);
                        __u = static_cast<remove_reference_t<_Tp> &&>(__tmp);
                    }
                }
                template<> constexpr void operator()<const char *&, const char *&>(const char *&__t, const char *&__u) const noexcept(_S_noexcept<const char *&, const char *&>()operator()<const char *&, const char *&>(const char *&__t, const char *&__u) const noexcept(_S_noexcept<const char *&, const char *&>())                template<> constexpr void operator()<unsigned long &, unsigned long &>(unsigned long &__t, unsigned long &__u) const noexcept(_S_noexcept<unsigned long &, unsigned long &>()operator()<unsigned long &, unsigned long &>(unsigned long &__t, unsigned long &__u) const noexcept(_S_noexcept<unsigned long &, unsigned long &>())                template<> constexpr void operator()<const wchar_t *&, const wchar_t *&>(const wchar_t *&__t, const wchar_t *&__u) const noexcept(_S_noexcept<const wchar_t *&, const wchar_t *&>()operator()<const wchar_t *&, const wchar_t *&>(const wchar_t *&__t, const wchar_t *&__u) const noexcept(_S_noexcept<const wchar_t *&, const wchar_t *&>())                template<> constexpr void operator()<const char8_t *&, const char8_t *&>(const char8_t *&__t, const char8_t *&__u) const noexcept(_S_noexcept<const char8_t *&, const char8_t *&>()operator()<const char8_t *&, const char8_t *&>(const char8_t *&__t, const char8_t *&__u) const noexcept(_S_noexcept<const char8_t *&, const char8_t *&>())                template<> constexpr void operator()<const char16_t *&, const char16_t *&>(const char16_t *&__t, const char16_t *&__u) const noexcept(_S_noexcept<const char16_t *&, const char16_t *&>()operator()<const char16_t *&, const char16_t *&>(const char16_t *&__t, const char16_t *&__u) const noexcept(_S_noexcept<const char16_t *&, const char16_t *&>())                template<> constexpr void operator()<const char32_t *&, const char32_t *&>(const char32_t *&__t, const char32_t *&__u) const noexcept(_S_noexcept<const char32_t *&, const char32_t *&>()operator()<const char32_t *&, const char32_t *&>(const char32_t *&__t, const char32_t *&__u) const noexcept(_S_noexcept<const char32_t *&, const char32_t *&>())                template <typename _Tp, typename _Up, std::size_t _Num> constexpr void operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const noexcept(noexcept(std::declval<const std::ranges::__cust_swap::_Swap &>()(*__e1, *__e2))operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const noexcept(noexcept(std::declval<const std::ranges::__cust_swap::_Swap &>()(*__e1, *__e2)))                 {
                    for (std::size_t __n = 0; __n < _Num; ++__n)
                        (*this)(__e1[__n], __e2[__n]);
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_swap::_Swap swap{};
        }
    }
    template <typename _Tp> concept swappable = requires (_Tp &__a, _Tp &__b) { ranges::swap(__a, __b); };;
    template <typename _Tp, typename _Up> concept swappable_with = common_reference_with<_Tp, _Up> && requires (_Tp &&__t, _Up &&__u) { ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Tp &&>(__t)); ranges::swap(static_cast<_Up &&>(__u), static_cast<_Up &&>(__u)); ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); ranges::swap(static_cast<_Up &&>(__u), static_cast<_Tp &&>(__t)); };;
    template <typename _Tp> concept movable = is_object_v<_Tp> && move_constructible<_Tp> && assignable_from<_Tp &, _Tp> && swappable<_Tp>;;
    template <typename _Tp> concept copyable = copy_constructible<_Tp> && movable<_Tp> && assignable_from<_Tp &, _Tp &> && assignable_from<_Tp &, const _Tp &> && assignable_from<_Tp &, const _Tp>;;
    template <typename _Tp> concept semiregular = copyable<_Tp> && default_initializable<_Tp>;;
    namespace __detail {
        template <typename _Tp> concept __boolean_testable_impl = convertible_to<_Tp, bool>;;
        template <typename _Tp> concept __boolean_testable = __boolean_testable_impl<_Tp> && requires (_Tp &&__t) { { !static_cast<_Tp &&>(__t) } -> __boolean_testable_impl; };;
    }
    namespace __detail {
        template <typename _Tp, typename _Up> concept __weakly_eq_cmp_with = requires (__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) { { __t == __u } -> __boolean_testable; { __t != __u } -> __boolean_testable; { __u == __t } -> __boolean_testable; { __u != __t } -> __boolean_testable; };;
    }
    template <typename _Tp> concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;;
    template <typename _Tp, typename _Up> concept equality_comparable_with = equality_comparable<_Tp> && equality_comparable<_Up> && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>> && equality_comparable<common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> && __detail::__weakly_eq_cmp_with<_Tp, _Up>;;
    namespace __detail {
        template <typename _Tp, typename _Up> concept __partially_ordered_with = requires (const remove_reference_t<_Tp> &__t, const remove_reference_t<_Up> &__u) { { __t < __u } -> __boolean_testable; { __t > __u } -> __boolean_testable; { __t <= __u } -> __boolean_testable; { __t >= __u } -> __boolean_testable; { __u < __t } -> __boolean_testable; { __u > __t } -> __boolean_testable; { __u <= __t } -> __boolean_testable; { __u >= __t } -> __boolean_testable; };;
    }
    template <typename _Tp> concept totally_ordered = equality_comparable<_Tp> && __detail::__partially_ordered_with<_Tp, _Tp>;;
    template <typename _Tp, typename _Up> concept totally_ordered_with = totally_ordered<_Tp> && totally_ordered<_Up> && equality_comparable_with<_Tp, _Up> && totally_ordered<common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> && __detail::__partially_ordered_with<_Tp, _Up>;;
    template <typename _Tp> concept regular = semiregular<_Tp> && equality_comparable<_Tp>;;
    template <typename _Fn, typename ..._Args> concept invocable = is_invocable_v<_Fn, _Args...>;;
    template <typename _Fn, typename ..._Args> concept regular_invocable = invocable<_Fn, _Args...>;;
    template <typename _Fn, typename ..._Args> concept predicate = regular_invocable<_Fn, _Args...> && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;;
    template <typename _Rel, typename _Tp, typename _Up> concept relation = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up> && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;;
    template <typename _Rel, typename _Tp, typename _Up> concept equivalence_relation = relation<_Rel, _Tp, _Up>;;
    template <typename _Rel, typename _Tp, typename _Up> concept strict_weak_order = relation<_Rel, _Tp, _Up>;;
}
namespace std {
    namespace __cmp_cat {
        using type = signed char;
        enum class _Ord : std::__cmp_cat::type {
            equivalent = 0,
            less = -1,
            greater = 1
        };
        enum class _Ncmp : std::__cmp_cat::type {
            _Unordered = 2
        };
        struct __unspec {
            constexpr __unspec(std::__cmp_cat::__unspec *) noexcept             {
            }
        };
    }
    class partial_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit partial_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
        constexpr explicit partial_ordering(__cmp_cat::_Ncmp __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
        friend  class weak_ordering;
        friend  class strong_ordering;
    public:
        static const std::partial_ordering less;
        static const std::partial_ordering equivalent;
        static const std::partial_ordering greater;
        static const std::partial_ordering unordered;
        friend constexpr bool operator==(std::partial_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value == 0;
        }
;
        friend bool operator==(std::partial_ordering, std::partial_ordering) noexcept = default;
        friend constexpr bool operator<(std::partial_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value == -1;
        }
;
        friend constexpr bool operator>(std::partial_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value == 1;
        }
;
        friend constexpr bool operator<=(std::partial_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(std::partial_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, std::partial_ordering __v) noexcept         {
            return __v._M_value == 1;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, std::partial_ordering __v) noexcept         {
            return __v._M_value == -1;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, std::partial_ordering __v) noexcept         {
            return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, std::partial_ordering __v) noexcept         {
            return 0 >= __v._M_value;
        }
;
        friend constexpr std::partial_ordering operator<=>(std::partial_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v;
        }
;
        friend constexpr std::partial_ordering operator<=>(__cmp_cat::__unspec, std::partial_ordering __v) noexcept         {
            if (__v._M_value & 1)
                return std::partial_ordering(__cmp_cat::_Ord(-__v._M_value));
            else
                return __v;
        }
;
    };
    constexpr std::partial_ordering less(__cmp_cat::_Ord::less);
    constexpr std::partial_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr std::partial_ordering greater(__cmp_cat::_Ord::greater);
    constexpr std::partial_ordering unordered(__cmp_cat::_Ncmp::_Unordered);
    class weak_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
        friend  class strong_ordering;
    public:
        static const std::weak_ordering less;
        static const std::weak_ordering equivalent;
        static const std::weak_ordering greater;
        constexpr operator partial_ordering() const noexcept         {
            return std::partial_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        friend constexpr bool operator==(std::weak_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value == 0;
        }
;
        friend bool operator==(std::weak_ordering, std::weak_ordering) noexcept = default;
        friend constexpr bool operator<(std::weak_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value < 0;
        }
;
        friend constexpr bool operator>(std::weak_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value > 0;
        }
;
        friend constexpr bool operator<=(std::weak_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(std::weak_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value >= 0;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, std::weak_ordering __v) noexcept         {
            return 0 < __v._M_value;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, std::weak_ordering __v) noexcept         {
            return 0 > __v._M_value;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, std::weak_ordering __v) noexcept         {
            return 0 <= __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, std::weak_ordering __v) noexcept         {
            return 0 >= __v._M_value;
        }
;
        friend constexpr std::weak_ordering operator<=>(std::weak_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v;
        }
;
        friend constexpr std::weak_ordering operator<=>(__cmp_cat::__unspec, std::weak_ordering __v) noexcept         {
            return std::weak_ordering(__cmp_cat::_Ord(-__v._M_value));
        }
;
    };
    constexpr std::weak_ordering less(__cmp_cat::_Ord::less);
    constexpr std::weak_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr std::weak_ordering greater(__cmp_cat::_Ord::greater);
    class strong_ordering {
        __cmp_cat::type _M_value;
        constexpr explicit strong_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))         {
        }
    public:
        static const std::strong_ordering less;
        static const std::strong_ordering equal;
        static const std::strong_ordering equivalent;
        static const std::strong_ordering greater;
        constexpr operator partial_ordering() const noexcept         {
            return std::partial_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        constexpr operator weak_ordering() const noexcept         {
            return std::weak_ordering(__cmp_cat::_Ord(this->_M_value));
        }
        friend constexpr bool operator==(std::strong_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value == 0;
        }
;
        friend bool operator==(std::strong_ordering, std::strong_ordering) noexcept = default;
        friend constexpr bool operator<(std::strong_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value < 0;
        }
;
        friend constexpr bool operator>(std::strong_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value > 0;
        }
;
        friend constexpr bool operator<=(std::strong_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value <= 0;
        }
;
        friend constexpr bool operator>=(std::strong_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v._M_value >= 0;
        }
;
        friend constexpr bool operator<(__cmp_cat::__unspec, std::strong_ordering __v) noexcept         {
            return 0 < __v._M_value;
        }
;
        friend constexpr bool operator>(__cmp_cat::__unspec, std::strong_ordering __v) noexcept         {
            return 0 > __v._M_value;
        }
;
        friend constexpr bool operator<=(__cmp_cat::__unspec, std::strong_ordering __v) noexcept         {
            return 0 <= __v._M_value;
        }
;
        friend constexpr bool operator>=(__cmp_cat::__unspec, std::strong_ordering __v) noexcept         {
            return 0 >= __v._M_value;
        }
;
        friend constexpr std::strong_ordering operator<=>(std::strong_ordering __v, __cmp_cat::__unspec) noexcept         {
            return __v;
        }
;
        friend constexpr std::strong_ordering operator<=>(__cmp_cat::__unspec, std::strong_ordering __v) noexcept         {
            return std::strong_ordering(__cmp_cat::_Ord(-__v._M_value));
        }
;
    };
    constexpr std::strong_ordering less(__cmp_cat::_Ord::less);
    constexpr std::strong_ordering equal(__cmp_cat::_Ord::equivalent);
    constexpr std::strong_ordering equivalent(__cmp_cat::_Ord::equivalent);
    constexpr std::strong_ordering greater(__cmp_cat::_Ord::greater);
    constexpr bool is_eq(std::partial_ordering __cmp) noexcept     {
        return __cmp == 0;
    }
    constexpr bool is_neq(std::partial_ordering __cmp) noexcept     {
        return __cmp != 0;
    }
    constexpr bool is_lt(std::partial_ordering __cmp) noexcept     {
        return __cmp < 0;
    }
    constexpr bool is_lteq(std::partial_ordering __cmp) noexcept     {
        return __cmp <= 0;
    }
    constexpr bool is_gt(std::partial_ordering __cmp) noexcept     {
        return __cmp > 0;
    }
    constexpr bool is_gteq(std::partial_ordering __cmp) noexcept     {
        return __cmp >= 0;
    }
    namespace __detail {
        template <typename _Tp> constexpr unsigned int __cmp_cat_id = 1;
        constexpr unsigned int __cmp_cat_id = 2;
        constexpr unsigned int __cmp_cat_id = 4;
        constexpr unsigned int __cmp_cat_id = 8;
        template <typename ..._Ts> constexpr auto __common_cmp_cat()         {
            constexpr unsigned int __cats = (__cmp_cat_id<_Ts> | ...);
            if (__cats & 1)
                return;
            else if (bool(__cats & __cmp_cat_id<std::partial_ordering>))
                return partial_ordering::equivalent;
            else if (bool(__cats & __cmp_cat_id<std::weak_ordering>))
                return weak_ordering::equivalent;
            else
                return strong_ordering::equivalent;
        }
    }
    template <typename ..._Ts> struct common_comparison_category {
        using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };
    template <typename _Tp> struct common_comparison_category<_Tp> {
        using type = void;
    };
    template<> struct common_comparison_category<std::partial_ordering> {
        using type = std::partial_ordering;
    };
    template<> struct common_comparison_category<std::weak_ordering> {
        using type = std::weak_ordering;
    };
    template<> struct common_comparison_category<std::strong_ordering> {
        using type = std::strong_ordering;
    };
    template<> struct common_comparison_category<> {
        using type = std::strong_ordering;
    };
    template <typename ..._Ts> using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;
    namespace __detail {
        template <typename _Tp, typename _Cat> concept __compares_as = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;;
    }
    template <typename _Tp, typename _Cat = std::partial_ordering> concept three_way_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp> && __detail::__partially_ordered_with<_Tp, _Tp> && requires (const remove_reference_t<_Tp> &__a, const remove_reference_t<_Tp> &__b) { { __a <=> __b } -> __detail::__compares_as<_Cat>; };;
    template <typename _Tp, typename _Up, typename _Cat = std::partial_ordering> concept three_way_comparable_with = three_way_comparable<_Tp, _Cat> && three_way_comparable<_Up, _Cat> && common_reference_with<const remove_reference_t<_Tp> &, const remove_reference_t<_Up> &> && three_way_comparable<common_reference_t<const remove_reference_t<_Tp> &, const remove_reference_t<_Up> &>, _Cat> && __detail::__weakly_eq_cmp_with<_Tp, _Up> && __detail::__partially_ordered_with<_Tp, _Up> && requires (const remove_reference_t<_Tp> &__t, const remove_reference_t<_Up> &__u) { { __t <=> __u } -> __detail::__compares_as<_Cat>; { __u <=> __t } -> __detail::__compares_as<_Cat>; };;
    namespace __detail {
        template <typename _Tp, typename _Up> using __cmp3way_res_t = decltype(std::declval<_Tp>() <=> std::declval<_Up>());
        template <typename _Tp, typename _Up> struct __cmp3way_res_impl {
        };
        template <typename _Tp, typename _Up> struct __cmp3way_res_impl<_Tp, _Up> {
            using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
        };
    }
    template <typename _Tp, typename _Up = _Tp> struct compare_three_way_result : __detail::__cmp3way_res_impl<_Tp, _Up> {
    };
    template <typename _Tp, typename _Up = _Tp> using compare_three_way_result_t = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;
    namespace __detail {
        template <typename _Tp, typename _Up> concept __3way_builtin_ptr_cmp = requires (_Tp &&__t, _Up &&__u) { static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u); } && convertible_to<_Tp, const volatile void *> && convertible_to<_Up, const volatile void *> && !requires (_Tp &&__t, _Up &&__u) { operator<=>(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); } && !requires (_Tp &&__t, _Up &&__u) { static_cast<_Tp &&>(__t).operator<=>(static_cast<_Up &&>(__u)); };;
    }
    struct compare_three_way {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>()))         {
            if (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>) {
                auto __pt = static_cast<const volatile void *>(__t);
                auto __pu = static_cast<const volatile void *>(__u);
                if (__builtin_is_constant_evaluated())
                    return __pt <=> __pu;
                auto __it = reinterpret_cast<unsigned long>(__pt);
                auto __iu = reinterpret_cast<unsigned long>(__pu);
                return __it <=> __iu;
            } else
                return static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u);
        }
        using is_transparent = void;
    };
    namespace __cmp_cust {
        template <floating_point _Tp> constexpr std::weak_ordering __fp_weak_ordering(_Tp __e, _Tp __f)         {
            auto __cat = [](_Tp __fp) -> int {
                const int __sign = __builtin_signbit(__fp) ? -1 : 1;
                if (__builtin_isnormal(__fp))
                    return (__fp == 0 ? 1 : 3) * __sign;
                if (__builtin_isnan(__fp))
                    return 5 * __sign;
                if (int __inf = __builtin_isinf_sign(__fp))
                    return 4 * __inf;
                return 2 * __sign;
            };
            auto __po = __e <=> __f;
            if (is_lt(__po))
                return weak_ordering::less;
            else if (is_gt(__po))
                return weak_ordering::greater;
            else if (__po == partial_ordering::equivalent)
                return weak_ordering::equivalent;
            else {
                auto __isnan_sign = [](_Tp __fp) -> int {
                    return __builtin_isnan(__fp) ? __builtin_signbit(__fp) ? -1 : 1 : 0;
                };
                auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
                if (is_eq(__ord))
                    return weak_ordering::equivalent;
                else if (is_lt(__ord))
                    return weak_ordering::less;
                else
                    return weak_ordering::greater;
            }
        }
        template <typename _Tp, typename _Up> concept __adl_strong = requires (_Tp &&__t, _Up &&__u) { std::strong_ordering(strong_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Tp, typename _Up> concept __adl_weak = requires (_Tp &&__t, _Up &&__u) { std::weak_ordering(weak_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Tp, typename _Up> concept __adl_partial = requires (_Tp &&__t, _Up &&__u) { std::partial_ordering(partial_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Ord, typename _Tp, typename _Up> concept __cmp3way = requires (_Tp &&__t, _Up &&__u, std::compare_three_way __c) { _Ord(__c(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u))); };;
        template <typename _Tp, typename _Up> concept __strongly_ordered = __adl_strong<_Tp, _Up> || __cmp3way<std::strong_ordering, _Tp, _Up>;;
        class _Strong_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (floating_point<decay_t<_Tp>>)
                    return true;
                else if (__adl_strong<_Tp, _Up>)
                    return noexcept(std::strong_ordering(strong_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<std::strong_ordering, _Tp, _Up>)
                    return noexcept(std::compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
            }
            friend  class _Weak_order;
            friend  class _Strong_fallback;
        public:
            template <typename _Tp, typename _Up> constexpr std::strong_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>())             {
                static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
                if (__adl_strong<_Tp, _Up>)
                    return std::strong_ordering(strong_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<std::strong_ordering, _Tp, _Up>)
                    return std::compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __weakly_ordered = floating_point<remove_reference_t<_Tp>> || __adl_weak<_Tp, _Up> || __cmp3way<std::weak_ordering, _Tp, _Up> || __strongly_ordered<_Tp, _Up>;;
        class _Weak_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (floating_point<decay_t<_Tp>>)
                    return true;
                else if (__adl_weak<_Tp, _Up>)
                    return noexcept(std::weak_ordering(weak_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<std::weak_ordering, _Tp, _Up>)
                    return noexcept(std::compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
                else if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order::_S_noexcept<_Tp, _Up>();
            }
            friend  class _Partial_order;
            friend  class _Weak_fallback;
        public:
            template <typename _Tp, typename _Up> constexpr std::weak_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>())             {
                static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
                if (floating_point<decay_t<_Tp>>)
                    return __cmp_cust::__fp_weak_ordering(__e, __f);
                else if (__adl_weak<_Tp, _Up>)
                    return std::weak_ordering(weak_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<std::weak_ordering, _Tp, _Up>)
                    return std::compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__strongly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Strong_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __partially_ordered = __adl_partial<_Tp, _Up> || __cmp3way<std::partial_ordering, _Tp, _Up> || __weakly_ordered<_Tp, _Up>;;
        class _Partial_order {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__adl_partial<_Tp, _Up>)
                    return noexcept(std::partial_ordering(partial_order(std::declval<_Tp>(), std::declval<_Up>())));
                else if (__cmp3way<std::partial_ordering, _Tp, _Up>)
                    return noexcept(std::compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
                else if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order::_S_noexcept<_Tp, _Up>();
            }
            friend  class _Partial_fallback;
        public:
            template <typename _Tp, typename _Up> constexpr std::partial_ordering operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>())             {
                static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
                if (__adl_partial<_Tp, _Up>)
                    return std::partial_ordering(partial_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
                else if (__cmp3way<std::partial_ordering, _Tp, _Up>)
                    return std::compare_three_way()(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__weakly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Weak_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
            }
        };
        template <typename _Tp, typename _Up> concept __op_eq_lt = requires (_Tp &&__t, _Up &&__u) { { static_cast<_Tp &&>(__t) == static_cast<_Up &&>(__u) } -> convertible_to<bool>; { static_cast<_Tp &&>(__t) < static_cast<_Up &&>(__u) } -> convertible_to<bool>; };;
        class _Strong_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__strongly_ordered<_Tp, _Up>)
                    return _Strong_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, typename _Up> constexpr decltype(auto) operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>())             {
                static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
                if (__strongly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Strong_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__op_eq_lt<_Tp, _Up>)
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? strong_ordering::equal : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? strong_ordering::less : strong_ordering::greater;
            }
        };
        class _Weak_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__weakly_ordered<_Tp, _Up>)
                    return _Weak_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, typename _Up> constexpr decltype(auto) operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>())             {
                static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
                if (__weakly_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Weak_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__op_eq_lt<_Tp, _Up>)
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? weak_ordering::equivalent : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? weak_ordering::less : weak_ordering::greater;
            }
        };
        class _Partial_fallback {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()             {
                if (__partially_ordered<_Tp, _Up>)
                    return _Partial_order::_S_noexcept<_Tp, _Up>();
                else
                    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
            }
        public:
            template <typename _Tp, typename _Up> constexpr decltype(auto) operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e, _Up &&__f) const noexcept(_S_noexcept<_Tp, _Up>())             {
                static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);
                if (__partially_ordered<_Tp, _Up>)
                    return std::__cmp_cust::_Partial_order{}(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f));
                else if (__op_eq_lt<_Tp, _Up>)
                    return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f) ? partial_ordering::equivalent : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f) ? partial_ordering::less : static_cast<_Up &&>(__f) < static_cast<_Tp &&>(__e) ? partial_ordering::greater : partial_ordering::unordered;
            }
        };
    }
    inline namespace __cmp_alg {
        constexpr __cmp_cust::_Strong_order strong_order{};
        constexpr __cmp_cust::_Weak_order weak_order{};
        constexpr __cmp_cust::_Partial_order partial_order{};
        constexpr __cmp_cust::_Strong_fallback compare_strong_order_fallback{};
        constexpr __cmp_cust::_Weak_fallback compare_weak_order_fallback{};
        constexpr __cmp_cust::_Partial_fallback compare_partial_order_fallback{};
    }
    namespace __detail {
        constexpr struct _Synth3way {
            template <typename _Tp, typename _Up> static constexpr bool _S_noexcept(const _Tp *__t = nullptr, const _Up *__u = nullptr)             {
                if (three_way_comparable_with<_Tp, _Up>)
                    return noexcept(*__t <=> *__u);
                else
                    return noexcept(*__t < *__u) && noexcept(*__u < *__t);
            }
            template <typename _Tp, typename _Up> constexpr auto operator()(const _Tp &__t, const _Up &__u) const noexcept(_S_noexcept<_Tp, _Up>()operator()(const _Tp &__t, const _Up &__u) const noexcept(_S_noexcept<_Tp, _Up>()) requires requires { { __t < __u } -> __boolean_testable; { __u < __t } -> __boolean_testable; }             {
                if (three_way_comparable_with<_Tp, _Up>)
                    return __t <=> __u;
                else {
                    if (__t < __u)
                        return weak_ordering::less;
                    else if (__u < __t)
                        return weak_ordering::greater;
                    else
                        return weak_ordering::equivalent;
                }
            }
        } __synth3way = {};
        template <typename _Tp, typename _Up = _Tp> using __synth3way_t = decltype(__detail::__synth3way(std::declval<_Tp &>(), std::declval<_Up &>()));
    }
}
namespace std {
    struct piecewise_construct_t {
        explicit piecewise_construct_t() noexcept = default
    };
    constexpr std::piecewise_construct_t piecewise_construct = std::piecewise_construct_t();
    template <typename ...> class tuple;
    template <std::size_t ...> struct _Index_tuple;
    template <bool, typename _T1, typename _T2> struct _PCC {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair()         {
            return __and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, const _U2 &>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair()         {
            return __and_<is_convertible<const _U1 &, _T1>, is_convertible<const _U2 &, _T2>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair()         {
            return __and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, _U2 &&>>::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair()         {
            return __and_<is_convertible<_U1 &&, _T1>, is_convertible<_U2 &&, _T2>>::value;
        }
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _CopyMovePair()         {
            using __do_converts = __and_<is_convertible<const _U1 &, _T1>, is_convertible<_U2 &&, _T2>>;
            using __converts = typename conditional<__implicit, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, _U2 &&>, __converts>::value;
        }
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _MoveCopyPair()         {
            using __do_converts = __and_<is_convertible<_U1 &&, _T1>, is_convertible<const _U2 &, _T2>>;
            using __converts = typename conditional<__implicit, __do_converts, __not_<__do_converts>>::type;
            return __and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, const _U2 &&>, __converts>::value;
        }
    };
    template <typename _T1, typename _T2> struct _PCC<false, _T1, _T2> {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair()         {
            return false;
        }
    };
    template <typename _U1, typename _U2> class __pair_base {
        friend template <typename _T1, typename _T2> struct pair;
        __pair_base<_U1, _U2>() = default
        ~__pair_base<_U1, _U2>() = default
        __pair_base<_U1, _U2>(const __pair_base<_U1, _U2> &) = default
        __pair_base<_U1, _U2> &operator=(const __pair_base<_U1, _U2> &) = delete
    };
    template <typename _T1, typename _T2> struct pair : private __pair_base<_T1, _T2> {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>::value, bool>::type = true> constexpr pair<_T1, _T2>() : first(), second()         {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2>>>>::value, bool>::type = false> constexpr explicit pair<_T1, _T2>() : first(), second()         {
        }
        using _PCCP = _PCC<true, _T1, _T2>;
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b)         {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b)         {
        }
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<_T1, _U1>::value || !is_same<_T2, _U2>::value, _T1, _T2>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)         {
        }
        pair<_T1, _T2>(const pair<_T1, _T2> &) = default
        pair<_T1, _T2>(pair<_T1, _T2> &&) = default
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<true, _U1, _T2>(), bool>::type = true> constexpr pair<_T1, _T2>(_U1 &&__x, const _T2 &__y) : first(std::forward<_U1>(__x)), second(__y)         {
        }
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<false, _U1, _T2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, const _T2 &__y) : first(std::forward<_U1>(__x)), second(__y)         {
        }
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<true, _T1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward<_U2>(__y))         {
        }
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<false, _T1, _U2>(), bool>::type = false> explicit pair<_T1, _T2>(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))         {
        }
        template <typename ..._Args1, typename ..._Args2> constexpr pair<_T1, _T2>(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        constexpr pair<_T1, _T2> &operator=(typename conditional<__and_<is_copy_assignable<_T1>, is_copy_assignable<_T2>>::value, const pair<_T1, _T2> &, const __nonesuch &>::type __p)         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        constexpr pair<_T1, _T2> &operator=(typename conditional<__and_<is_move_assignable<_T1>, is_move_assignable<_T2>>::value, pair<_T1, _T2> &&, __nonesuch &&>::type __p) noexcept(__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2>>::valueoperator=(typename conditional<__and_<is_move_assignable<_T1>, is_move_assignable<_T2>>::value, pair<_T1, _T2> &&, __nonesuch &&>::type __p) noexcept(__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2>>::value)         {
            this->first = std::forward<std::pair::first_type>(__p.first);
            this->second = std::forward<std::pair::second_type>(__p.second);
            return *this;
        }
        template <typename _U1, typename _U2> constexpr typename enable_if<__and_<is_assignable<_T1 &, const _U1 &>, is_assignable<_T2 &, const _U2 &>>::value, pair<_T1, _T2> &>::type operator=(const pair<_U1, _U2> &__p)         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        template <typename _U1, typename _U2> constexpr typename enable_if<__and_<is_assignable<_T1 &, _U1 &&>, is_assignable<_T2 &, _U2 &&>>::value, pair<_T1, _T2> &>::type operator=(pair<_U1, _U2> &&__p)         {
            this->first = std::forward<_U1>(__p.first);
            this->second = std::forward<_U2>(__p.second);
            return *this;
        }
        constexpr void swap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::valueswap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2>>::value)         {
            using std::swap;
            swap(this->first, __p.first);
            swap(this->second, __p.second);
        }
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> constexpr pair<_T1, _T2>(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    };
    template <typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
    template <typename _T1, typename _T2> inline constexpr bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first == __y.first && __x.second == __y.second;
    }
    template <typename _T1, typename _T2> constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>, __detail::__synth3way_t<_T2>> operator<=>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
            return __c;
        return __detail::__synth3way(__x.second, __y.second);
    }
    template <typename _T1, typename _T2> inline constexpr typename enable_if<__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y))swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)))     {
        __x.swap(__y);
    }
    template <typename _T1, typename _T2> typename enable_if<!__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete
    template <typename _T1, typename _T2> constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y)     {
        typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        typedef pair<__ds_type1, __ds_type2> __pair_type;
        return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
}
namespace __gnu_debug {
    struct _Safe_iterator_base;
}
namespace std {
    class __undefined;
    template <typename _Tp> struct __get_first_arg {
        using type = std::__undefined;
    };
    template <template <typename, typename ...> class _Template, typename _Tp, typename ..._Types> struct __get_first_arg<_Template<_Tp, _Types...>> {
        using type = _Tp;
    };
    template <typename _Tp> using __get_first_arg_t = typename __get_first_arg<_Tp>::type;
    template <typename _Tp, typename _Up> struct __replace_first_arg {
    };
    template <template <typename, typename ...> class _Template, typename _Up, typename _Tp, typename ..._Types> struct __replace_first_arg<_Template<_Tp, _Types...>, _Up> {
        using type = _Template<_Up, _Types...>;
    };
    template <typename _Tp, typename _Up> using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;
    template <typename _Tp> using __make_not_void = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;
    template <typename _Ptr> struct pointer_traits {
    private:
        template <typename _Tp> using __element_type = typename _Tp::element_type;
        template <typename _Tp> using __difference_type = typename _Tp::difference_type;
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>> {
            using type = typename _Tp::template rebind<_Up>;
        };
    public:
        using pointer = _Ptr;
        using element_type = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;
        using difference_type = __detected_or_t<std::ptrdiff_t, __difference_type, _Ptr>;
        template <typename _Up> using rebind = typename __rebind<_Ptr, _Up>::type;
        static _Ptr pointer_to(__make_not_void<std::pointer_traits::element_type> &__e)         {
            return _Ptr::pointer_to(__e);
        }
        static_assert(!is_same<element_type, __undefined>::value, "pointer type defines element_type or is like SomePointer<T, Args>");
    };
    template <typename _Tp> struct pointer_traits<_Tp *> {
        typedef _Tp *pointer;
        typedef _Tp element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static constexpr std::pointer_traits<type-parameter-0-0 *>::pointer pointer_to(__make_not_void<std::pointer_traits<type-parameter-0-0 *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Tp> using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
    template <typename _Tp> constexpr _Tp *__to_address(_Tp *__ptr) noexcept     {
        static_assert(!std::is_function<_Tp>::value, "not a function pointer");
        return __ptr;
    }
    template <typename _Ptr> constexpr auto __to_address(const _Ptr &__ptr) noexcept -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))     {
        return std::pointer_traits<_Ptr>::to_address(__ptr);
    }
    template <typename _Ptr, typename ..._None> constexpr auto __to_address(const _Ptr &__ptr, _None ...) noexcept     {
        if (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
            return std::__to_address(__ptr.base().operator->());
        else
            return std::__to_address(__ptr.operator->());
    }
    template <typename _Tp> constexpr _Tp *to_address(_Tp *__ptr) noexcept     {
        return std::__to_address(__ptr);
    }
    template<> constexpr const char *to_address<const char>(const char *__ptr) noexcept    template<> constexpr const wchar_t *to_address<const wchar_t>(const wchar_t *__ptr) noexcept    template<> constexpr const char8_t *to_address<const char8_t>(const char8_t *__ptr) noexcept    template<> constexpr const char16_t *to_address<const char16_t>(const char16_t *__ptr) noexcept    template<> constexpr const char32_t *to_address<const char32_t>(const char32_t *__ptr) noexcept    template <typename _Ptr> constexpr auto to_address(const _Ptr &__ptr) noexcept     {
        return std::__to_address(__ptr);
    }
    template<> constexpr auto to_address<const char *>(const char *const &__ptr) noexcept    template<> constexpr auto to_address<const wchar_t *>(const wchar_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char8_t *>(const char8_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char16_t *>(const char16_t *const &__ptr) noexcept    template<> constexpr auto to_address<const char32_t *>(const char32_t *const &__ptr) noexcept}
namespace std {
    struct __is_transparent;
    struct identity {
        template <typename _Tp> constexpr _Tp &&operator()(_Tp &&__t) const noexcept         {
            return std::forward<_Tp>(__t);
        }
        using is_transparent = std::__is_transparent;
    };
    namespace ranges {
        namespace __detail {
            template <typename _Tp, typename _Up> concept __eq_builtin_ptr_cmp = requires (_Tp &&__t, _Up &&__u) { { __t == __u } -> same_as<bool>; } && convertible_to<_Tp, const volatile void *> && convertible_to<_Up, const volatile void *> && (!requires (_Tp &&__t, _Up &&__u) { operator==(std::forward<_Tp>(__t), std::forward<_Up>(__u)); } && !requires (_Tp &&__t, _Up &&__u) { std::forward<_Tp>(__t).operator==(std::forward<_Up>(__u)); });;
            template <typename _Tp, typename _Up> concept __less_builtin_ptr_cmp = requires (_Tp &&__t, _Up &&__u) { { __t < __u } -> same_as<bool>; } && convertible_to<_Tp, const volatile void *> && convertible_to<_Up, const volatile void *> && (!requires (_Tp &&__t, _Up &&__u) { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); } && !requires (_Tp &&__t, _Up &&__u) { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });;
        }
        struct equal_to {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>()))             {
                return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
            }
            using is_transparent = std::__is_transparent;
        };
        struct not_equal_to {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>()))             {
                return !std::ranges::equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
            }
            using is_transparent = std::__is_transparent;
        };
        struct less {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))             {
                if (__detail::__less_builtin_ptr_cmp<_Tp, _Up>) {
                    if (std::is_constant_evaluated())
                        return __t < __u;
                    auto __x = reinterpret_cast<unsigned long>(static_cast<const volatile void *>(std::forward<_Tp>(__t)));
                    auto __y = reinterpret_cast<unsigned long>(static_cast<const volatile void *>(std::forward<_Up>(__u)));
                    return __x < __y;
                } else
                    return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
            }
            using is_transparent = std::__is_transparent;
        };
        struct greater {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))             {
                return std::ranges::less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
            }
            using is_transparent = std::__is_transparent;
        };
        struct greater_equal {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))             {
                return !std::ranges::less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
            }
            using is_transparent = std::__is_transparent;
        };
        struct less_equal {
            template <typename _Tp, typename _Up> constexpr bool operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))             {
                return !std::ranges::less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
            }
            using is_transparent = std::__is_transparent;
        };
    }
}
namespace std {
    struct input_iterator_tag;
    struct output_iterator_tag;
    struct forward_iterator_tag;
    struct bidirectional_iterator_tag;
    struct random_access_iterator_tag;
    struct contiguous_iterator_tag;
    template <typename _Iterator> struct iterator_traits
template<> struct iterator_traits<const char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    }
template<> struct iterator_traits<char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = std::ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    }
template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    }
template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    }
template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    }
template<> struct iterator_traits<char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = char8_t *;
        using reference = char8_t &;
    }
template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    }
template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    };
    template <typename _Tp> struct iterator_traits<_Tp *>;
    template <typename _Iterator, typename> struct __iterator_traits;
    namespace __detail {
        template <typename _Tp> using __with_ref = _Tp &;
        template <typename _Tp> concept __can_reference = requires { typename __with_ref<_Tp>; };;
        template <typename _Tp> concept __dereferenceable = requires (_Tp &__t) { { *__t } -> __can_reference; };;
    }
    template <__detail::__dereferenceable _Tp> using iter_reference_t = decltype(*std::declval<_Tp &>());
    namespace ranges {
        namespace __cust_imove {
            void iter_move();
            template <typename _Tp> concept __adl_imove = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>) && requires (_Tp &&__t) { iter_move(static_cast<_Tp &&>(__t)); };;
            struct _IMove {
            private:
                template <typename _Tp> struct __result {
                    using type = iter_reference_t<_Tp>;
                };
template<> struct __result<const char *&> {
                    using type = remove_reference_t<iter_reference_t<const char *&>> &&;
                };
template<> struct __result<const char *const &> {
                    using type = remove_reference_t<iter_reference_t<const char *const &>> &&;
                };
template<> struct __result<const wchar_t *&> {
                    using type = remove_reference_t<iter_reference_t<const wchar_t *&>> &&;
                };
template<> struct __result<const wchar_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const wchar_t *const &>> &&;
                };
template<> struct __result<const char8_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char8_t *&>> &&;
                };
template<> struct __result<const char8_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char8_t *const &>> &&;
                };
template<> struct __result<const char16_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char16_t *&>> &&;
                };
template<> struct __result<const char16_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char16_t *const &>> &&;
                };
template<> struct __result<const char32_t *&> {
                    using type = remove_reference_t<iter_reference_t<const char32_t *&>> &&;
                };
template<> struct __result<const char32_t *const &> {
                    using type = remove_reference_t<iter_reference_t<const char32_t *const &>> &&;
                };
                template <typename _Tp> struct __result<_Tp> {
                    using type = decltype(iter_move(std::declval<_Tp>()));
                };
                template <typename _Tp> struct __result<_Tp> {
                    using type = remove_reference_t<iter_reference_t<_Tp>> &&;
                };
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__adl_imove<_Tp>)
                        return noexcept(iter_move(std::declval<_Tp>()));
                    else
                        return noexcept(*std::declval<_Tp>());
                }
                template<> static constexpr bool _S_noexcept<const char *&>()                 {
                    if (__adl_imove<const char *&>)
                        ;
                    else
                        return noexcept(*std::declval<const char *&>());
                }
                template<> static constexpr bool _S_noexcept<const char *const &>()                 {
                    if (__adl_imove<const char *const &>)
                        ;
                    else
                        return noexcept(*std::declval<const char *const &>());
                }
                template<> static constexpr bool _S_noexcept<const wchar_t *&>()                 {
                    if (__adl_imove<const wchar_t *&>)
                        ;
                    else
                        return noexcept(*std::declval<const wchar_t *&>());
                }
                template<> static constexpr bool _S_noexcept<const wchar_t *const &>()                 {
                    if (__adl_imove<const wchar_t *const &>)
                        ;
                    else
                        return noexcept(*std::declval<const wchar_t *const &>());
                }
                template<> static constexpr bool _S_noexcept<const char8_t *&>()                 {
                    if (__adl_imove<const char8_t *&>)
                        ;
                    else
                        return noexcept(*std::declval<const char8_t *&>());
                }
                template<> static constexpr bool _S_noexcept<const char8_t *const &>()                 {
                    if (__adl_imove<const char8_t *const &>)
                        ;
                    else
                        return noexcept(*std::declval<const char8_t *const &>());
                }
                template<> static constexpr bool _S_noexcept<const char16_t *&>()                 {
                    if (__adl_imove<const char16_t *&>)
                        ;
                    else
                        return noexcept(*std::declval<const char16_t *&>());
                }
                template<> static constexpr bool _S_noexcept<const char16_t *const &>()                 {
                    if (__adl_imove<const char16_t *const &>)
                        ;
                    else
                        return noexcept(*std::declval<const char16_t *const &>());
                }
                template<> static constexpr bool _S_noexcept<const char32_t *&>()                 {
                    if (__adl_imove<const char32_t *&>)
                        ;
                    else
                        return noexcept(*std::declval<const char32_t *&>());
                }
                template<> static constexpr bool _S_noexcept<const char32_t *const &>()                 {
                    if (__adl_imove<const char32_t *const &>)
                        ;
                    else
                        return noexcept(*std::declval<const char32_t *const &>());
                }
            public:
                template <std::__detail::__dereferenceable _Tp> using __type = typename __result<_Tp>::type;
                template <std::__detail::__dereferenceable _Tp> constexpr __type<_Tp> operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>())                 {
                    if (__adl_imove<_Tp>)
                        return iter_move(static_cast<_Tp &&>(__e));
                    else if (is_lvalue_reference_v<iter_reference_t<_Tp>>)
                        return static_cast<__type<_Tp>>(*__e);
                    else
                        return *__e;
                }
                template<> constexpr __type<const char *&> operator()<const char *&>(const char *&__e) const noexcept(_S_noexcept<const char *&>()operator()<const char *&>(const char *&__e) const noexcept(_S_noexcept<const char *&>())                template<> constexpr __type<const char *const &> operator()<const char *const &>(const char *const &__e) const noexcept(_S_noexcept<const char *const &>()operator()<const char *const &>(const char *const &__e) const noexcept(_S_noexcept<const char *const &>())                template<> constexpr __type<const wchar_t *&> operator()<const wchar_t *&>(const wchar_t *&__e) const noexcept(_S_noexcept<const wchar_t *&>()operator()<const wchar_t *&>(const wchar_t *&__e) const noexcept(_S_noexcept<const wchar_t *&>())                template<> constexpr __type<const wchar_t *const &> operator()<const wchar_t *const &>(const wchar_t *const &__e) const noexcept(_S_noexcept<const wchar_t *const &>()operator()<const wchar_t *const &>(const wchar_t *const &__e) const noexcept(_S_noexcept<const wchar_t *const &>())                template<> constexpr __type<const char8_t *&> operator()<const char8_t *&>(const char8_t *&__e) const noexcept(_S_noexcept<const char8_t *&>()operator()<const char8_t *&>(const char8_t *&__e) const noexcept(_S_noexcept<const char8_t *&>())                template<> constexpr __type<const char8_t *const &> operator()<const char8_t *const &>(const char8_t *const &__e) const noexcept(_S_noexcept<const char8_t *const &>()operator()<const char8_t *const &>(const char8_t *const &__e) const noexcept(_S_noexcept<const char8_t *const &>())                template<> constexpr __type<const char16_t *&> operator()<const char16_t *&>(const char16_t *&__e) const noexcept(_S_noexcept<const char16_t *&>()operator()<const char16_t *&>(const char16_t *&__e) const noexcept(_S_noexcept<const char16_t *&>())                template<> constexpr __type<const char16_t *const &> operator()<const char16_t *const &>(const char16_t *const &__e) const noexcept(_S_noexcept<const char16_t *const &>()operator()<const char16_t *const &>(const char16_t *const &__e) const noexcept(_S_noexcept<const char16_t *const &>())                template<> constexpr __type<const char32_t *&> operator()<const char32_t *&>(const char32_t *&__e) const noexcept(_S_noexcept<const char32_t *&>()operator()<const char32_t *&>(const char32_t *&__e) const noexcept(_S_noexcept<const char32_t *&>())                template<> constexpr __type<const char32_t *const &> operator()<const char32_t *const &>(const char32_t *const &__e) const noexcept(_S_noexcept<const char32_t *const &>()operator()<const char32_t *const &>(const char32_t *const &__e) const noexcept(_S_noexcept<const char32_t *const &>())            };
        }
        inline namespace __cust {
            constexpr __cust_imove::_IMove iter_move{};
        }
    }
    template <__detail::__dereferenceable _Tp> using iter_rvalue_reference_t = decltype(ranges::iter_move(std::declval<_Tp &>()));
    template <typename> struct incrementable_traits {
    };
    template <typename _Tp> struct incrementable_traits<_Tp *> {
        using difference_type = std::ptrdiff_t;
    };
    template <typename _Iter> struct incrementable_traits<const _Iter> : incrementable_traits<_Iter> {
    };
    template <typename _Tp> struct incrementable_traits<_Tp> {
        using difference_type = typename _Tp::difference_type;
    };
    template <typename _Tp> struct incrementable_traits<_Tp> {
        using difference_type = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };
    template<> struct incrementable_traits<__int128> {
        using difference_type = __int128;
    };
    template<> struct incrementable_traits<unsigned __int128> {
        using difference_type = __int128;
    };
    namespace __detail {
        template <typename _Iter> concept __primary_traits_iter = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);;
        template <typename _Iter, typename _Tp> struct __iter_traits_impl {
            using type = iterator_traits<_Iter>;
        };
template<> struct __iter_traits_impl<const char *, std::incrementable_traits<const char *>> {
            using type = iterator_traits<const char *>;
        };
template<> struct __iter_traits_impl<const char *, std::indirectly_readable_traits<const char *>> {
            using type = iterator_traits<const char *>;
        };
template<> struct __iter_traits_impl<const char *, const char *> {
            using type = iterator_traits<const char *>;
        };
template<> struct __iter_traits_impl<const wchar_t *, std::incrementable_traits<const wchar_t *>> {
            using type = iterator_traits<const wchar_t *>;
        };
template<> struct __iter_traits_impl<const wchar_t *, std::indirectly_readable_traits<const wchar_t *>> {
            using type = iterator_traits<const wchar_t *>;
        };
template<> struct __iter_traits_impl<const wchar_t *, const wchar_t *> {
            using type = iterator_traits<const wchar_t *>;
        };
template<> struct __iter_traits_impl<const char8_t *, std::incrementable_traits<const char8_t *>> {
            using type = iterator_traits<const char8_t *>;
        };
template<> struct __iter_traits_impl<const char8_t *, std::indirectly_readable_traits<const char8_t *>> {
            using type = iterator_traits<const char8_t *>;
        };
template<> struct __iter_traits_impl<const char8_t *, const char8_t *> {
            using type = iterator_traits<const char8_t *>;
        };
template<> struct __iter_traits_impl<const char16_t *, std::incrementable_traits<const char16_t *>> {
            using type = iterator_traits<const char16_t *>;
        };
template<> struct __iter_traits_impl<const char16_t *, std::indirectly_readable_traits<const char16_t *>> {
            using type = iterator_traits<const char16_t *>;
        };
template<> struct __iter_traits_impl<const char16_t *, const char16_t *> {
            using type = iterator_traits<const char16_t *>;
        };
template<> struct __iter_traits_impl<const char32_t *, std::incrementable_traits<const char32_t *>> {
            using type = iterator_traits<const char32_t *>;
        };
template<> struct __iter_traits_impl<const char32_t *, std::indirectly_readable_traits<const char32_t *>> {
            using type = iterator_traits<const char32_t *>;
        };
template<> struct __iter_traits_impl<const char32_t *, const char32_t *> {
            using type = iterator_traits<const char32_t *>;
        };
        template <typename _Iter, typename _Tp> struct __iter_traits_impl<_Iter, _Tp> {
            using type = _Tp;
        };
        template <typename _Iter, typename _Tp = _Iter> using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;
        template <typename _Tp> using __iter_diff_t = typename __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
    }
    template <typename _Tp> using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;
    namespace __detail {
        template <typename> struct __cond_value_type {
        };
        template <typename _Tp> struct __cond_value_type<_Tp> {
            using value_type = remove_cv_t<_Tp>;
        };
    }
    template <typename> struct indirectly_readable_traits {
    };
    template <typename _Tp> struct indirectly_readable_traits<_Tp *> : __detail::__cond_value_type<_Tp> {
    };
    template <typename _Iter> struct indirectly_readable_traits<_Iter> {
        using value_type = remove_cv_t<remove_extent_t<_Iter>>;
    };
    template <typename _Iter> struct indirectly_readable_traits<const _Iter> : indirectly_readable_traits<_Iter> {
    };
    template <typename _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::value_type> {
    };
    template <typename _Tp> struct indirectly_readable_traits<_Tp> : __detail::__cond_value_type<typename _Tp::element_type> {
    };
    namespace __detail {
        template <typename _Tp> using __iter_value_t = typename __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
    }
    template <typename _Tp> using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;
    namespace __detail {
        template <typename _Iter> concept __cpp17_iterator = requires (_Iter __it) { { *__it } -> __can_reference; { ++__it } -> same_as<_Iter &>; { *__it++ } -> __can_reference; } && copyable<_Iter>;;
        template <typename _Iter> concept __cpp17_input_iterator = __cpp17_iterator<_Iter> && equality_comparable<_Iter> && requires (_Iter __it) { typename incrementable_traits<_Iter>::difference_type; typename indirectly_readable_traits<_Iter>::value_type; typename common_reference_t<iter_reference_t<_Iter> &&, typename indirectly_readable_traits<_Iter>::value_type &>; typename common_reference_t<decltype(*__it++) &&, typename indirectly_readable_traits<_Iter>::value_type &>; requires signed_integral<typename incrementable_traits<_Iter>::difference_type>; };;
        template <typename _Iter> concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter> && constructible_from<_Iter> && is_lvalue_reference_v<iter_reference_t<_Iter>> && same_as<remove_cvref_t<iter_reference_t<_Iter>>, typename indirectly_readable_traits<_Iter>::value_type> && requires (_Iter __it) { { __it++ } -> convertible_to<const _Iter &>; { *__it++ } -> same_as<iter_reference_t<_Iter>>; };;
        template <typename _Iter> concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter> && requires (_Iter __it) { { --__it } -> same_as<_Iter &>; { __it-- } -> convertible_to<const _Iter &>; { *__it-- } -> same_as<iter_reference_t<_Iter>>; };;
        template <typename _Iter> concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter> && totally_ordered<_Iter> && requires (_Iter __it, typename incrementable_traits<_Iter>::difference_type __n) { { __it += __n } -> same_as<_Iter &>; { __it -= __n } -> same_as<_Iter &>; { __it + __n } -> same_as<_Iter>; { __n + __it } -> same_as<_Iter>; { __it - __n } -> same_as<_Iter>; { __it - __it } -> same_as<decltype(__n)>; { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>; };;
        template <typename _Iter> concept __iter_with_nested_types = requires { typename _Iter::iterator_category; typename _Iter::value_type; typename _Iter::difference_type; typename _Iter::reference; };;
        template <typename _Iter> concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;;
        template <typename _Iter> concept __iter_without_category = !requires { typename _Iter::iterator_category; };;
    }
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = typename _Iter::pointer;
        };
    public:
        using iterator_category = typename _Iterator::iterator_category;
        using value_type = typename _Iterator::value_type;
        using difference_type = typename _Iterator::difference_type;
        using pointer = typename __ptr<_Iterator>::type;
        using reference = typename _Iterator::reference;
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __cat {
            using type = std::input_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = typename _Iter::iterator_category;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = std::random_access_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = std::bidirectional_iterator_tag;
        };
        template <typename _Iter> struct __cat<_Iter> {
            using type = std::forward_iterator_tag;
        };
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = typename _Iter::pointer;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using type = decltype(std::declval<_Iter &>().operator->());
        };
        template <typename _Iter> struct __ref {
            using type = iter_reference_t<_Iter>;
        };
        template <typename _Iter> struct __ref<_Iter> {
            using type = typename _Iter::reference;
        };
    public:
        using iterator_category = typename __cat<_Iterator>::type;
        using value_type = typename indirectly_readable_traits<_Iterator>::value_type;
        using difference_type = typename incrementable_traits<_Iterator>::difference_type;
        using pointer = typename __ptr<_Iterator>::type;
        using reference = typename __ref<_Iterator>::type;
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, void> {
    private:
        template <typename _Iter> struct __diff {
            using type = void;
        };
        template <typename _Iter> struct __diff<_Iter> {
            using type = typename incrementable_traits<_Iter>::difference_type;
        };
    public:
        using iterator_category = std::output_iterator_tag;
        using value_type = void;
        using difference_type = typename __diff<_Iterator>::type;
        using pointer = void;
        using reference = void;
    };
    namespace __detail {
        template <typename _Iter> struct __iter_concept_impl
template<> struct __iter_concept_impl<const char *> {
            using type = typename __iter_traits<const char *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const wchar_t *> {
            using type = typename __iter_traits<const wchar_t *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const char8_t *> {
            using type = typename __iter_traits<const char8_t *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const char16_t *> {
            using type = typename __iter_traits<const char16_t *>::iterator_concept;
        }
template<> struct __iter_concept_impl<const char32_t *> {
            using type = typename __iter_traits<const char32_t *>::iterator_concept;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = typename __iter_traits<_Iter>::iterator_concept;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = typename __iter_traits<_Iter>::iterator_category;
        };
        template <typename _Iter> struct __iter_concept_impl<_Iter> {
            using type = std::random_access_iterator_tag;
        };
        template <typename _Iter> struct __iter_concept_impl {
        };
template<> struct __iter_concept_impl<const char *> {
            using type = typename __iter_traits<const char *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const wchar_t *> {
            using type = typename __iter_traits<const wchar_t *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const char8_t *> {
            using type = typename __iter_traits<const char8_t *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const char16_t *> {
            using type = typename __iter_traits<const char16_t *>::iterator_concept;
        };
template<> struct __iter_concept_impl<const char32_t *> {
            using type = typename __iter_traits<const char32_t *>::iterator_concept;
        };
        template <typename _Iter> using __iter_concept = typename __iter_concept_impl<_Iter>::type;
        template <typename _In> concept __indirectly_readable_impl = requires (const _In __in) { typename iter_value_t<_In>; typename iter_reference_t<_In>; typename iter_rvalue_reference_t<_In>; { *__in } -> same_as<iter_reference_t<_In>>; { ranges::iter_move(__in) } -> same_as<iter_rvalue_reference_t<_In>>; } && common_reference_with<iter_reference_t<_In> &&, iter_value_t<_In> &> && common_reference_with<iter_reference_t<_In> &&, iter_rvalue_reference_t<_In> &&> && common_reference_with<iter_rvalue_reference_t<_In> &&, const iter_value_t<_In> &>;;
    }
    template <typename _In> concept indirectly_readable = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;;
    template <indirectly_readable _Tp> using iter_common_reference_t = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp> &>;
    template <typename _Out, typename _Tp> concept indirectly_writable = requires (_Out &&__o, _Tp &&__t) { *__o = std::forward<_Tp>(__t); *std::forward<_Out>(__o) = std::forward<_Tp>(__t); const_cast<const iter_reference_t<_Out> &&>(*__o) = std::forward<_Tp>(__t); const_cast<const iter_reference_t<_Out> &&>(*std::forward<_Out>(__o)) = std::forward<_Tp>(__t); };;
    namespace ranges {
        namespace __detail {
            using __max_diff_type = __int128;
            using __max_size_type = unsigned __int128;
            template <typename _Tp> concept __is_integer_like = integral<_Tp> || same_as<_Tp, std::ranges::__detail::__max_diff_type> || same_as<_Tp, std::ranges::__detail::__max_size_type>;;
            template <typename _Tp> concept __is_signed_integer_like = signed_integral<_Tp> || same_as<_Tp, std::ranges::__detail::__max_diff_type>;;
        }
    }
    namespace __detail {
        using ranges::__detail::__is_signed_integer_like;
    }
    template <typename _Iter> concept weakly_incrementable = default_initializable<_Iter> && movable<_Iter> && requires (_Iter __i) { typename iter_difference_t<_Iter>; requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>; { ++__i } -> same_as<_Iter &>; __i++; };;
    template <typename _Iter> concept incrementable = regular<_Iter> && weakly_incrementable<_Iter> && requires (_Iter __i) { { __i++ } -> same_as<_Iter>; };;
    template <typename _Iter> concept input_or_output_iterator = requires (_Iter __i) { { *__i } -> __detail::__can_reference; } && weakly_incrementable<_Iter>;;
    template <typename _Sent, typename _Iter> concept sentinel_for = semiregular<_Sent> && input_or_output_iterator<_Iter> && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;;
    template <typename _Sent, typename _Iter> constexpr bool disable_sized_sentinel_for = false;
    template <typename _Sent, typename _Iter> concept sized_sentinel_for = sentinel_for<_Sent, _Iter> && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>> && requires (const _Iter &__i, const _Sent &__s) { { __s - __i } -> same_as<iter_difference_t<_Iter>>; { __i - __s } -> same_as<iter_difference_t<_Iter>>; };;
    template <typename _Iter> concept input_iterator = input_or_output_iterator<_Iter> && indirectly_readable<_Iter> && requires { typename __detail::__iter_concept<_Iter>; } && derived_from<__detail::__iter_concept<_Iter>, std::input_iterator_tag>;;
    template <typename _Iter, typename _Tp> concept output_iterator = input_or_output_iterator<_Iter> && indirectly_writable<_Iter, _Tp> && requires (_Iter __i, _Tp &&__t) { *__i++ = std::forward<_Tp>(__t); };;
    template <typename _Iter> concept forward_iterator = input_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::forward_iterator_tag> && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;;
    template <typename _Iter> concept bidirectional_iterator = forward_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::bidirectional_iterator_tag> && requires (_Iter __i) { { --__i } -> same_as<_Iter &>; { __i-- } -> same_as<_Iter>; };;
    template <typename _Iter> concept random_access_iterator = bidirectional_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::random_access_iterator_tag> && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter> && requires (_Iter __i, const _Iter __j, const iter_difference_t<_Iter> __n) { { __i += __n } -> same_as<_Iter &>; { __j + __n } -> same_as<_Iter>; { __n + __j } -> same_as<_Iter>; { __i -= __n } -> same_as<_Iter &>; { __j - __n } -> same_as<_Iter>; { __j[__n] } -> same_as<iter_reference_t<_Iter>>; };;
    template <typename _Iter> concept contiguous_iterator = random_access_iterator<_Iter> && derived_from<__detail::__iter_concept<_Iter>, std::contiguous_iterator_tag> && is_lvalue_reference_v<iter_reference_t<_Iter>> && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>> && requires (const _Iter &__i) { { std::to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_Iter>>>; };;
    template <typename _Fn, typename _Iter> concept indirectly_unary_invocable = indirectly_readable<_Iter> && copy_constructible<_Fn> && invocable<_Fn &, iter_value_t<_Iter> &> && invocable<_Fn &, iter_reference_t<_Iter>> && invocable<_Fn &, iter_common_reference_t<_Iter>> && common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>, invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;;
    template <typename _Fn, typename _Iter> concept indirectly_regular_unary_invocable = indirectly_readable<_Iter> && copy_constructible<_Fn> && regular_invocable<_Fn &, iter_value_t<_Iter> &> && regular_invocable<_Fn &, iter_reference_t<_Iter>> && regular_invocable<_Fn &, iter_common_reference_t<_Iter>> && common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>, invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;;
    template <typename _Fn, typename _Iter> concept indirect_unary_predicate = indirectly_readable<_Iter> && copy_constructible<_Fn> && predicate<_Fn &, iter_value_t<_Iter> &> && predicate<_Fn &, iter_reference_t<_Iter>> && predicate<_Fn &, iter_common_reference_t<_Iter>>;;
    template <typename _Fn, typename _I1, typename _I2> concept indirect_binary_predicate = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && predicate<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && predicate<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && predicate<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && predicate<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && predicate<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;;
    template <typename _Fn, typename _I1, typename _I2 = _I1> concept indirect_equivalence_relation = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && equivalence_relation<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && equivalence_relation<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && equivalence_relation<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;;
    template <typename _Fn, typename _I1, typename _I2 = _I1> concept indirect_strict_weak_order = indirectly_readable<_I1> && indirectly_readable<_I2> && copy_constructible<_Fn> && strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> && strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> && strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> && strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> && strict_weak_order<_Fn &, iter_common_reference_t<_I1>, iter_common_reference_t<_I2>>;;
    template <typename _Fn, typename ..._Is> using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;
    template <indirectly_readable _Iter, indirectly_regular_unary_invocable<_Iter> _Proj> struct projected {
        using value_type = remove_cvref_t<indirect_result_t<_Proj &, _Iter>>;
        indirect_result_t<_Proj &, _Iter> operator*() const;
    };
    template <weakly_incrementable _Iter, typename _Proj> struct incrementable_traits<projected<_Iter, _Proj>> {
        using difference_type = iter_difference_t<_Iter>;
    };
    template <typename _In, typename _Out> concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;;
    template <typename _In, typename _Out> concept indirectly_movable_storable = indirectly_movable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>> && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> && assignable_from<iter_value_t<_In> &, iter_rvalue_reference_t<_In>>;;
    template <typename _In, typename _Out> concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;;
    template <typename _In, typename _Out> concept indirectly_copyable_storable = indirectly_copyable<_In, _Out> && indirectly_writable<_Out, iter_value_t<_In> &> && indirectly_writable<_Out, const iter_value_t<_In> &> && indirectly_writable<_Out, iter_value_t<_In> &&> && indirectly_writable<_Out, const iter_value_t<_In> &&> && copyable<iter_value_t<_In>> && constructible_from<iter_value_t<_In>, iter_reference_t<_In>> && assignable_from<iter_value_t<_In> &, iter_reference_t<_In>>;;
    namespace ranges {
        namespace __cust_iswap {
            template <typename _It1, typename _It2> void iter_swap(_It1, _It2) = delete
            template <typename _Tp, typename _Up> concept __adl_iswap = (std::__detail::__class_or_enum<remove_reference_t<_Tp>> || std::__detail::__class_or_enum<remove_reference_t<_Up>>) && requires (_Tp &&__t, _Up &&__u) { iter_swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)); };;
            template <typename _Xp, typename _Yp> constexpr iter_value_t<_Xp> __iter_exchange_move(_Xp &&__x, _Yp &&__y) noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x))) && noexcept(*__x = iter_move(__y))__iter_exchange_move(_Xp &&__x, _Yp &&__y) noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x))) && noexcept(*__x = iter_move(__y)))             {
                iter_value_t<_Xp> __old_value(iter_move(__x));
                *__x = iter_move(__y);
                return __old_value;
            }
            struct _IterSwap {
            private:
                template <typename _Tp, typename _Up> static constexpr bool _S_noexcept()                 {
                    if (__adl_iswap<_Tp, _Up>)
                        return noexcept(iter_swap(std::declval<_Tp>(), std::declval<_Up>()));
                    else if (indirectly_readable<_Tp> && indirectly_readable<_Up> && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
                        return noexcept(ranges::swap(*std::declval<_Tp>(), *std::declval<_Up>()));
                    else
                        return noexcept(*std::declval<_Tp>() = __iter_exchange_move(std::declval<_Up>(), std::declval<_Tp>()));
                }
            public:
                template <typename _Tp, typename _Up> constexpr void operator()(_Tp &&__e1, _Up &&__e2) const noexcept(_S_noexcept<_Tp, _Up>()operator()(_Tp &&__e1, _Up &&__e2) const noexcept(_S_noexcept<_Tp, _Up>())                 {
                    if (__adl_iswap<_Tp, _Up>)
                        iter_swap(static_cast<_Tp &&>(__e1), static_cast<_Up &&>(__e2));
                    else if (indirectly_readable<_Tp> && indirectly_readable<_Up> && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
                        ranges::swap(*__e1, *__e2);
                    else
                        *__e1 = __iter_exchange_move(__e2, __e1);
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_iswap::_IterSwap iter_swap{};
        }
    }
    template <typename _I1, typename _I2 = _I1> concept indirectly_swappable = indirectly_readable<_I1> && indirectly_readable<_I2> && requires (const _I1 __i1, const _I2 __i2) { ranges::iter_swap(__i1, __i1); ranges::iter_swap(__i2, __i2); ranges::iter_swap(__i1, __i2); ranges::iter_swap(__i2, __i1); };;
    template <typename _I1, typename _I2, typename _Rel, typename _P1 = std::identity, typename _P2 = std::identity> concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;;
    template <typename _Iter> concept permutable = forward_iterator<_Iter> && indirectly_movable_storable<_Iter, _Iter> && indirectly_swappable<_Iter, _Iter>;;
    template <typename _I1, typename _I2, typename _Out, typename _Rel = ranges::less, typename _P1 = std::identity, typename _P2 = std::identity> concept mergeable = input_iterator<_I1> && input_iterator<_I2> && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out> && indirectly_copyable<_I2, _Out> && indirect_strict_weak_order<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;;
    template <typename _Iter, typename _Rel = ranges::less, typename _Proj = std::identity> concept sortable = permutable<_Iter> && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;;
    struct unreachable_sentinel_t {
        friend template <weakly_incrementable _It> constexpr bool operator==(std::unreachable_sentinel_t, const _It &) noexcept         {
            return false;
        }
;
    };
    constexpr std::unreachable_sentinel_t unreachable_sentinel{};
    struct default_sentinel_t {
    };
    constexpr std::default_sentinel_t default_sentinel{};
    namespace __detail {
        template <typename _Tp> constexpr decay_t<_Tp> __decay_copy(_Tp &&__t) noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>__decay_copy(_Tp &&__t) noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)         {
            return std::forward<_Tp>(__t);
        }
        template <typename _Tp> concept __member_begin = requires (_Tp &__t) { { __detail::__decay_copy(__t.begin()) } -> input_or_output_iterator; };;
        template <> void begin(auto &) = delete
        template <> void begin(const auto &) = delete
        template <typename _Tp> concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __detail::__decay_copy(begin(__t)) } -> input_or_output_iterator; };;
        template <typename _Tp> auto __ranges_begin(_Tp &__t)         {
            if (is_array_v<_Tp>) {
                static_assert(sizeof(remove_all_extents_t<_Tp>) != 0, "not array of incomplete type");
                return __t + 0;
            } else if (__member_begin<_Tp &>)
                return __t.begin();
            else
                return begin(__t);
        }
        template <typename _Tp> using __range_iter_t = decltype(__detail::__ranges_begin(std::declval<_Tp &>()));
    }
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
    constexpr bool disable_sized_sentinel_for = false;
}
namespace std {
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : public std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : public std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : public std::bidirectional_iterator_tag {
    };
    struct contiguous_iterator_tag : public std::random_access_iterator_tag {
    };
    template <typename _Category, typename _Tp, typename _Distance = std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp &> struct iterator {
        typedef _Category iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef _Pointer pointer;
        typedef _Reference reference;
    };
template<> struct iterator<std::output_iterator_tag, void, void, void, void> {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
    };
    template <typename _Iterator> struct iterator_traits
template<> struct iterator_traits<const char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    }
template<> struct iterator_traits<char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = std::ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    }
template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    }
template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    }
template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    }
template<> struct iterator_traits<char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = char8_t *;
        using reference = char8_t &;
    }
template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    }
template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    };
    template <typename _Iterator, typename = __void_t<>> struct __iterator_traits {
    };
    template <typename _Iterator> struct iterator_traits : public __iterator_traits<_Iterator> {
    };
template<> struct iterator_traits<const char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char *;
        using reference = const char &;
    };
template<> struct iterator_traits<char *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char>;
        using difference_type = std::ptrdiff_t;
        using pointer = char *;
        using reference = char &;
    };
template<> struct iterator_traits<const wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const wchar_t *;
        using reference = const wchar_t &;
    };
template<> struct iterator_traits<wchar_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<wchar_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = wchar_t *;
        using reference = wchar_t &;
    };
template<> struct iterator_traits<const char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char8_t *;
        using reference = const char8_t &;
    };
template<> struct iterator_traits<char8_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<char8_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = char8_t *;
        using reference = char8_t &;
    };
template<> struct iterator_traits<const char16_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char16_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char16_t *;
        using reference = const char16_t &;
    };
template<> struct iterator_traits<const char32_t *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<const char32_t>;
        using difference_type = std::ptrdiff_t;
        using pointer = const char32_t *;
        using reference = const char32_t &;
    };
    template <typename _Tp> struct iterator_traits<_Tp *> {
        using iterator_concept = std::contiguous_iterator_tag;
        using iterator_category = std::random_access_iterator_tag;
        using value_type = remove_cv_t<_Tp>;
        using difference_type = std::ptrdiff_t;
        using pointer = _Tp *;
        using reference = _Tp &;
    };
    template <typename _Iter> inline constexpr typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)     {
        return typename iterator_traits<_Iter>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<char *>::iterator_category __iterator_category<char *>(char *const &)     {
        return typename iterator_traits<char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::iterator_category __iterator_category<wchar_t *>(wchar_t *const &)     {
        return typename iterator_traits<wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<char8_t *>::iterator_category __iterator_category<char8_t *>(char8_t *const &)     {
        return typename iterator_traits<char8_t *>::iterator_category();
    }
    template <typename _Iter> using __iterator_category_t = typename iterator_traits<_Iter>::iterator_category;
    template <typename _InIter> using _RequireInputIter = __enable_if_t<is_convertible<__iterator_category_t<_InIter>, input_iterator_tag>::value>;
    template <typename _It, typename _Cat = __iterator_category_t<_It>> struct __is_random_access_iter : is_base_of<std::random_access_iterator_tag, _Cat> {
        typedef is_base_of<std::random_access_iterator_tag, _Cat> _Base;
        enum  {
            __value = _Base::value
        };
    };
}
namespace std {
    template <typename> struct _List_iterator;
    template <typename> struct _List_const_iterator;
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        while (__first != __last)
            {
                ++__first;
                ++__n;
            }
        return __n;
    }
    template <typename _RandomAccessIterator> inline constexpr typename iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>, std::input_iterator_tag);
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_const_iterator<_Tp>, std::_List_const_iterator<_Tp>, std::input_iterator_tag);
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void __advance(_InputIterator &__i, _Distance __n, std::input_iterator_tag)     {
        ;
        while (__n--)
            ++__i;
    }
    template <typename _BidirectionalIterator, typename _Distance> inline constexpr void __advance(_BidirectionalIterator &__i, _Distance __n, std::bidirectional_iterator_tag)     {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }
    template <typename _RandomAccessIterator, typename _Distance> inline constexpr void __advance(_RandomAccessIterator &__i, _Distance __n, std::random_access_iterator_tag)     {
        if (__builtin_constant_p(__n) && __n == 1)
            ++__i;
        else if (__builtin_constant_p(__n) && __n == -1)
            --__i;
        else
            __i += __n;
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void advance(_InputIterator &__i, _Distance __n)     {
        typename iterator_traits<_InputIterator>::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }
    template <typename _InputIterator> inline constexpr _InputIterator next(_InputIterator __x, typename iterator_traits<_InputIterator>::difference_type __n = 1)     {
        std::advance(__x, __n);
        return __x;
    }
    template <typename _BidirectionalIterator> inline constexpr _BidirectionalIterator prev(_BidirectionalIterator __x, typename iterator_traits<_BidirectionalIterator>::difference_type __n = 1)     {
        std::advance(__x, -__n);
        return __x;
    }
}
extern "C++" {
    namespace std {
        class exception {
        public:
            exception() noexcept             {
            }
            virtual ~exception() noexcept;
            exception(const std::exception &) = default
            std::exception &operator=(const std::exception &) = default
            exception(std::exception &&) = default
            std::exception &operator=(std::exception &&) = default
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_exception : public std::exception {
        public:
            bad_exception() noexcept : std::exception()             {
            }
            virtual ~bad_exception() noexcept;
            virtual const char *what() const noexcept;
        };
        typedef void (*terminate_handler)();
        typedef void (*unexpected_handler)();
        std::terminate_handler set_terminate(std::terminate_handler) noexcept;
        std::terminate_handler get_terminate() noexcept;
        void terminate() noexcept;
        std::unexpected_handler set_unexpected(std::unexpected_handler) noexcept;
        std::unexpected_handler get_unexpected() noexcept;
        void unexpected();
        bool uncaught_exception() noexcept [[deprecated("")]] __attribute__((pure));
        int uncaught_exceptions() noexcept __attribute__((pure));
    }
    namespace __gnu_cxx {
        void __verbose_terminate_handler();
    }
}
typedef long ptrdiff_t;
typedef unsigned long size_t;
typedef unsigned long rsize_t;
typedef struct {
    long long __clang_max_align_nonce1 __attribute__((aligned(__alignof(long long))));
    long double __clang_max_align_nonce2 __attribute__((aligned(__alignof(long double))));
} max_align_t;
namespace std {
    class type_info;
}
namespace __cxxabiv1 {
    struct __cxa_refcounted_exception;
    extern "C" {
        void *__cxa_allocate_exception(size_t) noexcept;
        void __cxa_free_exception(void *) noexcept;
        __cxxabiv1::__cxa_refcounted_exception *__cxa_init_primary_exception(void *object, std::type_info *tinfo, void (*dest)(void *)) noexcept;
    }
}
namespace std {
    std::size_t _Hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
    std::size_t _Fnv_hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
}
extern "C++" {
    namespace __cxxabiv1 {
        class __class_type_info;
    }
    namespace std {
        class type_info {
        public:
            virtual ~type_info() noexcept;
            const char *name() const noexcept             {
                return this->__name[0] == '*' ? this->__name + 1 : this->__name;
            }
            bool before(const std::type_info &__arg) const noexcept             {
                return (this->__name[0] == '*' && __arg.__name[0] == '*') ? this->__name < __arg.__name : __builtin_strcmp(this->__name, __arg.__name) < 0;
            }
            bool operator==(const std::type_info &__arg) const noexcept             {
                return ((this->__name == __arg.__name) || (this->__name[0] != '*' && __builtin_strcmp(this->__name, __arg.__name) == 0));
            }
            std::size_t hash_code() const noexcept             {
                return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast<std::size_t>(3339675911UL));
            }
            virtual bool __is_pointer_p() const;
            virtual bool __is_function_p() const;
            virtual bool __do_catch(const std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
            virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target, void **__obj_ptr) const;
        protected:
            const char *__name;
            explicit type_info(const char *__n) : __name(__n)             {
            }
        private:
            std::type_info &operator=(const std::type_info &);
            type_info(const std::type_info &);
        };
        class bad_cast : public std::exception {
        public:
            bad_cast() noexcept : std::exception()             {
            }
            virtual ~bad_cast() noexcept;
            virtual const char *what() const noexcept;
        };
        class bad_typeid : public std::exception {
        public:
            bad_typeid() noexcept : std::exception()             {
            }
            virtual ~bad_typeid() noexcept;
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class type_info;
        namespace __exception_ptr {
            class exception_ptr;
        }
        using __exception_ptr::exception_ptr;
        std::__exception_ptr::exception_ptr current_exception() noexcept;
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex) noexcept;
        void rethrow_exception(std::__exception_ptr::exception_ptr);
        namespace __exception_ptr {
            using std::rethrow_exception;
            class exception_ptr {
                void *_M_exception_object;
                explicit exception_ptr(void *__e) noexcept;
                void _M_addref() noexcept;
                void _M_release() noexcept;
                void *_M_get() const noexcept __attribute__((pure));
                friend std::__exception_ptr::exception_ptr std::current_exception() noexcept;
                friend void std::rethrow_exception(std::__exception_ptr::exception_ptr);
                friend template <typename _Ex> std::__exception_ptr::exception_ptr std::make_exception_ptr(_Ex) noexcept;
            public:
                exception_ptr() noexcept;
                exception_ptr(const std::__exception_ptr::exception_ptr &) noexcept;
                exception_ptr(std::nullptr_t) noexcept : _M_exception_object(0)                 {
                }
                exception_ptr(std::__exception_ptr::exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object)                 {
                    __o._M_exception_object = 0;
                }
                std::__exception_ptr::exception_ptr &operator=(const std::__exception_ptr::exception_ptr &) noexcept;
                std::__exception_ptr::exception_ptr &operator=(std::__exception_ptr::exception_ptr &&__o) noexcept                 {
                    std::__exception_ptr::exception_ptr(static_cast<std::__exception_ptr::exception_ptr &&>(__o)).swap(*this);
                    return *this;
                }
                ~exception_ptr() noexcept;
                void swap(std::__exception_ptr::exception_ptr &) noexcept;
                explicit operator bool() const                 {
                    return this->_M_exception_object;
                }
                friend bool operator==(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
                const class std::type_info *__cxa_exception_type() const noexcept __attribute__((pure));
            };
            bool operator==(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
            bool operator!=(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
            inline void swap(std::__exception_ptr::exception_ptr &__lhs, std::__exception_ptr::exception_ptr &__rhs)             {
                __lhs.swap(__rhs);
            }
            template <typename _Ex> inline void __dest_thunk(void *__x)             {
                static_cast<_Ex *>(__x)->~_Ex();
            }
        }
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept         {
            void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
            (void)__cxxabiv1::__cxa_init_primary_exception(__e, const_cast<std::type_info *>(&typeid(__ex)), __exception_ptr::__dest_thunk<_Ex>);
            try {
                ::new (__e) _Ex((__ex));
                return std::__exception_ptr::exception_ptr(__e);
            } catch (...) {
                __cxxabiv1::__cxa_free_exception(__e);
                return current_exception();
            }
        }
    }
}
extern "C++" {
    namespace std {
        class nested_exception {
            std::__exception_ptr::exception_ptr _M_ptr;
        public:
            nested_exception() noexcept : _M_ptr(current_exception())             {
            }
            nested_exception(const std::nested_exception &) noexcept = default
            std::nested_exception &operator=(const std::nested_exception &) noexcept = default
            virtual ~nested_exception() noexcept;
            void rethrow_nested() const [[noreturn]]             {
                if (this->_M_ptr)
                    rethrow_exception(this->_M_ptr);
                std::terminate();
            }
            std::__exception_ptr::exception_ptr nested_ptr() const noexcept             {
                return this->_M_ptr;
            }
        };
        template <typename _Except> struct _Nested_exception : public _Except, public std::nested_exception {
            explicit _Nested_exception<_Except>(const _Except &__ex) : _Except(__ex)             {
            }
            explicit _Nested_exception<_Except>(_Except &&__ex) : _Except(static_cast<_Except &&>(__ex))             {
            }
        };
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::true_type) [[noreturn]]         {
            using _Up = typename remove_reference<_Tp>::type;
            throw _Nested_exception<_Up>({std::forward<_Tp>(__t)});
        }
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::false_type) [[noreturn]]         {
            throw std::forward<_Tp>(__t);
        }
        template <typename _Tp> inline void throw_with_nested(_Tp &&__t) [[noreturn]]         {
            using _Up = typename decay<_Tp>::type;
            using _CopyConstructible = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
            static_assert(_CopyConstructible::value, "throw_with_nested argument must be CopyConstructible");
            using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>, __not_<is_base_of<std::nested_exception, _Up>>>;
            std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest({}));
        }
        template <typename _Tp> using __rethrow_if_nested_cond = typename enable_if<__and_<is_polymorphic<_Tp>, __or_<__not_<is_base_of<nested_exception, _Tp>>, is_convertible<_Tp *, nested_exception *>>>::value>::type;
        template <typename _Ex> inline __rethrow_if_nested_cond<_Ex> __rethrow_if_nested_impl(const _Ex *__ptr)         {
            if (auto __ne_ptr = dynamic_cast<const std::nested_exception *>(__ptr))
                __ne_ptr->rethrow_nested();
        }
        inline void __rethrow_if_nested_impl(const void *)         {
        }
        template <typename _Ex> inline void rethrow_if_nested(const _Ex &__ex)         {
            std::__rethrow_if_nested_impl(std::__addressof(__ex));
        }
    }
}
extern "C++" {
    namespace std {
        class bad_alloc : public std::exception {
        public:
            bad_alloc() throw() : std::exception()             {
            }
            bad_alloc(const std::bad_alloc &) = default
            std::bad_alloc &operator=(const std::bad_alloc &) = default
            virtual ~bad_alloc() throw();
            virtual const char *what() const throw();
        };
        class bad_array_new_length : public std::bad_alloc {
        public:
            bad_array_new_length() throw() : std::bad_alloc()             {
            }
            virtual ~bad_array_new_length() throw();
            virtual const char *what() const throw();
        };
        enum class align_val_t : std::size_t {
        };
        struct nothrow_t {
            explicit nothrow_t() = default
        };
        extern const std::nothrow_t nothrow;
        typedef void (*new_handler)();
        std::new_handler set_new_handler(std::new_handler) throw();
        std::new_handler get_new_handler() noexcept;
    }
    void *operator new(std::size_t) [[nodiscard("")]];
    void *operator new[](std::size_t) [[nodiscard("")]];
    void operator delete(void *) noexcept;
    void operator delete[](void *) noexcept;
    void *operator new(std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void *operator new[](std::size_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void operator delete(void *, const std::nothrow_t &) noexcept;
    void operator delete[](void *, const std::nothrow_t &) noexcept;
    void *operator new(std::size_t, std::align_val_t) [[nodiscard("")]];
    void *operator new(std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void operator delete(void *, std::align_val_t) noexcept;
    void operator delete(void *, std::align_val_t, const std::nothrow_t &) noexcept;
    void *operator new[](std::size_t, std::align_val_t) [[nodiscard("")]];
    void *operator new[](std::size_t, std::align_val_t, const std::nothrow_t &) noexcept [[nodiscard("")]] __attribute__((malloc));
    void operator delete[](void *, std::align_val_t) noexcept;
    void operator delete[](void *, std::align_val_t, const std::nothrow_t &) noexcept;
    inline void *operator new(std::size_t, void *__p) noexcept [[nodiscard("")]]     {
        return __p;
    }
    inline void *operator new[](std::size_t, void *__p) noexcept [[nodiscard("")]]     {
        return __p;
    }
    inline void operator delete(void *, void *) noexcept     {
    }
    inline void operator delete[](void *, void *) noexcept     {
    }
}
namespace std {
    template <typename _Tp> constexpr _Tp *launder(_Tp *__p) noexcept [[nodiscard("")]]     {
        return __builtin_launder(__p);
    }
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args...) noexcept(_NE)) = delete
    template <typename _Ret, typename ..._Args, bool _NE> void launder(_Ret (*)(_Args..., ...) noexcept(_NE)) = delete
    void launder(void *) = delete
    void launder(const void *) = delete
    void launder(volatile void *) = delete
    void launder(const volatile void *) = delete
}
namespace std {
    struct destroying_delete_t {
        explicit destroying_delete_t() noexcept = default
    };
    constexpr std::destroying_delete_t destroying_delete{};
}
namespace std {
    namespace __detail {
        template <typename _Cat, typename _Limit, typename _Otherwise = _Cat> using __clamp_iter_cat = conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
    }
    template <typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference> {
    protected:
        _Iterator current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::pointer pointer;
        typedef typename __traits_type::reference reference;
        using iterator_concept = conditional_t<random_access_iterator<_Iterator>, std::random_access_iterator_tag, std::bidirectional_iterator_tag>;
        using iterator_category = __detail::__clamp_iter_cat<typename __traits_type::iterator_category, random_access_iterator_tag>;
        constexpr reverse_iterator<_Iterator>() : current()         {
        }
        constexpr explicit reverse_iterator<_Iterator>(std::reverse_iterator::iterator_type __x) : current(__x)         {
        }
        constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) : current(__x.current)         {
        }
        reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iterator> &) = default
        template <typename _Iter> constexpr reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) : current(__x.base())         {
        }
        constexpr std::reverse_iterator::iterator_type base() const         {
            return this->current;
        }
        constexpr std::reverse_iterator::reference operator*() const         {
            _Iterator __tmp = this->current;
            return *--__tmp;
        }
        constexpr std::reverse_iterator::pointer operator->() const requires is_pointer_v<_Iterator> || requires (const _Iterator __i) { __i.operator->(); }         {
            _Iterator __tmp = this->current;
            --__tmp;
            return _S_to_pointer(__tmp);
        }
        constexpr reverse_iterator<_Iterator> &operator++()         {
            --this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator++(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            --this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> &operator--()         {
            ++this->current;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator--(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            ++this->current;
            return __tmp;
        }
        constexpr reverse_iterator<_Iterator> operator+(std::reverse_iterator::difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current - __n);
        }
        constexpr reverse_iterator<_Iterator> &operator+=(std::reverse_iterator::difference_type __n)         {
            this->current -= __n;
            return *this;
        }
        constexpr reverse_iterator<_Iterator> operator-(std::reverse_iterator::difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current + __n);
        }
        constexpr reverse_iterator<_Iterator> &operator-=(std::reverse_iterator::difference_type __n)         {
            this->current += __n;
            return *this;
        }
        constexpr std::reverse_iterator::reference operator[](std::reverse_iterator::difference_type __n) const         {
            return *(*this + __n);
        }
        friend constexpr iter_rvalue_reference_t<_Iterator> iter_move(const reverse_iterator<_Iterator> &__i) noexcept(is_nothrow_copy_constructible_v<_Iterator> && noexcept(ranges::iter_move(--std::declval<_Iterator &>()))iter_move(const reverse_iterator<_Iterator> &__i) noexcept(is_nothrow_copy_constructible_v<_Iterator> && noexcept(ranges::iter_move(--std::declval<_Iterator &>())))         {
            auto __tmp = __i.base();
            return ranges::iter_move(--__tmp);
        }
;
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iter2> &__y) noexcept(is_nothrow_copy_constructible_v<_Iterator> && is_nothrow_copy_constructible_v<_Iter2> && noexcept(ranges::iter_swap(--std::declval<_Iterator &>(), --std::declval<_Iter2 &>()))iter_swap(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iter2> &__y) noexcept(is_nothrow_copy_constructible_v<_Iterator> && is_nothrow_copy_constructible_v<_Iter2> && noexcept(ranges::iter_swap(--std::declval<_Iterator &>(), --std::declval<_Iter2 &>())))         {
            auto __xtmp = __x.base();
            auto __ytmp = __y.base();
            ranges::iter_swap(--__xtmp, --__ytmp);
        }
;
    private:
        template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p)         {
            return __p;
        }
        template <typename _Tp> static constexpr std::reverse_iterator::pointer _S_to_pointer(_Tp __t)         {
            return __t.operator->();
        }
    };
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator==(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator!=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }     {
        return __x.base() != __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator<(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }     {
        return __x.base() > __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }     {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator<=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }     {
        return __x.base() >= __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> constexpr bool operator>=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }     {
        return __x.base() <= __y.base();
    }
    template <typename _IteratorL, three_way_comparable_with<_IteratorL> _IteratorR> constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y.base() <=> __x.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base())     {
        return __y.base() - __x.base();
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> operator+(typename reverse_iterator<_Iterator>::difference_type __n, const reverse_iterator<_Iterator> &__x)     {
        return reverse_iterator<_Iterator>(__x.base() - __n);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> __make_reverse_iterator(_Iterator __i)     {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> inline constexpr reverse_iterator<_Iterator> make_reverse_iterator(_Iterator __i)     {
        return reverse_iterator<_Iterator>(__i);
    }
    constexpr bool disable_sized_sentinel_for = true;
    template <typename _Iterator> constexpr auto __niter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__niter_base(__it.base())))     {
        return __make_reverse_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<reverse_iterator<_Iterator>> : __is_move_iterator<_Iterator> {
    };
    template <typename _Iterator> constexpr auto __miter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__miter_base(__it.base())))     {
        return __make_reverse_iterator(__miter_base(__it.base()));
    }
    template <typename _Container> class back_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        using difference_type = std::ptrdiff_t;
        constexpr back_insert_iterator<_Container>() noexcept : container(nullptr)         {
        }
        constexpr explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        constexpr back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_back(__value);
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_back(std::move(__value));
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator*()         {
            return *this;
        }
        constexpr back_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        constexpr back_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline constexpr back_insert_iterator<_Container> back_inserter(_Container &__x)     {
        return back_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class front_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        using difference_type = std::ptrdiff_t;
        constexpr front_insert_iterator<_Container>() noexcept : container(nullptr)         {
        }
        constexpr explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        constexpr front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_front(__value);
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_front(std::move(__value));
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator*()         {
            return *this;
        }
        constexpr front_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        constexpr front_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline constexpr front_insert_iterator<_Container> front_inserter(_Container &__x)     {
        return front_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
        using _Iter = std::__detail::__range_iter_t<_Container>;
    protected:
        _Container *container = nullptr;
        std::insert_iterator::_Iter iter = std::insert_iterator::_Iter();
    public:
        typedef _Container container_type;
        using difference_type = std::ptrdiff_t;
        insert_iterator<_Container>() = default
        constexpr insert_iterator<_Container>(_Container &__x, std::insert_iterator::_Iter __i) : container(std::__addressof(__x)), iter(__i)         {
        }
        constexpr insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->iter = this->container->insert(this->iter, __value);
            ++this->iter;
            return *this;
        }
        constexpr insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->iter = this->container->insert(this->iter, std::move(__value));
            ++this->iter;
            return *this;
        }
        constexpr insert_iterator<_Container> &operator*()         {
            return *this;
        }
        constexpr insert_iterator<_Container> &operator++()         {
            return *this;
        }
        constexpr insert_iterator<_Container> &operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> constexpr insert_iterator<_Container> inserter(_Container &__x, std::__detail::__range_iter_t<_Container> __i)     {
        return insert_iterator<_Container>(__x, __i);
    }
}
namespace __gnu_cxx {
    template <typename _Iterator, typename _Container> class __normal_iterator {
    protected:
        _Iterator _M_current;
        typedef std::iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        using iterator_concept = std::__detail::__iter_concept<_Iterator>;
        constexpr __normal_iterator<_Iterator, _Container>() noexcept : _M_current(_Iterator())         {
        }
        constexpr explicit __normal_iterator<_Iterator, _Container>(const _Iterator &__i) noexcept : _M_current(__i)         {
        }
        template <typename _Iter> constexpr __normal_iterator<_Iterator, _Container>(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename _Container::pointer>::__value), _Container>::__type> &__i) noexcept : _M_current(__i.base())         {
        }
        constexpr __gnu_cxx::__normal_iterator::reference operator*() const noexcept         {
            return *this->_M_current;
        }
        constexpr __gnu_cxx::__normal_iterator::pointer operator->() const noexcept         {
            return this->_M_current;
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator++() noexcept         {
            ++this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator++(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current++);
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator--() noexcept         {
            --this->_M_current;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator--(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current--);
        }
        constexpr __gnu_cxx::__normal_iterator::reference operator[](__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return this->_M_current[__n];
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator+=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current += __n;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator+(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current + __n);
        }
        constexpr __normal_iterator<_Iterator, _Container> &operator-=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current -= __n;
            return *this;
        }
        constexpr __normal_iterator<_Iterator, _Container> operator-(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current - __n);
        }
        constexpr const _Iterator &base() const noexcept         {
            return this->_M_current;
        }
    };
    template <typename _IteratorL, typename _IteratorR, typename _Container> constexpr bool operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base())operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base()))     {
        return __lhs.base() == __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL> operator<=>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base()))operator<=>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))     {
        return std::__detail::__synth3way(__lhs.base(), __rhs.base());
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline constexpr auto operator-(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base())     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline constexpr typename __normal_iterator<_Iterator, _Container>::difference_type operator-(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline constexpr __normal_iterator<_Iterator, _Container> operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n, const __normal_iterator<_Iterator, _Container> &__i) noexcept     {
        return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
    }
}
namespace std {
    template <typename _Iterator, typename _Container> constexpr _Iterator __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it.base();
    }
    template <semiregular _Sent> class move_sentinel {
    public:
        constexpr move_sentinel<_Sent>() noexcept(is_nothrow_default_constructible_v<_Sent>move_sentinel<_Sent>() noexcept(is_nothrow_default_constructible_v<_Sent>) : _M_last()         {
        }
        constexpr explicit move_sentinel<_Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>move_sentinel<_Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>) : _M_last(std::move(__s))         {
        }
        template <typename _S2> constexpr move_sentinel<_Sent>(const move_sentinel<_S2> &__s) noexcept(is_nothrow_constructible_v<_Sent, const _S2 &>move_sentinel<_Sent>(const move_sentinel<_S2> &__s) noexcept(is_nothrow_constructible_v<_Sent, const _S2 &>) : _M_last(__s.base())         {
        }
        template <typename _S2> constexpr move_sentinel<_Sent> &operator=(const move_sentinel<_S2> &__s) noexcept(is_nothrow_assignable_v<_Sent, const _S2 &>operator=(const move_sentinel<_S2> &__s) noexcept(is_nothrow_assignable_v<_Sent, const _S2 &>)         {
            this->_M_last = __s.base();
            return *this;
        }
        constexpr _Sent base() const noexcept(is_nothrow_copy_constructible_v<_Sent>base() const noexcept(is_nothrow_copy_constructible_v<_Sent>)         {
            return this->_M_last;
        }
    private:
        _Sent _M_last;
    };
    template <typename _Iterator> class move_iterator {
        _Iterator _M_current;
        using __traits_type = iterator_traits<_Iterator>;
        using __base_cat = typename __traits_type::iterator_category;
    public:
        using iterator_type = _Iterator;
        using iterator_concept = std::input_iterator_tag;
        using iterator_category = __detail::__clamp_iter_cat<__base_cat, random_access_iterator_tag>;
        using value_type = iter_value_t<_Iterator>;
        using difference_type = iter_difference_t<_Iterator>;
        using pointer = _Iterator;
        using reference = iter_rvalue_reference_t<_Iterator>;
        constexpr move_iterator<_Iterator>() : _M_current()         {
        }
        constexpr explicit move_iterator<_Iterator>(std::move_iterator::iterator_type __i) : _M_current(std::move(__i))         {
        }
        template <typename _Iter> constexpr move_iterator<_Iterator>(const move_iterator<_Iter> &__i) : _M_current(__i.base())         {
        }
        constexpr std::move_iterator::iterator_type base() const & requires copy_constructible<std::move_iterator::iterator_type>         {
            return this->_M_current;
        }
        constexpr std::move_iterator::iterator_type base() &&         {
            return std::move(this->_M_current);
        }
        constexpr std::move_iterator::reference operator*() const         {
            return ranges::iter_move(this->_M_current);
        }
        constexpr std::move_iterator::pointer operator->() const         {
            return this->_M_current;
        }
        constexpr move_iterator<_Iterator> &operator++()         {
            ++this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator++(int)         {
            move_iterator<_Iterator> __tmp = *this;
            ++this->_M_current;
            return __tmp;
        }
        constexpr void operator++(int) requires (!forward_iterator<_Iterator>)         {
            ++this->_M_current;
        }
        constexpr move_iterator<_Iterator> &operator--()         {
            --this->_M_current;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator--(int)         {
            move_iterator<_Iterator> __tmp = *this;
            --this->_M_current;
            return __tmp;
        }
        constexpr move_iterator<_Iterator> operator+(std::move_iterator::difference_type __n) const         {
            return move_iterator<_Iterator>(this->_M_current + __n);
        }
        constexpr move_iterator<_Iterator> &operator+=(std::move_iterator::difference_type __n)         {
            this->_M_current += __n;
            return *this;
        }
        constexpr move_iterator<_Iterator> operator-(std::move_iterator::difference_type __n) const         {
            return move_iterator<_Iterator>(this->_M_current - __n);
        }
        constexpr move_iterator<_Iterator> &operator-=(std::move_iterator::difference_type __n)         {
            this->_M_current -= __n;
            return *this;
        }
        constexpr std::move_iterator::reference operator[](std::move_iterator::difference_type __n) const         {
            return ranges::iter_move(this->_M_current + __n);
        }
        friend template <sentinel_for<_Iterator> _Sent> constexpr bool operator==(const move_iterator<_Iterator> &__x, const move_sentinel<_Sent> &__y)         {
            return __x.base() == __y.base();
        }
;
        friend template <sized_sentinel_for<_Iterator> _Sent> constexpr iter_difference_t<_Iterator> operator-(const move_sentinel<_Sent> &__x, const move_iterator<_Iterator> &__y)         {
            return __x.base() - __y.base();
        }
;
        friend template <sized_sentinel_for<_Iterator> _Sent> constexpr iter_difference_t<_Iterator> operator-(const move_iterator<_Iterator> &__x, const move_sentinel<_Sent> &__y)         {
            return __x.base() - __y.base();
        }
;
        friend constexpr iter_rvalue_reference_t<_Iterator> iter_move(const move_iterator<_Iterator> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))iter_move(const move_iterator<_Iterator> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current)))         {
            return ranges::iter_move(__i._M_current);
        }
;
        friend template <indirectly_swappable<_Iterator> _Iter2> constexpr void iter_swap(const move_iterator<_Iterator> &__x, const move_iterator<_Iter2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current))iter_swap(const move_iterator<_Iterator> &__x, const move_iterator<_Iter2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))         {
            return ranges::iter_swap(__x._M_current, __y._M_current);
        }
;
    };
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator==(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, three_way_comparable_with<_IteratorL> _IteratorR> constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return __x.base() <=> __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }     {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator<=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }     {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }     {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr bool operator>=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }     {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline constexpr auto operator-(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base())     {
        return __x.base() - __y.base();
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> operator+(typename move_iterator<_Iterator>::difference_type __n, const move_iterator<_Iterator> &__x)     {
        return __x + __n;
    }
    template <typename _Iterator> inline constexpr move_iterator<_Iterator> make_move_iterator(_Iterator __i)     {
        return move_iterator<_Iterator>(std::move(__i));
    }
    template <typename _Iterator, typename _ReturnType = typename conditional<__move_if_noexcept_cond<typename iterator_traits<_Iterator>::value_type>::value, _Iterator, move_iterator<_Iterator>>::type> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Iterator __i)     {
        return _ReturnType(__i);
    }
    template <typename _Tp, typename _ReturnType = typename conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp *, move_iterator<_Tp *>>::type> inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Tp *__i)     {
        return _ReturnType(__i);
    }
    namespace __detail {
        template <typename _It> concept __common_iter_has_arrow = indirectly_readable<const _It> && (requires (const _It &__it) { __it.operator->(); } || is_reference_v<iter_reference_t<_It>> || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);;
    }
    template <input_or_output_iterator _It, sentinel_for<_It> _Sent> class common_iterator {
        template <typename _Tp, typename _Up> static constexpr bool _S_noexcept1()         {
            if (is_trivially_default_constructible_v<_Tp>)
                return is_nothrow_assignable_v<_Tp, _Up>;
            else
                return is_nothrow_constructible_v<_Tp, _Up>;
        }
        template <typename _It2, typename _Sent2> static constexpr bool _S_noexcept()         {
            return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>();
        }
        class _Proxy {
            iter_value_t<_It> _M_keep;
            _Proxy(iter_reference_t<_It> &&__x) : _M_keep(std::move(__x))             {
            }
            friend  class common_iterator<_It, _Sent>;
        public:
            const iter_value_t<_It> *operator->() const             {
                return std::__addressof(this->_M_keep);
            }
        };
    public:
        constexpr common_iterator<_It, _Sent>() noexcept(is_nothrow_default_constructible_v<_It>common_iterator<_It, _Sent>() noexcept(is_nothrow_default_constructible_v<_It>) : _M_it(), _M_index(0)         {
        }
        constexpr common_iterator<_It, _Sent>(_It __i) noexcept(is_nothrow_move_constructible_v<_It>common_iterator<_It, _Sent>(_It __i) noexcept(is_nothrow_move_constructible_v<_It>) : _M_it(std::move(__i)), _M_index(0)         {
        }
        constexpr common_iterator<_It, _Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>common_iterator<_It, _Sent>(_Sent __s) noexcept(is_nothrow_move_constructible_v<_Sent>) : _M_sent(std::move(__s)), _M_index(1)         {
        }
        template <typename _It2, typename _Sent2> constexpr common_iterator<_It, _Sent>(const common_iterator<_It2, _Sent2> &__x) noexcept(_S_noexcept<const _It2 &, const _Sent2 &>()common_iterator<_It, _Sent>(const common_iterator<_It2, _Sent2> &__x) noexcept(_S_noexcept<const _It2 &, const _Sent2 &>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index)         {
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = std::move(__x._M_it);
                else
                    ::new ((void *)std::__addressof(this->_M_it)) _It((__x._M_it));
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = std::move(__x._M_sent);
                else
                    ::new ((void *)std::__addressof(this->_M_sent)) _Sent((__x._M_sent));
            }
        }
        constexpr common_iterator<_It, _Sent>(const common_iterator<_It, _Sent> &__x) noexcept(_S_noexcept<const _It &, const _Sent &>()common_iterator<_It, _Sent>(const common_iterator<_It, _Sent> &__x) noexcept(_S_noexcept<const _It &, const _Sent &>()) : _M_valueless(/*implicit*/(unsigned char)0), _M_index(__x._M_index)         {
            if (this->_M_index == 0) {
                if (is_trivially_default_constructible_v<_It>)
                    this->_M_it = std::move(__x._M_it);
                else
                    ::new ((void *)std::__addressof(this->_M_it)) _It((__x._M_it));
            } else if (this->_M_index == 1) {
                if (is_trivially_default_constructible_v<_Sent>)
                    this->_M_sent = std::move(__x._M_sent);
                else
                    ::new ((void *)std::__addressof(this->_M_sent)) _Sent((__x._M_sent));
            }
        }
        common_iterator<_It, _Sent> &operator=(const common_iterator<_It, _Sent> &__x) noexcept(is_nothrow_copy_assignable_v<_It> && is_nothrow_copy_assignable_v<_Sent> && is_nothrow_copy_constructible_v<_It> && is_nothrow_copy_constructible_v<_Sent>operator=(const common_iterator<_It, _Sent> &__x) noexcept(is_nothrow_copy_assignable_v<_It> && is_nothrow_copy_assignable_v<_Sent> && is_nothrow_copy_constructible_v<_It> && is_nothrow_copy_constructible_v<_Sent>)         {
            return this->operator=<_It, _Sent>(__x);
        }
        template <typename _It2, typename _Sent2> common_iterator<_It, _Sent> &operator=(const common_iterator<_It2, _Sent2> &__x) noexcept(is_nothrow_constructible_v<_It, const _It2 &> && is_nothrow_constructible_v<_Sent, const _Sent2 &> && is_nothrow_assignable_v<_It, const _It2 &> && is_nothrow_assignable_v<_Sent, const _Sent2 &>operator=(const common_iterator<_It2, _Sent2> &__x) noexcept(is_nothrow_constructible_v<_It, const _It2 &> && is_nothrow_constructible_v<_Sent, const _Sent2 &> && is_nothrow_assignable_v<_It, const _It2 &> && is_nothrow_assignable_v<_Sent, const _Sent2 &>)         {
            switch (this->_M_index << 2 | __x._M_index) {
              case 0:
                this->_M_it = __x._M_it;
                break;
              case 5:
                this->_M_sent = __x._M_sent;
                break;
              case 1:
                this->_M_it.~_It();
                this->_M_index = -1;
 [[fallthrough]]                ;
              case 9:
                ::new ((void *)std::__addressof(this->_M_sent)) _Sent((__x._M_sent));
                this->_M_index = 1;
                break;
              case 4:
                this->_M_sent.~_Sent();
                this->_M_index = -1;
 [[fallthrough]]                ;
              case 8:
                ::new ((void *)std::__addressof(this->_M_it)) _It((__x._M_it));
                this->_M_index = 0;
                break;
              default:
                ;
                __builtin_unreachable();
            }
            return *this;
        }
        ~common_iterator<_It, _Sent>()         {
            switch (this->_M_index) {
              case 0:
                this->_M_it.~_It();
                break;
              case 1:
                this->_M_sent.~_Sent();
                break;
            }
        }
        decltype(auto) operator*()         {
            ;
            return *this->_M_it;
        }
        decltype(auto) operator*() const requires __detail::__dereferenceable<const _It>         {
            ;
            return *this->_M_it;
        }
        decltype(auto) operator->() const requires __detail::__common_iter_has_arrow<_It>         {
            ;
            if (is_pointer_v<_It> || requires { this->_M_it.operator->(); })
                return this->_M_it;
            else if (is_reference_v<iter_reference_t<_It>>) {
                auto &&__tmp = *this->_M_it;
                return std::__addressof(__tmp);
            } else
                return std::common_iterator::_Proxy({*this->_M_it});
        }
        common_iterator<_It, _Sent> &operator++()         {
            ;
            ++this->_M_it;
            return *this;
        }
        decltype(auto) operator++(int)         {
            ;
            if (forward_iterator<_It>) {
                common_iterator<_It, _Sent> __tmp = *this;
                ++*this;
                return __tmp;
            } else
                return this->_M_it++;
        }
        friend template <typename _It2, sentinel_for<_It> _Sent2> bool operator==(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y)         {
            switch (__x._M_index << 2 | __y._M_index) {
              case 0:
              case 5:
                return true;
              case 1:
                return __x._M_it == __y._M_sent;
              case 4:
                return __x._M_sent == __y._M_it;
              default:
                ;
                ;
                __builtin_unreachable();
            }
        }
;
        friend template <typename _It2, sentinel_for<_It> _Sent2> bool operator==(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y)         {
            switch (__x._M_index << 2 | __y._M_index) {
              case 5:
                return true;
              case 0:
                return __x._M_it == __y._M_it;
              case 1:
                return __x._M_it == __y._M_sent;
              case 4:
                return __x._M_sent == __y._M_it;
              default:
                ;
                ;
                __builtin_unreachable();
            }
        }
;
        friend template <sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2> iter_difference_t<_It2> operator-(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y)         {
            switch (__x._M_index << 2 | __y._M_index) {
              case 5:
                return 0;
              case 0:
                return __x._M_it - __y._M_it;
              case 1:
                return __x._M_it - __y._M_sent;
              case 4:
                return __x._M_sent - __y._M_it;
              default:
                ;
                ;
                __builtin_unreachable();
            }
        }
;
        friend iter_rvalue_reference_t<_It> iter_move(const common_iterator<_It, _Sent> &__i) noexcept(noexcept(ranges::iter_move(std::declval<const _It &>()))iter_move(const common_iterator<_It, _Sent> &__i) noexcept(noexcept(ranges::iter_move(std::declval<const _It &>()))) requires input_iterator<_It>         {
            ;
            return ranges::iter_move(__i._M_it);
        }
;
        friend template <indirectly_swappable<_It> _It2, typename _Sent2> void iter_swap(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) noexcept(noexcept(ranges::iter_swap(std::declval<const _It &>(), std::declval<const _It2 &>()))iter_swap(const common_iterator<_It, _Sent> &__x, const common_iterator<_It2, _Sent2> &__y) noexcept(noexcept(ranges::iter_swap(std::declval<const _It &>(), std::declval<const _It2 &>())))         {
            ;
            ;
            return ranges::iter_swap(__x._M_it, __y._M_it);
        }
;
    private:
        friend template <input_or_output_iterator _It2, sentinel_for<_It2> _Sent2> class common_iterator;
        bool _M_has_value() const noexcept         {
            return this->_M_index < 2;
        }
        union {
            _It _M_it;
            _Sent _M_sent;
            unsigned char _M_valueless;
        };
        unsigned char _M_index;
    };
    template <typename _It, typename _Sent> struct incrementable_traits<common_iterator<_It, _Sent>> {
        using difference_type = iter_difference_t<_It>;
    };
    template <input_iterator _It, typename _Sent> struct iterator_traits<common_iterator<_It, _Sent>> {
    private:
        template <typename _Iter> struct __ptr {
            using type = void;
        };
        template <typename _Iter> struct __ptr<_Iter> {
            using _CIter = common_iterator<_Iter, _Sent>;
            using type = decltype(std::declval<const std::iterator_traits<common_iterator<type-parameter-0-0, type-parameter-0-1>>::__ptr<type-parameter-1-0>::_CIter &>().operator->());
        };
    public:
        using iterator_concept = conditional_t<forward_iterator<_It>, std::forward_iterator_tag, std::input_iterator_tag>;
        using iterator_category = __detail::__clamp_iter_cat<typename iterator_traits<_It>::iterator_category, forward_iterator_tag, input_iterator_tag>;
        using value_type = iter_value_t<_It>;
        using difference_type = iter_difference_t<_It>;
        using pointer = typename __ptr<_It>::type;
        using reference = iter_reference_t<_It>;
    };
    template <input_or_output_iterator _It> class counted_iterator {
    public:
        using iterator_type = _It;
        counted_iterator<_It>() = default
        constexpr counted_iterator<_It>(_It __i, iter_difference_t<_It> __n) : _M_current(std::move(__i)), _M_length(__n)         {
            ;
        }
        template <typename _It2> constexpr counted_iterator<_It>(const counted_iterator<_It2> &__x) : _M_current(__x._M_current), _M_length(__x._M_length)         {
        }
        template <typename _It2> constexpr counted_iterator<_It> &operator=(const counted_iterator<_It2> &__x)         {
            this->_M_current = __x._M_current;
            this->_M_length = __x._M_length;
            return *this;
        }
        constexpr _It base() const & noexcept(is_nothrow_copy_constructible_v<_It>base() const & noexcept(is_nothrow_copy_constructible_v<_It>) requires copy_constructible<_It>         {
            return this->_M_current;
        }
        constexpr _It base() && noexcept(is_nothrow_move_constructible_v<_It>base() && noexcept(is_nothrow_move_constructible_v<_It>)         {
            return std::move(this->_M_current);
        }
        constexpr iter_difference_t<_It> count() const noexcept         {
            return this->_M_length;
        }
        constexpr decltype(auto) operator*() noexcept(noexcept(*this->_M_current)operator*() noexcept(noexcept(*this->_M_current))         {
            return *this->_M_current;
        }
        constexpr decltype(auto) operator*() const noexcept(noexcept(*this->_M_current)operator*() const noexcept(noexcept(*this->_M_current)) requires __detail::__dereferenceable<const _It>         {
            return *this->_M_current;
        }
        constexpr counted_iterator<_It> &operator++()         {
            ;
            ++this->_M_current;
            --this->_M_length;
            return *this;
        }
        decltype(auto) operator++(int)         {
            ;
            --this->_M_length;
            try {
                return this->_M_current++;
            } catch (...) {
                ++this->_M_length;
                throw;
            }
        }
        constexpr counted_iterator<_It> operator++(int) requires forward_iterator<_It>         {
            auto __tmp = *this;
            ++*this;
            return __tmp;
        }
        constexpr counted_iterator<_It> &operator--() requires bidirectional_iterator<_It>         {
            --this->_M_current;
            ++this->_M_length;
            return *this;
        }
        constexpr counted_iterator<_It> operator--(int) requires bidirectional_iterator<_It>         {
            auto __tmp = *this;
            --*this;
            return __tmp;
        }
        constexpr counted_iterator<_It> operator+(iter_difference_t<_It> __n) const requires random_access_iterator<_It>         {
            return counted_iterator<_It>(this->_M_current + __n, this->_M_length - __n);
        }
        friend constexpr counted_iterator<_It> operator+(iter_difference_t<_It> __n, const counted_iterator<_It> &__x) requires random_access_iterator<_It>         {
            return __x + __n;
        }
;
        constexpr counted_iterator<_It> &operator+=(iter_difference_t<_It> __n) requires random_access_iterator<_It>         {
            ;
            this->_M_current += __n;
            this->_M_length -= __n;
            return *this;
        }
        constexpr counted_iterator<_It> operator-(iter_difference_t<_It> __n) const requires random_access_iterator<_It>         {
            return counted_iterator<_It>(this->_M_current - __n, this->_M_length + __n);
        }
        friend template <common_with<_It> _It2> constexpr iter_difference_t<_It2> operator-(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y)         {
            return __y._M_length - __x._M_length;
        }
;
        friend constexpr iter_difference_t<_It> operator-(const counted_iterator<_It> &__x, std::default_sentinel_t)         {
            return - __x._M_length;
        }
;
        friend constexpr iter_difference_t<_It> operator-(std::default_sentinel_t, const counted_iterator<_It> &__y)         {
            return __y._M_length;
        }
;
        constexpr counted_iterator<_It> &operator-=(iter_difference_t<_It> __n) requires random_access_iterator<_It>         {
            ;
            this->_M_current -= __n;
            this->_M_length += __n;
            return *this;
        }
        constexpr decltype(auto) operator[](iter_difference_t<_It> __n) const noexcept(noexcept(this->_M_current[__n])operator[](iter_difference_t<_It> __n) const noexcept(noexcept(this->_M_current[__n])) requires random_access_iterator<_It>         {
            ;
            return this->_M_current[__n];
        }
        friend template <common_with<_It> _It2> constexpr bool operator==(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y)         {
            return __x._M_length == __y._M_length;
        }
;
        friend constexpr bool operator==(const counted_iterator<_It> &__x, std::default_sentinel_t)         {
            return __x._M_length == 0;
        }
;
        friend template <common_with<_It> _It2> constexpr std::strong_ordering operator<=>(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y)         {
            return __y._M_length <=> __x._M_length;
        }
;
        friend constexpr iter_rvalue_reference_t<_It> iter_move(const counted_iterator<_It> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))iter_move(const counted_iterator<_It> &__i) noexcept(noexcept(ranges::iter_move(__i._M_current))) requires input_iterator<_It>         {
            return ranges::iter_move(__i._M_current);
        }
;
        friend template <indirectly_swappable<_It> _It2> constexpr void iter_swap(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current))iter_swap(const counted_iterator<_It> &__x, const counted_iterator<_It2> &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))         {
            ranges::iter_swap(__x._M_current, __y._M_current);
        }
;
    private:
        friend template <input_or_output_iterator _It2> class counted_iterator;
        _It _M_current = _It();
        iter_difference_t<_It> _M_length = 0;
    };
    template <typename _It> struct incrementable_traits<counted_iterator<_It>> {
        using difference_type = iter_difference_t<_It>;
    };
    template <input_iterator _It> struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It> {
        using pointer = void;
    };
    template <typename _Iterator> auto __niter_base(move_iterator<_Iterator> __it) -> decltype(make_move_iterator(__niter_base(__it.base())))     {
        return make_move_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<move_iterator<_Iterator>> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Iterator> auto __miter_base(move_iterator<_Iterator> __it) -> decltype(__miter_base(__it.base()))     {
        return __miter_base(__it.base());
    }
    template <typename _InputIterator> using __iter_key_t = remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;
    template <typename _InputIterator> using __iter_val_t = typename iterator_traits<_InputIterator>::value_type::second_type;
    template <typename _T1, typename _T2> struct pair;
    template <typename _InputIterator> using __iter_to_alloc_t = pair<add_const_t<__iter_key_t<_InputIterator>>, __iter_val_t<_InputIterator>>;
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
    template <typename _Ite, typename _Seq, typename _Cat> struct _Safe_iterator;
}
namespace __gnu_cxx {
    namespace __ops {
        struct _Iter_less_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 < *__it2;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_less_iter __iter_less_iter()         {
            return __gnu_cxx::__ops::_Iter_less_iter();
        }
        struct _Iter_less_val {
            _Iter_less_val() noexcept = default
            constexpr explicit _Iter_less_val(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it < __val;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_less_val __iter_less_val()         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        inline constexpr __gnu_cxx::__ops::_Iter_less_val __iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        struct _Val_less_iter {
            _Val_less_iter() noexcept = default
            constexpr explicit _Val_less_iter(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Value, typename _Iterator> constexpr bool operator()(_Value &__val, _Iterator __it) const             {
                return __val < *__it;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Val_less_iter __val_less_iter()         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        inline constexpr __gnu_cxx::__ops::_Val_less_iter __val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        struct _Iter_equal_to_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 == *__it2;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter()         {
            return __gnu_cxx::__ops::_Iter_equal_to_iter();
        }
        struct _Iter_equal_to_val {
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it == __val;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val()         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        inline constexpr __gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter)         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        template <typename _Compare> struct _Iter_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2)             {
                return bool(this->_M_comp(*__it1, *__it2));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)         {
            return _Iter_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Iter_comp_val {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_val<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            constexpr explicit _Iter_comp_val<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            constexpr explicit _Iter_comp_val<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Iterator, typename _Value> constexpr bool operator()(_Iterator __it, _Value &__val)             {
                return bool(this->_M_comp(*__it, __val));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline constexpr _Iter_comp_val<_Compare> __iter_comp_val(_Iter_comp_iter<_Compare> __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Val_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Val_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            constexpr explicit _Val_comp_iter<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            constexpr explicit _Val_comp_iter<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Value, typename _Iterator> constexpr bool operator()(_Value &__val, _Iterator __it)             {
                return bool(this->_M_comp(__val, *__it));
            }
        };
        template <typename _Compare> inline constexpr _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline constexpr _Val_comp_iter<_Compare> __val_comp_iter(_Iter_comp_iter<_Compare> __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Value> struct _Iter_equals_val {
            _Value &_M_value;
            constexpr explicit _Iter_equals_val<_Value>(_Value &__value) : _M_value(__value)             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return *__it == this->_M_value;
            }
        };
        template <typename _Value> inline constexpr _Iter_equals_val<_Value> __iter_equals_val(_Value &__val)         {
            return _Iter_equals_val<_Value>(__val);
        }
        template <typename _Iterator1> struct _Iter_equals_iter {
            _Iterator1 _M_it1;
            constexpr explicit _Iter_equals_iter<_Iterator1>(_Iterator1 __it1) : _M_it1(__it1)             {
            }
            template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2)             {
                return *__it2 == *this->_M_it1;
            }
        };
        template <typename _Iterator> inline constexpr _Iter_equals_iter<_Iterator> __iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it)         {
            return _Iter_equals_iter<_Iterator>(__it);
        }
        template <typename _Predicate> struct _Iter_pred {
            _Predicate _M_pred;
            constexpr explicit _Iter_pred<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline constexpr _Iter_pred<_Predicate> __pred_iter(_Predicate __pred)         {
            return _Iter_pred<_Predicate>(std::move(__pred));
        }
        template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
            _Compare _M_comp;
            _Value &_M_value;
            constexpr _Iter_comp_to_val<_Compare, _Value>(_Compare __comp, _Value &__value) : _M_comp(std::move(__comp)), _M_value(__value)             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return bool(this->_M_comp(*__it, this->_M_value));
            }
        };
        template <typename _Compare, typename _Value> constexpr _Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val)         {
            return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
        }
        template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
            _Compare _M_comp;
            _Iterator1 _M_it1;
            constexpr _Iter_comp_to_iter<_Compare, _Iterator1>(_Compare __comp, _Iterator1 __it1) : _M_comp(std::move(__comp)), _M_it1(__it1)             {
            }
            template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2)             {
                return bool(this->_M_comp(*__it2, *this->_M_it1));
            }
        };
        template <typename _Compare, typename _Iterator> inline constexpr _Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)         {
            return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp), __it);
        }
        template <typename _Predicate> struct _Iter_negate {
            _Predicate _M_pred;
            constexpr explicit _Iter_negate<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> constexpr bool operator()(_Iterator __it)             {
                return !bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline constexpr _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred)         {
            return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
        }
    }
}
namespace std {
    template <typename _Tp, typename _Up> inline constexpr int __memcmp(const _Tp *__first1, const _Up *__first2, std::size_t __num)     {
        static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
        if (std::is_constant_evaluated()) {
            for (; __num > 0; ++__first1 , ++__first2 , --__num)
                if (*__first1 != *__first2)
                    return *__first1 < *__first2 ? -1 : 1;
            return 0;
        } else
            return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline constexpr void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)     {
        swap(*__a, *__b);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> constexpr _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            std::iter_swap(__first1, __first2);
        return __first2;
    }
    template <typename _Tp> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const unsigned long &min<unsigned long>(const unsigned long &__a, const unsigned long &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template <typename _Tp> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<> inline constexpr const int &max<int>(const int &__a, const int &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<> inline constexpr const float &max<float>(const float &__a, const float &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template<> inline constexpr const long double &max<long double>(const long double &__a, const long double &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }
    template <typename _Iterator> inline constexpr _Iterator __niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it;
    }
    template<> inline constexpr const char *__niter_base<const char *>(const char *__it) noexcept(std::is_nothrow_copy_constructible<const char *>::value__niter_base<const char *>(const char *__it) noexcept(std::is_nothrow_copy_constructible<const char *>::value)     {
        return __it;
    }
    template<> inline constexpr char *__niter_base<char *>(char *__it) noexcept(std::is_nothrow_copy_constructible<char *>::value__niter_base<char *>(char *__it) noexcept(std::is_nothrow_copy_constructible<char *>::value)     {
        return __it;
    }
    template<> inline constexpr const wchar_t *__niter_base<const wchar_t *>(const wchar_t *__it) noexcept(std::is_nothrow_copy_constructible<const wchar_t *>::value__niter_base<const wchar_t *>(const wchar_t *__it) noexcept(std::is_nothrow_copy_constructible<const wchar_t *>::value)     {
        return __it;
    }
    template<> inline constexpr wchar_t *__niter_base<wchar_t *>(wchar_t *__it) noexcept(std::is_nothrow_copy_constructible<wchar_t *>::value__niter_base<wchar_t *>(wchar_t *__it) noexcept(std::is_nothrow_copy_constructible<wchar_t *>::value)     {
        return __it;
    }
    template<> inline constexpr const char8_t *__niter_base<const char8_t *>(const char8_t *__it) noexcept(std::is_nothrow_copy_constructible<const char8_t *>::value__niter_base<const char8_t *>(const char8_t *__it) noexcept(std::is_nothrow_copy_constructible<const char8_t *>::value)     {
        return __it;
    }
    template<> inline constexpr char8_t *__niter_base<char8_t *>(char8_t *__it) noexcept(std::is_nothrow_copy_constructible<char8_t *>::value__niter_base<char8_t *>(char8_t *__it) noexcept(std::is_nothrow_copy_constructible<char8_t *>::value)     {
        return __it;
    }
    template<> inline constexpr const char16_t *__niter_base<const char16_t *>(const char16_t *__it) noexcept(std::is_nothrow_copy_constructible<const char16_t *>::value__niter_base<const char16_t *>(const char16_t *__it) noexcept(std::is_nothrow_copy_constructible<const char16_t *>::value)     {
        return __it;
    }
    template<> inline constexpr char16_t *__niter_base<char16_t *>(char16_t *__it) noexcept(std::is_nothrow_copy_constructible<char16_t *>::value__niter_base<char16_t *>(char16_t *__it) noexcept(std::is_nothrow_copy_constructible<char16_t *>::value)     {
        return __it;
    }
    template<> inline constexpr const char32_t *__niter_base<const char32_t *>(const char32_t *__it) noexcept(std::is_nothrow_copy_constructible<const char32_t *>::value__niter_base<const char32_t *>(const char32_t *__it) noexcept(std::is_nothrow_copy_constructible<const char32_t *>::value)     {
        return __it;
    }
    template<> inline constexpr char32_t *__niter_base<char32_t *>(char32_t *__it) noexcept(std::is_nothrow_copy_constructible<char32_t *>::value__niter_base<char32_t *>(char32_t *__it) noexcept(std::is_nothrow_copy_constructible<char32_t *>::value)     {
        return __it;
    }
    template <typename _From, typename _To> inline constexpr _From __niter_wrap(_From __from, _To __res)     {
        return __from + (__res - std::__niter_base(__from));
    }
    template<> inline constexpr char *__niter_wrap<char *, char *>(char *__from, char *__res)    template<> inline constexpr wchar_t *__niter_wrap<wchar_t *, wchar_t *>(wchar_t *__from, wchar_t *__res)    template<> inline constexpr char8_t *__niter_wrap<char8_t *, char8_t *>(char8_t *__from, char8_t *__res)    template<> inline constexpr char16_t *__niter_wrap<char16_t *, char16_t *>(char16_t *__from, char16_t *__res)    template<> inline constexpr char32_t *__niter_wrap<char32_t *, char32_t *>(char32_t *__from, char32_t *__res)    template <typename _Iterator> inline constexpr _Iterator __niter_wrap(const _Iterator &, _Iterator __res)     {
        return __res;
    }
    template<> inline constexpr char *__niter_wrap<char *>(char *const &, char *__res)     {
        return __res;
    }
    template<> inline constexpr wchar_t *__niter_wrap<wchar_t *>(wchar_t *const &, wchar_t *__res)     {
        return __res;
    }
    template<> inline constexpr char8_t *__niter_wrap<char8_t *>(char8_t *const &, char8_t *__res)     {
        return __res;
    }
    template<> inline constexpr char16_t *__niter_wrap<char16_t *>(char16_t *const &, char16_t *__res)     {
        return __res;
    }
    template<> inline constexpr char32_t *__niter_wrap<char32_t *>(char32_t *const &, char32_t *__res)     {
        return __res;
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = *__first;
            return __result;
        }
    };
template<> struct __copy_move<false, true, std::random_access_iterator_tag> {
        template <typename _Tp> static constexpr _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result);
        template<> static constexpr char *__copy_m<char>(const char *__first, const char *__last, char *__result)         {
            using __assignable = conditional<false, is_move_assignable<char>, is_copy_assignable<char>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(char) * _Num);
            return __result + _Num;
        }
;
        template<> static constexpr wchar_t *__copy_m<wchar_t>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<wchar_t>, is_copy_assignable<wchar_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(wchar_t) * _Num);
            return __result + _Num;
        }
;
        template<> static constexpr char8_t *__copy_m<char8_t>(const char8_t *__first, const char8_t *__last, char8_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<char8_t>, is_copy_assignable<char8_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(char8_t) * _Num);
            return __result + _Num;
        }
;
        template<> static constexpr char16_t *__copy_m<char16_t>(const char16_t *__first, const char16_t *__last, char16_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<char16_t>, is_copy_assignable<char16_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(char16_t) * _Num);
            return __result + _Num;
        }
;
        template<> static constexpr char32_t *__copy_m<char32_t>(const char32_t *__first, const char32_t *__last, char32_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<char32_t>, is_copy_assignable<char32_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(char32_t) * _Num);
            return __result + _Num;
        }
;
    };
    template <typename _Category> struct __copy_move<true, false, _Category> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = std::move(*__first);
            return __result;
        }
    };
    template<> struct __copy_move<false, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr char *__copy_m<const char *, char *>(const char *__first, const char *__last, char *__result)         {
            typedef typename iterator_traits<const char *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr wchar_t *__copy_m<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)         {
            typedef typename iterator_traits<const wchar_t *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr char8_t *__copy_m<const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)         {
            typedef typename iterator_traits<const char8_t *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr char16_t *__copy_m<const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)         {
            typedef typename iterator_traits<const char16_t *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
        template<> static constexpr char32_t *__copy_m<const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)         {
            typedef typename iterator_traits<const char32_t *>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template<> struct __copy_move<true, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static constexpr _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = std::move(*__first);
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static constexpr _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = conditional<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
            return __result + _Num;
        }
    };
    template <typename _CharT> struct char_traits;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT>>);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>, istreambuf_iterator<_CharT, char_traits<_CharT>>, _CharT *);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a2(_II __first, _II __last, _OI __result)     {
        typedef typename iterator_traits<_II>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<_IsMove, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr char *__copy_move_a2<false, const char *, char *>(const char *__first, const char *__last, char *__result)     {
        typedef typename iterator_traits<const char *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<char *, const char *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr wchar_t *__copy_move_a2<false, const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        typedef typename iterator_traits<const wchar_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<wchar_t *, const wchar_t *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr char8_t *__copy_move_a2<false, const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        typedef typename iterator_traits<const char8_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<char8_t *, const char8_t *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr char16_t *__copy_move_a2<false, const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        typedef typename iterator_traits<const char16_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<char16_t *, const char16_t *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template<> inline constexpr char32_t *__copy_move_a2<false, const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        typedef typename iterator_traits<const char32_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move<false, false, _Category>::__copy_m(__first, __last, __result);
        return std::__copy_move<false, __memcpyable<char32_t *, const char32_t *>::__value, _Category>::__copy_m(__first, __last, __result);
    }
    template <typename _Tp, typename _Ref, typename _Ptr> struct _Deque_iterator;
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a1(_II __first, _II __last, _OI __result)     {
        return std::__copy_move_a2<_IsMove>(__first, __last, __result);
    }
    template<> inline constexpr char *__copy_move_a1<false, const char *, char *>(const char *__first, const char *__last, char *__result)     {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr wchar_t *__copy_move_a1<false, const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr char8_t *__copy_move_a1<false, const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr char16_t *__copy_move_a1<false, const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr char32_t *__copy_move_a1<false, const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        return std::__copy_move_a2<false>(__first, __last, __result);
    }
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_a(_II __first, _II __last, _OI __result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char *__copy_move_a<false, const char *, char *>(const char *__first, const char *__last, char *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr wchar_t *__copy_move_a<false, const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char8_t *__copy_move_a<false, const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char16_t *__copy_move_a<false, const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char32_t *__copy_move_a<false, const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _II, typename _OI> inline constexpr _OI copy(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char *copy<const char *, char *>(const char *__first, const char *__last, char *__result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<const char *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr wchar_t *copy<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<const wchar_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char8_t *copy<const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<const char8_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char16_t *copy<const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<const char16_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char32_t *copy<const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        ;
        return std::__copy_move_a<__is_move_iterator<const char32_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _II, typename _OI> inline constexpr _OI move(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
    };
template<> struct __copy_move_backward<false, true, std::random_access_iterator_tag> {
        template <typename _Tp> static constexpr _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result);
        template<> static constexpr char *__copy_move_b<char>(const char *__first, const char *__last, char *__result)         {
            using __assignable = conditional<false, is_move_assignable<char>, is_copy_assignable<char>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(char) * _Num);
            return __result - _Num;
        }
;
        template<> static constexpr wchar_t *__copy_move_b<wchar_t>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<wchar_t>, is_copy_assignable<wchar_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(wchar_t) * _Num);
            return __result - _Num;
        }
;
        template<> static constexpr char8_t *__copy_move_b<char8_t>(const char8_t *__first, const char8_t *__last, char8_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<char8_t>, is_copy_assignable<char8_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(char8_t) * _Num);
            return __result - _Num;
        }
;
        template<> static constexpr char16_t *__copy_move_b<char16_t>(const char16_t *__first, const char16_t *__last, char16_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<char16_t>, is_copy_assignable<char16_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(char16_t) * _Num);
            return __result - _Num;
        }
;
        template<> static constexpr char32_t *__copy_move_b<char32_t>(const char32_t *__first, const char32_t *__last, char32_t *__result)         {
            using __assignable = conditional<false, is_move_assignable<char32_t>, is_copy_assignable<char32_t>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(char32_t) * _Num);
            return __result - _Num;
        }
;
    };
    template <typename _Category> struct __copy_move_backward<true, false, _Category> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template<> struct __copy_move_backward<false, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
        template<> static constexpr char *__copy_move_b<const char *, char *>(const char *__first, const char *__last, char *__result)         {
            typename iterator_traits<const char *>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
        template<> static constexpr wchar_t *__copy_move_b<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)         {
            typename iterator_traits<const wchar_t *>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
        template<> static constexpr char8_t *__copy_move_b<const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)         {
            typename iterator_traits<const char8_t *>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
        template<> static constexpr char16_t *__copy_move_b<const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)         {
            typename iterator_traits<const char16_t *>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
        template<> static constexpr char32_t *__copy_move_b<const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)         {
            typename iterator_traits<const char32_t *>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
    };
    template<> struct __copy_move_backward<true, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static constexpr _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n = __last - __first;
            for (; __n > 0; --__n)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move_backward<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static constexpr _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = conditional<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp>>;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
            return __result - _Num;
        }
    };
    template <bool _IsMove, typename _BI1, typename _BI2> inline constexpr _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)     {
        typedef typename iterator_traits<_BI1>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<_IsMove, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<_IsMove, __memcpyable<_BI2, _BI1>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template<> inline constexpr char *__copy_move_backward_a2<false, const char *, char *>(const char *__first, const char *__last, char *__result)     {
        typedef typename iterator_traits<const char *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<false, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<false, __memcpyable<char *, const char *>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template<> inline constexpr wchar_t *__copy_move_backward_a2<false, const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        typedef typename iterator_traits<const wchar_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<false, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<false, __memcpyable<wchar_t *, const wchar_t *>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template<> inline constexpr char8_t *__copy_move_backward_a2<false, const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        typedef typename iterator_traits<const char8_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<false, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<false, __memcpyable<char8_t *, const char8_t *>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template<> inline constexpr char16_t *__copy_move_backward_a2<false, const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        typedef typename iterator_traits<const char16_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<false, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<false, __memcpyable<char16_t *, const char16_t *>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template<> inline constexpr char32_t *__copy_move_backward_a2<false, const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        typedef typename iterator_traits<const char32_t *>::iterator_category _Category;
        if (std::is_constant_evaluated())
            return std::__copy_move_backward<false, false, _Category>::__copy_move_b(__first, __last, __result);
        return std::__copy_move_backward<false, __memcpyable<char32_t *, const char32_t *>::__value, _Category>::__copy_move_b(__first, __last, __result);
    }
    template <bool _IsMove, typename _BI1, typename _BI2> inline constexpr _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)     {
        return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result);
    }
    template<> inline constexpr char *__copy_move_backward_a1<false, const char *, char *>(const char *__first, const char *__last, char *__result)     {
        return std::__copy_move_backward_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr wchar_t *__copy_move_backward_a1<false, const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        return std::__copy_move_backward_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr char8_t *__copy_move_backward_a1<false, const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        return std::__copy_move_backward_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr char16_t *__copy_move_backward_a1<false, const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        return std::__copy_move_backward_a2<false>(__first, __last, __result);
    }
    template<> inline constexpr char32_t *__copy_move_backward_a1<false, const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        return std::__copy_move_backward_a2<false>(__first, __last, __result);
    }
    template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr, typename _OI> _OI __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);
    template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr, typename _OTp> std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_ITp, _IRef, _IPtr>, std::_Deque_iterator<_OTp, _OTp &, _OTp *>);
    template <bool _IsMove, typename _II, typename _Tp> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::__type __copy_move_backward_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);
    template <bool _IsMove, typename _II, typename _OI> inline constexpr _OI __copy_move_backward_a(_II __first, _II __last, _OI __result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char *__copy_move_backward_a<false, const char *, char *>(const char *__first, const char *__last, char *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr wchar_t *__copy_move_backward_a<false, const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char8_t *__copy_move_backward_a<false, const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char16_t *__copy_move_backward_a<false, const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template<> inline constexpr char32_t *__copy_move_backward_a<false, const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a1<false>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat, typename _OI> _OI __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);
    template <bool _IsMove, typename _II, typename _Ite, typename _Seq, typename _Cat> __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(_II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);
    template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat, typename _OIte, typename _OSeq, typename _OCat> ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &, const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
    template <typename _BI1, typename _BI2> inline constexpr _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char *copy_backward<const char *, char *>(const char *__first, const char *__last, char *__result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<const char *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr wchar_t *copy_backward<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<const wchar_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char8_t *copy_backward<const char8_t *, char8_t *>(const char8_t *__first, const char8_t *__last, char8_t *__result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<const char8_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char16_t *copy_backward<const char16_t *, char16_t *>(const char16_t *__first, const char16_t *__last, char16_t *__result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<const char16_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template<> inline constexpr char32_t *copy_backward<const char32_t *, char32_t *>(const char32_t *__first, const char32_t *__last, char32_t *__result)     {
        ;
        return std::__copy_move_backward_a<__is_move_iterator<const char32_t *>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _BI1, typename _BI2> inline constexpr _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        for (; __first != __last; ++__first)
            *__first = __value;
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a1(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __first != __last; ++__first)
            *__first = __tmp;
    }
    template<> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<char>::__value, void>::__type __fill_a1<char *, char>(char *__first, char *__last, const char &__value)    template<> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<wchar_t>::__value, void>::__type __fill_a1<wchar_t *, wchar_t>(wchar_t *__first, wchar_t *__last, const wchar_t &__value)     {
        const wchar_t __tmp = __value;
        for (; __first != __last; ++__first)
            *__first = __tmp;
    }
    template<> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<char8_t>::__value, void>::__type __fill_a1<char8_t *, char8_t>(char8_t *__first, char8_t *__last, const char8_t &__value)    template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a1(_Tp *__first, _Tp *__last, const _Tp &__c)     {
        const _Tp __tmp = __c;
        if (std::is_constant_evaluated()) {
            for (; __first != __last; ++__first)
                *__first = __tmp;
            return;
        }
        if (const std::size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template<> inline constexpr typename __gnu_cxx::__enable_if<__is_byte<char>::__value, void>::__type __fill_a1<char>(char *__first, char *__last, const char &__c)     {
        const char __tmp = __c;
        if (std::is_constant_evaluated()) {
            for (; __first != __last; ++__first)
                *__first = __tmp;
            return;
        }
        if (const std::size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template<> inline constexpr typename __gnu_cxx::__enable_if<__is_byte<char8_t>::__value, void>::__type __fill_a1<char8_t>(char8_t *__first, char8_t *__last, const char8_t &__c)     {
        const char8_t __tmp = __c;
        if (std::is_constant_evaluated()) {
            for (; __first != __last; ++__first)
                *__first = __tmp;
            return;
        }
        if (const std::size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template <typename _Ite, typename _Cont, typename _Tp> inline constexpr void __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first, ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last, const _Tp &__value)     {
        std::__fill_a1(__first.base(), __last.base(), __value);
    }
    template <typename _Tp, typename _VTp> void __fill_a1(const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const _VTp &);
    template <typename _FIte, typename _Tp> inline constexpr void __fill_a(_FIte __first, _FIte __last, const _Tp &__value)     {
        std::__fill_a1(__first, __last, __value);
    }
    template<> inline constexpr void __fill_a<char *, char>(char *__first, char *__last, const char &__value)     {
        std::__fill_a1(__first, __last, __value);
    }
    template<> inline constexpr void __fill_a<wchar_t *, wchar_t>(wchar_t *__first, wchar_t *__last, const wchar_t &__value)     {
        std::__fill_a1(__first, __last, __value);
    }
    template<> inline constexpr void __fill_a<char8_t *, char8_t>(char8_t *__first, char8_t *__last, const char8_t &__value)     {
        std::__fill_a1(__first, __last, __value);
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Tp> void __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, const _Tp &);
    template <typename _ForwardIterator, typename _Tp> inline constexpr void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        ;
        std::__fill_a(__first, __last, __value);
    }
    inline constexpr int __size_to_integer(int __n)     {
        return __n;
    }
    inline constexpr unsigned int __size_to_integer(unsigned int __n)     {
        return __n;
    }
    inline constexpr long __size_to_integer(long __n)     {
        return __n;
    }
    inline constexpr unsigned long __size_to_integer(unsigned long __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(long long __n)     {
        return __n;
    }
    inline constexpr unsigned long long __size_to_integer(unsigned long long __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(float __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(double __n)     {
        return __n;
    }
    inline constexpr long long __size_to_integer(long double __n)     {
        return __n;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        for (; __n > 0; --__n , (void)++__first)
            *__first = __value;
        return __first;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __n > 0; --__n , (void)++__first)
            *__first = __tmp;
        return __first;
    }
    template <typename _Ite, typename _Seq, typename _Cat, typename _Size, typename _Tp> ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first, _Size __n, const _Tp &__value, std::input_iterator_tag);
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::output_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::input_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        return __fill_n_a1(__first, __n, __value);
    }
    template<> inline constexpr char *__fill_n_a<char *, unsigned long, char>(char *__first, unsigned long __n, const char &__value, std::input_iterator_tag)    template<> inline constexpr wchar_t *__fill_n_a<wchar_t *, unsigned long, wchar_t>(wchar_t *__first, unsigned long __n, const wchar_t &__value, std::input_iterator_tag)    template<> inline constexpr char8_t *__fill_n_a<char8_t *, unsigned long, char8_t>(char8_t *__first, unsigned long __n, const char8_t &__value, std::input_iterator_tag)    template <typename _OutputIterator, typename _Size, typename _Tp> inline constexpr _OutputIterator __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value, std::random_access_iterator_tag)     {
        static_assert(is_integral<_Size>({}), "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template<> inline constexpr char *__fill_n_a<char *, unsigned long, char>(char *__first, unsigned long __n, const char &__value, std::random_access_iterator_tag)     {
        static_assert(is_integral<unsigned long>{}, "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template<> inline constexpr wchar_t *__fill_n_a<wchar_t *, unsigned long, wchar_t>(wchar_t *__first, unsigned long __n, const wchar_t &__value, std::random_access_iterator_tag)     {
        static_assert(is_integral<unsigned long>{}, "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template<> inline constexpr char8_t *__fill_n_a<char8_t *, unsigned long, char8_t>(char8_t *__first, unsigned long __n, const char8_t &__value, std::random_access_iterator_tag)     {
        static_assert(is_integral<unsigned long>{}, "fill_n must pass integral size");
        if (__n <= 0)
            return __first;
        ;
        std::__fill_a(__first, __first + __n, __value);
        return __first + __n;
    }
    template <typename _OI, typename _Size, typename _Tp> inline constexpr _OI fill_n(_OI __first, _Size __n, const _Tp &__value)     {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template<> inline constexpr char *fill_n<char *, unsigned long, char>(char *__first, unsigned long __n, const char &__value)     {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template<> inline constexpr wchar_t *fill_n<wchar_t *, unsigned long, wchar_t>(wchar_t *__first, unsigned long __n, const wchar_t &__value)     {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template<> inline constexpr char8_t *fill_n<char8_t *, unsigned long, char8_t>(char8_t *__first, unsigned long __n, const char8_t &__value)     {
        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value, std::__iterator_category(__first));
    }
    template <bool _BoolType> struct __equal {
        template <typename _II1, typename _II2> static constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2)         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!(*__first1 == *__first2))
                    return false;
            return true;
        }
    };
    template<> struct __equal<true> {
        template <typename _Tp> static constexpr bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)         {
            if (const std::size_t __len = (__last1 - __first1))
                return !std::__memcmp(__first1, __first2, __len);
            return true;
        }
    };
    template <typename _Tp, typename _Ref, typename _Ptr, typename _II> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>, std::_Deque_iterator<_Tp, _Ref, _Ptr>, _II);
    template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2, typename _Ref2, typename _Ptr2> bool __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>, std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
    template <typename _II, typename _Tp, typename _Ref, typename _Ptr> typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value, bool>::__type __equal_aux1(_II, _II, std::_Deque_iterator<_Tp, _Ref, _Ptr>);
    template <typename _II1, typename _II2> inline constexpr bool __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        const bool __simple = ((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __memcmpable<_II1, _II2>::__value);
        return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
    template <typename _II1, typename _II2> inline constexpr bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)     {
        return std::__equal_aux1(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
    }
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, _II2);
    template <typename _II1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(_II1, _II1, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename _II1, typename _Seq1, typename _Cat1, typename _II2, typename _Seq2, typename _Cat2> bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &, const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);
    template <typename, typename> struct __lc_rai {
        template <typename _II1, typename _II2> static constexpr _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)         {
            return __last1;
        }
        template <typename _II> static constexpr bool __cnd2(_II __first, _II __last)         {
            return __first != __last;
        }
    };
    template<> struct __lc_rai<std::random_access_iterator_tag, std::random_access_iterator_tag> {
        template <typename _RAI1, typename _RAI2> static constexpr _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)         {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }
        template <typename _RAI> static constexpr bool __cnd2(_RAI, _RAI)         {
            return true;
        }
    };
    template <typename _II1, typename _II2, typename _Compare> constexpr bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        typedef typename iterator_traits<_II1>::iterator_category _Category1;
        typedef typename iterator_traits<_II2>::iterator_category _Category2;
        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ++__first1 , (void)++__first2) {
            if (__comp(__first1, __first2))
                return true;
            if (__comp(__first2, __first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template <bool _BoolType> struct __lexicographical_compare {
        template <typename _II1, typename _II2> static constexpr bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)         {
            using __gnu_cxx::__ops::__iter_less_iter;
            return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __iter_less_iter());
        }
    };
    template<> struct __lexicographical_compare<true> {
        template <typename _Tp, typename _Up> static constexpr bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)         {
            const std::size_t __len1 = __last1 - __first1;
            const std::size_t __len2 = __last2 - __first2;
            if (const std::size_t __len = std::min(__len1, __len2))
                if (int __result = std::__memcmp(__first1, __first2, __len))
                    return __result < 0;
            return __len1 < __len2;
        }
    };
    template <typename _II1, typename _II2> inline constexpr bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>> && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>);
        return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
    }
    template <typename _ForwardIterator, typename _Tp, typename _Compare> constexpr _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else
                    __len = __half;
            }
        return __first;
    }
    template <typename _ForwardIterator, typename _Tp> inline constexpr _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    }
    inline constexpr int __lg(int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr unsigned int __lg(unsigned int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr long __lg(long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr unsigned long __lg(unsigned long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr long long __lg(long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    inline constexpr unsigned long long __lg(unsigned long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    template <typename _II1, typename _II2> inline constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2)     {
        ;
        return std::__equal_aux(__first1, __last1, __first2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline constexpr bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return true;
    }
    template <typename _II1, typename _II2> inline constexpr bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!(*__first1 == *__first2))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2, typename _BinaryPredicate> inline constexpr bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _BinaryPredicate __binary_pred)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2, __binary_pred);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2> inline constexpr bool equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline constexpr bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
    }
    template <typename _II1, typename _II2> inline constexpr bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
    }
    template <typename _II1, typename _II2, typename _Compare> inline constexpr bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        ;
        ;
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
    template <typename _Iter> concept __is_byte_iter = contiguous_iterator<_Iter> && __is_memcmp_ordered<iter_value_t<_Iter>>::__value;;
    template <typename _Tp> constexpr auto __min_cmp(_Tp __x, _Tp __y)     {
        struct _Res {
            _Tp _M_min;
            decltype(__x <=> __y) _M_cmp;
        };
        auto __c = __x <=> __y;
        if (__c > 0)
            return _Res({__y, __c});
        return _Res({__x, __c});
    }
    template <typename _InputIter1, typename _InputIter2, typename _Comp> constexpr auto lexicographical_compare_three_way(_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2, _Comp __comp) -> decltype(__comp(*__first1, *__first2))     {
        ;
        ;
        using _Cat = decltype(__comp(*__first1, *__first2));
        static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);
        if (!std::is_constant_evaluated())
            if (same_as<_Comp, __detail::_Synth3way> || same_as<_Comp, std::compare_three_way>)
                if (__is_byte_iter<_InputIter1>)
                    if (__is_byte_iter<_InputIter2>) {
                        const auto = std::__min_cmp(__last1 - __first1, __last2 - __first2);
                        if (__len) {
                            const auto __c = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;
                            if (__c != 0)
                                return __c;
                        }
                        return __lencmp;
                    }
        while (__first1 != __last1)
            {
                if (__first2 == __last2)
                    return strong_ordering::greater;
                if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
                    return __cmp;
                ++__first1;
                ++__first2;
            }
        return (__first2 == __last2) <=> true;
    }
    template <typename _InputIter1, typename _InputIter2> constexpr auto lexicographical_compare_three_way(_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2, _InputIter2 __last2)     {
        return std::lexicographical_compare_three_way(__first1, __last1, __first2, __last2, std::compare_three_way{});
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> constexpr pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> constexpr pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __first2 != __last2 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline constexpr pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator, typename _Predicate> inline constexpr _InputIterator __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, std::input_iterator_tag)     {
        while (__first != __last && !__pred(__first))
            ++__first;
        return __first;
    }
    template <typename _RandomAccessIterator, typename _Predicate> constexpr _RandomAccessIterator __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, std::random_access_iterator_tag)     {
        typename iterator_traits<_RandomAccessIterator>::difference_type __trip_count = (__last - __first) >> 2;
        for (; __trip_count > 0; --__trip_count) {
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
            if (__pred(__first))
                return __first;
            ++__first;
        }
        switch (__last - __first) {
          case 3:
            if (__pred(__first))
                return __first;
            ++__first;
          case 2:
            if (__pred(__first))
                return __first;
            ++__first;
          case 1:
            if (__pred(__first))
                return __first;
            ++__first;
          case 0:
          default:
            return __last;
        }
    }
    template <typename _Iterator, typename _Predicate> inline constexpr _Iterator __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)     {
        return __find_if(__first, __last, __pred, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Predicate> constexpr typename iterator_traits<_InputIterator>::difference_type __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        for (; __first != __last; ++__first)
            if (__pred(__first))
                ++__n;
        return __n;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2, typename _BinaryPredicate> constexpr bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)     {
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!__pred(__first1, __first2))
                break;
        if (__first1 == __last1)
            return true;
        _ForwardIterator2 __last2 = __first2;
        std::advance(__last2, std::distance(__first1, __last1));
        for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
            if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                continue;
            auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
            if (0 == __matches || std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)
                return false;
        }
        return true;
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline constexpr bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
}
namespace __gnu_cxx {
    template <typename _CharT> struct _Char_types {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<wchar_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char8_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char16_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
template<> struct _Char_types<char32_t> {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template <typename _CharT> struct char_traits {
        typedef _CharT char_type;
        typedef typename _Char_types<_CharT>::int_type int_type;
        typedef typename _Char_types<_CharT>::pos_type pos_type;
        typedef typename _Char_types<_CharT>::off_type off_type;
        typedef typename _Char_types<_CharT>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            __c1 = __c2;
        }
        static constexpr bool eq(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits::char_type *__s);
        static constexpr const __gnu_cxx::char_traits::char_type *find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a);
        static constexpr __gnu_cxx::char_traits::char_type *move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr __gnu_cxx::char_traits::char_type *copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr __gnu_cxx::char_traits::char_type *assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a);
        static constexpr __gnu_cxx::char_traits::char_type to_char_type(const __gnu_cxx::char_traits::int_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::char_type>(__c);
        }
        static constexpr __gnu_cxx::char_traits::int_type to_int_type(const __gnu_cxx::char_traits::char_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::int_type>(__c);
        }
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits::int_type &__c1, const __gnu_cxx::char_traits::int_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr __gnu_cxx::char_traits::int_type eof()         {
            return static_cast<__gnu_cxx::char_traits::int_type>(-1);
        }
        static constexpr __gnu_cxx::char_traits::int_type not_eof(const __gnu_cxx::char_traits::int_type &__c)         {
            return !eq_int_type(__c, eof()) ? __c : to_int_type(__gnu_cxx::char_traits::char_type());
        }
    };
template<> struct char_traits<char> {
        typedef char char_type;
        typedef typename _Char_types<char>::int_type int_type;
        typedef typename _Char_types<char>::pos_type pos_type;
        typedef typename _Char_types<char>::off_type off_type;
        typedef typename _Char_types<char>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<char>::char_type &__c1, const __gnu_cxx::char_traits<char>::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int char_traits<char>::compare(const __gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<char>::length(const __gnu_cxx::char_traits<char>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<char>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<char>::char_type *char_traits<char>::find(const __gnu_cxx::char_traits<char>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type *char_traits<char>::move(__gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated()) {
                if (__s1 > __s2 && __s1 < __s2 + __n)
                    std::copy_backward(__s2, __s2 + __n, __s1);
                else
                    std::copy(__s2, __s2 + __n, __s1);
                return __s1;
            }
            return static_cast<char *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char>::char_type)));
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type *char_traits<char>::copy(__gnu_cxx::char_traits<char>::char_type *__s1, const __gnu_cxx::char_traits<char>::char_type *__s2, std::size_t __n)         {
            std::copy(__s2, __s2 + __n, __s1);
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type *char_traits<char>::assign(__gnu_cxx::char_traits<char>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char>::char_type __a)         {
            std::fill_n(__s, __n, __a);
            return __s;
        }
        static constexpr __gnu_cxx::char_traits<char>::char_type to_char_type(const __gnu_cxx::char_traits<char>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char>::int_type to_int_type(const __gnu_cxx::char_traits<char>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char>::int_type &__c1, const __gnu_cxx::char_traits<char>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char>::int_type not_eof(const __gnu_cxx::char_traits<char>::int_type &__c);
    };
template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef typename _Char_types<wchar_t>::int_type int_type;
        typedef typename _Char_types<wchar_t>::pos_type pos_type;
        typedef typename _Char_types<wchar_t>::off_type off_type;
        typedef typename _Char_types<wchar_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<wchar_t>::char_type &__c1, const __gnu_cxx::char_traits<wchar_t>::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int char_traits<wchar_t>::compare(const __gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<wchar_t>::length(const __gnu_cxx::char_traits<wchar_t>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<wchar_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::find(const __gnu_cxx::char_traits<wchar_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<wchar_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::move(__gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated()) {
                if (__s1 > __s2 && __s1 < __s2 + __n)
                    std::copy_backward(__s2, __s2 + __n, __s1);
                else
                    std::copy(__s2, __s2 + __n, __s1);
                return __s1;
            }
            return static_cast<wchar_t *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<wchar_t>::char_type)));
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::copy(__gnu_cxx::char_traits<wchar_t>::char_type *__s1, const __gnu_cxx::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            std::copy(__s2, __s2 + __n, __s1);
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type *char_traits<wchar_t>::assign(__gnu_cxx::char_traits<wchar_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<wchar_t>::char_type __a)         {
            std::fill_n(__s, __n, __a);
            return __s;
        }
        static constexpr __gnu_cxx::char_traits<wchar_t>::char_type to_char_type(const __gnu_cxx::char_traits<wchar_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type to_int_type(const __gnu_cxx::char_traits<wchar_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<wchar_t>::int_type &__c1, const __gnu_cxx::char_traits<wchar_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<wchar_t>::int_type not_eof(const __gnu_cxx::char_traits<wchar_t>::int_type &__c);
    };
template<> struct char_traits<char8_t> {
        typedef char8_t char_type;
        typedef typename _Char_types<char8_t>::int_type int_type;
        typedef typename _Char_types<char8_t>::pos_type pos_type;
        typedef typename _Char_types<char8_t>::off_type off_type;
        typedef typename _Char_types<char8_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char8_t>::char_type &__c1, const __gnu_cxx::char_traits<char8_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char8_t>::char_type &__c1, const __gnu_cxx::char_traits<char8_t>::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits<char8_t>::char_type &__c1, const __gnu_cxx::char_traits<char8_t>::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int char_traits<char8_t>::compare(const __gnu_cxx::char_traits<char8_t>::char_type *__s1, const __gnu_cxx::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t char_traits<char8_t>::length(const __gnu_cxx::char_traits<char8_t>::char_type *__p)         {
            std::size_t __i = 0;
            while (!eq(__p[__i], __gnu_cxx::char_traits<char8_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::find(const __gnu_cxx::char_traits<char8_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char8_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::move(__gnu_cxx::char_traits<char8_t>::char_type *__s1, const __gnu_cxx::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated()) {
                if (__s1 > __s2 && __s1 < __s2 + __n)
                    std::copy_backward(__s2, __s2 + __n, __s1);
                else
                    std::copy(__s2, __s2 + __n, __s1);
                return __s1;
            }
            return static_cast<char8_t *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char8_t>::char_type)));
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::copy(__gnu_cxx::char_traits<char8_t>::char_type *__s1, const __gnu_cxx::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            std::copy(__s2, __s2 + __n, __s1);
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type *char_traits<char8_t>::assign(__gnu_cxx::char_traits<char8_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char8_t>::char_type __a)         {
            std::fill_n(__s, __n, __a);
            return __s;
        }
        static constexpr __gnu_cxx::char_traits<char8_t>::char_type to_char_type(const __gnu_cxx::char_traits<char8_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char8_t>::int_type to_int_type(const __gnu_cxx::char_traits<char8_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char8_t>::int_type &__c1, const __gnu_cxx::char_traits<char8_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char8_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char8_t>::int_type not_eof(const __gnu_cxx::char_traits<char8_t>::int_type &__c);
    };
template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef typename _Char_types<char16_t>::int_type int_type;
        typedef typename _Char_types<char16_t>::pos_type pos_type;
        typedef typename _Char_types<char16_t>::off_type off_type;
        typedef typename _Char_types<char16_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char16_t>::char_type &__c1, const __gnu_cxx::char_traits<char16_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char16_t>::char_type &__c1, const __gnu_cxx::char_traits<char16_t>::char_type &__c2);
        static constexpr bool lt(const __gnu_cxx::char_traits<char16_t>::char_type &__c1, const __gnu_cxx::char_traits<char16_t>::char_type &__c2);
        static constexpr int compare(const __gnu_cxx::char_traits<char16_t>::char_type *__s1, const __gnu_cxx::char_traits<char16_t>::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits<char16_t>::char_type *__s);
        static constexpr const __gnu_cxx::char_traits<char16_t>::char_type *find(const __gnu_cxx::char_traits<char16_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char16_t>::char_type &__a);
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type *char_traits<char16_t>::move(__gnu_cxx::char_traits<char16_t>::char_type *__s1, const __gnu_cxx::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated()) {
                if (__s1 > __s2 && __s1 < __s2 + __n)
                    std::copy_backward(__s2, __s2 + __n, __s1);
                else
                    std::copy(__s2, __s2 + __n, __s1);
                return __s1;
            }
            return static_cast<char16_t *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char16_t>::char_type)));
        }
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type *char_traits<char16_t>::copy(__gnu_cxx::char_traits<char16_t>::char_type *__s1, const __gnu_cxx::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            std::copy(__s2, __s2 + __n, __s1);
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type *assign(__gnu_cxx::char_traits<char16_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char16_t>::char_type __a);
        static constexpr __gnu_cxx::char_traits<char16_t>::char_type to_char_type(const __gnu_cxx::char_traits<char16_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char16_t>::int_type to_int_type(const __gnu_cxx::char_traits<char16_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char16_t>::int_type &__c1, const __gnu_cxx::char_traits<char16_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char16_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char16_t>::int_type not_eof(const __gnu_cxx::char_traits<char16_t>::int_type &__c);
    };
template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef typename _Char_types<char32_t>::int_type int_type;
        typedef typename _Char_types<char32_t>::pos_type pos_type;
        typedef typename _Char_types<char32_t>::off_type off_type;
        typedef typename _Char_types<char32_t>::state_type state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(__gnu_cxx::char_traits<char32_t>::char_type &__c1, const __gnu_cxx::char_traits<char32_t>::char_type &__c2);
        static constexpr bool eq(const __gnu_cxx::char_traits<char32_t>::char_type &__c1, const __gnu_cxx::char_traits<char32_t>::char_type &__c2);
        static constexpr bool lt(const __gnu_cxx::char_traits<char32_t>::char_type &__c1, const __gnu_cxx::char_traits<char32_t>::char_type &__c2);
        static constexpr int compare(const __gnu_cxx::char_traits<char32_t>::char_type *__s1, const __gnu_cxx::char_traits<char32_t>::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits<char32_t>::char_type *__s);
        static constexpr const __gnu_cxx::char_traits<char32_t>::char_type *find(const __gnu_cxx::char_traits<char32_t>::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits<char32_t>::char_type &__a);
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type *char_traits<char32_t>::move(__gnu_cxx::char_traits<char32_t>::char_type *__s1, const __gnu_cxx::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated()) {
                if (__s1 > __s2 && __s1 < __s2 + __n)
                    std::copy_backward(__s2, __s2 + __n, __s1);
                else
                    std::copy(__s2, __s2 + __n, __s1);
                return __s1;
            }
            return static_cast<char32_t *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits<char32_t>::char_type)));
        }
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type *char_traits<char32_t>::copy(__gnu_cxx::char_traits<char32_t>::char_type *__s1, const __gnu_cxx::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            std::copy(__s2, __s2 + __n, __s1);
            return __s1;
        }
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type *assign(__gnu_cxx::char_traits<char32_t>::char_type *__s, std::size_t __n, __gnu_cxx::char_traits<char32_t>::char_type __a);
        static constexpr __gnu_cxx::char_traits<char32_t>::char_type to_char_type(const __gnu_cxx::char_traits<char32_t>::int_type &__c);
        static constexpr __gnu_cxx::char_traits<char32_t>::int_type to_int_type(const __gnu_cxx::char_traits<char32_t>::char_type &__c);
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits<char32_t>::int_type &__c1, const __gnu_cxx::char_traits<char32_t>::int_type &__c2);
        static constexpr __gnu_cxx::char_traits<char32_t>::int_type eof();
        static constexpr __gnu_cxx::char_traits<char32_t>::int_type not_eof(const __gnu_cxx::char_traits<char32_t>::int_type &__c);
    };
    template <typename _CharT> constexpr int char_traits<_CharT>::compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (lt(__s1[__i], __s2[__i]))
                return -1;
            else if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }
    template <typename _CharT> constexpr std::size_t char_traits<_CharT>::length(const __gnu_cxx::char_traits::char_type *__p)     {
        std::size_t __i = 0;
        while (!eq(__p[__i], __gnu_cxx::char_traits::char_type()))
            ++__i;
        return __i;
    }
    template <typename _CharT> constexpr const typename char_traits<_CharT>::char_type *char_traits<_CharT>::find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (eq(__s[__i], __a))
                return __s + __i;
        return 0;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        if (__n == 0)
            return __s1;
        if (std::is_constant_evaluated()) {
            if (__s1 > __s2 && __s1 < __s2 + __n)
                std::copy_backward(__s2, __s2 + __n, __s1);
            else
                std::copy(__s2, __s2 + __n, __s1);
            return __s1;
        }
        return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits::char_type)));
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        std::copy(__s2, __s2 + __n, __s1);
        return __s1;
    }
    template <typename _CharT> constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a)     {
        std::fill_n(__s, __n, __a);
        return __s;
    }
}
namespace std {
    template <typename _CharT> static inline constexpr bool __constant_string_p(const _CharT *__s) __attribute__((always_inline))     {
        (void)__s;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_string_p<char>(const char *__s) __attribute__((always_inline))     {
        (void)__s;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_string_p<wchar_t>(const wchar_t *__s) __attribute__((always_inline))     {
        (void)__s;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_string_p<char8_t>(const char8_t *__s) __attribute__((always_inline))     {
        (void)__s;
        return __builtin_is_constant_evaluated();
    }
    template <typename _CharT> static inline constexpr bool __constant_char_array_p(const _CharT *__a, std::size_t __n) __attribute__((always_inline))     {
        (void)__a;
        (void)__n;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_char_array_p<char>(const char *__a, std::size_t __n) __attribute__((always_inline))     {
        (void)__a;
        (void)__n;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_char_array_p<wchar_t>(const wchar_t *__a, std::size_t __n) __attribute__((always_inline))     {
        (void)__a;
        (void)__n;
        return __builtin_is_constant_evaluated();
    }
    template<> static inline constexpr bool __constant_char_array_p<char8_t>(const char8_t *__a, std::size_t __n) __attribute__((always_inline))     {
        (void)__a;
        (void)__n;
        return __builtin_is_constant_evaluated();
    }
    template <class _CharT> struct char_traits : public __gnu_cxx::char_traits<_CharT> {
    };
    template<> struct char_traits<char> {
        typedef char char_type;
        typedef int int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }
        static constexpr int compare(const std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __constant_char_array_p(__s1, __n) && __constant_char_array_p(__s2, __n))
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<char>::char_type *__s)         {
            if (__constant_string_p(__s))
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return __builtin_strlen(__s);
        }
        static constexpr const std::char_traits<char>::char_type *find(const std::char_traits<char>::char_type *__s, std::size_t __n, const std::char_traits<char>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __builtin_constant_p(__a) && __constant_char_array_p(__s, __n))
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return static_cast<const std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static constexpr std::char_traits<char>::char_type *move(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char>::char_type *copy(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char>::char_type *assign(std::char_traits<char>::char_type *__s, std::size_t __n, std::char_traits<char>::char_type __a)         {
            if (__n == 0)
                return __s;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr std::char_traits<char>::char_type to_char_type(const std::char_traits<char>::int_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::char_type>(__c);
        }
        static constexpr std::char_traits<char>::int_type to_int_type(const std::char_traits<char>::char_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
        }
        static constexpr bool eq_int_type(const std::char_traits<char>::int_type &__c1, const std::char_traits<char>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char>::int_type>(-1);
        }
        static constexpr std::char_traits<char>::int_type not_eof(const std::char_traits<char>::int_type &__c) noexcept         {
            return (__c == eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef std::streamoff off_type;
        typedef std::wstreampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __constant_char_array_p(__s1, __n) && __constant_char_array_p(__s2, __n))
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return wmemcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<wchar_t>::char_type *__s)         {
            if (__constant_string_p(__s))
                return __gnu_cxx::char_traits<char_type>::length(__s);
            return wcslen(__s);
        }
        static constexpr const std::char_traits<wchar_t>::char_type *find(const std::char_traits<wchar_t>::char_type *__s, std::size_t __n, const std::char_traits<wchar_t>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __builtin_constant_p(__a) && __constant_char_array_p(__s, __n))
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return wmemchr(__s, __a, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type *move(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return wmemmove(__s1, __s2, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type *copy(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return wmemcpy(__s1, __s2, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type *assign(std::char_traits<wchar_t>::char_type *__s, std::size_t __n, std::char_traits<wchar_t>::char_type __a)         {
            if (__n == 0)
                return __s;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return wmemset(__s, __a, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type to_char_type(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return std::char_traits<wchar_t>::char_type(__c);
        }
        static constexpr std::char_traits<wchar_t>::int_type to_int_type(const std::char_traits<wchar_t>::char_type &__c) noexcept         {
            return std::char_traits<wchar_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<wchar_t>::int_type &__c1, const std::char_traits<wchar_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<wchar_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<wchar_t>::int_type>((4294967295U));
        }
        static constexpr std::char_traits<wchar_t>::int_type not_eof(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char8_t> {
        typedef char8_t char_type;
        typedef unsigned int int_type;
        typedef std::u8streampos pos_type;
        typedef std::streamoff off_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char8_t>::char_type &__c1, const std::char_traits<char8_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char8_t>::char_type &__c1, const std::char_traits<char8_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char8_t>::char_type &__c1, const std::char_traits<char8_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char8_t>::char_type *__s1, const std::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __constant_char_array_p(__s1, __n) && __constant_char_array_p(__s2, __n))
                return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static constexpr std::size_t length(const std::char_traits<char8_t>::char_type *__s)         {
            if (__constant_string_p(__s))
                return __gnu_cxx::char_traits<char_type>::length(__s);
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char8_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char8_t>::char_type *find(const std::char_traits<char8_t>::char_type *__s, std::size_t __n, const std::char_traits<char8_t>::char_type &__a)         {
            if (__n == 0)
                return 0;
            if (__builtin_constant_p(__n) && __builtin_constant_p(__a) && __constant_char_array_p(__s, __n))
                return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
            return static_cast<const std::char_traits<char8_t>::char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type *move(std::char_traits<char8_t>::char_type *__s1, const std::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return static_cast<std::char_traits<char8_t>::char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type *copy(std::char_traits<char8_t>::char_type *__s1, const std::char_traits<char8_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return static_cast<std::char_traits<char8_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type *assign(std::char_traits<char8_t>::char_type *__s, std::size_t __n, std::char_traits<char8_t>::char_type __a)         {
            if (__n == 0)
                return __s;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
            return static_cast<std::char_traits<char8_t>::char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr std::char_traits<char8_t>::char_type to_char_type(const std::char_traits<char8_t>::int_type &__c) noexcept         {
            return std::char_traits<char8_t>::char_type(__c);
        }
        static constexpr std::char_traits<char8_t>::int_type to_int_type(const std::char_traits<char8_t>::char_type &__c) noexcept         {
            return std::char_traits<char8_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char8_t>::int_type &__c1, const std::char_traits<char8_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char8_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char8_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char8_t>::int_type not_eof(const std::char_traits<char8_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef struct {
    int __val[2];
} __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
namespace std {
    using ::int8_t;
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::int_fast8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::int_least8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uint8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::uint_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::uint_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::uintmax_t;
    using ::uintptr_t;
}
namespace std {
    template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef uint_least16_t int_type;
        typedef std::streamoff off_type;
        typedef std::u16streampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t length(const std::char_traits<char16_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char16_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char16_t>::char_type *find(const std::char_traits<char16_t>::char_type *__s, std::size_t __n, const std::char_traits<char16_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr std::char_traits<char16_t>::char_type *move(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static constexpr std::char_traits<char16_t>::char_type *copy(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static constexpr std::char_traits<char16_t>::char_type *assign(std::char_traits<char16_t>::char_type *__s, std::size_t __n, std::char_traits<char16_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char16_t>::char_type to_char_type(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return std::char_traits<char16_t>::char_type(__c);
        }
        static constexpr std::char_traits<char16_t>::int_type to_int_type(const std::char_traits<char16_t>::char_type &__c) noexcept         {
            return __c == eof() ? std::char_traits<char16_t>::int_type(65533) : std::char_traits<char16_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char16_t>::int_type &__c1, const std::char_traits<char16_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char16_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char16_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char16_t>::int_type not_eof(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef uint_least32_t int_type;
        typedef std::streamoff off_type;
        typedef std::u32streampos pos_type;
        typedef mbstate_t state_type;
        using comparison_category = std::strong_ordering;
        static constexpr void assign(std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static constexpr int compare(const std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static constexpr std::size_t length(const std::char_traits<char32_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char32_t>::char_type()))
                ++__i;
            return __i;
        }
        static constexpr const std::char_traits<char32_t>::char_type *find(const std::char_traits<char32_t>::char_type *__s, std::size_t __n, const std::char_traits<char32_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static constexpr std::char_traits<char32_t>::char_type *move(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static constexpr std::char_traits<char32_t>::char_type *copy(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            if (std::is_constant_evaluated())
                return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static constexpr std::char_traits<char32_t>::char_type *assign(std::char_traits<char32_t>::char_type *__s, std::size_t __n, std::char_traits<char32_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char32_t>::char_type to_char_type(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return std::char_traits<char32_t>::char_type(__c);
        }
        static constexpr std::char_traits<char32_t>::int_type to_int_type(const std::char_traits<char32_t>::char_type &__c) noexcept         {
            return std::char_traits<char32_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char32_t>::int_type &__c1, const std::char_traits<char32_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char32_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char32_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char32_t>::int_type not_eof(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    namespace __detail {
        template <typename _ChTraits> constexpr auto __char_traits_cmp_cat(int __cmp) noexcept         {
            if (requires { typename _ChTraits::comparison_category; }) {
                using _Cat = typename _ChTraits::comparison_category;
                static_assert(!is_void_v<common_comparison_category_t<_Cat>>);
                return static_cast<_Cat>(__cmp <=> 0);
            } else
                return static_cast<std::weak_ordering>(__cmp <=> 0);
        }
    }
}
namespace std {
    template <typename _Result, typename _Arg> struct __hash_base {
        typedef _Result result_type [[deprecated("")]];
        typedef _Arg argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, bool> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef bool argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, signed char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef signed char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned char> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned char argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, wchar_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef wchar_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char8_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char8_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char16_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char16_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, char32_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef char32_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef short argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef int argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned short> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned short argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned int> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned int argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, unsigned long long> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef unsigned long long argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, float> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef float argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef double argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, long double> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef long double argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, nullptr_t> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef nullptr_t argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char, std::char_traits<char>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char, std::char_traits<char>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<wchar_t, std::char_traits<wchar_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<wchar_t, std::char_traits<wchar_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char8_t, std::char_traits<char8_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char8_t, std::char_traits<char8_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char16_t, std::char_traits<char16_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char16_t, std::char_traits<char16_t>> argument_type [[deprecated("")]];
    };
template<> struct __hash_base<unsigned long, std::basic_string_view<char32_t, std::char_traits<char32_t>>> {
        typedef unsigned long result_type [[deprecated("")]];
        typedef std::basic_string_view<char32_t, std::char_traits<char32_t>> argument_type [[deprecated("")]];
    };
    template <typename _Tp> struct hash;
    template <typename _Tp, typename = void> struct __poison_hash {
        static constexpr bool __enable_hash_call = false;
    private:
        __poison_hash<_Tp, type-parameter-0-1>(__poison_hash<_Tp, type-parameter-0-1> &&);
        ~__poison_hash<_Tp, type-parameter-0-1>();
    };
    template <typename _Tp> struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
        static constexpr bool __enable_hash_call = true;
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
    private:
        __hash_enum<_Tp, >(__hash_enum<_Tp, > &&);
        ~__hash_enum<_Tp, >();
    };
    template <typename _Tp> struct __hash_enum<_Tp, true> : public __hash_base<std::size_t, _Tp> {
        std::size_t operator()(_Tp __val) const noexcept         {
            using __type = typename underlying_type<_Tp>::type;
            return hash<__type>({})(static_cast<__type>(__val));
        }
    };
    template <typename _Tp> struct hash : __hash_enum<_Tp> {
    };
    template <typename _Tp> struct hash<_Tp *> : public __hash_base<std::size_t, _Tp *> {
        std::size_t operator()(_Tp *__p) const noexcept         {
            return reinterpret_cast<std::size_t>(__p);
        }
    };
    template<> struct hash<bool> : public __hash_base<std::size_t, bool> {
        std::size_t operator()(bool __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char> : public __hash_base<std::size_t, char> {
        std::size_t operator()(char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<signed char> : public __hash_base<std::size_t, signed char> {
        std::size_t operator()(signed char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned char> : public __hash_base<std::size_t, unsigned char> {
        std::size_t operator()(unsigned char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<wchar_t> : public __hash_base<std::size_t, wchar_t> {
        std::size_t operator()(wchar_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char8_t> : public __hash_base<std::size_t, char8_t> {
        std::size_t operator()(char8_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char16_t> : public __hash_base<std::size_t, char16_t> {
        std::size_t operator()(char16_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char32_t> : public __hash_base<std::size_t, char32_t> {
        std::size_t operator()(char32_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<short> : public __hash_base<std::size_t, short> {
        std::size_t operator()(short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<int> : public __hash_base<std::size_t, int> {
        std::size_t operator()(int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long> : public __hash_base<std::size_t, long> {
        std::size_t operator()(long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long long> : public __hash_base<std::size_t, long long> {
        std::size_t operator()(long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned short> : public __hash_base<std::size_t, unsigned short> {
        std::size_t operator()(unsigned short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned int> : public __hash_base<std::size_t, unsigned int> {
        std::size_t operator()(unsigned int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long> : public __hash_base<std::size_t, unsigned long> {
        std::size_t operator()(unsigned long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long long> : public __hash_base<std::size_t, unsigned long long> {
        std::size_t operator()(unsigned long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    struct _Hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(3339675911UL))         {
            return _Hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<float>(const float &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<double>(const double &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    struct _Fnv_hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(2166136261UL))         {
            return _Fnv_hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    template<> struct hash<float> : public __hash_base<std::size_t, float> {
        std::size_t operator()(float __val) const noexcept         {
            return __val != 0.F ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<double> : public __hash_base<std::size_t, double> {
        std::size_t operator()(double __val) const noexcept         {
            return __val != 0. ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<long double> : public __hash_base<std::size_t, long double> {
        std::size_t operator()(long double __val) const noexcept __attribute__((pure));
    };
    template<> struct hash<std::nullptr_t> : public __hash_base<std::size_t, std::nullptr_t> {
        std::size_t operator()(std::nullptr_t) const noexcept         {
            return 0;
        }
    };
    template <typename _Hash> struct __is_fast_hash : public std::true_type {
    };
    template<> struct __is_fast_hash<hash<long double>> : public std::false_type {
    };
}
namespace std {
    template <class _E> class initializer_list {
    public:
        typedef _E value_type;
        typedef const _E &reference;
        typedef const _E &const_reference;
        typedef std::size_t size_type;
        typedef const _E *iterator;
        typedef const _E *const_iterator;
    private:
        std::initializer_list::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list<_E>(std::initializer_list::const_iterator __a, std::initializer_list::size_type __l) : _M_array(__a), _M_len(__l)         {
        }
    public:
        constexpr initializer_list<_E>() noexcept : _M_array(0), _M_len(0)         {
        }
        constexpr std::initializer_list::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::initializer_list::const_iterator begin() const noexcept         {
            return this->_M_array;
        }
        constexpr std::initializer_list::const_iterator end() const noexcept         {
            return this->begin() + this->size();
        }
    };
    template <class _Tp> constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept     {
        return __ils.begin();
    }
    template <class _Tp> constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept     {
        return __ils.end();
    }
}
namespace std {
    template <typename _Container> inline constexpr auto begin(_Container &__cont) -> decltype(__cont.begin())     {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto begin(const _Container &__cont) -> decltype(__cont.begin())     {
        return __cont.begin();
    }
    template <typename _Container> inline constexpr auto end(_Container &__cont) -> decltype(__cont.end())     {
        return __cont.end();
    }
    template <typename _Container> inline constexpr auto end(const _Container &__cont) -> decltype(__cont.end())     {
        return __cont.end();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *begin(_Tp (&__arr)[_Nm])     {
        return __arr;
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *end(_Tp (&__arr)[_Nm])     {
        return __arr + _Nm;
    }
    template <typename _Tp> class valarray;
    template <typename _Tp> _Tp *begin(valarray<_Tp> &);
    template <typename _Tp> const _Tp *begin(const valarray<_Tp> &);
    template <typename _Tp> _Tp *end(valarray<_Tp> &);
    template <typename _Tp> const _Tp *end(const valarray<_Tp> &);
    template <typename _Container> inline constexpr auto cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))) -> decltype(std::begin(__cont))     {
        return std::begin(__cont);
    }
    template <typename _Container> inline constexpr auto cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))) -> decltype(std::end(__cont))     {
        return std::end(__cont);
    }
    template <typename _Container> inline constexpr auto rbegin(_Container &__cont) -> decltype(__cont.rbegin())     {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rbegin(const _Container &__cont) -> decltype(__cont.rbegin())     {
        return __cont.rbegin();
    }
    template <typename _Container> inline constexpr auto rend(_Container &__cont) -> decltype(__cont.rend())     {
        return __cont.rend();
    }
    template <typename _Container> inline constexpr auto rend(const _Container &__cont) -> decltype(__cont.rend())     {
        return __cont.rend();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr reverse_iterator<_Tp *> rbegin(_Tp (&__arr)[_Nm])     {
        return reverse_iterator<_Tp *>(__arr + _Nm);
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr reverse_iterator<_Tp *> rend(_Tp (&__arr)[_Nm])     {
        return reverse_iterator<_Tp *>(__arr);
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rbegin(initializer_list<_Tp> __il)     {
        return reverse_iterator<const _Tp *>(__il.end());
    }
    template <typename _Tp> inline constexpr reverse_iterator<const _Tp *> rend(initializer_list<_Tp> __il)     {
        return reverse_iterator<const _Tp *>(__il.begin());
    }
    template <typename _Container> inline constexpr auto crbegin(const _Container &__cont) -> decltype(std::rbegin(__cont))     {
        return std::rbegin(__cont);
    }
    template <typename _Container> inline constexpr auto crend(const _Container &__cont) -> decltype(std::rend(__cont))     {
        return std::rend(__cont);
    }
    template <typename _Container> constexpr auto size(const _Container &__cont) noexcept(noexcept(__cont.size())size(const _Container &__cont) noexcept(noexcept(__cont.size())) -> decltype(__cont.size())     {
        return __cont.size();
    }
    template <typename _Tp, std::size_t _Nm> constexpr std::size_t size(const _Tp (&)[_Nm]) noexcept     {
        return _Nm;
    }
    template <typename _Container> constexpr auto empty(const _Container &__cont) noexcept(noexcept(__cont.empty())empty(const _Container &__cont) noexcept(noexcept(__cont.empty())) -> decltype(__cont.empty()) [[nodiscard("")]]     {
        return __cont.empty();
    }
    template <typename _Tp, std::size_t _Nm> constexpr bool empty(const _Tp (&)[_Nm]) noexcept [[nodiscard("")]]     {
        return false;
    }
    template <typename _Tp> constexpr bool empty(initializer_list<_Tp> __il) noexcept [[nodiscard("")]]     {
        return __il.size() == 0;
    }
    template <typename _Container> constexpr auto data(_Container &__cont) noexcept(noexcept(__cont.data())data(_Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data())     {
        return __cont.data();
    }
    template <typename _Container> constexpr auto data(const _Container &__cont) noexcept(noexcept(__cont.data())data(const _Container &__cont) noexcept(noexcept(__cont.data())) -> decltype(__cont.data())     {
        return __cont.data();
    }
    template <typename _Tp, std::size_t _Nm> constexpr _Tp *data(_Tp (&__array)[_Nm]) noexcept     {
        return __array;
    }
    template <typename _Tp> constexpr const _Tp *data(initializer_list<_Tp> __il) noexcept     {
        return __il.begin();
    }
    template <typename _Container> constexpr auto ssize(const _Container &__cont) noexcept(noexcept(__cont.size())ssize(const _Container &__cont) noexcept(noexcept(__cont.size())) -> common_type_t<std::ptrdiff_t, make_signed_t<decltype(__cont.size())>>     {
        using type = make_signed_t<decltype(__cont.size())>;
        return static_cast<common_type_t<std::ptrdiff_t, type>>(__cont.size());
    }
    template <typename _Tp, std::ptrdiff_t _Num> constexpr std::ptrdiff_t ssize(const _Tp (&)[_Num]) noexcept     {
        return _Num;
    }
    namespace ranges {
        template <typename> constexpr bool disable_sized_range = false;
        template <typename _Tp> constexpr bool enable_borrowed_range = false;
        template <typename _Tp> extern const bool enable_view;
        namespace __detail {
            template <integral _Tp> constexpr auto __to_unsigned_like(_Tp __t) noexcept             {
                return static_cast<make_unsigned_t<_Tp>>(__t);
            }
            constexpr unsigned __int128 __to_unsigned_like(__int128 __t) noexcept             {
                return __t;
            }
            constexpr unsigned __int128 __to_unsigned_like(unsigned __int128 __t) noexcept             {
                return __t;
            }
            template <typename _Tp> using __make_unsigned_like_t = decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));
            template <typename _Tp> concept __maybe_borrowed_range = is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;;
        }
        namespace __cust_access {
            using std::ranges::__detail::__maybe_borrowed_range;
            using std::__detail::__class_or_enum;
            using std::__detail::__decay_copy;
            using std::__detail::__member_begin;
            using std::__detail::__adl_begin;
            struct _Begin {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (is_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_begin<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().begin()));
                    else
                        return noexcept(__decay_copy(begin(std::declval<_Tp &>())));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>())                 {
                    if (is_array_v<remove_reference_t<_Tp>>) {
                        static_assert(is_lvalue_reference_v<_Tp>);
                        using _Up = remove_all_extents_t<remove_reference_t<_Tp>>;
                        static_assert(sizeof(_Up) != 0, "not array of incomplete type");
                        return __t + 0;
                    } else if (__member_begin<_Tp>)
                        return __t.begin();
                    else
                        return begin(__t);
                }
            };
            template <typename _Tp> concept __member_end = requires (_Tp &__t) { { __decay_copy(__t.end()) } -> sentinel_for<decltype(std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__t)))>; };;
            template <> void end(auto &) = delete
            template <> void end(const auto &) = delete
            template <typename _Tp> concept __adl_end = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(end(__t)) } -> sentinel_for<decltype(std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__t)))>; };;
            struct _End {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_end<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().end()));
                    else
                        return noexcept(__decay_copy(end(std::declval<_Tp &>())));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>())                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>) {
                        static_assert(is_lvalue_reference_v<_Tp>);
                        return __t + extent_v<remove_reference_t<_Tp>>;
                    } else if (__member_end<_Tp>)
                        return __t.end();
                    else
                        return end(__t);
                }
            };
            template <typename _Tp> constexpr decltype(auto) __as_const(_Tp &&__t) noexcept             {
                if (is_lvalue_reference_v<_Tp>)
                    return static_cast<const remove_reference_t<_Tp> &>(__t);
                else
                    return static_cast<const _Tp &&>(__t);
            }
            struct _CBegin {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Begin{}(__cust_access::__as_const((_Tp &&)__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Begin{}(__cust_access::__as_const((_Tp &&)__e)))) requires requires { std::ranges::__cust_access::_Begin{}(__cust_access::__as_const((_Tp &&)__e)); }                 {
                    return std::ranges::__cust_access::_Begin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
                }
            };
            struct _CEnd {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_End{}(__cust_access::__as_const((_Tp &&)__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_End{}(__cust_access::__as_const((_Tp &&)__e)))) requires requires { std::ranges::__cust_access::_End{}(__cust_access::__as_const((_Tp &&)__e)); }                 {
                    return std::ranges::__cust_access::_End{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
                }
            };
            template <typename _Tp> concept __member_rbegin = requires (_Tp &__t) { { __decay_copy(__t.rbegin()) } -> input_or_output_iterator; };;
            template <> void rbegin(auto &) = delete
            template <> void rbegin(const auto &) = delete
            template <typename _Tp> concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(rbegin(__t)) } -> input_or_output_iterator; };;
            template <typename _Tp> concept __reversable = requires (_Tp &__t) { { std::ranges::__cust_access::_Begin{}(__t) } -> bidirectional_iterator; { std::ranges::__cust_access::_End{}(__t) } -> same_as<decltype(std::ranges::__cust_access::_Begin{}(__t))>; };;
            struct _RBegin {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_rbegin<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().rbegin()));
                    else if (__adl_rbegin<_Tp>)
                        return noexcept(__decay_copy(rbegin(std::declval<_Tp &>())));
                    else {
                        if (noexcept(std::ranges::__cust_access::_End{}(std::declval<_Tp &>()))) {
                            using _It = decltype(std::ranges::__cust_access::_End{}(std::declval<_Tp &>()));
                            return is_nothrow_copy_constructible_v<_It>;
                        } else
                            return false;
                    }
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>())                 {
                    if (__member_rbegin<_Tp>)
                        return __t.rbegin();
                    else if (__adl_rbegin<_Tp>)
                        return rbegin(__t);
                    else
                        return std::make_reverse_iterator(std::ranges::__cust_access::_End{}(__t));
                }
            };
            template <typename _Tp> concept __member_rend = requires (_Tp &__t) { { __decay_copy(__t.rend()) } -> sentinel_for<decltype(std::ranges::__cust_access::_RBegin{}(__t))>; };;
            template <> void rend(auto &) = delete
            template <> void rend(const auto &) = delete
            template <typename _Tp> concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>> && requires (_Tp &__t) { { __decay_copy(rend(__t)) } -> sentinel_for<decltype(std::ranges::__cust_access::_RBegin{}(std::forward<_Tp>(__t)))>; };;
            struct _REnd {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_rend<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp &>().rend()));
                    else if (__adl_rend<_Tp>)
                        return noexcept(__decay_copy(rend(std::declval<_Tp &>())));
                    else {
                        if (noexcept(std::ranges::__cust_access::_Begin{}(std::declval<_Tp &>()))) {
                            using _It = decltype(std::ranges::__cust_access::_Begin{}(std::declval<_Tp &>()));
                            return is_nothrow_copy_constructible_v<_It>;
                        } else
                            return false;
                    }
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__t) const noexcept(_S_noexcept<_Tp>())                 {
                    if (__member_rend<_Tp>)
                        return __t.rend();
                    else if (__adl_rend<_Tp>)
                        return rend(__t);
                    else
                        return std::make_reverse_iterator(std::ranges::__cust_access::_Begin{}(__t));
                }
            };
            struct _CRBegin {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const((_Tp &&)__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const((_Tp &&)__e)))) requires requires { std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const((_Tp &&)__e)); }                 {
                    return std::ranges::__cust_access::_RBegin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
                }
            };
            struct _CREnd {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_REnd{}(__cust_access::__as_const((_Tp &&)__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_REnd{}(__cust_access::__as_const((_Tp &&)__e)))) requires requires { std::ranges::__cust_access::_REnd{}(__cust_access::__as_const((_Tp &&)__e)); }                 {
                    return std::ranges::__cust_access::_REnd{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
                }
            };
            template <typename _Tp> concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>> && requires (_Tp &&__t) { { __decay_copy(std::forward<_Tp>(__t).size()) } -> __detail::__is_integer_like; };;
            template <> void size(auto &) = delete
            template <> void size(const auto &) = delete
            template <typename _Tp> concept __adl_size = __class_or_enum<remove_reference_t<_Tp>> && !disable_sized_range<remove_cvref_t<_Tp>> && requires (_Tp &&__t) { { __decay_copy(size(std::forward<_Tp>(__t))) } -> __detail::__is_integer_like; };;
            template <typename _Tp> concept __sentinel_size = requires (_Tp &&__t) { { std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator; { std::ranges::__cust_access::_End{}(std::forward<_Tp>(__t)) } -> sized_sentinel_for<decltype(std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__t)))>; };;
            struct _Size {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>)
                        return true;
                    else if (__member_size<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp>().size()));
                    else if (__adl_size<_Tp>)
                        return noexcept(__decay_copy(size(std::declval<_Tp>())));
                    else if (__sentinel_size<_Tp>)
                        return noexcept(std::ranges::__cust_access::_End{}(std::declval<_Tp>()) - std::ranges::__cust_access::_Begin{}(std::declval<_Tp>()));
                }
            public:
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>())                 {
                    if (is_bounded_array_v<remove_reference_t<_Tp>>) {
                        return extent_v<remove_reference_t<_Tp>>;
                    } else if (__member_size<_Tp>)
                        return std::forward<_Tp>(__e).size();
                    else if (__adl_size<_Tp>)
                        return size(std::forward<_Tp>(__e));
                    else if (__sentinel_size<_Tp>)
                        return __detail::__to_unsigned_like(std::ranges::__cust_access::_End{}(std::forward<_Tp>(__e)) - std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__e)));
                }
            };
            struct _SSize {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Size{}(std::forward<_Tp>(__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Size{}(std::forward<_Tp>(__e))))                 {
                    using __iter_type = decltype(std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__e)));
                    using __diff_type = iter_difference_t<__iter_type>;
                    using __gnu_cxx::__int_traits;
                    auto __size = std::ranges::__cust_access::_Size{}(std::forward<_Tp>(__e));
                    if (integral<__diff_type>) {
                        if (__int_traits<__diff_type>::__digits < __int_traits<ptrdiff_t>::__digits)
                            return static_cast<std::ptrdiff_t>(__size);
                    }
                    return static_cast<__diff_type>(__size);
                }
            };
            template <typename _Tp> concept __member_empty = requires (_Tp &&__t) { bool(std::forward<_Tp>(__t).empty()); };;
            template <typename _Tp> concept __size0_empty = requires (_Tp &&__t) { std::ranges::__cust_access::_Size{}(std::forward<_Tp>(__t)) == 0; };;
            template <typename _Tp> concept __eq_iter_empty = requires (_Tp &&__t) { { std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator; bool(std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__t)) == std::ranges::__cust_access::_End{}(std::forward<_Tp>(__t))); };;
            struct _Empty {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_empty<_Tp>)
                        return noexcept(std::declval<_Tp>().empty());
                    else if (__size0_empty<_Tp>)
                        return noexcept(std::ranges::__cust_access::_Size{}(std::declval<_Tp>()) == 0);
                    else
                        return noexcept(bool(std::ranges::__cust_access::_Begin{}(std::declval<_Tp>()) == std::ranges::__cust_access::_End{}(std::declval<_Tp>())));
                }
            public:
                template <typename _Tp> constexpr bool operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>())                 {
                    if (__member_empty<_Tp>)
                        return bool(std::forward<_Tp>(__e).empty());
                    else if (__size0_empty<_Tp>)
                        return std::ranges::__cust_access::_Size{}(std::forward<_Tp>(__e)) == 0;
                    else
                        return bool(std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__e)) == std::ranges::__cust_access::_End{}(std::forward<_Tp>(__e)));
                }
            };
            template <typename _Tp> concept __pointer_to_object = is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;;
            template <typename _Tp> concept __member_data = is_lvalue_reference_v<_Tp> && requires (_Tp __t) { { __t.data() } -> __pointer_to_object; };;
            template <typename _Tp> concept __begin_data = requires (_Tp &&__t) { { std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__t)) } -> contiguous_iterator; };;
            struct _Data {
            private:
                template <typename _Tp> static constexpr bool _S_noexcept()                 {
                    if (__member_data<_Tp>)
                        return noexcept(__decay_copy(std::declval<_Tp>().data()));
                    else
                        return noexcept(std::ranges::__cust_access::_Begin{}(std::declval<_Tp>()));
                }
            public:
                template <__maybe_borrowed_range _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>()operator()(_Tp &&__e) const noexcept(_S_noexcept<_Tp>())                 {
                    if (__member_data<_Tp>)
                        return __e.data();
                    else
                        return std::to_address(std::ranges::__cust_access::_Begin{}(std::forward<_Tp>(__e)));
                }
            };
            struct _CData {
                template <typename _Tp> constexpr auto operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Data{}(__cust_access::__as_const((_Tp &&)__e)))operator()(_Tp &&__e) const noexcept(noexcept(std::ranges::__cust_access::_Data{}(__cust_access::__as_const((_Tp &&)__e)))) requires requires { std::ranges::__cust_access::_Data{}(__cust_access::__as_const((_Tp &&)__e)); }                 {
                    return std::ranges::__cust_access::_Data{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
                }
            };
        }
        inline namespace __cust {
            constexpr __cust_access::_Begin begin{};
            constexpr __cust_access::_End end{};
            constexpr __cust_access::_CBegin cbegin{};
            constexpr __cust_access::_CEnd cend{};
            constexpr __cust_access::_RBegin rbegin{};
            constexpr __cust_access::_REnd rend{};
            constexpr __cust_access::_CRBegin crbegin{};
            constexpr __cust_access::_CREnd crend{};
            constexpr __cust_access::_Size size{};
            constexpr __cust_access::_SSize ssize{};
            constexpr __cust_access::_Empty empty{};
            constexpr __cust_access::_Data data{};
            constexpr __cust_access::_CData cdata{};
        }
        template <typename _Tp> concept range = requires (_Tp &__t) { ranges::begin(__t); ranges::end(__t); };;
        template <typename _Tp> concept borrowed_range = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;;
        template <typename _Tp> using iterator_t = std::__detail::__range_iter_t<_Tp>;
        template <range _Range> using sentinel_t = decltype(ranges::end(std::declval<_Range &>()));
        template <range _Range> using range_difference_t = iter_difference_t<iterator_t<_Range>>;
        template <range _Range> using range_value_t = iter_value_t<iterator_t<_Range>>;
        template <range _Range> using range_reference_t = iter_reference_t<iterator_t<_Range>>;
        template <range _Range> using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Range>>;
        template <typename _Tp> concept sized_range = range<_Tp> && requires (_Tp &__t) { ranges::size(__t); };;
        template <sized_range _Range> using range_size_t = decltype(ranges::size(std::declval<_Range &>()));
        template <typename _Range, typename _Tp> concept output_range = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;;
        template <typename _Tp> concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept random_access_range = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;;
        template <typename _Tp> concept contiguous_range = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> && requires (_Tp &__t) { { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>; };;
        template <typename _Tp> concept common_range = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;;
        template <input_or_output_iterator _It> constexpr void advance(_It &__it, iter_difference_t<_It> __n)         {
            if (random_access_iterator<_It>)
                __it += __n;
            else if (bidirectional_iterator<_It>) {
                if (__n > 0) {
                    do {
                        ++__it;
                    } while (--__n);
                } else if (__n < 0) {
                    do {
                        --__it;
                    } while (++__n);
                }
            } else {
                if (std::is_constant_evaluated() && __n < 0)
                    throw "attempt to decrement a non-bidirectional iterator";
                ;
                while (__n-- > 0)
                    ++__it;
            }
        }
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr void advance(_It &__it, _Sent __bound)         {
            if (assignable_from<_It &, _Sent>)
                __it = std::move(__bound);
            else if (sized_sentinel_for<_Sent, _It>)
                ranges::advance(__it, __bound - __it);
            else {
                while (__it != __bound)
                    ++__it;
            }
        }
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> advance(_It &__it, iter_difference_t<_It> __n, _Sent __bound)         {
            if (sized_sentinel_for<_Sent, _It>) {
                const auto __diff = __bound - __it;
                if (std::is_constant_evaluated() && !(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0)))
                    throw "inconsistent directions for distance and bound";
                ;
                const auto __absdiff = __diff < 0 ? - __diff : __diff;
                const auto __absn = __n < 0 ? - __n : __n;
                ;
                if (__absn >= __absdiff) {
                    ranges::advance(__it, __bound);
                    return __n - __diff;
                } else {
                    ranges::advance(__it, __n);
                    return 0;
                }
            } else if (__it == __bound || __n == 0)
                return iter_difference_t<_It>(0);
            else if (__n > 0) {
                iter_difference_t<_It> __m = 0;
                do {
                    ++__it;
                    ++__m;
                } while (__m != __n && __it != __bound);
                return __n - __m;
            } else if (bidirectional_iterator<_It> && same_as<_It, _Sent>) {
                iter_difference_t<_It> __m = 0;
                do {
                    --__it;
                    --__m;
                } while (__m != __n && __it != __bound);
                return __n - __m;
            } else {
                if (std::is_constant_evaluated() && __n < 0)
                    throw "attempt to decrement a non-bidirectional iterator";
                ;
                return __n;
            }
        }
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr iter_difference_t<_It> distance(_It __first, _Sent __last)         {
            if (sized_sentinel_for<_Sent, _It>)
                return __last - __first;
            else {
                iter_difference_t<_It> __n = 0;
                while (__first != __last)
                    {
                        ++__first;
                        ++__n;
                    }
                return __n;
            }
        }
        template <range _Range> constexpr range_difference_t<_Range> distance(_Range &&__r)         {
            if (sized_range<_Range>)
                return static_cast<range_difference_t<_Range>>(ranges::size(__r));
            else
                return ranges::distance(ranges::begin(__r), ranges::end(__r));
        }
        template <input_or_output_iterator _It> constexpr _It next(_It __x)         {
            ++__x;
            return __x;
        }
        template <input_or_output_iterator _It> constexpr _It next(_It __x, iter_difference_t<_It> __n)         {
            ranges::advance(__x, __n);
            return __x;
        }
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr _It next(_It __x, _Sent __bound)         {
            ranges::advance(__x, __bound);
            return __x;
        }
        template <input_or_output_iterator _It, sentinel_for<_It> _Sent> constexpr _It next(_It __x, iter_difference_t<_It> __n, _Sent __bound)         {
            ranges::advance(__x, __n, __bound);
            return __x;
        }
        template <bidirectional_iterator _It> constexpr _It prev(_It __x)         {
            --__x;
            return __x;
        }
        template <bidirectional_iterator _It> constexpr _It prev(_It __x, iter_difference_t<_It> __n)         {
            ranges::advance(__x, - __n);
            return __x;
        }
        template <bidirectional_iterator _It> constexpr _It prev(_It __x, iter_difference_t<_It> __n, _It __bound)         {
            ranges::advance(__x, - __n, __bound);
            return __x;
        }
    }
}
namespace __cxxabiv1 {
    class __forced_unwind {
        virtual ~__forced_unwind() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace std {
    template <typename _CharT, typename _Traits> inline void __ostream_write(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }
    template <typename _CharT, typename _Traits> inline void __ostream_fill(basic_ostream<_CharT, _Traits> &__out, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (; __n > 0; --__n) {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof())) {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &__ostream_insert(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb) {
            try {
                const std::streamsize __w = __out.width();
                if (__w > __n) {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                } else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }
}
namespace std {
    constexpr std::size_t __sv_check(std::size_t __size, std::size_t __pos, const char *__s)     {
        if (__pos > __size)
            __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size (which is %zu)"), __s, __pos, __size);
        return __pos;
    }
    constexpr std::size_t __sv_limit(std::size_t __size, std::size_t __pos, std::size_t __off) noexcept     {
        const bool __testoff = __off < __size - __pos;
        return __testoff ? __off : __size - __pos;
    }
    template <typename _CharT, typename _Traits = std::char_traits<_CharT>> class basic_string_view {
        static_assert(!is_array_v<_CharT>);
        static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
        static_assert(is_same_v<_CharT, typename _Traits::char_type>);
    public:
        using traits_type = _Traits;
        using value_type = _CharT;
        using pointer = std::basic_string_view::value_type *;
        using const_pointer = const std::basic_string_view::value_type *;
        using reference = std::basic_string_view::value_type &;
        using const_reference = const std::basic_string_view::value_type &;
        using const_iterator = const std::basic_string_view::value_type *;
        using iterator = std::basic_string_view::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos = std::basic_string_view::size_type(-1);
        constexpr basic_string_view<_CharT, _Traits>() noexcept : _M_len({0}), _M_str({nullptr})         {
        }
        basic_string_view<_CharT, _Traits>(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str) noexcept : _M_len({traits_type::length(__str)}), _M_str({__str}) __attribute__((nonnull()))         {
        }
        constexpr basic_string_view<_CharT, _Traits>(const _CharT *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator _It, sized_sentinel_for<_It> _End> constexpr basic_string_view<_CharT, _Traits>(_It __first, _End __last) : _M_len(__last - __first), _M_str(std::to_address(__first))         {
        }
        basic_string_view<_CharT, _Traits> &operator=(const basic_string_view<_CharT, _Traits> &) noexcept = default
        constexpr std::basic_string_view::const_iterator begin() const noexcept         {
            return this->_M_str;
        }
        constexpr std::basic_string_view::const_iterator end() const noexcept         {
            return this->_M_str + this->_M_len;
        }
        constexpr std::basic_string_view::const_iterator cbegin() const noexcept         {
            return this->_M_str;
        }
        constexpr std::basic_string_view::const_iterator cend() const noexcept         {
            return this->_M_str + this->_M_len;
        }
        constexpr std::basic_string_view::const_reverse_iterator rbegin() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->end());
        }
        constexpr std::basic_string_view::const_reverse_iterator rend() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->begin());
        }
        constexpr std::basic_string_view::const_reverse_iterator crbegin() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->end());
        }
        constexpr std::basic_string_view::const_reverse_iterator crend() const noexcept         {
            return std::basic_string_view::const_reverse_iterator(this->begin());
        }
        constexpr std::basic_string_view::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept         {
            return (npos - sizeof(std::basic_string_view::size_type) - sizeof(void *)) / sizeof(std::basic_string_view::value_type) / 4;
        }
        constexpr bool empty() const noexcept [[nodiscard("")]]         {
            return this->_M_len == 0;
        }
        constexpr std::basic_string_view::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept         {
            ;
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view::const_reference at(std::basic_string_view::size_type __pos) const         {
            if (__pos >= this->_M_len)
                __throw_out_of_range_fmt(("basic_string_view::at: __pos (which is %zu) >= this->size() (which is %zu)"), __pos, this->size());
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view::const_reference front() const noexcept         {
            ;
            return *this->_M_str;
        }
        constexpr std::basic_string_view::const_reference back() const noexcept         {
            ;
            return *(this->_M_str + this->_M_len - 1);
        }
        constexpr std::basic_string_view::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept         {
            ;
            this->_M_str += __n;
            this->_M_len -= __n;
        }
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept         {
            this->_M_len -= __n;
        }
        constexpr void swap(basic_string_view<_CharT, _Traits> &__sv) noexcept         {
            auto __tmp = *this;
            *this = __sv;
            __sv = __tmp;
        }
        constexpr std::basic_string_view::size_type copy(_CharT *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos = 0) const         {
            ;
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::copy");
            const std::basic_string_view::size_type __rlen = std::min(__n, this->_M_len - __pos);
            traits_type::copy(__str, this->data() + __pos, __rlen);
            return __rlen;
        }
        constexpr basic_string_view<_CharT, _Traits> substr(std::basic_string_view::size_type __pos = 0, std::basic_string_view::size_type __n = npos) const noexcept(falsesubstr(std::basic_string_view::size_type __pos = 0, std::basic_string_view::size_type __n = npos) const noexcept(false)         {
            __pos = std::__sv_check(this->size(), __pos, "basic_string_view::substr");
            const std::basic_string_view::size_type __rlen = std::min(__n, this->_M_len - __pos);
            return basic_string_view<_CharT, _Traits>({this->_M_str + __pos, __rlen});
        }
        constexpr int compare(basic_string_view<_CharT, _Traits> __str) const noexcept         {
            const std::basic_string_view::size_type __rlen = std::min(this->_M_len, __str._M_len);
            int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
            if (__ret == 0)
                __ret = _S_compare(this->_M_len, __str._M_len);
            return __ret;
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __str) const         {
            return this->substr(__pos1, __n1).compare(__str);
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const         {
            return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
        }
        constexpr int compare(const _CharT *__str) const noexcept __attribute__((nonnull()))         {
            return this->compare(basic_string_view<_CharT, _Traits>({__str}));
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str) const __attribute__((nonnull()))         {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>({__str}));
        }
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str, std::basic_string_view::size_type __n2) const noexcept(falsecompare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const _CharT *__str, std::basic_string_view::size_type __n2) const noexcept(false)         {
            return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>(__str, __n2));
        }
        constexpr bool starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept         {
            return this->substr(0, __x.size()) == __x;
        }
        constexpr bool starts_with(_CharT __x) const noexcept         {
            return !this->empty() && traits_type::eq(this->front(), __x);
        }
        constexpr bool starts_with(const _CharT *__x) const noexcept         {
            return this->starts_with(basic_string_view<_CharT, _Traits>(__x));
        }
        constexpr bool ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept         {
            return this->size() >= __x.size() && this->compare(this->size() - __x.size(), npos, __x) == 0;
        }
        constexpr bool ends_with(_CharT __x) const noexcept         {
            return !this->empty() && traits_type::eq(this->back(), __x);
        }
        constexpr bool ends_with(const _CharT *__x) const noexcept         {
            return this->ends_with(basic_string_view<_CharT, _Traits>(__x));
        }
        constexpr std::basic_string_view::size_type find(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept;
        constexpr std::basic_string_view::size_type find(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type rfind(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->rfind(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type rfind(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept;
        constexpr std::basic_string_view::size_type rfind(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type rfind(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->rfind(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_first_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find_first_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_first_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find(__c, __pos);
        }
        constexpr std::basic_string_view::size_type find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find_first_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_last_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->find_last_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_last_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->rfind(__c, __pos);
        }
        constexpr std::basic_string_view::size_type find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->find_last_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_first_not_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = 0) const noexcept         {
            return this->find_first_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_first_not_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept;
        constexpr std::basic_string_view::size_type find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos = 0) const noexcept __attribute__((nonnull()))         {
            return this->find_first_not_of(__str, __pos, traits_type::length(__str));
        }
        constexpr std::basic_string_view::size_type find_last_not_of(basic_string_view<_CharT, _Traits> __str, std::basic_string_view::size_type __pos = npos) const noexcept         {
            return this->find_last_not_of(__str._M_str, __pos, __str._M_len);
        }
        constexpr std::basic_string_view::size_type find_last_not_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept;
        constexpr std::basic_string_view::size_type find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view::size_type find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos = npos) const noexcept __attribute__((nonnull()))         {
            return this->find_last_not_of(__str, __pos, traits_type::length(__str));
        }
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept         {
            const std::basic_string_view::difference_type __diff = __n1 - __n2;
            if (__diff > __gnu_cxx::__int_traits<int>::__max)
                return __gnu_cxx::__int_traits<int>::__max;
            if (__diff < __gnu_cxx::__int_traits<int>::__min)
                return __gnu_cxx::__int_traits<int>::__min;
            return static_cast<int>(__diff);
        }
        std::size_t _M_len;
        const _CharT *_M_str;
    };
template<> class basic_string_view<char, std::char_traits<char>> {
        static_assert(!is_array_v<char>);
        static_assert(is_trivial_v<char> && is_standard_layout_v<char>);
        static_assert(is_same_v<char, typename char_traits<char>::char_type>);
    public:
        using traits_type = std::char_traits<char>;
        using value_type = char;
        using pointer = std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using const_pointer = const std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using reference = std::basic_string_view<char, std::char_traits<char>>::value_type &;
        using const_reference = const std::basic_string_view<char, std::char_traits<char>>::value_type &;
        using const_iterator = const std::basic_string_view<char, std::char_traits<char>>::value_type *;
        using iterator = std::basic_string_view<char, std::char_traits<char>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char, std::char_traits<char>> &) noexcept = default
        constexpr basic_string_view(const char *__str) noexcept : _M_len({traits_type::length(__str)}), _M_str({__str}) __attribute__((nonnull()))         {
        }
        constexpr basic_string_view(const char *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char *, unsigned long>(const char *__first, unsigned long __last);
        std::basic_string_view<char, std::char_traits<char>> &operator=(const std::basic_string_view<char, std::char_traits<char>> &) noexcept = default
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept         {
            ;
            return *(this->_M_str + __pos);
        }
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char, std::char_traits<char>> &__sv) noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type copy(char *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char, std::char_traits<char>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char, std::char_traits<char>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char, std::char_traits<char>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char, std::char_traits<char>> __x) const noexcept;
        constexpr bool starts_with(char __x) const noexcept;
        constexpr bool starts_with(const char *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char, std::char_traits<char>> __x) const noexcept;
        constexpr bool ends_with(char __x) const noexcept;
        constexpr bool ends_with(const char *__x) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type rfind(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_first_not_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(std::basic_string_view<char, std::char_traits<char>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(char __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(const char *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char, std::char_traits<char>>::size_type find_last_not_of(const char *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char *_M_str;
    };
template<> class basic_string_view<wchar_t, std::char_traits<wchar_t>> {
        static_assert(!is_array_v<wchar_t>);
        static_assert(is_trivial_v<wchar_t> && is_standard_layout_v<wchar_t>);
        static_assert(is_same_v<wchar_t, typename char_traits<wchar_t>::char_type>);
    public:
        using traits_type = std::char_traits<wchar_t>;
        using value_type = wchar_t;
        using pointer = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using const_pointer = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using reference = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type &;
        using const_reference = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type &;
        using const_iterator = const std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::value_type *;
        using iterator = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &) noexcept = default
        constexpr basic_string_view(const wchar_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const wchar_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const wchar_t *, unsigned long>(const wchar_t *__first, unsigned long __last);
        std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &operator=(const std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &) noexcept = default
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> &__sv) noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type copy(wchar_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const wchar_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const wchar_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const wchar_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
        constexpr bool starts_with(wchar_t __x) const noexcept;
        constexpr bool starts_with(const wchar_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __x) const noexcept;
        constexpr bool ends_with(wchar_t __x) const noexcept;
        constexpr bool ends_with(const wchar_t *__x) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type rfind(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_first_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(std::basic_string_view<wchar_t, std::char_traits<wchar_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(wchar_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<wchar_t, std::char_traits<wchar_t>>::size_type find_last_not_of(const wchar_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const wchar_t *_M_str;
    };
template<> class basic_string_view<char8_t, std::char_traits<char8_t>> {
        static_assert(!is_array_v<char8_t>);
        static_assert(is_trivial_v<char8_t> && is_standard_layout_v<char8_t>);
        static_assert(is_same_v<char8_t, typename char_traits<char8_t>::char_type>);
    public:
        using traits_type = std::char_traits<char8_t>;
        using value_type = char8_t;
        using pointer = std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type *;
        using reference = std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type &;
        using const_reference = const std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char8_t, std::char_traits<char8_t>>::value_type *;
        using iterator = std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char8_t, std::char_traits<char8_t>> &) noexcept = default
        constexpr basic_string_view(const char8_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char8_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char8_t *, unsigned long>(const char8_t *__first, unsigned long __last);
        std::basic_string_view<char8_t, std::char_traits<char8_t>> &operator=(const std::basic_string_view<char8_t, std::char_traits<char8_t>> &) noexcept = default
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char8_t, std::char_traits<char8_t>> &__sv) noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type copy(char8_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char8_t, std::char_traits<char8_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char8_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char8_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char8_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
        constexpr bool starts_with(char8_t __x) const noexcept;
        constexpr bool starts_with(const char8_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char8_t, std::char_traits<char8_t>> __x) const noexcept;
        constexpr bool ends_with(char8_t __x) const noexcept;
        constexpr bool ends_with(const char8_t *__x) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type rfind(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_first_not_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(std::basic_string_view<char8_t, std::char_traits<char8_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(char8_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(const char8_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char8_t, std::char_traits<char8_t>>::size_type find_last_not_of(const char8_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char8_t *_M_str;
    };
template<> class basic_string_view<char16_t, std::char_traits<char16_t>> {
        static_assert(!is_array_v<char16_t>);
        static_assert(is_trivial_v<char16_t> && is_standard_layout_v<char16_t>);
        static_assert(is_same_v<char16_t, typename char_traits<char16_t>::char_type>);
    public:
        using traits_type = std::char_traits<char16_t>;
        using value_type = char16_t;
        using pointer = std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using reference = std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type &;
        using const_reference = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char16_t, std::char_traits<char16_t>>::value_type *;
        using iterator = std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char16_t, std::char_traits<char16_t>> &) noexcept = default
        constexpr basic_string_view(const char16_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char16_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char16_t *, unsigned long>(const char16_t *__first, unsigned long __last);
        std::basic_string_view<char16_t, std::char_traits<char16_t>> &operator=(const std::basic_string_view<char16_t, std::char_traits<char16_t>> &) noexcept = default
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char16_t, std::char_traits<char16_t>> &__sv) noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type copy(char16_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char16_t, std::char_traits<char16_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char16_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char16_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char16_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
        constexpr bool starts_with(char16_t __x) const noexcept;
        constexpr bool starts_with(const char16_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char16_t, std::char_traits<char16_t>> __x) const noexcept;
        constexpr bool ends_with(char16_t __x) const noexcept;
        constexpr bool ends_with(const char16_t *__x) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type rfind(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_first_not_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(std::basic_string_view<char16_t, std::char_traits<char16_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(char16_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(const char16_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char16_t, std::char_traits<char16_t>>::size_type find_last_not_of(const char16_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char16_t *_M_str;
    };
template<> class basic_string_view<char32_t, std::char_traits<char32_t>> {
        static_assert(!is_array_v<char32_t>);
        static_assert(is_trivial_v<char32_t> && is_standard_layout_v<char32_t>);
        static_assert(is_same_v<char32_t, typename char_traits<char32_t>::char_type>);
    public:
        using traits_type = std::char_traits<char32_t>;
        using value_type = char32_t;
        using pointer = std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using const_pointer = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using reference = std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type &;
        using const_reference = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type &;
        using const_iterator = const std::basic_string_view<char32_t, std::char_traits<char32_t>>::value_type *;
        using iterator = std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using reverse_iterator = std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        static constexpr std::basic_string_view::size_type npos;
        constexpr basic_string_view() noexcept;
        basic_string_view(const std::basic_string_view<char32_t, std::char_traits<char32_t>> &) noexcept = default
        constexpr basic_string_view(const char32_t *__str) noexcept __attribute__((nonnull()));
        constexpr basic_string_view(const char32_t *__str, std::basic_string_view::size_type __len) noexcept : _M_len({__len}), _M_str({__str})         {
        }
        template <contiguous_iterator<> _It, sized_sentinel_for<_It> _End> constexpr basic_string_view(_It __first, _End __last);
        template<> constexpr basic_string_view<const char32_t *, unsigned long>(const char32_t *__first, unsigned long __last);
        std::basic_string_view<char32_t, std::char_traits<char32_t>> &operator=(const std::basic_string_view<char32_t, std::char_traits<char32_t>> &) noexcept = default
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator begin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator end() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator cbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_iterator cend() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator rbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator rend() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator crbegin() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reverse_iterator crend() const noexcept;
        constexpr std::basic_string_view::size_type size() const noexcept;
        constexpr std::basic_string_view::size_type length() const noexcept         {
            return this->_M_len;
        }
        constexpr std::basic_string_view::size_type max_size() const noexcept;
        constexpr bool empty() const noexcept [[nodiscard("")]];
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference operator[](std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference at(std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference front() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_reference back() const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::const_pointer data() const noexcept         {
            return this->_M_str;
        }
        constexpr void remove_prefix(std::basic_string_view::size_type __n) noexcept;
        constexpr void remove_suffix(std::basic_string_view::size_type __n) noexcept;
        constexpr void swap(std::basic_string_view<char32_t, std::char_traits<char32_t>> &__sv) noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type copy(char32_t *__str, std::basic_string_view::size_type __n, std::basic_string_view::size_type __pos) const;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>> substr(std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const;
        constexpr int compare(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str) const noexcept;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char32_t, std::char_traits<char32_t>> __str) const;
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos2, std::basic_string_view::size_type __n2) const;
        constexpr int compare(const char32_t *__str) const noexcept __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char32_t *__str) const __attribute__((nonnull()));
        constexpr int compare(std::basic_string_view::size_type __pos1, std::basic_string_view::size_type __n1, const char32_t *__str, std::basic_string_view::size_type __n2) const;
        constexpr bool starts_with(std::basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
        constexpr bool starts_with(char32_t __x) const noexcept;
        constexpr bool starts_with(const char32_t *__x) const noexcept;
        constexpr bool ends_with(std::basic_string_view<char32_t, std::char_traits<char32_t>> __x) const noexcept;
        constexpr bool ends_with(char32_t __x) const noexcept;
        constexpr bool ends_with(const char32_t *__x) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type rfind(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_first_not_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(std::basic_string_view<char32_t, std::char_traits<char32_t>> __str, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(char32_t __c, std::basic_string_view::size_type __pos) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(const char32_t *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept;
        constexpr std::basic_string_view<char32_t, std::char_traits<char32_t>>::size_type find_last_not_of(const char32_t *__str, std::basic_string_view::size_type __pos) const noexcept __attribute__((nonnull()));
    private:
        static constexpr int _S_compare(std::basic_string_view::size_type __n1, std::basic_string_view::size_type __n2) noexcept;
        std::size_t _M_len;
        const char32_t *_M_str;
    };
    template <contiguous_iterator _It, sized_sentinel_for<_It> _End> basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept     {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr bool operator==(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept     {
        return __x.size() == __y.size() && __x.compare(__y) == 0;
    }
    template <typename _CharT, typename _Traits> constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __x, basic_string_view<_CharT, _Traits> __y) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))     {
        return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
    }
    template <typename _CharT, typename _Traits> constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __x, __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))     {
        return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, basic_string_view<_CharT, _Traits> __str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    using string_view = basic_string_view<char>;
    using wstring_view = basic_string_view<wchar_t>;
    using u8string_view = basic_string_view<char8_t>;
    using u16string_view = basic_string_view<char16_t>;
    using u32string_view = basic_string_view<char32_t>;
    template <typename _Tp> struct hash;
    template<> struct hash<std::string_view> : public __hash_base<std::size_t, std::string_view> {
        std::size_t operator()(const std::string_view &__str) const noexcept         {
            return std::_Hash_impl::hash(__str.data(), __str.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::string_view>> : std::false_type {
    };
    template<> struct hash<std::wstring_view> : public __hash_base<std::size_t, std::wstring_view> {
        std::size_t operator()(const std::wstring_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::wstring_view>> : std::false_type {
    };
    template<> struct hash<std::u8string_view> : public __hash_base<std::size_t, std::u8string_view> {
        std::size_t operator()(const std::u8string_view &__str) const noexcept         {
            return std::_Hash_impl::hash(__str.data(), __str.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::u8string_view>> : std::false_type {
    };
    template<> struct hash<std::u16string_view> : public __hash_base<std::size_t, std::u16string_view> {
        std::size_t operator()(const std::u16string_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u16string_view>> : std::false_type {
    };
    template<> struct hash<std::u32string_view> : public __hash_base<std::size_t, std::u32string_view> {
        std::size_t operator()(const std::u32string_view &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u32string_view>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_view_literals {
            inline constexpr basic_string_view<char> operator""sv(const char *__str, std::size_t __len) noexcept             {
                return basic_string_view<char>{__str, __len};
            }
            inline constexpr basic_string_view<wchar_t> operator""sv(const wchar_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<wchar_t>{__str, __len};
            }
            inline constexpr basic_string_view<char8_t> operator""sv(const char8_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char8_t>{__str, __len};
            }
            inline constexpr basic_string_view<char16_t> operator""sv(const char16_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char16_t>{__str, __len};
            }
            inline constexpr basic_string_view<char32_t> operator""sv(const char32_t *__str, std::size_t __len) noexcept             {
                return basic_string_view<char32_t>{__str, __len};
            }
        }
    }
    namespace ranges {
        constexpr bool enable_borrowed_range = true;
        constexpr bool enable_view = true;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        if (__n == 0)
            return __pos <= this->_M_len ? __pos : npos;
        if (__n <= this->_M_len) {
            for (; __pos <= this->_M_len - __n; ++__pos)
                if (traits_type::eq(this->_M_str[__pos], __str[0]) && traits_type::compare(this->_M_str + __pos + 1, __str + 1, __n - 1) == 0)
                    return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept     {
        std::basic_string_view::size_type __ret = npos;
        if (__pos < this->_M_len) {
            const std::basic_string_view::size_type __n = this->_M_len - __pos;
            const _CharT *__p = traits_type::find(this->_M_str + __pos, __n, __c);
            if (__p)
                __ret = __p - this->_M_str;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        if (__n <= this->_M_len) {
            __pos = std::min(std::basic_string_view::size_type(this->_M_len - __n), __pos);
            do {
                if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::rfind(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept     {
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size > 0) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(this->_M_str[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        for (; __n && __pos < this->_M_len; ++__pos) {
            const _CharT *__p = traits_type::find(__str, __n, this->_M_str[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        std::basic_string_view::size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::find(__str, __n, this->_M_str[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_first_not_of(_CharT __c, std::basic_string_view::size_type __pos = 0) const noexcept     {
        for (; __pos < this->_M_len; ++__pos)
            if (!traits_type::eq(this->_M_str[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(const _CharT *__str, std::basic_string_view::size_type __pos, std::basic_string_view::size_type __n) const noexcept     {
        ;
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__str, __n, this->_M_str[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits> constexpr typename basic_string_view<_CharT, _Traits>::size_type basic_string_view<_CharT, _Traits>::find_last_not_of(_CharT __c, std::basic_string_view::size_type __pos = npos) const noexcept     {
        std::basic_string_view::size_type __size = this->_M_len;
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(this->_M_str[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
}
extern "C" {
    typedef float float_t;
    typedef double double_t;
    enum  {
        FP_INT_UPWARD = 0,
        FP_INT_DOWNWARD = 1,
        FP_INT_TOWARDZERO = 2,
        FP_INT_TONEARESTFROMZERO = 3,
        FP_INT_TONEAREST = 4
    };
    extern int __fpclassify(double __value) throw() __attribute__((const));
    extern int __signbit(double __value) throw() __attribute__((const));
    extern int __isinf(double __value) throw() __attribute__((const));
    extern int __finite(double __value) throw() __attribute__((const));
    extern int __isnan(double __value) throw() __attribute__((const));
    extern int __iseqsig(double __x, double __y) throw();
    extern int __issignaling(double __value) throw() __attribute__((const));
    extern double acos(double __x) throw();
    extern double __acos(double __x) throw();
    extern double asin(double __x) throw();
    extern double __asin(double __x) throw();
    extern double atan(double __x) throw();
    extern double __atan(double __x) throw();
    extern double atan2(double __y, double __x) throw();
    extern double __atan2(double __y, double __x) throw();
    extern double cos(double __x) throw();
    extern double __cos(double __x) throw();
    extern double sin(double __x) throw();
    extern double __sin(double __x) throw();
    extern double tan(double __x) throw();
    extern double __tan(double __x) throw();
    extern double cosh(double __x) throw();
    extern double __cosh(double __x) throw();
    extern double sinh(double __x) throw();
    extern double __sinh(double __x) throw();
    extern double tanh(double __x) throw();
    extern double __tanh(double __x) throw();
    extern void sincos(double __x, double *__sinx, double *__cosx) throw();
    extern void __sincos(double __x, double *__sinx, double *__cosx) throw();
    extern double acosh(double __x) throw();
    extern double __acosh(double __x) throw();
    extern double asinh(double __x) throw();
    extern double __asinh(double __x) throw();
    extern double atanh(double __x) throw();
    extern double __atanh(double __x) throw();
    extern double exp(double __x) throw();
    extern double __exp(double __x) throw();
    extern double frexp(double __x, int *__exponent) throw();
    extern double __frexp(double __x, int *__exponent) throw();
    extern double ldexp(double __x, int __exponent) throw();
    extern double __ldexp(double __x, int __exponent) throw();
    extern double log(double __x) throw();
    extern double __log(double __x) throw();
    extern double log10(double __x) throw();
    extern double __log10(double __x) throw();
    extern double modf(double __x, double *__iptr) throw();
    extern double __modf(double __x, double *__iptr) throw() __attribute__((nonnull(2)));
    extern double exp10(double __x) throw();
    extern double __exp10(double __x) throw();
    extern double expm1(double __x) throw();
    extern double __expm1(double __x) throw();
    extern double log1p(double __x) throw();
    extern double __log1p(double __x) throw();
    extern double logb(double __x) throw();
    extern double __logb(double __x) throw();
    extern double exp2(double __x) throw();
    extern double __exp2(double __x) throw();
    extern double log2(double __x) throw();
    extern double __log2(double __x) throw();
    extern double pow(double __x, double __y) throw();
    extern double __pow(double __x, double __y) throw();
    extern double sqrt(double __x) throw();
    extern double __sqrt(double __x) throw();
    extern double hypot(double __x, double __y) throw();
    extern double __hypot(double __x, double __y) throw();
    extern double cbrt(double __x) throw();
    extern double __cbrt(double __x) throw();
    extern double ceil(double __x) throw() __attribute__((const));
    extern double __ceil(double __x) throw() __attribute__((const));
    extern double fabs(double __x) throw() __attribute__((const));
    extern double __fabs(double __x) throw() __attribute__((const));
    extern double floor(double __x) throw() __attribute__((const));
    extern double __floor(double __x) throw() __attribute__((const));
    extern double fmod(double __x, double __y) throw();
    extern double __fmod(double __x, double __y) throw();
    extern int finite(double __value) throw() __attribute__((const));
    extern double drem(double __x, double __y) throw();
    extern double __drem(double __x, double __y) throw();
    extern double significand(double __x) throw();
    extern double __significand(double __x) throw();
    extern double copysign(double __x, double __y) throw() __attribute__((const));
    extern double __copysign(double __x, double __y) throw() __attribute__((const));
    extern double nan(const char *__tagb) throw();
    extern double __nan(const char *__tagb) throw();
    extern double j0(double) throw();
    extern double __j0(double) throw();
    extern double j1(double) throw();
    extern double __j1(double) throw();
    extern double jn(int, double) throw();
    extern double __jn(int, double) throw();
    extern double y0(double) throw();
    extern double __y0(double) throw();
    extern double y1(double) throw();
    extern double __y1(double) throw();
    extern double yn(int, double) throw();
    extern double __yn(int, double) throw();
    extern double erf(double) throw();
    extern double __erf(double) throw();
    extern double erfc(double) throw();
    extern double __erfc(double) throw();
    extern double lgamma(double) throw();
    extern double __lgamma(double) throw();
    extern double tgamma(double) throw();
    extern double __tgamma(double) throw();
    extern double gamma(double) throw();
    extern double __gamma(double) throw();
    extern double lgamma_r(double, int *__signgamp) throw();
    extern double __lgamma_r(double, int *__signgamp) throw();
    extern double rint(double __x) throw();
    extern double __rint(double __x) throw();
    extern double nextafter(double __x, double __y) throw();
    extern double __nextafter(double __x, double __y) throw();
    extern double nexttoward(double __x, long double __y) throw();
    extern double __nexttoward(double __x, long double __y) throw();
    extern double nextdown(double __x) throw();
    extern double __nextdown(double __x) throw();
    extern double nextup(double __x) throw();
    extern double __nextup(double __x) throw();
    extern double remainder(double __x, double __y) throw();
    extern double __remainder(double __x, double __y) throw();
    extern double scalbn(double __x, int __n) throw();
    extern double __scalbn(double __x, int __n) throw();
    extern int ilogb(double __x) throw();
    extern int __ilogb(double __x) throw();
    extern long llogb(double __x) throw();
    extern long __llogb(double __x) throw();
    extern double scalbln(double __x, long __n) throw();
    extern double __scalbln(double __x, long __n) throw();
    extern double nearbyint(double __x) throw();
    extern double __nearbyint(double __x) throw();
    extern double round(double __x) throw() __attribute__((const));
    extern double __round(double __x) throw() __attribute__((const));
    extern double trunc(double __x) throw() __attribute__((const));
    extern double __trunc(double __x) throw() __attribute__((const));
    extern double remquo(double __x, double __y, int *__quo) throw();
    extern double __remquo(double __x, double __y, int *__quo) throw();
    extern long lrint(double __x) throw();
    extern long __lrint(double __x) throw();
    extern long long llrint(double __x) throw();
    extern long long __llrint(double __x) throw();
    extern long lround(double __x) throw();
    extern long __lround(double __x) throw();
    extern long long llround(double __x) throw();
    extern long long __llround(double __x) throw();
    extern double fdim(double __x, double __y) throw();
    extern double __fdim(double __x, double __y) throw();
    extern double fmax(double __x, double __y) throw() __attribute__((const));
    extern double __fmax(double __x, double __y) throw() __attribute__((const));
    extern double fmin(double __x, double __y) throw() __attribute__((const));
    extern double __fmin(double __x, double __y) throw() __attribute__((const));
    extern double fma(double __x, double __y, double __z) throw();
    extern double __fma(double __x, double __y, double __z) throw();
    extern double roundeven(double __x) throw() __attribute__((const));
    extern double __roundeven(double __x) throw() __attribute__((const));
    extern __intmax_t fromfp(double __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfp(double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfp(double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfp(double __x, int __round, unsigned int __width) throw();
    extern __intmax_t fromfpx(double __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpx(double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpx(double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpx(double __x, int __round, unsigned int __width) throw();
    extern double fmaxmag(double __x, double __y) throw() __attribute__((const));
    extern double __fmaxmag(double __x, double __y) throw() __attribute__((const));
    extern double fminmag(double __x, double __y) throw() __attribute__((const));
    extern double __fminmag(double __x, double __y) throw() __attribute__((const));
    extern int canonicalize(double *__cx, const double *__x) throw();
    extern int totalorder(const double *__x, const double *__y) throw() __attribute__((pure));
    extern int totalordermag(const double *__x, const double *__y) throw() __attribute__((pure));
    extern double getpayload(const double *__x) throw();
    extern double __getpayload(const double *__x) throw();
    extern int setpayload(double *__x, double __payload) throw();
    extern int setpayloadsig(double *__x, double __payload) throw();
    extern double scalb(double __x, double __n) throw();
    extern double __scalb(double __x, double __n) throw();
    extern int __fpclassifyf(float __value) throw() __attribute__((const));
    extern int __signbitf(float __value) throw() __attribute__((const));
    extern int __isinff(float __value) throw() __attribute__((const));
    extern int __finitef(float __value) throw() __attribute__((const));
    extern int __isnanf(float __value) throw() __attribute__((const));
    extern int __iseqsigf(float __x, float __y) throw();
    extern int __issignalingf(float __value) throw() __attribute__((const));
    extern float acosf(float __x) throw();
    extern float __acosf(float __x) throw();
    extern float asinf(float __x) throw();
    extern float __asinf(float __x) throw();
    extern float atanf(float __x) throw();
    extern float __atanf(float __x) throw();
    extern float atan2f(float __y, float __x) throw();
    extern float __atan2f(float __y, float __x) throw();
    extern float cosf(float __x) throw();
    extern float __cosf(float __x) throw();
    extern float sinf(float __x) throw();
    extern float __sinf(float __x) throw();
    extern float tanf(float __x) throw();
    extern float __tanf(float __x) throw();
    extern float coshf(float __x) throw();
    extern float __coshf(float __x) throw();
    extern float sinhf(float __x) throw();
    extern float __sinhf(float __x) throw();
    extern float tanhf(float __x) throw();
    extern float __tanhf(float __x) throw();
    extern void sincosf(float __x, float *__sinx, float *__cosx) throw();
    extern void __sincosf(float __x, float *__sinx, float *__cosx) throw();
    extern float acoshf(float __x) throw();
    extern float __acoshf(float __x) throw();
    extern float asinhf(float __x) throw();
    extern float __asinhf(float __x) throw();
    extern float atanhf(float __x) throw();
    extern float __atanhf(float __x) throw();
    extern float expf(float __x) throw();
    extern float __expf(float __x) throw();
    extern float frexpf(float __x, int *__exponent) throw();
    extern float __frexpf(float __x, int *__exponent) throw();
    extern float ldexpf(float __x, int __exponent) throw();
    extern float __ldexpf(float __x, int __exponent) throw();
    extern float logf(float __x) throw();
    extern float __logf(float __x) throw();
    extern float log10f(float __x) throw();
    extern float __log10f(float __x) throw();
    extern float modff(float __x, float *__iptr) throw();
    extern float __modff(float __x, float *__iptr) throw() __attribute__((nonnull(2)));
    extern float exp10f(float __x) throw();
    extern float __exp10f(float __x) throw();
    extern float expm1f(float __x) throw();
    extern float __expm1f(float __x) throw();
    extern float log1pf(float __x) throw();
    extern float __log1pf(float __x) throw();
    extern float logbf(float __x) throw();
    extern float __logbf(float __x) throw();
    extern float exp2f(float __x) throw();
    extern float __exp2f(float __x) throw();
    extern float log2f(float __x) throw();
    extern float __log2f(float __x) throw();
    extern float powf(float __x, float __y) throw();
    extern float __powf(float __x, float __y) throw();
    extern float sqrtf(float __x) throw();
    extern float __sqrtf(float __x) throw();
    extern float hypotf(float __x, float __y) throw();
    extern float __hypotf(float __x, float __y) throw();
    extern float cbrtf(float __x) throw();
    extern float __cbrtf(float __x) throw();
    extern float ceilf(float __x) throw() __attribute__((const));
    extern float __ceilf(float __x) throw() __attribute__((const));
    extern float fabsf(float __x) throw() __attribute__((const));
    extern float __fabsf(float __x) throw() __attribute__((const));
    extern float floorf(float __x) throw() __attribute__((const));
    extern float __floorf(float __x) throw() __attribute__((const));
    extern float fmodf(float __x, float __y) throw();
    extern float __fmodf(float __x, float __y) throw();
    extern int isinff(float __value) throw() __attribute__((const));
    extern int finitef(float __value) throw() __attribute__((const));
    extern float dremf(float __x, float __y) throw();
    extern float __dremf(float __x, float __y) throw();
    extern float significandf(float __x) throw();
    extern float __significandf(float __x) throw();
    extern float copysignf(float __x, float __y) throw() __attribute__((const));
    extern float __copysignf(float __x, float __y) throw() __attribute__((const));
    extern float nanf(const char *__tagb) throw();
    extern float __nanf(const char *__tagb) throw();
    extern int isnanf(float __value) throw() __attribute__((const));
    extern float j0f(float) throw();
    extern float __j0f(float) throw();
    extern float j1f(float) throw();
    extern float __j1f(float) throw();
    extern float jnf(int, float) throw();
    extern float __jnf(int, float) throw();
    extern float y0f(float) throw();
    extern float __y0f(float) throw();
    extern float y1f(float) throw();
    extern float __y1f(float) throw();
    extern float ynf(int, float) throw();
    extern float __ynf(int, float) throw();
    extern float erff(float) throw();
    extern float __erff(float) throw();
    extern float erfcf(float) throw();
    extern float __erfcf(float) throw();
    extern float lgammaf(float) throw();
    extern float __lgammaf(float) throw();
    extern float tgammaf(float) throw();
    extern float __tgammaf(float) throw();
    extern float gammaf(float) throw();
    extern float __gammaf(float) throw();
    extern float lgammaf_r(float, int *__signgamp) throw();
    extern float __lgammaf_r(float, int *__signgamp) throw();
    extern float rintf(float __x) throw();
    extern float __rintf(float __x) throw();
    extern float nextafterf(float __x, float __y) throw();
    extern float __nextafterf(float __x, float __y) throw();
    extern float nexttowardf(float __x, long double __y) throw();
    extern float __nexttowardf(float __x, long double __y) throw();
    extern float nextdownf(float __x) throw();
    extern float __nextdownf(float __x) throw();
    extern float nextupf(float __x) throw();
    extern float __nextupf(float __x) throw();
    extern float remainderf(float __x, float __y) throw();
    extern float __remainderf(float __x, float __y) throw();
    extern float scalbnf(float __x, int __n) throw();
    extern float __scalbnf(float __x, int __n) throw();
    extern int ilogbf(float __x) throw();
    extern int __ilogbf(float __x) throw();
    extern long llogbf(float __x) throw();
    extern long __llogbf(float __x) throw();
    extern float scalblnf(float __x, long __n) throw();
    extern float __scalblnf(float __x, long __n) throw();
    extern float nearbyintf(float __x) throw();
    extern float __nearbyintf(float __x) throw();
    extern float roundf(float __x) throw() __attribute__((const));
    extern float __roundf(float __x) throw() __attribute__((const));
    extern float truncf(float __x) throw() __attribute__((const));
    extern float __truncf(float __x) throw() __attribute__((const));
    extern float remquof(float __x, float __y, int *__quo) throw();
    extern float __remquof(float __x, float __y, int *__quo) throw();
    extern long lrintf(float __x) throw();
    extern long __lrintf(float __x) throw();
    extern long long llrintf(float __x) throw();
    extern long long __llrintf(float __x) throw();
    extern long lroundf(float __x) throw();
    extern long __lroundf(float __x) throw();
    extern long long llroundf(float __x) throw();
    extern long long __llroundf(float __x) throw();
    extern float fdimf(float __x, float __y) throw();
    extern float __fdimf(float __x, float __y) throw();
    extern float fmaxf(float __x, float __y) throw() __attribute__((const));
    extern float __fmaxf(float __x, float __y) throw() __attribute__((const));
    extern float fminf(float __x, float __y) throw() __attribute__((const));
    extern float __fminf(float __x, float __y) throw() __attribute__((const));
    extern float fmaf(float __x, float __y, float __z) throw();
    extern float __fmaf(float __x, float __y, float __z) throw();
    extern float roundevenf(float __x) throw() __attribute__((const));
    extern float __roundevenf(float __x) throw() __attribute__((const));
    extern __intmax_t fromfpf(float __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpf(float __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpf(float __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpf(float __x, int __round, unsigned int __width) throw();
    extern __intmax_t fromfpxf(float __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpxf(float __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpxf(float __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpxf(float __x, int __round, unsigned int __width) throw();
    extern float fmaxmagf(float __x, float __y) throw() __attribute__((const));
    extern float __fmaxmagf(float __x, float __y) throw() __attribute__((const));
    extern float fminmagf(float __x, float __y) throw() __attribute__((const));
    extern float __fminmagf(float __x, float __y) throw() __attribute__((const));
    extern int canonicalizef(float *__cx, const float *__x) throw();
    extern int totalorderf(const float *__x, const float *__y) throw() __attribute__((pure));
    extern int totalordermagf(const float *__x, const float *__y) throw() __attribute__((pure));
    extern float getpayloadf(const float *__x) throw();
    extern float __getpayloadf(const float *__x) throw();
    extern int setpayloadf(float *__x, float __payload) throw();
    extern int setpayloadsigf(float *__x, float __payload) throw();
    extern float scalbf(float __x, float __n) throw();
    extern float __scalbf(float __x, float __n) throw();
    extern int __fpclassifyl(long double __value) throw() __attribute__((const));
    extern int __signbitl(long double __value) throw() __attribute__((const));
    extern int __isinfl(long double __value) throw() __attribute__((const));
    extern int __finitel(long double __value) throw() __attribute__((const));
    extern int __isnanl(long double __value) throw() __attribute__((const));
    extern int __iseqsigl(long double __x, long double __y) throw();
    extern int __issignalingl(long double __value) throw() __attribute__((const));
    extern long double acosl(long double __x) throw();
    extern long double __acosl(long double __x) throw();
    extern long double asinl(long double __x) throw();
    extern long double __asinl(long double __x) throw();
    extern long double atanl(long double __x) throw();
    extern long double __atanl(long double __x) throw();
    extern long double atan2l(long double __y, long double __x) throw();
    extern long double __atan2l(long double __y, long double __x) throw();
    extern long double cosl(long double __x) throw();
    extern long double __cosl(long double __x) throw();
    extern long double sinl(long double __x) throw();
    extern long double __sinl(long double __x) throw();
    extern long double tanl(long double __x) throw();
    extern long double __tanl(long double __x) throw();
    extern long double coshl(long double __x) throw();
    extern long double __coshl(long double __x) throw();
    extern long double sinhl(long double __x) throw();
    extern long double __sinhl(long double __x) throw();
    extern long double tanhl(long double __x) throw();
    extern long double __tanhl(long double __x) throw();
    extern void sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
    extern void __sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
    extern long double acoshl(long double __x) throw();
    extern long double __acoshl(long double __x) throw();
    extern long double asinhl(long double __x) throw();
    extern long double __asinhl(long double __x) throw();
    extern long double atanhl(long double __x) throw();
    extern long double __atanhl(long double __x) throw();
    extern long double expl(long double __x) throw();
    extern long double __expl(long double __x) throw();
    extern long double frexpl(long double __x, int *__exponent) throw();
    extern long double __frexpl(long double __x, int *__exponent) throw();
    extern long double ldexpl(long double __x, int __exponent) throw();
    extern long double __ldexpl(long double __x, int __exponent) throw();
    extern long double logl(long double __x) throw();
    extern long double __logl(long double __x) throw();
    extern long double log10l(long double __x) throw();
    extern long double __log10l(long double __x) throw();
    extern long double modfl(long double __x, long double *__iptr) throw();
    extern long double __modfl(long double __x, long double *__iptr) throw() __attribute__((nonnull(2)));
    extern long double exp10l(long double __x) throw();
    extern long double __exp10l(long double __x) throw();
    extern long double expm1l(long double __x) throw();
    extern long double __expm1l(long double __x) throw();
    extern long double log1pl(long double __x) throw();
    extern long double __log1pl(long double __x) throw();
    extern long double logbl(long double __x) throw();
    extern long double __logbl(long double __x) throw();
    extern long double exp2l(long double __x) throw();
    extern long double __exp2l(long double __x) throw();
    extern long double log2l(long double __x) throw();
    extern long double __log2l(long double __x) throw();
    extern long double powl(long double __x, long double __y) throw();
    extern long double __powl(long double __x, long double __y) throw();
    extern long double sqrtl(long double __x) throw();
    extern long double __sqrtl(long double __x) throw();
    extern long double hypotl(long double __x, long double __y) throw();
    extern long double __hypotl(long double __x, long double __y) throw();
    extern long double cbrtl(long double __x) throw();
    extern long double __cbrtl(long double __x) throw();
    extern long double ceill(long double __x) throw() __attribute__((const));
    extern long double __ceill(long double __x) throw() __attribute__((const));
    extern long double fabsl(long double __x) throw() __attribute__((const));
    extern long double __fabsl(long double __x) throw() __attribute__((const));
    extern long double floorl(long double __x) throw() __attribute__((const));
    extern long double __floorl(long double __x) throw() __attribute__((const));
    extern long double fmodl(long double __x, long double __y) throw();
    extern long double __fmodl(long double __x, long double __y) throw();
    extern int isinfl(long double __value) throw() __attribute__((const));
    extern int finitel(long double __value) throw() __attribute__((const));
    extern long double dreml(long double __x, long double __y) throw();
    extern long double __dreml(long double __x, long double __y) throw();
    extern long double significandl(long double __x) throw();
    extern long double __significandl(long double __x) throw();
    extern long double copysignl(long double __x, long double __y) throw() __attribute__((const));
    extern long double __copysignl(long double __x, long double __y) throw() __attribute__((const));
    extern long double nanl(const char *__tagb) throw();
    extern long double __nanl(const char *__tagb) throw();
    extern int isnanl(long double __value) throw() __attribute__((const));
    extern long double j0l(long double) throw();
    extern long double __j0l(long double) throw();
    extern long double j1l(long double) throw();
    extern long double __j1l(long double) throw();
    extern long double jnl(int, long double) throw();
    extern long double __jnl(int, long double) throw();
    extern long double y0l(long double) throw();
    extern long double __y0l(long double) throw();
    extern long double y1l(long double) throw();
    extern long double __y1l(long double) throw();
    extern long double ynl(int, long double) throw();
    extern long double __ynl(int, long double) throw();
    extern long double erfl(long double) throw();
    extern long double __erfl(long double) throw();
    extern long double erfcl(long double) throw();
    extern long double __erfcl(long double) throw();
    extern long double lgammal(long double) throw();
    extern long double __lgammal(long double) throw();
    extern long double tgammal(long double) throw();
    extern long double __tgammal(long double) throw();
    extern long double gammal(long double) throw();
    extern long double __gammal(long double) throw();
    extern long double lgammal_r(long double, int *__signgamp) throw();
    extern long double __lgammal_r(long double, int *__signgamp) throw();
    extern long double rintl(long double __x) throw();
    extern long double __rintl(long double __x) throw();
    extern long double nextafterl(long double __x, long double __y) throw();
    extern long double __nextafterl(long double __x, long double __y) throw();
    extern long double nexttowardl(long double __x, long double __y) throw();
    extern long double __nexttowardl(long double __x, long double __y) throw();
    extern long double nextdownl(long double __x) throw();
    extern long double __nextdownl(long double __x) throw();
    extern long double nextupl(long double __x) throw();
    extern long double __nextupl(long double __x) throw();
    extern long double remainderl(long double __x, long double __y) throw();
    extern long double __remainderl(long double __x, long double __y) throw();
    extern long double scalbnl(long double __x, int __n) throw();
    extern long double __scalbnl(long double __x, int __n) throw();
    extern int ilogbl(long double __x) throw();
    extern int __ilogbl(long double __x) throw();
    extern long llogbl(long double __x) throw();
    extern long __llogbl(long double __x) throw();
    extern long double scalblnl(long double __x, long __n) throw();
    extern long double __scalblnl(long double __x, long __n) throw();
    extern long double nearbyintl(long double __x) throw();
    extern long double __nearbyintl(long double __x) throw();
    extern long double roundl(long double __x) throw() __attribute__((const));
    extern long double __roundl(long double __x) throw() __attribute__((const));
    extern long double truncl(long double __x) throw() __attribute__((const));
    extern long double __truncl(long double __x) throw() __attribute__((const));
    extern long double remquol(long double __x, long double __y, int *__quo) throw();
    extern long double __remquol(long double __x, long double __y, int *__quo) throw();
    extern long lrintl(long double __x) throw();
    extern long __lrintl(long double __x) throw();
    extern long long llrintl(long double __x) throw();
    extern long long __llrintl(long double __x) throw();
    extern long lroundl(long double __x) throw();
    extern long __lroundl(long double __x) throw();
    extern long long llroundl(long double __x) throw();
    extern long long __llroundl(long double __x) throw();
    extern long double fdiml(long double __x, long double __y) throw();
    extern long double __fdiml(long double __x, long double __y) throw();
    extern long double fmaxl(long double __x, long double __y) throw() __attribute__((const));
    extern long double __fmaxl(long double __x, long double __y) throw() __attribute__((const));
    extern long double fminl(long double __x, long double __y) throw() __attribute__((const));
    extern long double __fminl(long double __x, long double __y) throw() __attribute__((const));
    extern long double fmal(long double __x, long double __y, long double __z) throw();
    extern long double __fmal(long double __x, long double __y, long double __z) throw();
    extern long double roundevenl(long double __x) throw() __attribute__((const));
    extern long double __roundevenl(long double __x) throw() __attribute__((const));
    extern __intmax_t fromfpl(long double __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpl(long double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpl(long double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpl(long double __x, int __round, unsigned int __width) throw();
    extern __intmax_t fromfpxl(long double __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpxl(long double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpxl(long double __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpxl(long double __x, int __round, unsigned int __width) throw();
    extern long double fmaxmagl(long double __x, long double __y) throw() __attribute__((const));
    extern long double __fmaxmagl(long double __x, long double __y) throw() __attribute__((const));
    extern long double fminmagl(long double __x, long double __y) throw() __attribute__((const));
    extern long double __fminmagl(long double __x, long double __y) throw() __attribute__((const));
    extern int canonicalizel(long double *__cx, const long double *__x) throw();
    extern int totalorderl(const long double *__x, const long double *__y) throw() __attribute__((pure));
    extern int totalordermagl(const long double *__x, const long double *__y) throw() __attribute__((pure));
    extern long double getpayloadl(const long double *__x) throw();
    extern long double __getpayloadl(const long double *__x) throw();
    extern int setpayloadl(long double *__x, long double __payload) throw();
    extern int setpayloadsigl(long double *__x, long double __payload) throw();
    extern long double scalbl(long double __x, long double __n) throw();
    extern long double __scalbl(long double __x, long double __n) throw();
    extern _Float32 acosf32(_Float32 __x) throw();
    extern _Float32 __acosf32(_Float32 __x) throw();
    extern _Float32 asinf32(_Float32 __x) throw();
    extern _Float32 __asinf32(_Float32 __x) throw();
    extern _Float32 atanf32(_Float32 __x) throw();
    extern _Float32 __atanf32(_Float32 __x) throw();
    extern _Float32 atan2f32(_Float32 __y, _Float32 __x) throw();
    extern _Float32 __atan2f32(_Float32 __y, _Float32 __x) throw();
    extern _Float32 cosf32(_Float32 __x) throw();
    extern _Float32 __cosf32(_Float32 __x) throw();
    extern _Float32 sinf32(_Float32 __x) throw();
    extern _Float32 __sinf32(_Float32 __x) throw();
    extern _Float32 tanf32(_Float32 __x) throw();
    extern _Float32 __tanf32(_Float32 __x) throw();
    extern _Float32 coshf32(_Float32 __x) throw();
    extern _Float32 __coshf32(_Float32 __x) throw();
    extern _Float32 sinhf32(_Float32 __x) throw();
    extern _Float32 __sinhf32(_Float32 __x) throw();
    extern _Float32 tanhf32(_Float32 __x) throw();
    extern _Float32 __tanhf32(_Float32 __x) throw();
    extern void sincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw();
    extern void __sincosf32(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw();
    extern _Float32 acoshf32(_Float32 __x) throw();
    extern _Float32 __acoshf32(_Float32 __x) throw();
    extern _Float32 asinhf32(_Float32 __x) throw();
    extern _Float32 __asinhf32(_Float32 __x) throw();
    extern _Float32 atanhf32(_Float32 __x) throw();
    extern _Float32 __atanhf32(_Float32 __x) throw();
    extern _Float32 expf32(_Float32 __x) throw();
    extern _Float32 __expf32(_Float32 __x) throw();
    extern _Float32 frexpf32(_Float32 __x, int *__exponent) throw();
    extern _Float32 __frexpf32(_Float32 __x, int *__exponent) throw();
    extern _Float32 ldexpf32(_Float32 __x, int __exponent) throw();
    extern _Float32 __ldexpf32(_Float32 __x, int __exponent) throw();
    extern _Float32 logf32(_Float32 __x) throw();
    extern _Float32 __logf32(_Float32 __x) throw();
    extern _Float32 log10f32(_Float32 __x) throw();
    extern _Float32 __log10f32(_Float32 __x) throw();
    extern _Float32 modff32(_Float32 __x, _Float32 *__iptr) throw();
    extern _Float32 __modff32(_Float32 __x, _Float32 *__iptr) throw() __attribute__((nonnull(2)));
    extern _Float32 exp10f32(_Float32 __x) throw();
    extern _Float32 __exp10f32(_Float32 __x) throw();
    extern _Float32 expm1f32(_Float32 __x) throw();
    extern _Float32 __expm1f32(_Float32 __x) throw();
    extern _Float32 log1pf32(_Float32 __x) throw();
    extern _Float32 __log1pf32(_Float32 __x) throw();
    extern _Float32 logbf32(_Float32 __x) throw();
    extern _Float32 __logbf32(_Float32 __x) throw();
    extern _Float32 exp2f32(_Float32 __x) throw();
    extern _Float32 __exp2f32(_Float32 __x) throw();
    extern _Float32 log2f32(_Float32 __x) throw();
    extern _Float32 __log2f32(_Float32 __x) throw();
    extern _Float32 powf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 __powf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 sqrtf32(_Float32 __x) throw();
    extern _Float32 __sqrtf32(_Float32 __x) throw();
    extern _Float32 hypotf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 __hypotf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 cbrtf32(_Float32 __x) throw();
    extern _Float32 __cbrtf32(_Float32 __x) throw();
    extern _Float32 ceilf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 __ceilf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 fabsf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 __fabsf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 floorf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 __floorf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 fmodf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 __fmodf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 copysignf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 __copysignf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 nanf32(const char *__tagb) throw();
    extern _Float32 __nanf32(const char *__tagb) throw();
    extern _Float32 j0f32(_Float32) throw();
    extern _Float32 __j0f32(_Float32) throw();
    extern _Float32 j1f32(_Float32) throw();
    extern _Float32 __j1f32(_Float32) throw();
    extern _Float32 jnf32(int, _Float32) throw();
    extern _Float32 __jnf32(int, _Float32) throw();
    extern _Float32 y0f32(_Float32) throw();
    extern _Float32 __y0f32(_Float32) throw();
    extern _Float32 y1f32(_Float32) throw();
    extern _Float32 __y1f32(_Float32) throw();
    extern _Float32 ynf32(int, _Float32) throw();
    extern _Float32 __ynf32(int, _Float32) throw();
    extern _Float32 erff32(_Float32) throw();
    extern _Float32 __erff32(_Float32) throw();
    extern _Float32 erfcf32(_Float32) throw();
    extern _Float32 __erfcf32(_Float32) throw();
    extern _Float32 lgammaf32(_Float32) throw();
    extern _Float32 __lgammaf32(_Float32) throw();
    extern _Float32 tgammaf32(_Float32) throw();
    extern _Float32 __tgammaf32(_Float32) throw();
    extern _Float32 lgammaf32_r(_Float32, int *__signgamp) throw();
    extern _Float32 __lgammaf32_r(_Float32, int *__signgamp) throw();
    extern _Float32 rintf32(_Float32 __x) throw();
    extern _Float32 __rintf32(_Float32 __x) throw();
    extern _Float32 nextafterf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 __nextafterf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 nextdownf32(_Float32 __x) throw();
    extern _Float32 __nextdownf32(_Float32 __x) throw();
    extern _Float32 nextupf32(_Float32 __x) throw();
    extern _Float32 __nextupf32(_Float32 __x) throw();
    extern _Float32 remainderf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 __remainderf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 scalbnf32(_Float32 __x, int __n) throw();
    extern _Float32 __scalbnf32(_Float32 __x, int __n) throw();
    extern int ilogbf32(_Float32 __x) throw();
    extern int __ilogbf32(_Float32 __x) throw();
    extern long llogbf32(_Float32 __x) throw();
    extern long __llogbf32(_Float32 __x) throw();
    extern _Float32 scalblnf32(_Float32 __x, long __n) throw();
    extern _Float32 __scalblnf32(_Float32 __x, long __n) throw();
    extern _Float32 nearbyintf32(_Float32 __x) throw();
    extern _Float32 __nearbyintf32(_Float32 __x) throw();
    extern _Float32 roundf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 __roundf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 truncf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 __truncf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 remquof32(_Float32 __x, _Float32 __y, int *__quo) throw();
    extern _Float32 __remquof32(_Float32 __x, _Float32 __y, int *__quo) throw();
    extern long lrintf32(_Float32 __x) throw();
    extern long __lrintf32(_Float32 __x) throw();
    extern long long llrintf32(_Float32 __x) throw();
    extern long long __llrintf32(_Float32 __x) throw();
    extern long lroundf32(_Float32 __x) throw();
    extern long __lroundf32(_Float32 __x) throw();
    extern long long llroundf32(_Float32 __x) throw();
    extern long long __llroundf32(_Float32 __x) throw();
    extern _Float32 fdimf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 __fdimf32(_Float32 __x, _Float32 __y) throw();
    extern _Float32 fmaxf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 __fmaxf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 fminf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 __fminf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) throw();
    extern _Float32 __fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) throw();
    extern _Float32 roundevenf32(_Float32 __x) throw() __attribute__((const));
    extern _Float32 __roundevenf32(_Float32 __x) throw() __attribute__((const));
    extern __intmax_t fromfpf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern __intmax_t fromfpxf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpxf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpxf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpxf32(_Float32 __x, int __round, unsigned int __width) throw();
    extern _Float32 fmaxmagf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 __fmaxmagf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 fminmagf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern _Float32 __fminmagf32(_Float32 __x, _Float32 __y) throw() __attribute__((const));
    extern int canonicalizef32(_Float32 *__cx, const _Float32 *__x) throw();
    extern int totalorderf32(const _Float32 *__x, const _Float32 *__y) throw() __attribute__((pure));
    extern int totalordermagf32(const _Float32 *__x, const _Float32 *__y) throw() __attribute__((pure));
    extern _Float32 getpayloadf32(const _Float32 *__x) throw();
    extern _Float32 __getpayloadf32(const _Float32 *__x) throw();
    extern int setpayloadf32(_Float32 *__x, _Float32 __payload) throw();
    extern int setpayloadsigf32(_Float32 *__x, _Float32 __payload) throw();
    extern _Float64 acosf64(_Float64 __x) throw();
    extern _Float64 __acosf64(_Float64 __x) throw();
    extern _Float64 asinf64(_Float64 __x) throw();
    extern _Float64 __asinf64(_Float64 __x) throw();
    extern _Float64 atanf64(_Float64 __x) throw();
    extern _Float64 __atanf64(_Float64 __x) throw();
    extern _Float64 atan2f64(_Float64 __y, _Float64 __x) throw();
    extern _Float64 __atan2f64(_Float64 __y, _Float64 __x) throw();
    extern _Float64 cosf64(_Float64 __x) throw();
    extern _Float64 __cosf64(_Float64 __x) throw();
    extern _Float64 sinf64(_Float64 __x) throw();
    extern _Float64 __sinf64(_Float64 __x) throw();
    extern _Float64 tanf64(_Float64 __x) throw();
    extern _Float64 __tanf64(_Float64 __x) throw();
    extern _Float64 coshf64(_Float64 __x) throw();
    extern _Float64 __coshf64(_Float64 __x) throw();
    extern _Float64 sinhf64(_Float64 __x) throw();
    extern _Float64 __sinhf64(_Float64 __x) throw();
    extern _Float64 tanhf64(_Float64 __x) throw();
    extern _Float64 __tanhf64(_Float64 __x) throw();
    extern void sincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw();
    extern void __sincosf64(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw();
    extern _Float64 acoshf64(_Float64 __x) throw();
    extern _Float64 __acoshf64(_Float64 __x) throw();
    extern _Float64 asinhf64(_Float64 __x) throw();
    extern _Float64 __asinhf64(_Float64 __x) throw();
    extern _Float64 atanhf64(_Float64 __x) throw();
    extern _Float64 __atanhf64(_Float64 __x) throw();
    extern _Float64 expf64(_Float64 __x) throw();
    extern _Float64 __expf64(_Float64 __x) throw();
    extern _Float64 frexpf64(_Float64 __x, int *__exponent) throw();
    extern _Float64 __frexpf64(_Float64 __x, int *__exponent) throw();
    extern _Float64 ldexpf64(_Float64 __x, int __exponent) throw();
    extern _Float64 __ldexpf64(_Float64 __x, int __exponent) throw();
    extern _Float64 logf64(_Float64 __x) throw();
    extern _Float64 __logf64(_Float64 __x) throw();
    extern _Float64 log10f64(_Float64 __x) throw();
    extern _Float64 __log10f64(_Float64 __x) throw();
    extern _Float64 modff64(_Float64 __x, _Float64 *__iptr) throw();
    extern _Float64 __modff64(_Float64 __x, _Float64 *__iptr) throw() __attribute__((nonnull(2)));
    extern _Float64 exp10f64(_Float64 __x) throw();
    extern _Float64 __exp10f64(_Float64 __x) throw();
    extern _Float64 expm1f64(_Float64 __x) throw();
    extern _Float64 __expm1f64(_Float64 __x) throw();
    extern _Float64 log1pf64(_Float64 __x) throw();
    extern _Float64 __log1pf64(_Float64 __x) throw();
    extern _Float64 logbf64(_Float64 __x) throw();
    extern _Float64 __logbf64(_Float64 __x) throw();
    extern _Float64 exp2f64(_Float64 __x) throw();
    extern _Float64 __exp2f64(_Float64 __x) throw();
    extern _Float64 log2f64(_Float64 __x) throw();
    extern _Float64 __log2f64(_Float64 __x) throw();
    extern _Float64 powf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 __powf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 sqrtf64(_Float64 __x) throw();
    extern _Float64 __sqrtf64(_Float64 __x) throw();
    extern _Float64 hypotf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 __hypotf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 cbrtf64(_Float64 __x) throw();
    extern _Float64 __cbrtf64(_Float64 __x) throw();
    extern _Float64 ceilf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 __ceilf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 fabsf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 __fabsf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 floorf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 __floorf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 fmodf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 __fmodf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 copysignf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 __copysignf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 nanf64(const char *__tagb) throw();
    extern _Float64 __nanf64(const char *__tagb) throw();
    extern _Float64 j0f64(_Float64) throw();
    extern _Float64 __j0f64(_Float64) throw();
    extern _Float64 j1f64(_Float64) throw();
    extern _Float64 __j1f64(_Float64) throw();
    extern _Float64 jnf64(int, _Float64) throw();
    extern _Float64 __jnf64(int, _Float64) throw();
    extern _Float64 y0f64(_Float64) throw();
    extern _Float64 __y0f64(_Float64) throw();
    extern _Float64 y1f64(_Float64) throw();
    extern _Float64 __y1f64(_Float64) throw();
    extern _Float64 ynf64(int, _Float64) throw();
    extern _Float64 __ynf64(int, _Float64) throw();
    extern _Float64 erff64(_Float64) throw();
    extern _Float64 __erff64(_Float64) throw();
    extern _Float64 erfcf64(_Float64) throw();
    extern _Float64 __erfcf64(_Float64) throw();
    extern _Float64 lgammaf64(_Float64) throw();
    extern _Float64 __lgammaf64(_Float64) throw();
    extern _Float64 tgammaf64(_Float64) throw();
    extern _Float64 __tgammaf64(_Float64) throw();
    extern _Float64 lgammaf64_r(_Float64, int *__signgamp) throw();
    extern _Float64 __lgammaf64_r(_Float64, int *__signgamp) throw();
    extern _Float64 rintf64(_Float64 __x) throw();
    extern _Float64 __rintf64(_Float64 __x) throw();
    extern _Float64 nextafterf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 __nextafterf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 nextdownf64(_Float64 __x) throw();
    extern _Float64 __nextdownf64(_Float64 __x) throw();
    extern _Float64 nextupf64(_Float64 __x) throw();
    extern _Float64 __nextupf64(_Float64 __x) throw();
    extern _Float64 remainderf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 __remainderf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 scalbnf64(_Float64 __x, int __n) throw();
    extern _Float64 __scalbnf64(_Float64 __x, int __n) throw();
    extern int ilogbf64(_Float64 __x) throw();
    extern int __ilogbf64(_Float64 __x) throw();
    extern long llogbf64(_Float64 __x) throw();
    extern long __llogbf64(_Float64 __x) throw();
    extern _Float64 scalblnf64(_Float64 __x, long __n) throw();
    extern _Float64 __scalblnf64(_Float64 __x, long __n) throw();
    extern _Float64 nearbyintf64(_Float64 __x) throw();
    extern _Float64 __nearbyintf64(_Float64 __x) throw();
    extern _Float64 roundf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 __roundf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 truncf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 __truncf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 remquof64(_Float64 __x, _Float64 __y, int *__quo) throw();
    extern _Float64 __remquof64(_Float64 __x, _Float64 __y, int *__quo) throw();
    extern long lrintf64(_Float64 __x) throw();
    extern long __lrintf64(_Float64 __x) throw();
    extern long long llrintf64(_Float64 __x) throw();
    extern long long __llrintf64(_Float64 __x) throw();
    extern long lroundf64(_Float64 __x) throw();
    extern long __lroundf64(_Float64 __x) throw();
    extern long long llroundf64(_Float64 __x) throw();
    extern long long __llroundf64(_Float64 __x) throw();
    extern _Float64 fdimf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 __fdimf64(_Float64 __x, _Float64 __y) throw();
    extern _Float64 fmaxf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 __fmaxf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 fminf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 __fminf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) throw();
    extern _Float64 __fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) throw();
    extern _Float64 roundevenf64(_Float64 __x) throw() __attribute__((const));
    extern _Float64 __roundevenf64(_Float64 __x) throw() __attribute__((const));
    extern __intmax_t fromfpf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern __intmax_t fromfpxf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpxf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpxf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpxf64(_Float64 __x, int __round, unsigned int __width) throw();
    extern _Float64 fmaxmagf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 __fmaxmagf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 fminmagf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern _Float64 __fminmagf64(_Float64 __x, _Float64 __y) throw() __attribute__((const));
    extern int canonicalizef64(_Float64 *__cx, const _Float64 *__x) throw();
    extern int totalorderf64(const _Float64 *__x, const _Float64 *__y) throw() __attribute__((pure));
    extern int totalordermagf64(const _Float64 *__x, const _Float64 *__y) throw() __attribute__((pure));
    extern _Float64 getpayloadf64(const _Float64 *__x) throw();
    extern _Float64 __getpayloadf64(const _Float64 *__x) throw();
    extern int setpayloadf64(_Float64 *__x, _Float64 __payload) throw();
    extern int setpayloadsigf64(_Float64 *__x, _Float64 __payload) throw();
    extern _Float32x acosf32x(_Float32x __x) throw();
    extern _Float32x __acosf32x(_Float32x __x) throw();
    extern _Float32x asinf32x(_Float32x __x) throw();
    extern _Float32x __asinf32x(_Float32x __x) throw();
    extern _Float32x atanf32x(_Float32x __x) throw();
    extern _Float32x __atanf32x(_Float32x __x) throw();
    extern _Float32x atan2f32x(_Float32x __y, _Float32x __x) throw();
    extern _Float32x __atan2f32x(_Float32x __y, _Float32x __x) throw();
    extern _Float32x cosf32x(_Float32x __x) throw();
    extern _Float32x __cosf32x(_Float32x __x) throw();
    extern _Float32x sinf32x(_Float32x __x) throw();
    extern _Float32x __sinf32x(_Float32x __x) throw();
    extern _Float32x tanf32x(_Float32x __x) throw();
    extern _Float32x __tanf32x(_Float32x __x) throw();
    extern _Float32x coshf32x(_Float32x __x) throw();
    extern _Float32x __coshf32x(_Float32x __x) throw();
    extern _Float32x sinhf32x(_Float32x __x) throw();
    extern _Float32x __sinhf32x(_Float32x __x) throw();
    extern _Float32x tanhf32x(_Float32x __x) throw();
    extern _Float32x __tanhf32x(_Float32x __x) throw();
    extern void sincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw();
    extern void __sincosf32x(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw();
    extern _Float32x acoshf32x(_Float32x __x) throw();
    extern _Float32x __acoshf32x(_Float32x __x) throw();
    extern _Float32x asinhf32x(_Float32x __x) throw();
    extern _Float32x __asinhf32x(_Float32x __x) throw();
    extern _Float32x atanhf32x(_Float32x __x) throw();
    extern _Float32x __atanhf32x(_Float32x __x) throw();
    extern _Float32x expf32x(_Float32x __x) throw();
    extern _Float32x __expf32x(_Float32x __x) throw();
    extern _Float32x frexpf32x(_Float32x __x, int *__exponent) throw();
    extern _Float32x __frexpf32x(_Float32x __x, int *__exponent) throw();
    extern _Float32x ldexpf32x(_Float32x __x, int __exponent) throw();
    extern _Float32x __ldexpf32x(_Float32x __x, int __exponent) throw();
    extern _Float32x logf32x(_Float32x __x) throw();
    extern _Float32x __logf32x(_Float32x __x) throw();
    extern _Float32x log10f32x(_Float32x __x) throw();
    extern _Float32x __log10f32x(_Float32x __x) throw();
    extern _Float32x modff32x(_Float32x __x, _Float32x *__iptr) throw();
    extern _Float32x __modff32x(_Float32x __x, _Float32x *__iptr) throw() __attribute__((nonnull(2)));
    extern _Float32x exp10f32x(_Float32x __x) throw();
    extern _Float32x __exp10f32x(_Float32x __x) throw();
    extern _Float32x expm1f32x(_Float32x __x) throw();
    extern _Float32x __expm1f32x(_Float32x __x) throw();
    extern _Float32x log1pf32x(_Float32x __x) throw();
    extern _Float32x __log1pf32x(_Float32x __x) throw();
    extern _Float32x logbf32x(_Float32x __x) throw();
    extern _Float32x __logbf32x(_Float32x __x) throw();
    extern _Float32x exp2f32x(_Float32x __x) throw();
    extern _Float32x __exp2f32x(_Float32x __x) throw();
    extern _Float32x log2f32x(_Float32x __x) throw();
    extern _Float32x __log2f32x(_Float32x __x) throw();
    extern _Float32x powf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x __powf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x sqrtf32x(_Float32x __x) throw();
    extern _Float32x __sqrtf32x(_Float32x __x) throw();
    extern _Float32x hypotf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x __hypotf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x cbrtf32x(_Float32x __x) throw();
    extern _Float32x __cbrtf32x(_Float32x __x) throw();
    extern _Float32x ceilf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x __ceilf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x fabsf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x __fabsf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x floorf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x __floorf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x fmodf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x __fmodf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x copysignf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x __copysignf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x nanf32x(const char *__tagb) throw();
    extern _Float32x __nanf32x(const char *__tagb) throw();
    extern _Float32x j0f32x(_Float32x) throw();
    extern _Float32x __j0f32x(_Float32x) throw();
    extern _Float32x j1f32x(_Float32x) throw();
    extern _Float32x __j1f32x(_Float32x) throw();
    extern _Float32x jnf32x(int, _Float32x) throw();
    extern _Float32x __jnf32x(int, _Float32x) throw();
    extern _Float32x y0f32x(_Float32x) throw();
    extern _Float32x __y0f32x(_Float32x) throw();
    extern _Float32x y1f32x(_Float32x) throw();
    extern _Float32x __y1f32x(_Float32x) throw();
    extern _Float32x ynf32x(int, _Float32x) throw();
    extern _Float32x __ynf32x(int, _Float32x) throw();
    extern _Float32x erff32x(_Float32x) throw();
    extern _Float32x __erff32x(_Float32x) throw();
    extern _Float32x erfcf32x(_Float32x) throw();
    extern _Float32x __erfcf32x(_Float32x) throw();
    extern _Float32x lgammaf32x(_Float32x) throw();
    extern _Float32x __lgammaf32x(_Float32x) throw();
    extern _Float32x tgammaf32x(_Float32x) throw();
    extern _Float32x __tgammaf32x(_Float32x) throw();
    extern _Float32x lgammaf32x_r(_Float32x, int *__signgamp) throw();
    extern _Float32x __lgammaf32x_r(_Float32x, int *__signgamp) throw();
    extern _Float32x rintf32x(_Float32x __x) throw();
    extern _Float32x __rintf32x(_Float32x __x) throw();
    extern _Float32x nextafterf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x __nextafterf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x nextdownf32x(_Float32x __x) throw();
    extern _Float32x __nextdownf32x(_Float32x __x) throw();
    extern _Float32x nextupf32x(_Float32x __x) throw();
    extern _Float32x __nextupf32x(_Float32x __x) throw();
    extern _Float32x remainderf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x __remainderf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x scalbnf32x(_Float32x __x, int __n) throw();
    extern _Float32x __scalbnf32x(_Float32x __x, int __n) throw();
    extern int ilogbf32x(_Float32x __x) throw();
    extern int __ilogbf32x(_Float32x __x) throw();
    extern long llogbf32x(_Float32x __x) throw();
    extern long __llogbf32x(_Float32x __x) throw();
    extern _Float32x scalblnf32x(_Float32x __x, long __n) throw();
    extern _Float32x __scalblnf32x(_Float32x __x, long __n) throw();
    extern _Float32x nearbyintf32x(_Float32x __x) throw();
    extern _Float32x __nearbyintf32x(_Float32x __x) throw();
    extern _Float32x roundf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x __roundf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x truncf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x __truncf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x remquof32x(_Float32x __x, _Float32x __y, int *__quo) throw();
    extern _Float32x __remquof32x(_Float32x __x, _Float32x __y, int *__quo) throw();
    extern long lrintf32x(_Float32x __x) throw();
    extern long __lrintf32x(_Float32x __x) throw();
    extern long long llrintf32x(_Float32x __x) throw();
    extern long long __llrintf32x(_Float32x __x) throw();
    extern long lroundf32x(_Float32x __x) throw();
    extern long __lroundf32x(_Float32x __x) throw();
    extern long long llroundf32x(_Float32x __x) throw();
    extern long long __llroundf32x(_Float32x __x) throw();
    extern _Float32x fdimf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x __fdimf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32x fmaxf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x __fmaxf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x fminf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x __fminf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) throw();
    extern _Float32x __fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) throw();
    extern _Float32x roundevenf32x(_Float32x __x) throw() __attribute__((const));
    extern _Float32x __roundevenf32x(_Float32x __x) throw() __attribute__((const));
    extern __intmax_t fromfpf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern __intmax_t fromfpxf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpxf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpxf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpxf32x(_Float32x __x, int __round, unsigned int __width) throw();
    extern _Float32x fmaxmagf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x __fmaxmagf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x fminmagf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern _Float32x __fminmagf32x(_Float32x __x, _Float32x __y) throw() __attribute__((const));
    extern int canonicalizef32x(_Float32x *__cx, const _Float32x *__x) throw();
    extern int totalorderf32x(const _Float32x *__x, const _Float32x *__y) throw() __attribute__((pure));
    extern int totalordermagf32x(const _Float32x *__x, const _Float32x *__y) throw() __attribute__((pure));
    extern _Float32x getpayloadf32x(const _Float32x *__x) throw();
    extern _Float32x __getpayloadf32x(const _Float32x *__x) throw();
    extern int setpayloadf32x(_Float32x *__x, _Float32x __payload) throw();
    extern int setpayloadsigf32x(_Float32x *__x, _Float32x __payload) throw();
    extern _Float64x acosf64x(_Float64x __x) throw();
    extern _Float64x __acosf64x(_Float64x __x) throw();
    extern _Float64x asinf64x(_Float64x __x) throw();
    extern _Float64x __asinf64x(_Float64x __x) throw();
    extern _Float64x atanf64x(_Float64x __x) throw();
    extern _Float64x __atanf64x(_Float64x __x) throw();
    extern _Float64x atan2f64x(_Float64x __y, _Float64x __x) throw();
    extern _Float64x __atan2f64x(_Float64x __y, _Float64x __x) throw();
    extern _Float64x cosf64x(_Float64x __x) throw();
    extern _Float64x __cosf64x(_Float64x __x) throw();
    extern _Float64x sinf64x(_Float64x __x) throw();
    extern _Float64x __sinf64x(_Float64x __x) throw();
    extern _Float64x tanf64x(_Float64x __x) throw();
    extern _Float64x __tanf64x(_Float64x __x) throw();
    extern _Float64x coshf64x(_Float64x __x) throw();
    extern _Float64x __coshf64x(_Float64x __x) throw();
    extern _Float64x sinhf64x(_Float64x __x) throw();
    extern _Float64x __sinhf64x(_Float64x __x) throw();
    extern _Float64x tanhf64x(_Float64x __x) throw();
    extern _Float64x __tanhf64x(_Float64x __x) throw();
    extern void sincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw();
    extern void __sincosf64x(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw();
    extern _Float64x acoshf64x(_Float64x __x) throw();
    extern _Float64x __acoshf64x(_Float64x __x) throw();
    extern _Float64x asinhf64x(_Float64x __x) throw();
    extern _Float64x __asinhf64x(_Float64x __x) throw();
    extern _Float64x atanhf64x(_Float64x __x) throw();
    extern _Float64x __atanhf64x(_Float64x __x) throw();
    extern _Float64x expf64x(_Float64x __x) throw();
    extern _Float64x __expf64x(_Float64x __x) throw();
    extern _Float64x frexpf64x(_Float64x __x, int *__exponent) throw();
    extern _Float64x __frexpf64x(_Float64x __x, int *__exponent) throw();
    extern _Float64x ldexpf64x(_Float64x __x, int __exponent) throw();
    extern _Float64x __ldexpf64x(_Float64x __x, int __exponent) throw();
    extern _Float64x logf64x(_Float64x __x) throw();
    extern _Float64x __logf64x(_Float64x __x) throw();
    extern _Float64x log10f64x(_Float64x __x) throw();
    extern _Float64x __log10f64x(_Float64x __x) throw();
    extern _Float64x modff64x(_Float64x __x, _Float64x *__iptr) throw();
    extern _Float64x __modff64x(_Float64x __x, _Float64x *__iptr) throw() __attribute__((nonnull(2)));
    extern _Float64x exp10f64x(_Float64x __x) throw();
    extern _Float64x __exp10f64x(_Float64x __x) throw();
    extern _Float64x expm1f64x(_Float64x __x) throw();
    extern _Float64x __expm1f64x(_Float64x __x) throw();
    extern _Float64x log1pf64x(_Float64x __x) throw();
    extern _Float64x __log1pf64x(_Float64x __x) throw();
    extern _Float64x logbf64x(_Float64x __x) throw();
    extern _Float64x __logbf64x(_Float64x __x) throw();
    extern _Float64x exp2f64x(_Float64x __x) throw();
    extern _Float64x __exp2f64x(_Float64x __x) throw();
    extern _Float64x log2f64x(_Float64x __x) throw();
    extern _Float64x __log2f64x(_Float64x __x) throw();
    extern _Float64x powf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x __powf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x sqrtf64x(_Float64x __x) throw();
    extern _Float64x __sqrtf64x(_Float64x __x) throw();
    extern _Float64x hypotf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x __hypotf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x cbrtf64x(_Float64x __x) throw();
    extern _Float64x __cbrtf64x(_Float64x __x) throw();
    extern _Float64x ceilf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x __ceilf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x fabsf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x __fabsf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x floorf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x __floorf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x fmodf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x __fmodf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x copysignf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x __copysignf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x nanf64x(const char *__tagb) throw();
    extern _Float64x __nanf64x(const char *__tagb) throw();
    extern _Float64x j0f64x(_Float64x) throw();
    extern _Float64x __j0f64x(_Float64x) throw();
    extern _Float64x j1f64x(_Float64x) throw();
    extern _Float64x __j1f64x(_Float64x) throw();
    extern _Float64x jnf64x(int, _Float64x) throw();
    extern _Float64x __jnf64x(int, _Float64x) throw();
    extern _Float64x y0f64x(_Float64x) throw();
    extern _Float64x __y0f64x(_Float64x) throw();
    extern _Float64x y1f64x(_Float64x) throw();
    extern _Float64x __y1f64x(_Float64x) throw();
    extern _Float64x ynf64x(int, _Float64x) throw();
    extern _Float64x __ynf64x(int, _Float64x) throw();
    extern _Float64x erff64x(_Float64x) throw();
    extern _Float64x __erff64x(_Float64x) throw();
    extern _Float64x erfcf64x(_Float64x) throw();
    extern _Float64x __erfcf64x(_Float64x) throw();
    extern _Float64x lgammaf64x(_Float64x) throw();
    extern _Float64x __lgammaf64x(_Float64x) throw();
    extern _Float64x tgammaf64x(_Float64x) throw();
    extern _Float64x __tgammaf64x(_Float64x) throw();
    extern _Float64x lgammaf64x_r(_Float64x, int *__signgamp) throw();
    extern _Float64x __lgammaf64x_r(_Float64x, int *__signgamp) throw();
    extern _Float64x rintf64x(_Float64x __x) throw();
    extern _Float64x __rintf64x(_Float64x __x) throw();
    extern _Float64x nextafterf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x __nextafterf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x nextdownf64x(_Float64x __x) throw();
    extern _Float64x __nextdownf64x(_Float64x __x) throw();
    extern _Float64x nextupf64x(_Float64x __x) throw();
    extern _Float64x __nextupf64x(_Float64x __x) throw();
    extern _Float64x remainderf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x __remainderf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x scalbnf64x(_Float64x __x, int __n) throw();
    extern _Float64x __scalbnf64x(_Float64x __x, int __n) throw();
    extern int ilogbf64x(_Float64x __x) throw();
    extern int __ilogbf64x(_Float64x __x) throw();
    extern long llogbf64x(_Float64x __x) throw();
    extern long __llogbf64x(_Float64x __x) throw();
    extern _Float64x scalblnf64x(_Float64x __x, long __n) throw();
    extern _Float64x __scalblnf64x(_Float64x __x, long __n) throw();
    extern _Float64x nearbyintf64x(_Float64x __x) throw();
    extern _Float64x __nearbyintf64x(_Float64x __x) throw();
    extern _Float64x roundf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x __roundf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x truncf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x __truncf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x remquof64x(_Float64x __x, _Float64x __y, int *__quo) throw();
    extern _Float64x __remquof64x(_Float64x __x, _Float64x __y, int *__quo) throw();
    extern long lrintf64x(_Float64x __x) throw();
    extern long __lrintf64x(_Float64x __x) throw();
    extern long long llrintf64x(_Float64x __x) throw();
    extern long long __llrintf64x(_Float64x __x) throw();
    extern long lroundf64x(_Float64x __x) throw();
    extern long __lroundf64x(_Float64x __x) throw();
    extern long long llroundf64x(_Float64x __x) throw();
    extern long long __llroundf64x(_Float64x __x) throw();
    extern _Float64x fdimf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x __fdimf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64x fmaxf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x __fmaxf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x fminf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x __fminf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) throw();
    extern _Float64x __fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) throw();
    extern _Float64x roundevenf64x(_Float64x __x) throw() __attribute__((const));
    extern _Float64x __roundevenf64x(_Float64x __x) throw() __attribute__((const));
    extern __intmax_t fromfpf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern __intmax_t fromfpxf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern __intmax_t __fromfpxf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t ufromfpxf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern __uintmax_t __ufromfpxf64x(_Float64x __x, int __round, unsigned int __width) throw();
    extern _Float64x fmaxmagf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x __fmaxmagf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x fminmagf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern _Float64x __fminmagf64x(_Float64x __x, _Float64x __y) throw() __attribute__((const));
    extern int canonicalizef64x(_Float64x *__cx, const _Float64x *__x) throw();
    extern int totalorderf64x(const _Float64x *__x, const _Float64x *__y) throw() __attribute__((pure));
    extern int totalordermagf64x(const _Float64x *__x, const _Float64x *__y) throw() __attribute__((pure));
    extern _Float64x getpayloadf64x(const _Float64x *__x) throw();
    extern _Float64x __getpayloadf64x(const _Float64x *__x) throw();
    extern int setpayloadf64x(_Float64x *__x, _Float64x __payload) throw();
    extern int setpayloadsigf64x(_Float64x *__x, _Float64x __payload) throw();
    extern float fadd(double __x, double __y) throw();
    extern float fdiv(double __x, double __y) throw();
    extern float fmul(double __x, double __y) throw();
    extern float fsub(double __x, double __y) throw();
    extern float faddl(long double __x, long double __y) throw();
    extern float fdivl(long double __x, long double __y) throw();
    extern float fmull(long double __x, long double __y) throw();
    extern float fsubl(long double __x, long double __y) throw();
    extern double daddl(long double __x, long double __y) throw();
    extern double ddivl(long double __x, long double __y) throw();
    extern double dmull(long double __x, long double __y) throw();
    extern double dsubl(long double __x, long double __y) throw();
    extern _Float32 f32addf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32 f32divf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32 f32mulf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32 f32subf32x(_Float32x __x, _Float32x __y) throw();
    extern _Float32 f32addf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32 f32divf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32 f32mulf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32 f32subf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32 f32addf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float32 f32divf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float32 f32mulf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float32 f32subf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float32x f32xaddf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32x f32xdivf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32x f32xmulf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32x f32xsubf64(_Float64 __x, _Float64 __y) throw();
    extern _Float32x f32xaddf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float32x f32xdivf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float32x f32xmulf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float32x f32xsubf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64 f64addf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64 f64divf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64 f64mulf64x(_Float64x __x, _Float64x __y) throw();
    extern _Float64 f64subf64x(_Float64x __x, _Float64x __y) throw();
    extern int signgam;
    enum  {
        FP_NAN = 0,
        FP_INFINITE = 1,
        FP_ZERO = 2,
        FP_SUBNORMAL = 3,
        FP_NORMAL = 4
    };
    extern int __iscanonicall(long double __x) throw() __attribute__((const));
    extern "C++" {
        inline int iscanonical(float __val)         {
            return ((void)(typeof (__val))(__val) , 1);
        }
        inline int iscanonical(double __val)         {
            return ((void)(typeof (__val))(__val) , 1);
        }
        inline int iscanonical(long double __val)         {
            return __iscanonicall(__val);
        }
    }
    extern "C++" {
        inline int issignaling(float __val)         {
            return __issignalingf(__val);
        }
        inline int issignaling(double __val)         {
            return __issignaling(__val);
        }
        inline int issignaling(long double __val)         {
            return __issignalingl(__val);
        }
    }
    extern "C++" {
        template <class __T> inline bool iszero(__T __val)         {
            return __val == 0;
        }
    }
    extern "C++" {
        template <typename> struct __iseqsig_type;
        template<> struct __iseqsig_type<float> {
            static int __call(float __x, float __y) throw()             {
                return __iseqsigf(__x, __y);
            }
        };
        template<> struct __iseqsig_type<double> {
            static int __call(double __x, double __y) throw()             {
                return __iseqsig(__x, __y);
            }
        };
        template<> struct __iseqsig_type<long double> {
            static int __call(long double __x, long double __y) throw()             {
                return __iseqsigl(__x, __y);
            }
        };
        template <typename _T1, typename _T2> inline int iseqsig(_T1 __x, _T2 __y) throw()         {
            typedef decltype(((__x) + (__y) + 0.F)) _T3;
            return __iseqsig_type<_T3>::__call(__x, __y);
        }
    }
}
typedef unsigned long size_t;
extern "C" {
    typedef enum  {
        P_ALL,
        P_PID,
        P_PGID
    } idtype_t;
    typedef struct {
        int quot;
        int rem;
    } div_t;
    typedef struct {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct {
        long long quot;
        long long rem;
    } lldiv_t;
    extern size_t __ctype_get_mb_cur_max() throw();
    extern double atof(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern int atoi(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern long atol(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern long long atoll(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float32 strtof32(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float64 strtof64(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float32x strtof32x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float64x strtof64x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern int strfromd(char *__dest, size_t __size, const char *__format, double __f) throw() __attribute__((nonnull(3)));
    extern int strfromf(char *__dest, size_t __size, const char *__format, float __f) throw() __attribute__((nonnull(3)));
    extern int strfroml(char *__dest, size_t __size, const char *__format, long double __f) throw() __attribute__((nonnull(3)));
    extern int strfromf32(char *__dest, size_t __size, const char *__format, _Float32 __f) throw() __attribute__((nonnull(3)));
    extern int strfromf64(char *__dest, size_t __size, const char *__format, _Float64 __f) throw() __attribute__((nonnull(3)));
    extern int strfromf32x(char *__dest, size_t __size, const char *__format, _Float32x __f) throw() __attribute__((nonnull(3)));
    extern int strfromf64x(char *__dest, size_t __size, const char *__format, _Float64x __f) throw() __attribute__((nonnull(3)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float32 strtof32_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float64 strtof64_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float32x strtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float64x strtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern char *l64a(long __n) throw();
    extern long a64l(const char *__s) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern "C" {
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __off_t off_t;
        typedef __off64_t off64_t;
        typedef __pid_t pid_t;
        typedef __id_t id_t;
        typedef __ssize_t ssize_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __clock_t clock_t;
        typedef __clockid_t clockid_t;
        typedef __time_t time_t;
        typedef __timer_t timer_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long size_t;
        typedef unsigned long ulong;
        typedef unsigned short ushort;
        typedef unsigned int uint;
        typedef __uint8_t u_int8_t;
        typedef __uint16_t u_int16_t;
        typedef __uint32_t u_int32_t;
        typedef __uint64_t u_int64_t;
        typedef int register_t __attribute__((mode(__word__)));
        static inline __uint16_t __bswap_16(__uint16_t __bsx)         {
            return ((__uint16_t)((((__bsx) >> 8) & 255) | (((__bsx) & 255) << 8)));
        }
        static inline __uint32_t __bswap_32(__uint32_t __bsx)         {
            return ((((__bsx) & 4278190080U) >> 24) | (((__bsx) & 16711680U) >> 8) | (((__bsx) & 65280U) << 8) | (((__bsx) & 255U) << 24));
        }
        static inline __uint64_t __bswap_64(__uint64_t __bsx)         {
            return ((((__bsx) & 18374686479671623680ULL) >> 56) | (((__bsx) & 71776119061217280ULL) >> 40) | (((__bsx) & 280375465082880ULL) >> 24) | (((__bsx) & 1095216660480ULL) >> 8) | (((__bsx) & 4278190080ULL) << 8) | (((__bsx) & 16711680ULL) << 24) | (((__bsx) & 65280ULL) << 40) | (((__bsx) & 255ULL) << 56));
        }
        static inline __uint16_t __uint16_identity(__uint16_t __x)         {
            return __x;
        }
        static inline __uint32_t __uint32_identity(__uint32_t __x)         {
            return __x;
        }
        static inline __uint64_t __uint64_identity(__uint64_t __x)         {
            return __x;
        }
        typedef struct {
            unsigned long __val[16];
        } __sigset_t;
        typedef __sigset_t sigset_t;
        struct timeval {
            __time_t tv_sec;
            __suseconds_t tv_usec;
        };
        struct timespec {
            __time_t tv_sec;
            __syscall_slong_t tv_nsec;
        };
        typedef long __fd_mask;
        typedef struct {
            __fd_mask fds_bits[16];
        } fd_set;
        typedef __fd_mask fd_mask;
        extern "C" {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
        typedef struct __pthread_internal_list {
            struct __pthread_internal_list *__prev;
            struct __pthread_internal_list *__next;
        } __pthread_list_t;
        typedef struct __pthread_internal_slist {
            struct __pthread_internal_slist *__next;
        } __pthread_slist_t;
        struct __pthread_mutex_s {
            int __lock;
            unsigned int __count;
            int __owner;
            unsigned int __nusers;
            int __kind;
            short __spins;
            short __elision;
            __pthread_list_t __list;
        };
        struct __pthread_rwlock_arch_t {
            unsigned int __readers;
            unsigned int __writers;
            unsigned int __wrphase_futex;
            unsigned int __writers_futex;
            unsigned int __pad3;
            unsigned int __pad4;
            int __cur_writer;
            int __shared;
            signed char __rwelision;
            unsigned char __pad1[7];
            unsigned long __pad2;
            unsigned int __flags;
        };
        struct __pthread_cond_s {
            union {
                unsigned long long __wseq;
                struct {
                    unsigned int __low;
                    unsigned int __high;
                } __wseq32;
            };
            union {
                unsigned long long __g1_start;
                struct {
                    unsigned int __low;
                    unsigned int __high;
                } __g1_start32;
            };
            unsigned int __g_refs[2];
            unsigned int __g_size[2];
            unsigned int __g1_orig_size;
            unsigned int __wrefs;
            unsigned int __g_signals[2];
        };
        typedef unsigned long pthread_t;
        typedef union {
            char __size[4];
            int __align;
        } pthread_mutexattr_t;
        typedef union {
            char __size[4];
            int __align;
        } pthread_condattr_t;
        typedef unsigned int pthread_key_t;
        typedef int pthread_once_t;
        union pthread_attr_t {
            char __size[56];
            long __align;
        };
        typedef union pthread_attr_t pthread_attr_t;
        typedef union {
            struct __pthread_mutex_s __data;
            char __size[40];
            long __align;
        } pthread_mutex_t;
        typedef union {
            struct __pthread_cond_s __data;
            char __size[48];
            long long __align;
        } pthread_cond_t;
        typedef union {
            struct __pthread_rwlock_arch_t __data;
            char __size[56];
            long __align;
        } pthread_rwlock_t;
        typedef union {
            char __size[8];
            long __align;
        } pthread_rwlockattr_t;
        typedef volatile int pthread_spinlock_t;
        typedef union {
            char __size[32];
            long __align;
        } pthread_barrier_t;
        typedef union {
            char __size[4];
            int __align;
        } pthread_barrierattr_t;
    }
    extern long random() throw();
    extern void srandom(unsigned int __seed) throw();
    extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen) throw() __attribute__((nonnull(2)));
    extern char *setstate(char *__statebuf) throw() __attribute__((nonnull(1)));
    struct random_data {
        int32_t *fptr;
        int32_t *rptr;
        int32_t *state;
        int rand_type;
        int rand_deg;
        int rand_sep;
        int32_t *end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int srandom_r(unsigned int __seed, struct random_data *__buf) throw() __attribute__((nonnull(2)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) throw() __attribute__((nonnull(2, 4)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) throw() __attribute__((nonnull(1, 2)));
    extern int rand() throw();
    extern void srand(unsigned int __seed) throw();
    extern int rand_r(unsigned int *__seed) throw();
    extern double drand48() throw();
    extern double erand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern long lrand48() throw();
    extern long nrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern long mrand48() throw();
    extern long jrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern void srand48(long __seedval) throw();
    extern unsigned short *seed48(unsigned short __seed16v[3]) throw() __attribute__((nonnull(1)));
    extern void lcong48(unsigned short __param[7]) throw() __attribute__((nonnull(1)));
    struct drand48_data {
        unsigned short __x[3];
        unsigned short __old_x[3];
        unsigned short __c;
        unsigned short __init;
        unsigned long long __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int srand48_r(long __seedval, struct drand48_data *__buffer) throw() __attribute__((nonnull(2)));
    extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) throw() __attribute__((nonnull(1, 2)));
    extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer) throw() __attribute__((nonnull(1, 2)));
    extern void *malloc(size_t __size) throw() __attribute__((malloc));
    extern void *calloc(size_t __nmemb, size_t __size) throw() __attribute__((malloc));
    extern void *realloc(void *__ptr, size_t __size) throw() __attribute__((warn_unused_result("")));
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) throw() __attribute__((warn_unused_result("")));
    extern void free(void *__ptr) throw();
    typedef unsigned long size_t;
    extern "C" {
        extern void *alloca(size_t __size) throw();
    }
    extern void *valloc(size_t __size) throw() __attribute__((malloc));
    extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size) throw() __attribute__((nonnull(1)));
    extern void *aligned_alloc(size_t __alignment, size_t __size) throw() __attribute__((malloc));
    extern void abort() throw();
    extern int atexit(void (*__func)()) throw() __attribute__((nonnull(1)));
    extern "C++" int at_quick_exit(void (*__func)()) throw() asm("at_quick_exit") __attribute__((nonnull(1)))
    extern int on_exit(void (*__func)(int, void *), void *__arg) throw() __attribute__((nonnull(1)));
    extern void exit(int __status) throw();
    extern void quick_exit(int __status) throw();
    extern void _Exit(int __status) throw();
    extern char *getenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern char *secure_getenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern int putenv(char *__string) throw() __attribute__((nonnull(1)));
    extern int setenv(const char *__name, const char *__value, int __replace) throw() __attribute__((nonnull(2)));
    extern int unsetenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern int clearenv() throw();
    extern char *mktemp(char *__template) throw() __attribute__((nonnull(1)));
    extern int mkstemp(char *__template) __attribute__((nonnull(1)));
    extern int mkstemp64(char *__template) __attribute__((nonnull(1)));
    extern int mkstemps(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern int mkstemps64(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern char *mkdtemp(char *__template) throw() __attribute__((nonnull(1)));
    extern int mkostemp(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemp64(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int system(const char *__command);
    extern char *canonicalize_file_name(const char *__name) throw() __attribute__((nonnull(1)));
    extern char *realpath(const char *__restrict __name, char *__restrict __resolved) throw();
    typedef int (*__compar_fn_t)(const void *, const void *);
    typedef __compar_fn_t comparison_fn_t;
    typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
    extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 2, 5)));
    extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 4)));
    extern void qsort_r(void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg) __attribute__((nonnull(1, 4)));
    extern int abs(int __x) throw() __attribute__((const));
    extern long labs(long __x) throw() __attribute__((const));
    extern long long llabs(long long __x) throw() __attribute__((const));
    extern div_t div(int __numer, int __denom) throw() __attribute__((const));
    extern ldiv_t ldiv(long __numer, long __denom) throw() __attribute__((const));
    extern lldiv_t lldiv(long long __numer, long long __denom) throw() __attribute__((const));
    extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *gcvt(double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(3)));
    extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(3)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int mblen(const char *__s, size_t __n) throw();
    extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) throw();
    extern int wctomb(char *__s, wchar_t __wchar) throw();
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) throw();
    extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) throw();
    extern int rpmatch(const char *__response) throw() __attribute__((nonnull(1)));
    extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw() __attribute__((nonnull(1, 2, 3)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) throw();
    extern int unlockpt(int __fd) throw();
    extern char *ptsname(int __fd) throw();
    extern int ptsname_r(int __fd, char *__buf, size_t __buflen) throw() __attribute__((nonnull(2)));
    extern int getpt();
    extern int getloadavg(double __loadavg[], int __nelem) throw() __attribute__((nonnull(1)));
}
extern "C++" {
    namespace std {
        using ::abs;
        inline long abs(long __i)         {
            return __builtin_labs(__i);
        }
        inline long long abs(long long __x)         {
            return __builtin_llabs(__x);
        }
        inline constexpr double abs(double __x)         {
            return __builtin_fabs(__x);
        }
        inline constexpr float abs(float __x)         {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double abs(long double __x)         {
            return __builtin_fabsl(__x);
        }
    }
}
extern "C++" {
    namespace std {
        using ::acos;
        inline constexpr float acos(float __x)         {
            return __builtin_acosf(__x);
        }
        inline constexpr long double acos(long double __x)         {
            return __builtin_acosl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x)         {
            return __builtin_acos(__x);
        }
        using ::asin;
        inline constexpr float asin(float __x)         {
            return __builtin_asinf(__x);
        }
        inline constexpr long double asin(long double __x)         {
            return __builtin_asinl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x)         {
            return __builtin_asin(__x);
        }
        using ::atan;
        inline constexpr float atan(float __x)         {
            return __builtin_atanf(__x);
        }
        inline constexpr long double atan(long double __x)         {
            return __builtin_atanl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x)         {
            return __builtin_atan(__x);
        }
        using ::atan2;
        inline constexpr float atan2(float __y, float __x)         {
            return __builtin_atan2f(__y, __x);
        }
        inline constexpr long double atan2(long double __y, long double __x)         {
            return __builtin_atan2l(__y, __x);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return atan2(__type(__y), __type(__x));
        }
        using ::ceil;
        inline constexpr float ceil(float __x)         {
            return __builtin_ceilf(__x);
        }
        inline constexpr long double ceil(long double __x)         {
            return __builtin_ceill(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x)         {
            return __builtin_ceil(__x);
        }
        using ::cos;
        inline constexpr float cos(float __x)         {
            return __builtin_cosf(__x);
        }
        inline constexpr long double cos(long double __x)         {
            return __builtin_cosl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x)         {
            return __builtin_cos(__x);
        }
        using ::cosh;
        inline constexpr float cosh(float __x)         {
            return __builtin_coshf(__x);
        }
        inline constexpr long double cosh(long double __x)         {
            return __builtin_coshl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x)         {
            return __builtin_cosh(__x);
        }
        using ::exp;
        inline constexpr float exp(float __x)         {
            return __builtin_expf(__x);
        }
        inline constexpr long double exp(long double __x)         {
            return __builtin_expl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x)         {
            return __builtin_exp(__x);
        }
        using ::fabs;
        inline constexpr float fabs(float __x)         {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double fabs(long double __x)         {
            return __builtin_fabsl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x)         {
            return __builtin_fabs(__x);
        }
        using ::floor;
        inline constexpr float floor(float __x)         {
            return __builtin_floorf(__x);
        }
        inline constexpr long double floor(long double __x)         {
            return __builtin_floorl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x)         {
            return __builtin_floor(__x);
        }
        using ::fmod;
        inline constexpr float fmod(float __x, float __y)         {
            return __builtin_fmodf(__x, __y);
        }
        inline constexpr long double fmod(long double __x, long double __y)         {
            return __builtin_fmodl(__x, __y);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmod(__type(__x), __type(__y));
        }
        template<> inline constexpr typename __gnu_cxx::__promote_2<float, float>::__type fmod<float, float>(float __x, float __y)        template<> inline constexpr typename __gnu_cxx::__promote_2<long double, long double>::__type fmod<long double, long double>(long double __x, long double __y)        using ::frexp;
        inline float frexp(float __x, int *__exp)         {
            return __builtin_frexpf(__x, __exp);
        }
        inline long double frexp(long double __x, int *__exp)         {
            return __builtin_frexpl(__x, __exp);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp)         {
            return __builtin_frexp(__x, __exp);
        }
        using ::ldexp;
        inline constexpr float ldexp(float __x, int __exp)         {
            return __builtin_ldexpf(__x, __exp);
        }
        inline constexpr long double ldexp(long double __x, int __exp)         {
            return __builtin_ldexpl(__x, __exp);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp)         {
            return __builtin_ldexp(__x, __exp);
        }
        using ::log;
        inline constexpr float log(float __x)         {
            return __builtin_logf(__x);
        }
        inline constexpr long double log(long double __x)         {
            return __builtin_logl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x)         {
            return __builtin_log(__x);
        }
        using ::log10;
        inline constexpr float log10(float __x)         {
            return __builtin_log10f(__x);
        }
        inline constexpr long double log10(long double __x)         {
            return __builtin_log10l(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x)         {
            return __builtin_log10(__x);
        }
        using ::modf;
        inline float modf(float __x, float *__iptr)         {
            return __builtin_modff(__x, __iptr);
        }
        inline long double modf(long double __x, long double *__iptr)         {
            return __builtin_modfl(__x, __iptr);
        }
        using ::pow;
        inline constexpr float pow(float __x, float __y)         {
            return __builtin_powf(__x, __y);
        }
        inline constexpr long double pow(long double __x, long double __y)         {
            return __builtin_powl(__x, __y);
        }
        template <typename _Tp, typename _Up> inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return pow(__type(__x), __type(__y));
        }
        template<> inline constexpr typename __gnu_cxx::__promote_2<float, float>::__type pow<float, float>(float __x, float __y)        template<> inline constexpr typename __gnu_cxx::__promote_2<long double, long double>::__type pow<long double, long double>(long double __x, long double __y)        using ::sin;
        inline constexpr float sin(float __x)         {
            return __builtin_sinf(__x);
        }
        inline constexpr long double sin(long double __x)         {
            return __builtin_sinl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x)         {
            return __builtin_sin(__x);
        }
        using ::sinh;
        inline constexpr float sinh(float __x)         {
            return __builtin_sinhf(__x);
        }
        inline constexpr long double sinh(long double __x)         {
            return __builtin_sinhl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x)         {
            return __builtin_sinh(__x);
        }
        using ::sqrt;
        inline constexpr float sqrt(float __x)         {
            return __builtin_sqrtf(__x);
        }
        inline constexpr long double sqrt(long double __x)         {
            return __builtin_sqrtl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x)         {
            return __builtin_sqrt(__x);
        }
        using ::tan;
        inline constexpr float tan(float __x)         {
            return __builtin_tanf(__x);
        }
        inline constexpr long double tan(long double __x)         {
            return __builtin_tanl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x)         {
            return __builtin_tan(__x);
        }
        using ::tanh;
        inline constexpr float tanh(float __x)         {
            return __builtin_tanhf(__x);
        }
        inline constexpr long double tanh(long double __x)         {
            return __builtin_tanhl(__x);
        }
        template <typename _Tp> inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x)         {
            return __builtin_tanh(__x);
        }
        constexpr int fpclassify(float __x)         {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        constexpr int fpclassify(double __x)         {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        constexpr int fpclassify(long double __x)         {
            return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type fpclassify(_Tp __x)         {
            return __x != 0 ? 4 : 2;
        }
        constexpr bool isfinite(float __x)         {
            return __builtin_isfinite(__x);
        }
        constexpr bool isfinite(double __x)         {
            return __builtin_isfinite(__x);
        }
        constexpr bool isfinite(long double __x)         {
            return __builtin_isfinite(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isfinite(_Tp __x)         {
            return true;
        }
        constexpr bool isinf(float __x)         {
            return __builtin_isinf(__x);
        }
        constexpr bool isinf(double __x)         {
            return __builtin_isinf(__x);
        }
        constexpr bool isinf(long double __x)         {
            return __builtin_isinf(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isinf(_Tp __x)         {
            return false;
        }
        constexpr bool isnan(float __x)         {
            return __builtin_isnan(__x);
        }
        constexpr bool isnan(double __x)         {
            return __builtin_isnan(__x);
        }
        constexpr bool isnan(long double __x)         {
            return __builtin_isnan(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnan(_Tp __x)         {
            return false;
        }
        constexpr bool isnormal(float __x)         {
            return __builtin_isnormal(__x);
        }
        constexpr bool isnormal(double __x)         {
            return __builtin_isnormal(__x);
        }
        constexpr bool isnormal(long double __x)         {
            return __builtin_isnormal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnormal(_Tp __x)         {
            return __x != 0 ? true : false;
        }
        constexpr bool signbit(float __x)         {
            return __builtin_signbit(__x);
        }
        constexpr bool signbit(double __x)         {
            return __builtin_signbit(__x);
        }
        constexpr bool signbit(long double __x)         {
            return __builtin_signbit(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type signbit(_Tp __x)         {
            return __x < 0 ? true : false;
        }
        constexpr bool isgreater(float __x, float __y)         {
            return __builtin_isgreater(__x, __y);
        }
        constexpr bool isgreater(double __x, double __y)         {
            return __builtin_isgreater(__x, __y);
        }
        constexpr bool isgreater(long double __x, long double __y)         {
            return __builtin_isgreater(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isgreater(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isgreater(__type(__x), __type(__y));
        }
        constexpr bool isgreaterequal(float __x, float __y)         {
            return __builtin_isgreaterequal(__x, __y);
        }
        constexpr bool isgreaterequal(double __x, double __y)         {
            return __builtin_isgreaterequal(__x, __y);
        }
        constexpr bool isgreaterequal(long double __x, long double __y)         {
            return __builtin_isgreaterequal(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isgreaterequal(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isgreaterequal(__type(__x), __type(__y));
        }
        constexpr bool isless(float __x, float __y)         {
            return __builtin_isless(__x, __y);
        }
        constexpr bool isless(double __x, double __y)         {
            return __builtin_isless(__x, __y);
        }
        constexpr bool isless(long double __x, long double __y)         {
            return __builtin_isless(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isless(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isless(__type(__x), __type(__y));
        }
        constexpr bool islessequal(float __x, float __y)         {
            return __builtin_islessequal(__x, __y);
        }
        constexpr bool islessequal(double __x, double __y)         {
            return __builtin_islessequal(__x, __y);
        }
        constexpr bool islessequal(long double __x, long double __y)         {
            return __builtin_islessequal(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type islessequal(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_islessequal(__type(__x), __type(__y));
        }
        constexpr bool islessgreater(float __x, float __y)         {
            return __builtin_islessgreater(__x, __y);
        }
        constexpr bool islessgreater(double __x, double __y)         {
            return __builtin_islessgreater(__x, __y);
        }
        constexpr bool islessgreater(long double __x, long double __y)         {
            return __builtin_islessgreater(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type islessgreater(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_islessgreater(__type(__x), __type(__y));
        }
        constexpr bool isunordered(float __x, float __y)         {
            return __builtin_isunordered(__x, __y);
        }
        constexpr bool isunordered(double __x, double __y)         {
            return __builtin_isunordered(__x, __y);
        }
        constexpr bool isunordered(long double __x, long double __y)         {
            return __builtin_isunordered(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value), bool>::__type isunordered(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return __builtin_isunordered(__type(__x), __type(__y));
        }
        using ::double_t;
        using ::float_t;
        using ::acosh;
        using ::acoshf;
        using ::acoshl;
        using ::asinh;
        using ::asinhf;
        using ::asinhl;
        using ::atanh;
        using ::atanhf;
        using ::atanhl;
        using ::cbrt;
        using ::cbrtf;
        using ::cbrtl;
        using ::copysign;
        using ::copysignf;
        using ::copysignl;
        using ::erf;
        using ::erff;
        using ::erfl;
        using ::erfc;
        using ::erfcf;
        using ::erfcl;
        using ::exp2;
        using ::exp2f;
        using ::exp2l;
        using ::expm1;
        using ::expm1f;
        using ::expm1l;
        using ::fdim;
        using ::fdimf;
        using ::fdiml;
        using ::fma;
        using ::fmaf;
        using ::fmal;
        using ::fmax;
        using ::fmaxf;
        using ::fmaxl;
        using ::fmin;
        using ::fminf;
        using ::fminl;
        using ::hypot;
        using ::hypotf;
        using ::hypotl;
        using ::ilogb;
        using ::ilogbf;
        using ::ilogbl;
        using ::lgamma;
        using ::lgammaf;
        using ::lgammal;
        using ::llrint;
        using ::llrintf;
        using ::llrintl;
        using ::llround;
        using ::llroundf;
        using ::llroundl;
        using ::log1p;
        using ::log1pf;
        using ::log1pl;
        using ::log2;
        using ::log2f;
        using ::log2l;
        using ::logb;
        using ::logbf;
        using ::logbl;
        using ::lrint;
        using ::lrintf;
        using ::lrintl;
        using ::lround;
        using ::lroundf;
        using ::lroundl;
        using ::nan;
        using ::nanf;
        using ::nanl;
        using ::nearbyint;
        using ::nearbyintf;
        using ::nearbyintl;
        using ::nextafter;
        using ::nextafterf;
        using ::nextafterl;
        using ::nexttoward;
        using ::nexttowardf;
        using ::nexttowardl;
        using ::remainder;
        using ::remainderf;
        using ::remainderl;
        using ::remquo;
        using ::remquof;
        using ::remquol;
        using ::rint;
        using ::rintf;
        using ::rintl;
        using ::round;
        using ::roundf;
        using ::roundl;
        using ::scalbln;
        using ::scalblnf;
        using ::scalblnl;
        using ::scalbn;
        using ::scalbnf;
        using ::scalbnl;
        using ::tgamma;
        using ::tgammaf;
        using ::tgammal;
        using ::trunc;
        using ::truncf;
        using ::truncl;
        constexpr float acosh(float __x)         {
            return __builtin_acoshf(__x);
        }
        constexpr long double acosh(long double __x)         {
            return __builtin_acoshl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acosh(_Tp __x)         {
            return __builtin_acosh(__x);
        }
        constexpr float asinh(float __x)         {
            return __builtin_asinhf(__x);
        }
        constexpr long double asinh(long double __x)         {
            return __builtin_asinhl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asinh(_Tp __x)         {
            return __builtin_asinh(__x);
        }
        constexpr float atanh(float __x)         {
            return __builtin_atanhf(__x);
        }
        constexpr long double atanh(long double __x)         {
            return __builtin_atanhl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atanh(_Tp __x)         {
            return __builtin_atanh(__x);
        }
        constexpr float cbrt(float __x)         {
            return __builtin_cbrtf(__x);
        }
        constexpr long double cbrt(long double __x)         {
            return __builtin_cbrtl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cbrt(_Tp __x)         {
            return __builtin_cbrt(__x);
        }
        constexpr float copysign(float __x, float __y)         {
            return __builtin_copysignf(__x, __y);
        }
        constexpr long double copysign(long double __x, long double __y)         {
            return __builtin_copysignl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return copysign(__type(__x), __type(__y));
        }
        template<> constexpr typename __gnu_cxx::__promote_2<float, float>::__type copysign<float, float>(float __x, float __y)        template<> constexpr typename __gnu_cxx::__promote_2<long double, long double>::__type copysign<long double, long double>(long double __x, long double __y)        constexpr float erf(float __x)         {
            return __builtin_erff(__x);
        }
        constexpr long double erf(long double __x)         {
            return __builtin_erfl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erf(_Tp __x)         {
            return __builtin_erf(__x);
        }
        constexpr float erfc(float __x)         {
            return __builtin_erfcf(__x);
        }
        constexpr long double erfc(long double __x)         {
            return __builtin_erfcl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erfc(_Tp __x)         {
            return __builtin_erfc(__x);
        }
        constexpr float exp2(float __x)         {
            return __builtin_exp2f(__x);
        }
        constexpr long double exp2(long double __x)         {
            return __builtin_exp2l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp2(_Tp __x)         {
            return __builtin_exp2(__x);
        }
        constexpr float expm1(float __x)         {
            return __builtin_expm1f(__x);
        }
        constexpr long double expm1(long double __x)         {
            return __builtin_expm1l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type expm1(_Tp __x)         {
            return __builtin_expm1(__x);
        }
        constexpr float fdim(float __x, float __y)         {
            return __builtin_fdimf(__x, __y);
        }
        constexpr long double fdim(long double __x, long double __y)         {
            return __builtin_fdiml(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fdim(__type(__x), __type(__y));
        }
        constexpr float fma(float __x, float __y, float __z)         {
            return __builtin_fmaf(__x, __y, __z);
        }
        constexpr long double fma(long double __x, long double __y, long double __z)         {
            return __builtin_fmal(__x, __y, __z);
        }
        template <typename _Tp, typename _Up, typename _Vp> constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(_Tp __x, _Up __y, _Vp __z)         {
            typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
            return fma(__type(__x), __type(__y), __type(__z));
        }
        constexpr float fmax(float __x, float __y)         {
            return __builtin_fmaxf(__x, __y);
        }
        constexpr long double fmax(long double __x, long double __y)         {
            return __builtin_fmaxl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmax(__type(__x), __type(__y));
        }
        constexpr float fmin(float __x, float __y)         {
            return __builtin_fminf(__x, __y);
        }
        constexpr long double fmin(long double __x, long double __y)         {
            return __builtin_fminl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return fmin(__type(__x), __type(__y));
        }
        constexpr float hypot(float __x, float __y)         {
            return __builtin_hypotf(__x, __y);
        }
        constexpr long double hypot(long double __x, long double __y)         {
            return __builtin_hypotl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return hypot(__type(__x), __type(__y));
        }
        constexpr int ilogb(float __x)         {
            return __builtin_ilogbf(__x);
        }
        constexpr int ilogb(long double __x)         {
            return __builtin_ilogbl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type ilogb(_Tp __x)         {
            return __builtin_ilogb(__x);
        }
        constexpr float lgamma(float __x)         {
            return __builtin_lgammaf(__x);
        }
        constexpr long double lgamma(long double __x)         {
            return __builtin_lgammal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type lgamma(_Tp __x)         {
            return __builtin_lgamma(__x);
        }
        constexpr long long llrint(float __x)         {
            return __builtin_llrintf(__x);
        }
        constexpr long long llrint(long double __x)         {
            return __builtin_llrintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long>::__type llrint(_Tp __x)         {
            return __builtin_llrint(__x);
        }
        constexpr long long llround(float __x)         {
            return __builtin_llroundf(__x);
        }
        constexpr long long llround(long double __x)         {
            return __builtin_llroundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long>::__type llround(_Tp __x)         {
            return __builtin_llround(__x);
        }
        constexpr float log1p(float __x)         {
            return __builtin_log1pf(__x);
        }
        constexpr long double log1p(long double __x)         {
            return __builtin_log1pl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log1p(_Tp __x)         {
            return __builtin_log1p(__x);
        }
        constexpr float log2(float __x)         {
            return __builtin_log2f(__x);
        }
        constexpr long double log2(long double __x)         {
            return __builtin_log2l(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log2(_Tp __x)         {
            return __builtin_log2(__x);
        }
        constexpr float logb(float __x)         {
            return __builtin_logbf(__x);
        }
        constexpr long double logb(long double __x)         {
            return __builtin_logbl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type logb(_Tp __x)         {
            return __builtin_logb(__x);
        }
        constexpr long lrint(float __x)         {
            return __builtin_lrintf(__x);
        }
        constexpr long lrint(long double __x)         {
            return __builtin_lrintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type lrint(_Tp __x)         {
            return __builtin_lrint(__x);
        }
        constexpr long lround(float __x)         {
            return __builtin_lroundf(__x);
        }
        constexpr long lround(long double __x)         {
            return __builtin_lroundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type lround(_Tp __x)         {
            return __builtin_lround(__x);
        }
        constexpr float nearbyint(float __x)         {
            return __builtin_nearbyintf(__x);
        }
        constexpr long double nearbyint(long double __x)         {
            return __builtin_nearbyintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nearbyint(_Tp __x)         {
            return __builtin_nearbyint(__x);
        }
        constexpr float nextafter(float __x, float __y)         {
            return __builtin_nextafterf(__x, __y);
        }
        constexpr long double nextafter(long double __x, long double __y)         {
            return __builtin_nextafterl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return nextafter(__type(__x), __type(__y));
        }
        constexpr float nexttoward(float __x, long double __y)         {
            return __builtin_nexttowardf(__x, __y);
        }
        constexpr long double nexttoward(long double __x, long double __y)         {
            return __builtin_nexttowardl(__x, __y);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nexttoward(_Tp __x, long double __y)         {
            return __builtin_nexttoward(__x, __y);
        }
        constexpr float remainder(float __x, float __y)         {
            return __builtin_remainderf(__x, __y);
        }
        constexpr long double remainder(long double __x, long double __y)         {
            return __builtin_remainderl(__x, __y);
        }
        template <typename _Tp, typename _Up> constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(_Tp __x, _Up __y)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return remainder(__type(__x), __type(__y));
        }
        inline float remquo(float __x, float __y, int *__pquo)         {
            return __builtin_remquof(__x, __y, __pquo);
        }
        inline long double remquo(long double __x, long double __y, int *__pquo)         {
            return __builtin_remquol(__x, __y, __pquo);
        }
        template <typename _Tp, typename _Up> inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(_Tp __x, _Up __y, int *__pquo)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
            return remquo(__type(__x), __type(__y), __pquo);
        }
        constexpr float rint(float __x)         {
            return __builtin_rintf(__x);
        }
        constexpr long double rint(long double __x)         {
            return __builtin_rintl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type rint(_Tp __x)         {
            return __builtin_rint(__x);
        }
        constexpr float round(float __x)         {
            return __builtin_roundf(__x);
        }
        constexpr long double round(long double __x)         {
            return __builtin_roundl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type round(_Tp __x)         {
            return __builtin_round(__x);
        }
        constexpr float scalbln(float __x, long __ex)         {
            return __builtin_scalblnf(__x, __ex);
        }
        constexpr long double scalbln(long double __x, long __ex)         {
            return __builtin_scalblnl(__x, __ex);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbln(_Tp __x, long __ex)         {
            return __builtin_scalbln(__x, __ex);
        }
        constexpr float scalbn(float __x, int __ex)         {
            return __builtin_scalbnf(__x, __ex);
        }
        constexpr long double scalbn(long double __x, int __ex)         {
            return __builtin_scalbnl(__x, __ex);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbn(_Tp __x, int __ex)         {
            return __builtin_scalbn(__x, __ex);
        }
        constexpr float tgamma(float __x)         {
            return __builtin_tgammaf(__x);
        }
        constexpr long double tgamma(long double __x)         {
            return __builtin_tgammal(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tgamma(_Tp __x)         {
            return __builtin_tgamma(__x);
        }
        constexpr float trunc(float __x)         {
            return __builtin_truncf(__x);
        }
        constexpr long double trunc(long double __x)         {
            return __builtin_truncl(__x);
        }
        template <typename _Tp> constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type trunc(_Tp __x)         {
            return __builtin_trunc(__x);
        }
        template <typename _Tp> inline _Tp __hypot3(_Tp __x, _Tp __y, _Tp __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        template<> inline float __hypot3<float>(float __x, float __y, float __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (float __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        template<> inline double __hypot3<double>(double __x, double __y, double __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (double __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        template<> inline long double __hypot3<long double>(long double __x, long double __y, long double __z)         {
            __x = std::abs(__x);
            __y = std::abs(__y);
            __z = std::abs(__z);
            if (long double __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
                return __a * std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) + (__z / __a) * (__z / __a));
            else
                return {};
        }
        inline float hypot(float __x, float __y, float __z)         {
            return std::__hypot3<float>(__x, __y, __z);
        }
        inline double hypot(double __x, double __y, double __z)         {
            return std::__hypot3<double>(__x, __y, __z);
        }
        inline long double hypot(long double __x, long double __y, long double __z)         {
            return std::__hypot3<long double>(__x, __y, __z);
        }
        template <typename _Tp, typename _Up, typename _Vp> typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type hypot(_Tp __x, _Up __y, _Vp __z)         {
            using __type = typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type;
            return std::__hypot3<__type>(__x, __y, __z);
        }
        template <typename _Fp> constexpr _Fp __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept         {
            if (__a <= 0 && __b >= 0 || __a >= 0 && __b <= 0)
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const _Fp __x = __a + __t * (__b - __a);
            return __t > 1 == __b > __a ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        template<> constexpr float __lerp<float>(float __a, float __b, float __t) noexcept         {
            if (__a <= 0 && __b >= 0 || __a >= 0 && __b <= 0)
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const float __x = __a + __t * (__b - __a);
            return __t > 1 == __b > __a ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        template<> constexpr double __lerp<double>(double __a, double __b, double __t) noexcept         {
            if (__a <= 0 && __b >= 0 || __a >= 0 && __b <= 0)
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const double __x = __a + __t * (__b - __a);
            return __t > 1 == __b > __a ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        template<> constexpr long double __lerp<long double>(long double __a, long double __b, long double __t) noexcept         {
            if (__a <= 0 && __b >= 0 || __a >= 0 && __b <= 0)
                return __t * __b + (1 - __t) * __a;
            if (__t == 1)
                return __b;
            const long double __x = __a + __t * (__b - __a);
            return __t > 1 == __b > __a ? (__b < __x ? __x : __b) : (__b > __x ? __x : __b);
        }
        constexpr float lerp(float __a, float __b, float __t) noexcept         {
            return std::__lerp(__a, __b, __t);
        }
        constexpr double lerp(double __a, double __b, double __t) noexcept         {
            return std::__lerp(__a, __b, __t);
        }
        constexpr long double lerp(long double __a, long double __b, long double __t) noexcept         {
            return std::__lerp(__a, __b, __t);
        }
    }
    namespace std {
        enum float_round_style {
            round_indeterminate = -1,
            round_toward_zero = 0,
            round_to_nearest = 1,
            round_toward_infinity = 2,
            round_toward_neg_infinity = 3
        };
        enum float_denorm_style {
            denorm_indeterminate = -1,
            denorm_absent = 0,
            denorm_present = 1
        };
        struct __numeric_limits_base {
            static constexpr bool is_specialized = false;
            static constexpr int digits = 0;
            static constexpr int digits10 = 0;
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 0;
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = false;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template <typename _Tp> struct numeric_limits : public std::__numeric_limits_base {
            static constexpr _Tp min() noexcept             {
                return _Tp();
            }
            static constexpr _Tp max() noexcept             {
                return _Tp();
            }
            static constexpr _Tp lowest() noexcept             {
                return _Tp();
            }
            static constexpr _Tp epsilon() noexcept             {
                return _Tp();
            }
            static constexpr _Tp round_error() noexcept             {
                return _Tp();
            }
            static constexpr _Tp infinity() noexcept             {
                return _Tp();
            }
            static constexpr _Tp quiet_NaN() noexcept             {
                return _Tp();
            }
            static constexpr _Tp signaling_NaN() noexcept             {
                return _Tp();
            }
            static constexpr _Tp denorm_min() noexcept             {
                return _Tp();
            }
        };
        template <typename _Tp> struct numeric_limits<const _Tp> : public numeric_limits<_Tp> {
        };
        template <typename _Tp> struct numeric_limits<volatile _Tp> : public numeric_limits<_Tp> {
        };
        template <typename _Tp> struct numeric_limits<const volatile _Tp> : public numeric_limits<_Tp> {
        };
        template<> struct numeric_limits<bool> {
            static constexpr bool is_specialized = true;
            static constexpr bool min() noexcept             {
                return false;
            }
            static constexpr bool max() noexcept             {
                return true;
            }
            static constexpr bool lowest() noexcept             {
                return min();
            }
            static constexpr int digits = 1;
            static constexpr int digits10 = 0;
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr bool epsilon() noexcept             {
                return false;
            }
            static constexpr bool round_error() noexcept             {
                return false;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr bool infinity() noexcept             {
                return false;
            }
            static constexpr bool quiet_NaN() noexcept             {
                return false;
            }
            static constexpr bool signaling_NaN() noexcept             {
                return false;
            }
            static constexpr bool denorm_min() noexcept             {
                return false;
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char> {
            static constexpr bool is_specialized = true;
            static constexpr char min() noexcept             {
                return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0);
            }
            static constexpr char max() noexcept             {
                return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0);
            }
            static constexpr char lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char epsilon() noexcept             {
                return 0;
            }
            static constexpr char round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char infinity() noexcept             {
                return char();
            }
            static constexpr char quiet_NaN() noexcept             {
                return char();
            }
            static constexpr char signaling_NaN() noexcept             {
                return char();
            }
            static constexpr char denorm_min() noexcept             {
                return static_cast<char>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<signed char> {
            static constexpr bool is_specialized = true;
            static constexpr signed char min() noexcept             {
                return -127 - 1;
            }
            static constexpr signed char max() noexcept             {
                return 127;
            }
            static constexpr signed char lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
            static constexpr int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr signed char epsilon() noexcept             {
                return 0;
            }
            static constexpr signed char round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr signed char infinity() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr signed char quiet_NaN() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr signed char signaling_NaN() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr signed char denorm_min() noexcept             {
                return static_cast<signed char>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned char> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned char min() noexcept             {
                return 0;
            }
            static constexpr unsigned char max() noexcept             {
                return 127 * 2U + 1;
            }
            static constexpr unsigned char lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned char epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned char round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned char infinity() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr unsigned char quiet_NaN() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr unsigned char signaling_NaN() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr unsigned char denorm_min() noexcept             {
                return static_cast<unsigned char>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<wchar_t> {
            static constexpr bool is_specialized = true;
            static constexpr wchar_t min() noexcept             {
                return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0);
            }
            static constexpr wchar_t max() noexcept             {
                return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0);
            }
            static constexpr wchar_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((wchar_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr wchar_t epsilon() noexcept             {
                return 0;
            }
            static constexpr wchar_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr wchar_t infinity() noexcept             {
                return wchar_t();
            }
            static constexpr wchar_t quiet_NaN() noexcept             {
                return wchar_t();
            }
            static constexpr wchar_t signaling_NaN() noexcept             {
                return wchar_t();
            }
            static constexpr wchar_t denorm_min() noexcept             {
                return wchar_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char8_t> {
            static constexpr bool is_specialized = true;
            static constexpr char8_t min() noexcept             {
                return (((char8_t)(-1) < 0) ? -(((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0) - 1 : (char8_t)0);
            }
            static constexpr char8_t max() noexcept             {
                return (((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0);
            }
            static constexpr char8_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char8_t) * 8 - ((char8_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char8_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char8_t epsilon() noexcept             {
                return 0;
            }
            static constexpr char8_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char8_t infinity() noexcept             {
                return char8_t();
            }
            static constexpr char8_t quiet_NaN() noexcept             {
                return char8_t();
            }
            static constexpr char8_t signaling_NaN() noexcept             {
                return char8_t();
            }
            static constexpr char8_t denorm_min() noexcept             {
                return char8_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char16_t> {
            static constexpr bool is_specialized = true;
            static constexpr char16_t min() noexcept             {
                return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0);
            }
            static constexpr char16_t max() noexcept             {
                return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0);
            }
            static constexpr char16_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char16_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char16_t epsilon() noexcept             {
                return 0;
            }
            static constexpr char16_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char16_t infinity() noexcept             {
                return char16_t();
            }
            static constexpr char16_t quiet_NaN() noexcept             {
                return char16_t();
            }
            static constexpr char16_t signaling_NaN() noexcept             {
                return char16_t();
            }
            static constexpr char16_t denorm_min() noexcept             {
                return char16_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<char32_t> {
            static constexpr bool is_specialized = true;
            static constexpr char32_t min() noexcept             {
                return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0);
            }
            static constexpr char32_t max() noexcept             {
                return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0);
            }
            static constexpr char32_t lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
            static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = ((char32_t)(-1) < 0);
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr char32_t epsilon() noexcept             {
                return 0;
            }
            static constexpr char32_t round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr char32_t infinity() noexcept             {
                return char32_t();
            }
            static constexpr char32_t quiet_NaN() noexcept             {
                return char32_t();
            }
            static constexpr char32_t signaling_NaN() noexcept             {
                return char32_t();
            }
            static constexpr char32_t denorm_min() noexcept             {
                return char32_t();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = !is_signed;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<short> {
            static constexpr bool is_specialized = true;
            static constexpr short min() noexcept             {
                return -32767 - 1;
            }
            static constexpr short max() noexcept             {
                return 32767;
            }
            static constexpr short lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
            static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr short epsilon() noexcept             {
                return 0;
            }
            static constexpr short round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr short infinity() noexcept             {
                return short();
            }
            static constexpr short quiet_NaN() noexcept             {
                return short();
            }
            static constexpr short signaling_NaN() noexcept             {
                return short();
            }
            static constexpr short denorm_min() noexcept             {
                return short();
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned short> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned short min() noexcept             {
                return 0;
            }
            static constexpr unsigned short max() noexcept             {
                return 32767 * 2U + 1;
            }
            static constexpr unsigned short lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned short epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned short round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned short infinity() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr unsigned short quiet_NaN() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr unsigned short signaling_NaN() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr unsigned short denorm_min() noexcept             {
                return static_cast<unsigned short>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<int> {
            static constexpr bool is_specialized = true;
            static constexpr int min() noexcept             {
                return -2147483647 - 1;
            }
            static constexpr int max() noexcept             {
                return 2147483647;
            }
            static constexpr int lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
            static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr int epsilon() noexcept             {
                return 0;
            }
            static constexpr int round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr int infinity() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr int quiet_NaN() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr int signaling_NaN() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr int denorm_min() noexcept             {
                return static_cast<int>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned int> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned int min() noexcept             {
                return 0;
            }
            static constexpr unsigned int max() noexcept             {
                return 2147483647 * 2U + 1;
            }
            static constexpr unsigned int lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned int epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned int round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned int infinity() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr unsigned int quiet_NaN() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr unsigned int signaling_NaN() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr unsigned int denorm_min() noexcept             {
                return static_cast<unsigned int>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<long> {
            static constexpr bool is_specialized = true;
            static constexpr long min() noexcept             {
                return -9223372036854775807L - 1;
            }
            static constexpr long max() noexcept             {
                return 9223372036854775807L;
            }
            static constexpr long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr long epsilon() noexcept             {
                return 0;
            }
            static constexpr long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr long infinity() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr long quiet_NaN() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr long signaling_NaN() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr long denorm_min() noexcept             {
                return static_cast<long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned long> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned long min() noexcept             {
                return 0;
            }
            static constexpr unsigned long max() noexcept             {
                return 9223372036854775807L * 2UL + 1;
            }
            static constexpr unsigned long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned long epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned long infinity() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr unsigned long quiet_NaN() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr unsigned long signaling_NaN() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr unsigned long denorm_min() noexcept             {
                return static_cast<unsigned long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<long long> {
            static constexpr bool is_specialized = true;
            static constexpr long long min() noexcept             {
                return -9223372036854775807LL - 1;
            }
            static constexpr long long max() noexcept             {
                return 9223372036854775807LL;
            }
            static constexpr long long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr long long epsilon() noexcept             {
                return 0;
            }
            static constexpr long long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr long long infinity() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr long long quiet_NaN() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr long long signaling_NaN() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr long long denorm_min() noexcept             {
                return static_cast<long long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned long long> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned long long min() noexcept             {
                return 0;
            }
            static constexpr unsigned long long max() noexcept             {
                return 9223372036854775807LL * 2ULL + 1;
            }
            static constexpr unsigned long long lowest() noexcept             {
                return min();
            }
            static constexpr int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
            static constexpr int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);
            static constexpr int max_digits10 = 0;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned long long epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned long long round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned long long infinity() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr unsigned long long quiet_NaN() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr unsigned long long signaling_NaN() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr unsigned long long denorm_min() noexcept             {
                return static_cast<unsigned long long>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<__int128> {
            static constexpr bool is_specialized = true;
            static constexpr __int128 min() noexcept             {
                return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0);
            }
            static constexpr __int128 max() noexcept             {
                return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0);
            }
            static constexpr int digits = 128 - 1;
            static constexpr int digits10 = (128 - 1) * 643L / 2136;
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr __int128 epsilon() noexcept             {
                return 0;
            }
            static constexpr __int128 round_error() noexcept             {
                return 0;
            }
            static constexpr __int128 lowest() noexcept             {
                return min();
            }
            static constexpr int max_digits10 = 0;
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr __int128 infinity() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr __int128 quiet_NaN() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr __int128 signaling_NaN() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr __int128 denorm_min() noexcept             {
                return static_cast<__int128>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<unsigned __int128> {
            static constexpr bool is_specialized = true;
            static constexpr unsigned __int128 min() noexcept             {
                return 0;
            }
            static constexpr unsigned __int128 max() noexcept             {
                return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0);
            }
            static constexpr unsigned __int128 lowest() noexcept             {
                return min();
            }
            static constexpr int max_digits10 = 0;
            static constexpr int digits = 128;
            static constexpr int digits10 = 128 * 643L / 2136;
            static constexpr bool is_signed = false;
            static constexpr bool is_integer = true;
            static constexpr bool is_exact = true;
            static constexpr int radix = 2;
            static constexpr unsigned __int128 epsilon() noexcept             {
                return 0;
            }
            static constexpr unsigned __int128 round_error() noexcept             {
                return 0;
            }
            static constexpr int min_exponent = 0;
            static constexpr int min_exponent10 = 0;
            static constexpr int max_exponent = 0;
            static constexpr int max_exponent10 = 0;
            static constexpr bool has_infinity = false;
            static constexpr bool has_quiet_NaN = false;
            static constexpr bool has_signaling_NaN = false;
            static constexpr std::float_denorm_style has_denorm = denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr unsigned __int128 infinity() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr unsigned __int128 quiet_NaN() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr unsigned __int128 signaling_NaN() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr unsigned __int128 denorm_min() noexcept             {
                return static_cast<unsigned __int128>(0);
            }
            static constexpr bool is_iec559 = false;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = true;
            static constexpr bool traps = true;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_toward_zero;
        };
        template<> struct numeric_limits<float> {
            static constexpr bool is_specialized = true;
            static constexpr float min() noexcept             {
                return 1.17549435E-38F;
            }
            static constexpr float max() noexcept             {
                return 3.40282347E+38F;
            }
            static constexpr float lowest() noexcept             {
                return -3.40282347E+38F;
            }
            static constexpr int digits = 24;
            static constexpr int digits10 = 6;
            static constexpr int max_digits10 = (2 + (24) * 643L / 2136);
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 2;
            static constexpr float epsilon() noexcept             {
                return 1.1920929E-7F;
            }
            static constexpr float round_error() noexcept             {
                return 0.5F;
            }
            static constexpr int min_exponent = (-125);
            static constexpr int min_exponent10 = (-37);
            static constexpr int max_exponent = 128;
            static constexpr int max_exponent10 = 38;
            static constexpr bool has_infinity = 1;
            static constexpr bool has_quiet_NaN = 1;
            static constexpr bool has_signaling_NaN = has_quiet_NaN;
            static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr float infinity() noexcept             {
                return __builtin_huge_valf();
            }
            static constexpr float quiet_NaN() noexcept             {
                return __builtin_nanf("");
            }
            static constexpr float signaling_NaN() noexcept             {
                return __builtin_nansf("");
            }
            static constexpr float denorm_min() noexcept             {
                return 1.40129846E-45F;
            }
            static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_to_nearest;
        };
        template<> struct numeric_limits<double> {
            static constexpr bool is_specialized = true;
            static constexpr double min() noexcept             {
                return 2.2250738585072014E-308;
            }
            static constexpr double max() noexcept             {
                return 1.7976931348623157E+308;
            }
            static constexpr double lowest() noexcept             {
                return -1.7976931348623157E+308;
            }
            static constexpr int digits = 53;
            static constexpr int digits10 = 15;
            static constexpr int max_digits10 = (2 + (53) * 643L / 2136);
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 2;
            static constexpr double epsilon() noexcept             {
                return 2.2204460492503131E-16;
            }
            static constexpr double round_error() noexcept             {
                return 0.5;
            }
            static constexpr int min_exponent = (-1021);
            static constexpr int min_exponent10 = (-307);
            static constexpr int max_exponent = 1024;
            static constexpr int max_exponent10 = 308;
            static constexpr bool has_infinity = 1;
            static constexpr bool has_quiet_NaN = 1;
            static constexpr bool has_signaling_NaN = has_quiet_NaN;
            static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr double infinity() noexcept             {
                return __builtin_huge_val();
            }
            static constexpr double quiet_NaN() noexcept             {
                return __builtin_nan("");
            }
            static constexpr double signaling_NaN() noexcept             {
                return __builtin_nans("");
            }
            static constexpr double denorm_min() noexcept             {
                return 4.9406564584124654E-324;
            }
            static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_to_nearest;
        };
        template<> struct numeric_limits<long double> {
            static constexpr bool is_specialized = true;
            static constexpr long double min() noexcept             {
                return 3.36210314311209350626E-4932L;
            }
            static constexpr long double max() noexcept             {
                return 1.18973149535723176502E+4932L;
            }
            static constexpr long double lowest() noexcept             {
                return -1.18973149535723176502E+4932L;
            }
            static constexpr int digits = 64;
            static constexpr int digits10 = 18;
            static constexpr int max_digits10 = (2 + (64) * 643L / 2136);
            static constexpr bool is_signed = true;
            static constexpr bool is_integer = false;
            static constexpr bool is_exact = false;
            static constexpr int radix = 2;
            static constexpr long double epsilon() noexcept             {
                return 1.08420217248550443401E-19L;
            }
            static constexpr long double round_error() noexcept             {
                return 0.5L;
            }
            static constexpr int min_exponent = (-16381);
            static constexpr int min_exponent10 = (-4931);
            static constexpr int max_exponent = 16384;
            static constexpr int max_exponent10 = 4932;
            static constexpr bool has_infinity = 1;
            static constexpr bool has_quiet_NaN = 1;
            static constexpr bool has_signaling_NaN = has_quiet_NaN;
            static constexpr std::float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent;
            static constexpr bool has_denorm_loss = false;
            static constexpr long double infinity() noexcept             {
                return __builtin_huge_vall();
            }
            static constexpr long double quiet_NaN() noexcept             {
                return __builtin_nanl("");
            }
            static constexpr long double signaling_NaN() noexcept             {
                return __builtin_nansl("");
            }
            static constexpr long double denorm_min() noexcept             {
                return 3.64519953188247460253E-4951L;
            }
            static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
            static constexpr bool is_bounded = true;
            static constexpr bool is_modulo = false;
            static constexpr bool traps = false;
            static constexpr bool tinyness_before = false;
            static constexpr std::float_round_style round_style = round_to_nearest;
        };
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> struct __floating_point_constant {
                static const _Tp __value;
            };
            template <typename _Tp> struct __numeric_constants {
                static _Tp __pi() throw()                 {
                    return static_cast<_Tp>(3.14159265358979323851L);
                }
                static _Tp __pi_2() throw()                 {
                    return static_cast<_Tp>(1.57079632679489661926L);
                }
                static _Tp __pi_3() throw()                 {
                    return static_cast<_Tp>(1.04719755119659774613L);
                }
                static _Tp __pi_4() throw()                 {
                    return static_cast<_Tp>(0.785398163397448309628L);
                }
                static _Tp __1_pi() throw()                 {
                    return static_cast<_Tp>(0.318309886183790671538L);
                }
                static _Tp __2_sqrtpi() throw()                 {
                    return static_cast<_Tp>(1.12837916709551257385L);
                }
                static _Tp __sqrt2() throw()                 {
                    return static_cast<_Tp>(1.41421356237309504876L);
                }
                static _Tp __sqrt3() throw()                 {
                    return static_cast<_Tp>(1.73205080756887729357L);
                }
                static _Tp __sqrtpio2() throw()                 {
                    return static_cast<_Tp>(1.25331413731550025124L);
                }
                static _Tp __sqrt1_2() throw()                 {
                    return static_cast<_Tp>(0.707106781186547524382L);
                }
                static _Tp __lnpi() throw()                 {
                    return static_cast<_Tp>(1.14472988584940017418L);
                }
                static _Tp __gamma_e() throw()                 {
                    return static_cast<_Tp>(0.577215664901532860616L);
                }
                static _Tp __euler() throw()                 {
                    return static_cast<_Tp>(2.71828182845904523543L);
                }
            };
template<> struct __numeric_constants<float> {
                static float __pi() throw()                 {
                    return static_cast<float>(3.14159265358979323851L);
                }
                static float __pi_2() throw()                 {
                    return static_cast<float>(1.57079632679489661926L);
                }
                static float __pi_3() throw();
                static float __pi_4() throw()                 {
                    return static_cast<float>(0.785398163397448309628L);
                }
                static float __1_pi() throw();
                static float __2_sqrtpi() throw();
                static float __sqrt2() throw();
                static float __sqrt3() throw();
                static float __sqrtpio2() throw()                 {
                    return static_cast<float>(1.25331413731550025124L);
                }
                static float __sqrt1_2() throw();
                static float __lnpi() throw()                 {
                    return static_cast<float>(1.14472988584940017418L);
                }
                static float __gamma_e() throw()                 {
                    return static_cast<float>(0.577215664901532860616L);
                }
                static float __euler() throw();
            };
template<> struct __numeric_constants<long double> {
                static long double __pi() throw()                 {
                    return static_cast<long double>(3.14159265358979323851L);
                }
                static long double __pi_2() throw()                 {
                    return static_cast<long double>(1.57079632679489661926L);
                }
                static long double __pi_3() throw();
                static long double __pi_4() throw()                 {
                    return static_cast<long double>(0.785398163397448309628L);
                }
                static long double __1_pi() throw();
                static long double __2_sqrtpi() throw();
                static long double __sqrt2() throw();
                static long double __sqrt3() throw();
                static long double __sqrtpio2() throw()                 {
                    return static_cast<long double>(1.25331413731550025124L);
                }
                static long double __sqrt1_2() throw();
                static long double __lnpi() throw()                 {
                    return static_cast<long double>(1.14472988584940017418L);
                }
                static long double __gamma_e() throw()                 {
                    return static_cast<long double>(0.577215664901532860616L);
                }
                static long double __euler() throw();
            };
            template <typename _Tp> inline bool __isnan(_Tp __x)             {
                return std::isnan(__x);
            }
            template<> inline bool __isnan<float>(float __x)             {
                return std::isnan(__x);
            }
            template<> inline bool __isnan<long double>(long double __x)             {
                return std::isnan(__x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __bernoulli_series(unsigned int __n)             {
                static const _Tp __num[28] = {_Tp(1UL), - _Tp(1UL) / _Tp(2UL), _Tp(1UL) / _Tp(6UL), _Tp(0UL), - _Tp(1UL) / _Tp(30UL), _Tp(0UL), _Tp(1UL) / _Tp(42UL), _Tp(0UL), - _Tp(1UL) / _Tp(30UL), _Tp(0UL), _Tp(5UL) / _Tp(66UL), _Tp(0UL), - _Tp(691UL) / _Tp(2730UL), _Tp(0UL), _Tp(7UL) / _Tp(6UL), _Tp(0UL), - _Tp(3617UL) / _Tp(510UL), _Tp(0UL), _Tp(43867UL) / _Tp(798UL), _Tp(0UL), - _Tp(174611) / _Tp(330UL), _Tp(0UL), _Tp(854513UL) / _Tp(138UL), _Tp(0UL), - _Tp(236364091UL) / _Tp(2730UL), _Tp(0UL), _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)};
                if (__n == 0)
                    return _Tp(1);
                if (__n == 1)
                    return - _Tp(1) / _Tp(2);
                if (__n % 2 == 1)
                    return _Tp(0);
                if (__n < 28)
                    return __num[__n];
                _Tp __fact = _Tp(1);
                if ((__n / 2) % 2 == 0)
                    __fact *= _Tp(-1);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
                __fact *= _Tp(2);
                _Tp __sum = _Tp(0);
                for (unsigned int __i = 1; __i < 1000; ++__i) {
                    _Tp __term = std::pow(_Tp(__i), - _Tp(__n));
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term;
                }
                return __fact * __sum;
            }
            template <typename _Tp> inline _Tp __bernoulli(int __n)             {
                return __bernoulli_series<_Tp>(__n);
            }
            template <typename _Tp> _Tp __log_gamma_bernoulli(_Tp __x)             {
                _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x + _Tp(0.5L) * std::log(_Tp(2) * __numeric_constants<_Tp>::__pi());
                const _Tp __xx = __x * __x;
                _Tp __help = _Tp(1) / __x;
                for (unsigned int __i = 1; __i < 20; ++__i) {
                    const _Tp __2i = _Tp(2 * __i);
                    __help /= __2i * (__2i - _Tp(1)) * __xx;
                    __lg += __bernoulli<_Tp>(2 * __i) * __help;
                }
                return __lg;
            }
            template <typename _Tp> _Tp __log_gamma_lanczos(_Tp __x)             {
                const _Tp __xm1 = __x - _Tp(1);
                static const _Tp __lanczos_cheb_7[9] = {_Tp(0.999999999999809932257L), _Tp(676.520368121885098567L), _Tp(-1259.13921672240287042L), _Tp(771.323428777653078869L), _Tp(-176.615029162140599064L), _Tp(12.5073432786869048142L), _Tp(-0.138571095265720116896L), _Tp(9.98436957801957085945E-6L), _Tp(1.5056327351493115584E-7L)};
                static const _Tp __LOGROOT2PI = _Tp(0.918938533204672741803L);
                _Tp __sum = __lanczos_cheb_7[0];
                for (unsigned int __k = 1; __k < 9; ++__k)
                    __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);
                const _Tp __term1 = (__xm1 + _Tp(0.5L)) * std::log((__xm1 + _Tp(7.5L)) / __numeric_constants<_Tp>::__euler());
                const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
                const _Tp __result = __term1 + (__term2 - _Tp(7));
                return __result;
            }
            template <typename _Tp> _Tp __log_gamma(_Tp __x)             {
                if (__x > _Tp(0.5L))
                    return __log_gamma_lanczos(__x);
                else {
                    const _Tp __sin_fact = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
                    if (__sin_fact == _Tp(0))
                        std::__throw_domain_error(("Argument is nonpositive integer in __log_gamma"));
                    return __numeric_constants<_Tp>::__lnpi() - std::log(__sin_fact) - __log_gamma_lanczos(_Tp(1) - __x);
                }
            }
            template <typename _Tp> _Tp __log_gamma_sign(_Tp __x)             {
                if (__x > _Tp(0))
                    return _Tp(1);
                else {
                    const _Tp __sin_fact = std::sin(__numeric_constants<_Tp>::__pi() * __x);
                    if (__sin_fact > _Tp(0))
                        return (1);
                    else if (__sin_fact < _Tp(0))
                        return - _Tp(1);
                    else
                        return _Tp(0);
                }
            }
            template <typename _Tp> _Tp __log_bincoef(unsigned int __n, unsigned int __k)             {
                static const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                _Tp __coeff = ::std::lgamma(_Tp(1 + __n)) - ::std::lgamma(_Tp(1 + __k)) - ::std::lgamma(_Tp(1 + __n - __k));
            }
            template <typename _Tp> _Tp __bincoef(unsigned int __n, unsigned int __k)             {
                static const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
                if (__log_coeff > __max_bincoeff)
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return std::exp(__log_coeff);
            }
            template <typename _Tp> inline _Tp __gamma(_Tp __x)             {
                return std::exp(__log_gamma(__x));
            }
            template <typename _Tp> _Tp __psi_series(_Tp __x)             {
                _Tp __sum = - __numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
                const unsigned int __max_iter = 100000;
                for (unsigned int __k = 1; __k < __max_iter; ++__k) {
                    const _Tp __term = __x / (__k * (__k + __x));
                    __sum += __term;
                    if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
                        break;
                }
                return __sum;
            }
            template <typename _Tp> _Tp __psi_asymp(_Tp __x)             {
                _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
                const _Tp __xx = __x * __x;
                _Tp __xp = __xx;
                const unsigned int __max_iter = 100;
                for (unsigned int __k = 1; __k < __max_iter; ++__k) {
                    const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
                    __sum -= __term;
                    if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __xp *= __xx;
                }
                return __sum;
            }
            template <typename _Tp> _Tp __psi(_Tp __x)             {
                const int __n = static_cast<int>(__x + 0.5L);
                const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
                if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x < _Tp(0)) {
                    const _Tp __pi = __numeric_constants<_Tp>::__pi();
                    return __psi(_Tp(1) - __x) - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
                } else if (__x > _Tp(100))
                    return __psi_asymp(__x);
                else
                    return __psi_series(__x);
            }
            template <typename _Tp> _Tp __psi(unsigned int __n, _Tp __x)             {
                if (__x <= _Tp(0))
                    std::__throw_domain_error(("Argument out of range in __psi"));
                else if (__n == 0)
                    return __psi(__x);
                else {
                    const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);
                    const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));
                    _Tp __result = std::exp(__ln_nfact) * __hzeta;
                    if (__n % 2 == 1)
                        __result = - __result;
                    return __result;
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> void __gamma_temme(_Tp __mu, _Tp &__gam1, _Tp &__gam2, _Tp &__gampl, _Tp &__gammi)             {
                __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
                __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);
                if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
                    __gam1 = - _Tp(__numeric_constants<_Tp>::__gamma_e());
                else
                    __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);
                __gam2 = (__gammi + __gampl) / (_Tp(2));
                return;
            }
            template<> void __gamma_temme<float>(float __mu, float &__gam1, float &__gam2, float &__gampl, float &__gammi)             {
                __gampl = float(1) / ::std::tgamma(float(1) + __mu);
                __gammi = float(1) / ::std::tgamma(float(1) - __mu);
                if (std::abs(__mu) < std::numeric_limits<float>::epsilon())
                    __gam1 = -float(__numeric_constants<float>::__gamma_e());
                else
                    __gam1 = (__gammi - __gampl) / (float(2) * __mu);
                __gam2 = (__gammi + __gampl) / (float(2));
                return;
            }
            template<> void __gamma_temme<long double>(long double __mu, long double &__gam1, long double &__gam2, long double &__gampl, long double &__gammi)             {
                __gampl = long double(1) / ::std::tgamma(long double(1) + __mu);
                __gammi = long double(1) / ::std::tgamma(long double(1) - __mu);
                if (std::abs(__mu) < std::numeric_limits<long double>::epsilon())
                    __gam1 = -long double(__numeric_constants<long double>::__gamma_e());
                else
                    __gam1 = (__gammi - __gampl) / (long double(2) * __mu);
                __gam2 = (__gammi + __gampl) / (long double(2));
                return;
            }
            template <typename _Tp> void __bessel_jn(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu, _Tp &__Jpnu, _Tp &__Npnu)             {
                if (__x == _Tp(0)) {
                    if (__nu == _Tp(0)) {
                        __Jnu = _Tp(1);
                        __Jpnu = _Tp(0);
                    } else if (__nu == _Tp(1)) {
                        __Jnu = _Tp(0);
                        __Jpnu = _Tp(0.5L);
                    } else {
                        __Jnu = _Tp(0);
                        __Jpnu = _Tp(0);
                    }
                    __Nnu = - std::numeric_limits<_Tp>::infinity();
                    __Npnu = std::numeric_limits<_Tp>::infinity();
                    return;
                }
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
                const int __max_iter = 15000;
                const _Tp __x_min = _Tp(2);
                const int __nl = (__x < __x_min ? static_cast<int>(__nu + _Tp(0.5L)) : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));
                const _Tp __mu = __nu - __nl;
                const _Tp __mu2 = __mu * __mu;
                const _Tp __xi = _Tp(1) / __x;
                const _Tp __xi2 = _Tp(2) * __xi;
                _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
                int __isign = 1;
                _Tp __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                _Tp __b = __xi2 * __nu;
                _Tp __d = _Tp(0);
                _Tp __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = __b - __d;
                    if (std::abs(__d) < __fp_min)
                        __d = __fp_min;
                    __c = __b - _Tp(1) / __c;
                    if (std::abs(__c) < __fp_min)
                        __c = __fp_min;
                    __d = _Tp(1) / __d;
                    const _Tp __del = __c * __d;
                    __h *= __del;
                    if (__d < _Tp(0))
                        __isign = -__isign;
                    if (std::abs(__del - _Tp(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_jn; try asymptotic expansion."));
                _Tp __Jnul = __isign * __fp_min;
                _Tp __Jpnul = __h * __Jnul;
                _Tp __Jnul1 = __Jnul;
                _Tp __Jpnu1 = __Jpnul;
                _Tp __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
                    __fact -= __xi;
                    __Jpnul = __fact * __Jnutemp - __Jnul;
                    __Jnul = __Jnutemp;
                }
                if (__Jnul == _Tp(0))
                    __Jnul = __eps;
                _Tp __f = __Jpnul / __Jnul;
                _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
                if (__x < __x_min) {
                    const _Tp __x2 = __x / _Tp(2);
                    const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
                    _Tp __fact = (std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
                    _Tp __d = - std::log(__x2);
                    _Tp __e = __mu * __d;
                    _Tp __fact2 = (std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
                    _Tp __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi()) * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    __e = std::exp(__e);
                    _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
                    _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
                    const _Tp __pimu2 = __pimu / _Tp(2);
                    _Tp __fact3 = (std::abs(__pimu2) < __eps ? _Tp(1) : std::sin(__pimu2) / __pimu2);
                    _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
                    _Tp __c = _Tp(1);
                    __d = - __x2 * __x2;
                    _Tp __sum = __ff + __r * __q;
                    _Tp __sum1 = __p;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / _Tp(__i);
                        __p /= _Tp(__i) - __mu;
                        __q /= _Tp(__i) + __mu;
                        const _Tp __del = __c * (__ff + __r * __q);
                        __sum += __del;
                        const _Tp __del1 = __c * __p - __i * __del;
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel y series failed to converge in __bessel_jn."));
                    __Nmu = - __sum;
                    __Nnu1 = - __sum1 * __xi2;
                    __Npmu = __mu * __xi * __Nmu - __Nnu1;
                    __Jmu = __w / (__Npmu - __f * __Nmu);
                } else {
                    _Tp __a = _Tp(0.25L) - __mu2;
                    _Tp __q = _Tp(1);
                    _Tp __p = - __xi / _Tp(2);
                    _Tp __br = _Tp(2) * __x;
                    _Tp __bi = _Tp(2);
                    _Tp __fact = __a * __xi / (__p * __p + __q * __q);
                    _Tp __cr = __br + __q * __fact;
                    _Tp __ci = __bi + __p * __fact;
                    _Tp __den = __br * __br + __bi * __bi;
                    _Tp __dr = __br / __den;
                    _Tp __di = - __bi / __den;
                    _Tp __dlr = __cr * __dr - __ci * __di;
                    _Tp __dli = __cr * __di + __ci * __dr;
                    _Tp __temp = __p * __dlr - __q * __dli;
                    __q = __p * __dli + __q * __dlr;
                    __p = __temp;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a += _Tp(2 * (__i - 1));
                        __bi += _Tp(2);
                        __dr = __a * __dr + __br;
                        __di = __a * __di + __bi;
                        if (std::abs(__dr) + std::abs(__di) < __fp_min)
                            __dr = __fp_min;
                        __fact = __a / (__cr * __cr + __ci * __ci);
                        __cr = __br + __cr * __fact;
                        __ci = __bi - __ci * __fact;
                        if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                            __cr = __fp_min;
                        __den = __dr * __dr + __di * __di;
                        __dr /= __den;
                        __di /= - __den;
                        __dlr = __cr * __dr - __ci * __di;
                        __dli = __cr * __di + __ci * __dr;
                        __temp = __p * __dlr - __q * __dli;
                        __q = __p * __dli + __q * __dlr;
                        __p = __temp;
                        if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Lentz's method failed in __bessel_jn."));
                    const _Tp __gam = (__p - __f) / __q;
                    __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));
                    __Jmu = ::std::copysign(__Jmu, __Jnul);
                    __Nmu = __gam * __Jmu;
                    __Npmu = (__p + __q / __gam) * __Nmu;
                    __Nnu1 = __mu * __xi * __Nmu - __Npmu;
                }
                __fact = __Jmu / __Jnul;
                __Jnu = __fact * __Jnul1;
                __Jpnu = __fact * __Jpnu1;
                for (__i = 1; __i <= __nl; ++__i) {
                    const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
                    __Nmu = __Nnu1;
                    __Nnu1 = __Nnutemp;
                }
                __Nnu = __Nmu;
                __Npnu = __nu * __xi * __Nmu - __Nnu1;
                return;
            }
            template<> void __bessel_jn<float>(float __nu, float __x, float &__Jnu, float &__Nnu, float &__Jpnu, float &__Npnu)             {
                if (__x == float(0)) {
                    if (__nu == float(0)) {
                        __Jnu = float(1);
                        __Jpnu = float(0);
                    } else if (__nu == float(1)) {
                        __Jnu = float(0);
                        __Jpnu = float(0.5L);
                    } else {
                        __Jnu = float(0);
                        __Jpnu = float(0);
                    }
                    __Nnu = -std::numeric_limits<float>::infinity();
                    __Npnu = std::numeric_limits<float>::infinity();
                    return;
                }
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __fp_min = std::sqrt(std::numeric_limits<float>::min());
                const int __max_iter = 15000;
                const float __x_min = float(2);
                const int __nl = (__x < __x_min ? static_cast<int>(__nu + float(0.5L)) : std::max(0, static_cast<int>(__nu - __x + float(1.5L))));
                const float __mu = __nu - __nl;
                const float __mu2 = __mu * __mu;
                const float __xi = float(1) / __x;
                const float __xi2 = float(2) * __xi;
                float __w = __xi2 / __numeric_constants<float>::__pi();
                int __isign = 1;
                float __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                float __b = __xi2 * __nu;
                float __d = float(0);
                float __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = __b - __d;
                    if (std::abs(__d) < __fp_min)
                        __d = __fp_min;
                    __c = __b - float(1) / __c;
                    if (std::abs(__c) < __fp_min)
                        __c = __fp_min;
                    __d = float(1) / __d;
                    const float __del = __c * __d;
                    __h *= __del;
                    if (__d < float(0))
                        __isign = -__isign;
                    if (std::abs(__del - float(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_jn; try asymptotic expansion."));
                float __Jnul = __isign * __fp_min;
                float __Jpnul = __h * __Jnul;
                float __Jnul1 = __Jnul;
                float __Jpnu1 = __Jpnul;
                float __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const float __Jnutemp = __fact * __Jnul + __Jpnul;
                    __fact -= __xi;
                    __Jpnul = __fact * __Jnutemp - __Jnul;
                    __Jnul = __Jnutemp;
                }
                if (__Jnul == float(0))
                    __Jnul = __eps;
                float __f = __Jpnul / __Jnul;
                float __Nmu, __Nnu1, __Npmu, __Jmu;
                if (__x < __x_min) {
                    const float __x2 = __x / float(2);
                    const float __pimu = __numeric_constants<float>::__pi() * __mu;
                    float __fact = (std::abs(__pimu) < __eps ? float(1) : __pimu / std::sin(__pimu));
                    float __d = -std::log(__x2);
                    float __e = __mu * __d;
                    float __fact2 = (std::abs(__e) < __eps ? float(1) : std::sinh(__e) / __e);
                    float __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    float __ff = (float(2) / __numeric_constants<float>::__pi()) * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    __e = std::exp(__e);
                    float __p = __e / (__numeric_constants<float>::__pi() * __gampl);
                    float __q = float(1) / (__e * __numeric_constants<float>::__pi() * __gammi);
                    const float __pimu2 = __pimu / float(2);
                    float __fact3 = (std::abs(__pimu2) < __eps ? float(1) : std::sin(__pimu2) / __pimu2);
                    float __r = __numeric_constants<float>::__pi() * __pimu2 * __fact3 * __fact3;
                    float __c = float(1);
                    __d = -__x2 * __x2;
                    float __sum = __ff + __r * __q;
                    float __sum1 = __p;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / float(__i);
                        __p /= float(__i) - __mu;
                        __q /= float(__i) + __mu;
                        const float __del = __c * (__ff + __r * __q);
                        __sum += __del;
                        const float __del1 = __c * __p - __i * __del;
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * (float(1) + std::abs(__sum)))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel y series failed to converge in __bessel_jn."));
                    __Nmu = -__sum;
                    __Nnu1 = -__sum1 * __xi2;
                    __Npmu = __mu * __xi * __Nmu - __Nnu1;
                    __Jmu = __w / (__Npmu - __f * __Nmu);
                } else {
                    float __a = float(0.25L) - __mu2;
                    float __q = float(1);
                    float __p = -__xi / float(2);
                    float __br = float(2) * __x;
                    float __bi = float(2);
                    float __fact = __a * __xi / (__p * __p + __q * __q);
                    float __cr = __br + __q * __fact;
                    float __ci = __bi + __p * __fact;
                    float __den = __br * __br + __bi * __bi;
                    float __dr = __br / __den;
                    float __di = -__bi / __den;
                    float __dlr = __cr * __dr - __ci * __di;
                    float __dli = __cr * __di + __ci * __dr;
                    float __temp = __p * __dlr - __q * __dli;
                    __q = __p * __dli + __q * __dlr;
                    __p = __temp;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a += float(2 * (__i - 1));
                        __bi += float(2);
                        __dr = __a * __dr + __br;
                        __di = __a * __di + __bi;
                        if (std::abs(__dr) + std::abs(__di) < __fp_min)
                            __dr = __fp_min;
                        __fact = __a / (__cr * __cr + __ci * __ci);
                        __cr = __br + __cr * __fact;
                        __ci = __bi - __ci * __fact;
                        if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                            __cr = __fp_min;
                        __den = __dr * __dr + __di * __di;
                        __dr /= __den;
                        __di /= -__den;
                        __dlr = __cr * __dr - __ci * __di;
                        __dli = __cr * __di + __ci * __dr;
                        __temp = __p * __dlr - __q * __dli;
                        __q = __p * __dli + __q * __dlr;
                        __p = __temp;
                        if (std::abs(__dlr - float(1)) + std::abs(__dli) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Lentz's method failed in __bessel_jn."));
                    const float __gam = (__p - __f) / __q;
                    __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));
                    __Jmu = ::std::copysign(__Jmu, __Jnul);
                    __Nmu = __gam * __Jmu;
                    __Npmu = (__p + __q / __gam) * __Nmu;
                    __Nnu1 = __mu * __xi * __Nmu - __Npmu;
                }
                __fact = __Jmu / __Jnul;
                __Jnu = __fact * __Jnul1;
                __Jpnu = __fact * __Jpnu1;
                for (__i = 1; __i <= __nl; ++__i) {
                    const float __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
                    __Nmu = __Nnu1;
                    __Nnu1 = __Nnutemp;
                }
                __Nnu = __Nmu;
                __Npnu = __nu * __xi * __Nmu - __Nnu1;
                return;
            }
            template<> void __bessel_jn<long double>(long double __nu, long double __x, long double &__Jnu, long double &__Nnu, long double &__Jpnu, long double &__Npnu)             {
                if (__x == long double(0)) {
                    if (__nu == long double(0)) {
                        __Jnu = long double(1);
                        __Jpnu = long double(0);
                    } else if (__nu == long double(1)) {
                        __Jnu = long double(0);
                        __Jpnu = long double(0.5L);
                    } else {
                        __Jnu = long double(0);
                        __Jpnu = long double(0);
                    }
                    __Nnu = -std::numeric_limits<long double>::infinity();
                    __Npnu = std::numeric_limits<long double>::infinity();
                    return;
                }
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __fp_min = std::sqrt(std::numeric_limits<long double>::min());
                const int __max_iter = 15000;
                const long double __x_min = long double(2);
                const int __nl = (__x < __x_min ? static_cast<int>(__nu + long double(0.5L)) : std::max(0, static_cast<int>(__nu - __x + long double(1.5L))));
                const long double __mu = __nu - __nl;
                const long double __mu2 = __mu * __mu;
                const long double __xi = long double(1) / __x;
                const long double __xi2 = long double(2) * __xi;
                long double __w = __xi2 / __numeric_constants<long double>::__pi();
                int __isign = 1;
                long double __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                long double __b = __xi2 * __nu;
                long double __d = long double(0);
                long double __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = __b - __d;
                    if (std::abs(__d) < __fp_min)
                        __d = __fp_min;
                    __c = __b - long double(1) / __c;
                    if (std::abs(__c) < __fp_min)
                        __c = __fp_min;
                    __d = long double(1) / __d;
                    const long double __del = __c * __d;
                    __h *= __del;
                    if (__d < long double(0))
                        __isign = -__isign;
                    if (std::abs(__del - long double(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_jn; try asymptotic expansion."));
                long double __Jnul = __isign * __fp_min;
                long double __Jpnul = __h * __Jnul;
                long double __Jnul1 = __Jnul;
                long double __Jpnu1 = __Jpnul;
                long double __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const long double __Jnutemp = __fact * __Jnul + __Jpnul;
                    __fact -= __xi;
                    __Jpnul = __fact * __Jnutemp - __Jnul;
                    __Jnul = __Jnutemp;
                }
                if (__Jnul == long double(0))
                    __Jnul = __eps;
                long double __f = __Jpnul / __Jnul;
                long double __Nmu, __Nnu1, __Npmu, __Jmu;
                if (__x < __x_min) {
                    const long double __x2 = __x / long double(2);
                    const long double __pimu = __numeric_constants<long double>::__pi() * __mu;
                    long double __fact = (std::abs(__pimu) < __eps ? long double(1) : __pimu / std::sin(__pimu));
                    long double __d = -std::log(__x2);
                    long double __e = __mu * __d;
                    long double __fact2 = (std::abs(__e) < __eps ? long double(1) : std::sinh(__e) / __e);
                    long double __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    long double __ff = (long double(2) / __numeric_constants<long double>::__pi()) * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    __e = std::exp(__e);
                    long double __p = __e / (__numeric_constants<long double>::__pi() * __gampl);
                    long double __q = long double(1) / (__e * __numeric_constants<long double>::__pi() * __gammi);
                    const long double __pimu2 = __pimu / long double(2);
                    long double __fact3 = (std::abs(__pimu2) < __eps ? long double(1) : std::sin(__pimu2) / __pimu2);
                    long double __r = __numeric_constants<long double>::__pi() * __pimu2 * __fact3 * __fact3;
                    long double __c = long double(1);
                    __d = -__x2 * __x2;
                    long double __sum = __ff + __r * __q;
                    long double __sum1 = __p;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / long double(__i);
                        __p /= long double(__i) - __mu;
                        __q /= long double(__i) + __mu;
                        const long double __del = __c * (__ff + __r * __q);
                        __sum += __del;
                        const long double __del1 = __c * __p - __i * __del;
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * (long double(1) + std::abs(__sum)))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel y series failed to converge in __bessel_jn."));
                    __Nmu = -__sum;
                    __Nnu1 = -__sum1 * __xi2;
                    __Npmu = __mu * __xi * __Nmu - __Nnu1;
                    __Jmu = __w / (__Npmu - __f * __Nmu);
                } else {
                    long double __a = long double(0.25L) - __mu2;
                    long double __q = long double(1);
                    long double __p = -__xi / long double(2);
                    long double __br = long double(2) * __x;
                    long double __bi = long double(2);
                    long double __fact = __a * __xi / (__p * __p + __q * __q);
                    long double __cr = __br + __q * __fact;
                    long double __ci = __bi + __p * __fact;
                    long double __den = __br * __br + __bi * __bi;
                    long double __dr = __br / __den;
                    long double __di = -__bi / __den;
                    long double __dlr = __cr * __dr - __ci * __di;
                    long double __dli = __cr * __di + __ci * __dr;
                    long double __temp = __p * __dlr - __q * __dli;
                    __q = __p * __dli + __q * __dlr;
                    __p = __temp;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a += long double(2 * (__i - 1));
                        __bi += long double(2);
                        __dr = __a * __dr + __br;
                        __di = __a * __di + __bi;
                        if (std::abs(__dr) + std::abs(__di) < __fp_min)
                            __dr = __fp_min;
                        __fact = __a / (__cr * __cr + __ci * __ci);
                        __cr = __br + __cr * __fact;
                        __ci = __bi - __ci * __fact;
                        if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                            __cr = __fp_min;
                        __den = __dr * __dr + __di * __di;
                        __dr /= __den;
                        __di /= -__den;
                        __dlr = __cr * __dr - __ci * __di;
                        __dli = __cr * __di + __ci * __dr;
                        __temp = __p * __dlr - __q * __dli;
                        __q = __p * __dli + __q * __dlr;
                        __p = __temp;
                        if (std::abs(__dlr - long double(1)) + std::abs(__dli) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Lentz's method failed in __bessel_jn."));
                    const long double __gam = (__p - __f) / __q;
                    __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));
                    __Jmu = ::std::copysign(__Jmu, __Jnul);
                    __Nmu = __gam * __Jmu;
                    __Npmu = (__p + __q / __gam) * __Nmu;
                    __Nnu1 = __mu * __xi * __Nmu - __Npmu;
                }
                __fact = __Jmu / __Jnul;
                __Jnu = __fact * __Jnul1;
                __Jpnu = __fact * __Jpnu1;
                for (__i = 1; __i <= __nl; ++__i) {
                    const long double __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
                    __Nmu = __Nnu1;
                    __Nnu1 = __Nnutemp;
                }
                __Nnu = __Nmu;
                __Npnu = __nu * __xi * __Nmu - __Nnu1;
                return;
            }
            template <typename _Tp> void __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu)             {
                const _Tp __mu = _Tp(4) * __nu * __nu;
                const _Tp __8x = _Tp(8) * __x;
                _Tp __P = _Tp(0);
                _Tp __Q = _Tp(0);
                _Tp __k = _Tp(0);
                _Tp __term = _Tp(1);
                int __epsP = 0;
                int __epsQ = 0;
                _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                do {
                    __term *= (__k == 0 ? _Tp(1) : - (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));
                    __epsP = std::abs(__term) < __eps * std::abs(__P);
                    __P += __term;
                    __k++;
                    __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
                    __epsQ = std::abs(__term) < __eps * std::abs(__Q);
                    __Q += __term;
                    if (__epsP && __epsQ && __k > (__nu / 2.))
                        break;
                    __k++;
                } while (__k < 1000);
                const _Tp __chi = __x - (__nu + _Tp(0.5L)) * __numeric_constants<_Tp>::__pi_2();
                const _Tp __c = std::cos(__chi);
                const _Tp __s = std::sin(__chi);
                const _Tp __coef = std::sqrt(_Tp(2) / (__numeric_constants<_Tp>::__pi() * __x));
                __Jnu = __coef * (__c * __P - __s * __Q);
                __Nnu = __coef * (__s * __P + __c * __Q);
                return;
            }
            template<> void __cyl_bessel_jn_asymp<float>(float __nu, float __x, float &__Jnu, float &__Nnu)             {
                const float __mu = float(4) * __nu * __nu;
                const float __8x = float(8) * __x;
                float __P = float(0);
                float __Q = float(0);
                float __k = float(0);
                float __term = float(1);
                int __epsP = 0;
                int __epsQ = 0;
                float __eps = std::numeric_limits<float>::epsilon();
                do {
                    __term *= (__k == 0 ? float(1) : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));
                    __epsP = std::abs(__term) < __eps * std::abs(__P);
                    __P += __term;
                    __k++;
                    __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
                    __epsQ = std::abs(__term) < __eps * std::abs(__Q);
                    __Q += __term;
                    if (__epsP && __epsQ && __k > (__nu / 2.))
                        break;
                    __k++;
                } while (__k < 1000);
                const float __chi = __x - (__nu + float(0.5L)) * __numeric_constants<float>::__pi_2();
                const float __c = std::cos(__chi);
                const float __s = std::sin(__chi);
                const float __coef = std::sqrt(float(2) / (__numeric_constants<float>::__pi() * __x));
                __Jnu = __coef * (__c * __P - __s * __Q);
                __Nnu = __coef * (__s * __P + __c * __Q);
                return;
            }
            template<> void __cyl_bessel_jn_asymp<long double>(long double __nu, long double __x, long double &__Jnu, long double &__Nnu)             {
                const long double __mu = long double(4) * __nu * __nu;
                const long double __8x = long double(8) * __x;
                long double __P = long double(0);
                long double __Q = long double(0);
                long double __k = long double(0);
                long double __term = long double(1);
                int __epsP = 0;
                int __epsQ = 0;
                long double __eps = std::numeric_limits<long double>::epsilon();
                do {
                    __term *= (__k == 0 ? long double(1) : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));
                    __epsP = std::abs(__term) < __eps * std::abs(__P);
                    __P += __term;
                    __k++;
                    __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
                    __epsQ = std::abs(__term) < __eps * std::abs(__Q);
                    __Q += __term;
                    if (__epsP && __epsQ && __k > (__nu / 2.))
                        break;
                    __k++;
                } while (__k < 1000);
                const long double __chi = __x - (__nu + long double(0.5L)) * __numeric_constants<long double>::__pi_2();
                const long double __c = std::cos(__chi);
                const long double __s = std::sin(__chi);
                const long double __coef = std::sqrt(long double(2) / (__numeric_constants<long double>::__pi() * __x));
                __Jnu = __coef * (__c * __P - __s * __Q);
                __Nnu = __coef * (__s * __P + __c * __Q);
                return;
            }
            template <typename _Tp> _Tp __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn, unsigned int __max_iter)             {
                if (__x == _Tp(0))
                    return __nu == _Tp(0) ? _Tp(1) : _Tp(0);
                const _Tp __x2 = __x / _Tp(2);
                _Tp __fact = __nu * std::log(__x2);
                __fact -= ::std::lgamma(__nu + _Tp(1));
                __fact = std::exp(__fact);
                const _Tp __xx4 = __sgn * __x2 * __x2;
                _Tp __Jn = _Tp(1);
                _Tp __term = _Tp(1);
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
                    __Jn += __term;
                    if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
                        break;
                }
                return __fact * __Jn;
            }
            template<> float __cyl_bessel_ij_series<float>(float __nu, float __x, float __sgn, unsigned int __max_iter)             {
                if (__x == float(0))
                    return __nu == float(0) ? float(1) : float(0);
                const float __x2 = __x / float(2);
                float __fact = __nu * std::log(__x2);
                __fact -= ::std::lgamma(__nu + float(1));
                __fact = std::exp(__fact);
                const float __xx4 = __sgn * __x2 * __x2;
                float __Jn = float(1);
                float __term = float(1);
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __xx4 / (float(__i) * (__nu + float(__i)));
                    __Jn += __term;
                    if (std::abs(__term / __Jn) < std::numeric_limits<float>::epsilon())
                        break;
                }
                return __fact * __Jn;
            }
            template<> long double __cyl_bessel_ij_series<long double>(long double __nu, long double __x, long double __sgn, unsigned int __max_iter)             {
                if (__x == long double(0))
                    return __nu == long double(0) ? long double(1) : long double(0);
                const long double __x2 = __x / long double(2);
                long double __fact = __nu * std::log(__x2);
                __fact -= ::std::lgamma(__nu + long double(1));
                __fact = std::exp(__fact);
                const long double __xx4 = __sgn * __x2 * __x2;
                long double __Jn = long double(1);
                long double __term = long double(1);
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __xx4 / (long double(__i) * (__nu + long double(__i)));
                    __Jn += __term;
                    if (std::abs(__term / __Jn) < std::numeric_limits<long double>::epsilon())
                        break;
                }
                return __fact * __Jn;
            }
            template <typename _Tp> _Tp __cyl_bessel_j(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_j."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
                    return __cyl_bessel_ij_series(__nu, __x, - _Tp(1), 200);
                else if (__x > _Tp(1000)) {
                    _Tp __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __J_nu;
                } else {
                    _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __J_nu;
                }
            }
            template<> float __cyl_bessel_j<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_j."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x * __x < float(10) * (__nu + float(1)))
                    return __cyl_bessel_ij_series(__nu, __x, -float(1), 200);
                else if (__x > float(1000)) {
                    float __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __J_nu;
                } else {
                    float __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __J_nu;
                }
            }
            template<> long double __cyl_bessel_j<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_j."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x * __x < long double(10) * (__nu + long double(1)))
                    return __cyl_bessel_ij_series(__nu, __x, -long double(1), 200);
                else if (__x > long double(1000)) {
                    long double __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __J_nu;
                } else {
                    long double __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __J_nu;
                }
            }
            template <typename _Tp> _Tp __cyl_neumann_n(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_neumann_n."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x > _Tp(1000)) {
                    _Tp __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __N_nu;
                } else {
                    _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __N_nu;
                }
            }
            template<> float __cyl_neumann_n<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_neumann_n."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x > float(1000)) {
                    float __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __N_nu;
                } else {
                    float __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __N_nu;
                }
            }
            template<> long double __cyl_neumann_n<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_neumann_n."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x > long double(1000)) {
                    long double __J_nu, __N_nu;
                    __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
                    return __N_nu;
                } else {
                    long double __J_nu, __N_nu, __Jp_nu, __Np_nu;
                    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    return __N_nu;
                }
            }
            template <typename _Tp> void __sph_bessel_jn(unsigned int __n, _Tp __x, _Tp &__j_n, _Tp &__n_n, _Tp &__jp_n, _Tp &__np_n)             {
                const _Tp __nu = _Tp(__n) + _Tp(0.5L);
                _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
                __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);
                __j_n = __factor * __J_nu;
                __n_n = __factor * __N_nu;
                __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
                __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);
                return;
            }
            template<> void __sph_bessel_jn<float>(unsigned int __n, float __x, float &__j_n, float &__n_n, float &__jp_n, float &__np_n)             {
                const float __nu = float(__n) + float(0.5L);
                float __J_nu, __N_nu, __Jp_nu, __Np_nu;
                __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                const float __factor = __numeric_constants<float>::__sqrtpio2() / std::sqrt(__x);
                __j_n = __factor * __J_nu;
                __n_n = __factor * __N_nu;
                __jp_n = __factor * __Jp_nu - __j_n / (float(2) * __x);
                __np_n = __factor * __Np_nu - __n_n / (float(2) * __x);
                return;
            }
            template<> void __sph_bessel_jn<long double>(unsigned int __n, long double __x, long double &__j_n, long double &__n_n, long double &__jp_n, long double &__np_n)             {
                const long double __nu = long double(__n) + long double(0.5L);
                long double __J_nu, __N_nu, __Jp_nu, __Np_nu;
                __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                const long double __factor = __numeric_constants<long double>::__sqrtpio2() / std::sqrt(__x);
                __j_n = __factor * __J_nu;
                __n_n = __factor * __N_nu;
                __jp_n = __factor * __Jp_nu - __j_n / (long double(2) * __x);
                __np_n = __factor * __Np_nu - __n_n / (long double(2) * __x);
                return;
            }
            template <typename _Tp> _Tp __sph_bessel(unsigned int __n, _Tp __x)             {
                if (__x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __sph_bessel."));
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x == _Tp(0)) {
                    if (__n == 0)
                        return _Tp(1);
                    else
                        return _Tp(0);
                } else {
                    _Tp __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __j_n;
                }
            }
            template<> float __sph_bessel<float>(unsigned int __n, float __x)             {
                if (__x < float(0))
                    std::__throw_domain_error(("Bad argument in __sph_bessel."));
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x == float(0)) {
                    if (__n == 0)
                        return float(1);
                    else
                        return float(0);
                } else {
                    float __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __j_n;
                }
            }
            template<> long double __sph_bessel<long double>(unsigned int __n, long double __x)             {
                if (__x < long double(0))
                    std::__throw_domain_error(("Bad argument in __sph_bessel."));
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x == long double(0)) {
                    if (__n == 0)
                        return long double(1);
                    else
                        return long double(0);
                } else {
                    long double __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __j_n;
                }
            }
            template <typename _Tp> _Tp __sph_neumann(unsigned int __n, _Tp __x)             {
                if (__x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __sph_neumann."));
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x == _Tp(0))
                    return - std::numeric_limits<_Tp>::infinity();
                else {
                    _Tp __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __n_n;
                }
            }
            template<> float __sph_neumann<float>(unsigned int __n, float __x)             {
                if (__x < float(0))
                    std::__throw_domain_error(("Bad argument in __sph_neumann."));
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x == float(0))
                    return -std::numeric_limits<float>::infinity();
                else {
                    float __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __n_n;
                }
            }
            template<> long double __sph_neumann<long double>(unsigned int __n, long double __x)             {
                if (__x < long double(0))
                    std::__throw_domain_error(("Bad argument in __sph_neumann."));
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x == long double(0))
                    return -std::numeric_limits<long double>::infinity();
                else {
                    long double __j_n, __n_n, __jp_n, __np_n;
                    __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
                    return __n_n;
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __beta_gamma(_Tp __x, _Tp __y)             {
                _Tp __bet;
                if (__x > __y) {
                    __bet = ::std::tgamma(__x) / ::std::tgamma(__x + __y);
                    __bet *= ::std::tgamma(__y);
                } else {
                    __bet = ::std::tgamma(__y) / ::std::tgamma(__x + __y);
                    __bet *= ::std::tgamma(__x);
                }
                return __bet;
            }
            template <typename _Tp> _Tp __beta_lgamma(_Tp __x, _Tp __y)             {
                _Tp __bet = ::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);
                __bet = std::exp(__bet);
                return __bet;
            }
            template<> float __beta_lgamma<float>(float __x, float __y)             {
                float __bet = ::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);
                __bet = std::exp(__bet);
                return __bet;
            }
            template<> long double __beta_lgamma<long double>(long double __x, long double __y)             {
                long double __bet = ::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);
                __bet = std::exp(__bet);
                return __bet;
            }
            template <typename _Tp> _Tp __beta_product(_Tp __x, _Tp __y)             {
                _Tp __bet = (__x + __y) / (__x * __y);
                unsigned int __max_iter = 1000000;
                for (unsigned int __k = 1; __k < __max_iter; ++__k) {
                    _Tp __term = (_Tp(1) + (__x + __y) / __k) / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
                    __bet *= __term;
                }
                return __bet;
            }
            template <typename _Tp> inline _Tp __beta(_Tp __x, _Tp __y)             {
                if (__isnan(__x) || __isnan(__y))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __beta_lgamma(__x, __y);
            }
            template<> inline float __beta<float>(float __x, float __y)             {
                if (__isnan(__x) || __isnan(__y))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __beta_lgamma(__x, __y);
            }
            template<> inline long double __beta<long double>(long double __x, long double __y)             {
                if (__isnan(__x) || __isnan(__y))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __beta_lgamma(__x, __y);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __ellint_rf(_Tp __x, _Tp __y, _Tp __z)             {
                const _Tp __min = std::numeric_limits<_Tp>::min();
                const _Tp __max = std::numeric_limits<_Tp>::max();
                const _Tp __lolim = _Tp(5) * __min;
                const _Tp __uplim = __max / _Tp(5);
                if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rf."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rf"));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(1) / _Tp(24);
                    const _Tp __c2 = _Tp(1) / _Tp(10);
                    const _Tp __c3 = _Tp(3) / _Tp(44);
                    const _Tp __c4 = _Tp(1) / _Tp(14);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    _Tp __zn = __z;
                    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                    const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
                    _Tp __mu;
                    _Tp __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn) / _Tp(3);
                        __xndev = 2 - (__mu + __xn) / __mu;
                        __yndev = 2 - (__mu + __yn) / __mu;
                        __zndev = 2 - (__mu + __zn) / __mu;
                        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        const _Tp __xnroot = std::sqrt(__xn);
                        const _Tp __ynroot = std::sqrt(__yn);
                        const _Tp __znroot = std::sqrt(__zn);
                        const _Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
                    const _Tp __e3 = __xndev * __yndev * __zndev;
                    const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;
                    return __s / std::sqrt(__mu);
                }
            }
            template<> float __ellint_rf<float>(float __x, float __y, float __z)             {
                const float __min = std::numeric_limits<float>::min();
                const float __max = std::numeric_limits<float>::max();
                const float __lolim = float(5) * __min;
                const float __uplim = __max / float(5);
                if (__x < float(0) || __y < float(0) || __z < float(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rf."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rf"));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(1) / float(24);
                    const float __c2 = float(1) / float(10);
                    const float __c3 = float(3) / float(44);
                    const float __c4 = float(1) / float(14);
                    float __xn = __x;
                    float __yn = __y;
                    float __zn = __z;
                    const float __eps = std::numeric_limits<float>::epsilon();
                    const float __errtol = std::pow(__eps, float(1) / float(6));
                    float __mu;
                    float __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn) / float(3);
                        __xndev = 2 - (__mu + __xn) / __mu;
                        __yndev = 2 - (__mu + __yn) / __mu;
                        __zndev = 2 - (__mu + __zn) / __mu;
                        float __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        const float __xnroot = std::sqrt(__xn);
                        const float __ynroot = std::sqrt(__yn);
                        const float __znroot = std::sqrt(__zn);
                        const float __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    const float __e2 = __xndev * __yndev - __zndev * __zndev;
                    const float __e3 = __xndev * __yndev * __zndev;
                    const float __s = float(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;
                    return __s / std::sqrt(__mu);
                }
            }
            template<> long double __ellint_rf<long double>(long double __x, long double __y, long double __z)             {
                const long double __min = std::numeric_limits<long double>::min();
                const long double __max = std::numeric_limits<long double>::max();
                const long double __lolim = long double(5) * __min;
                const long double __uplim = __max / long double(5);
                if (__x < long double(0) || __y < long double(0) || __z < long double(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rf."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rf"));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(1) / long double(24);
                    const long double __c2 = long double(1) / long double(10);
                    const long double __c3 = long double(3) / long double(44);
                    const long double __c4 = long double(1) / long double(14);
                    long double __xn = __x;
                    long double __yn = __y;
                    long double __zn = __z;
                    const long double __eps = std::numeric_limits<long double>::epsilon();
                    const long double __errtol = std::pow(__eps, long double(1) / long double(6));
                    long double __mu;
                    long double __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn) / long double(3);
                        __xndev = 2 - (__mu + __xn) / __mu;
                        __yndev = 2 - (__mu + __yn) / __mu;
                        __zndev = 2 - (__mu + __zn) / __mu;
                        long double __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        const long double __xnroot = std::sqrt(__xn);
                        const long double __ynroot = std::sqrt(__yn);
                        const long double __znroot = std::sqrt(__zn);
                        const long double __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    const long double __e2 = __xndev * __yndev - __zndev * __zndev;
                    const long double __e3 = __xndev * __yndev * __zndev;
                    const long double __s = long double(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;
                    return __s / std::sqrt(__mu);
                }
            }
            template <typename _Tp> _Tp __comp_ellint_1_series(_Tp __k)             {
                const _Tp __kk = __k * __k;
                _Tp __term = __kk / _Tp(4);
                _Tp __sum = _Tp(1) + __term;
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 2; __i < __max_iter; ++__i) {
                    __term *= (2 * __i - 1) * __kk / (2 * __i);
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term;
                }
                return __numeric_constants<_Tp>::__pi_2() * __sum;
            }
            template <typename _Tp> _Tp __comp_ellint_1(_Tp __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) >= _Tp(1))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
            }
            template<> float __comp_ellint_1<float>(float __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) >= float(1))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __ellint_rf(float(0), float(1) - __k * __k, float(1));
            }
            template<> long double __comp_ellint_1<long double>(long double __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) >= long double(1))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __ellint_rf(long double(0), long double(1) - __k * __k, long double(1));
            }
            template <typename _Tp> _Tp __ellint_1(_Tp __k, _Tp __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __ellint_1."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
                    const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();
                    const _Tp __s = std::sin(__phi_red);
                    const _Tp __c = std::cos(__phi_red);
                    const _Tp __F = __s * __ellint_rf(__c * __c, _Tp(1) - __k * __k * __s * __s, _Tp(1));
                    if (__n == 0)
                        return __F;
                    else
                        return __F + _Tp(2) * __n * __comp_ellint_1(__k);
                }
            }
            template<> float __ellint_1<float>(float __k, float __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __ellint_1."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<float>::__pi() + float(0.5L));
                    const float __phi_red = __phi - __n * __numeric_constants<float>::__pi();
                    const float __s = std::sin(__phi_red);
                    const float __c = std::cos(__phi_red);
                    const float __F = __s * __ellint_rf(__c * __c, float(1) - __k * __k * __s * __s, float(1));
                    if (__n == 0)
                        return __F;
                    else
                        return __F + float(2) * __n * __comp_ellint_1(__k);
                }
            }
            template<> long double __ellint_1<long double>(long double __k, long double __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __ellint_1."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<long double>::__pi() + long double(0.5L));
                    const long double __phi_red = __phi - __n * __numeric_constants<long double>::__pi();
                    const long double __s = std::sin(__phi_red);
                    const long double __c = std::cos(__phi_red);
                    const long double __F = __s * __ellint_rf(__c * __c, long double(1) - __k * __k * __s * __s, long double(1));
                    if (__n == 0)
                        return __F;
                    else
                        return __F + long double(2) * __n * __comp_ellint_1(__k);
                }
            }
            template <typename _Tp> _Tp __comp_ellint_2_series(_Tp __k)             {
                const _Tp __kk = __k * __k;
                _Tp __term = __kk;
                _Tp __sum = __term;
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 2; __i < __max_iter; ++__i) {
                    const _Tp __i2m = 2 * __i - 1;
                    const _Tp __i2 = 2 * __i;
                    __term *= __i2m * __i2m * __kk / (__i2 * __i2);
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term / __i2m;
                }
                return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
            }
            template <typename _Tp> _Tp __ellint_rd(_Tp __x, _Tp __y, _Tp __z)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
                const _Tp __min = std::numeric_limits<_Tp>::min();
                const _Tp __max = std::numeric_limits<_Tp>::max();
                const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));
                const _Tp __uplim = std::pow(_Tp(0.100000000000000000001L) * __errtol / __min, _Tp(2) / _Tp(3));
                if (__x < _Tp(0) || __y < _Tp(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rd."));
                else if (__x + __y < __lolim || __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rd."));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(3) / _Tp(14);
                    const _Tp __c2 = _Tp(1) / _Tp(6);
                    const _Tp __c3 = _Tp(9) / _Tp(22);
                    const _Tp __c4 = _Tp(3) / _Tp(26);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    _Tp __zn = __z;
                    _Tp __sigma = _Tp(0);
                    _Tp __power4 = _Tp(1);
                    _Tp __mu;
                    _Tp __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        _Tp __xnroot = std::sqrt(__xn);
                        _Tp __ynroot = std::sqrt(__yn);
                        _Tp __znroot = std::sqrt(__zn);
                        _Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __sigma += __power4 / (__znroot * (__zn + __lambda));
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    _Tp __ea = __xndev * __yndev;
                    _Tp __eb = __zndev * __zndev;
                    _Tp __ec = __ea - __eb;
                    _Tp __ed = __ea - _Tp(6) * __eb;
                    _Tp __ef = __ed + __ec + __ec;
                    _Tp __s1 = __ed * (- __c1 + __c3 * __ed / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef / _Tp(2));
                    _Tp __s2 = __zndev * (__c2 * __ef + __zndev * (- __c3 * __ec - __zndev * __c4 - __ea));
                    return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
                }
            }
            template<> float __ellint_rd<float>(float __x, float __y, float __z)             {
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __errtol = std::pow(__eps / float(8), float(1) / float(6));
                const float __min = std::numeric_limits<float>::min();
                const float __max = std::numeric_limits<float>::max();
                const float __lolim = float(2) / std::pow(__max, float(2) / float(3));
                const float __uplim = std::pow(float(0.100000000000000000001L) * __errtol / __min, float(2) / float(3));
                if (__x < float(0) || __y < float(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rd."));
                else if (__x + __y < __lolim || __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rd."));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(3) / float(14);
                    const float __c2 = float(1) / float(6);
                    const float __c3 = float(9) / float(22);
                    const float __c4 = float(3) / float(26);
                    float __xn = __x;
                    float __yn = __y;
                    float __zn = __z;
                    float __sigma = float(0);
                    float __power4 = float(1);
                    float __mu;
                    float __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + float(3) * __zn) / float(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        float __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        float __xnroot = std::sqrt(__xn);
                        float __ynroot = std::sqrt(__yn);
                        float __znroot = std::sqrt(__zn);
                        float __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __sigma += __power4 / (__znroot * (__zn + __lambda));
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    float __ea = __xndev * __yndev;
                    float __eb = __zndev * __zndev;
                    float __ec = __ea - __eb;
                    float __ed = __ea - float(6) * __eb;
                    float __ef = __ed + __ec + __ec;
                    float __s1 = __ed * (-__c1 + __c3 * __ed / float(3) - float(3) * __c4 * __zndev * __ef / float(2));
                    float __s2 = __zndev * (__c2 * __ef + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));
                    return float(3) * __sigma + __power4 * (float(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
                }
            }
            template<> long double __ellint_rd<long double>(long double __x, long double __y, long double __z)             {
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __errtol = std::pow(__eps / long double(8), long double(1) / long double(6));
                const long double __min = std::numeric_limits<long double>::min();
                const long double __max = std::numeric_limits<long double>::max();
                const long double __lolim = long double(2) / std::pow(__max, long double(2) / long double(3));
                const long double __uplim = std::pow(long double(0.100000000000000000001L) * __errtol / __min, long double(2) / long double(3));
                if (__x < long double(0) || __y < long double(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rd."));
                else if (__x + __y < __lolim || __z < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rd."));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(3) / long double(14);
                    const long double __c2 = long double(1) / long double(6);
                    const long double __c3 = long double(9) / long double(22);
                    const long double __c4 = long double(3) / long double(26);
                    long double __xn = __x;
                    long double __yn = __y;
                    long double __zn = __z;
                    long double __sigma = long double(0);
                    long double __power4 = long double(1);
                    long double __mu;
                    long double __xndev, __yndev, __zndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + long double(3) * __zn) / long double(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        long double __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        if (__epsilon < __errtol)
                            break;
                        long double __xnroot = std::sqrt(__xn);
                        long double __ynroot = std::sqrt(__yn);
                        long double __znroot = std::sqrt(__zn);
                        long double __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        __sigma += __power4 / (__znroot * (__zn + __lambda));
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                    }
                    long double __ea = __xndev * __yndev;
                    long double __eb = __zndev * __zndev;
                    long double __ec = __ea - __eb;
                    long double __ed = __ea - long double(6) * __eb;
                    long double __ef = __ed + __ec + __ec;
                    long double __s1 = __ed * (-__c1 + __c3 * __ed / long double(3) - long double(3) * __c4 * __zndev * __ef / long double(2));
                    long double __s2 = __zndev * (__c2 * __ef + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));
                    return long double(3) * __sigma + __power4 * (long double(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
                }
            }
            template <typename _Tp> _Tp __comp_ellint_2(_Tp __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) == 1)
                    return _Tp(1);
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
                else {
                    const _Tp __kk = __k * __k;
                    return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
                }
            }
            template<> float __comp_ellint_2<float>(float __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) == 1)
                    return float(1);
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
                else {
                    const float __kk = __k * __k;
                    return __ellint_rf(float(0), float(1) - __kk, float(1)) - __kk * __ellint_rd(float(0), float(1) - __kk, float(1)) / float(3);
                }
            }
            template<> long double __comp_ellint_2<long double>(long double __k)             {
                if (__isnan(__k))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) == 1)
                    return long double(1);
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
                else {
                    const long double __kk = __k * __k;
                    return __ellint_rf(long double(0), long double(1) - __kk, long double(1)) - __kk * __ellint_rd(long double(0), long double(1) - __kk, long double(1)) / long double(3);
                }
            }
            template <typename _Tp> _Tp __ellint_2(_Tp __k, _Tp __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __ellint_2."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
                    const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();
                    const _Tp __kk = __k * __k;
                    const _Tp __s = std::sin(__phi_red);
                    const _Tp __ss = __s * __s;
                    const _Tp __sss = __ss * __s;
                    const _Tp __c = std::cos(__phi_red);
                    const _Tp __cc = __c * __c;
                    const _Tp __E = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) - __kk * __sss * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1)) / _Tp(3);
                    if (__n == 0)
                        return __E;
                    else
                        return __E + _Tp(2) * __n * __comp_ellint_2(__k);
                }
            }
            template<> float __ellint_2<float>(float __k, float __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __ellint_2."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<float>::__pi() + float(0.5L));
                    const float __phi_red = __phi - __n * __numeric_constants<float>::__pi();
                    const float __kk = __k * __k;
                    const float __s = std::sin(__phi_red);
                    const float __ss = __s * __s;
                    const float __sss = __ss * __s;
                    const float __c = std::cos(__phi_red);
                    const float __cc = __c * __c;
                    const float __E = __s * __ellint_rf(__cc, float(1) - __kk * __ss, float(1)) - __kk * __sss * __ellint_rd(__cc, float(1) - __kk * __ss, float(1)) / float(3);
                    if (__n == 0)
                        return __E;
                    else
                        return __E + float(2) * __n * __comp_ellint_2(__k);
                }
            }
            template<> long double __ellint_2<long double>(long double __k, long double __phi)             {
                if (__isnan(__k) || __isnan(__phi))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __ellint_2."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<long double>::__pi() + long double(0.5L));
                    const long double __phi_red = __phi - __n * __numeric_constants<long double>::__pi();
                    const long double __kk = __k * __k;
                    const long double __s = std::sin(__phi_red);
                    const long double __ss = __s * __s;
                    const long double __sss = __ss * __s;
                    const long double __c = std::cos(__phi_red);
                    const long double __cc = __c * __c;
                    const long double __E = __s * __ellint_rf(__cc, long double(1) - __kk * __ss, long double(1)) - __kk * __sss * __ellint_rd(__cc, long double(1) - __kk * __ss, long double(1)) / long double(3);
                    if (__n == 0)
                        return __E;
                    else
                        return __E + long double(2) * __n * __comp_ellint_2(__k);
                }
            }
            template <typename _Tp> _Tp __ellint_rc(_Tp __x, _Tp __y)             {
                const _Tp __min = std::numeric_limits<_Tp>::min();
                const _Tp __max = std::numeric_limits<_Tp>::max();
                const _Tp __lolim = _Tp(5) * __min;
                const _Tp __uplim = __max / _Tp(5);
                if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
                    std::__throw_domain_error(("Argument less than zero in __ellint_rc."));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(1) / _Tp(7);
                    const _Tp __c2 = _Tp(9) / _Tp(22);
                    const _Tp __c3 = _Tp(3) / _Tp(10);
                    const _Tp __c4 = _Tp(3) / _Tp(8);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                    const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
                    _Tp __mu;
                    _Tp __sn;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
                        __sn = (__yn + __mu) / __mu - _Tp(2);
                        if (std::abs(__sn) < __errtol)
                            break;
                        const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                    }
                    _Tp __s = __sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));
                    return (_Tp(1) + __s) / std::sqrt(__mu);
                }
            }
            template<> float __ellint_rc<float>(float __x, float __y)             {
                const float __min = std::numeric_limits<float>::min();
                const float __max = std::numeric_limits<float>::max();
                const float __lolim = float(5) * __min;
                const float __uplim = __max / float(5);
                if (__x < float(0) || __y < float(0) || __x + __y < __lolim)
                    std::__throw_domain_error(("Argument less than zero in __ellint_rc."));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(1) / float(7);
                    const float __c2 = float(9) / float(22);
                    const float __c3 = float(3) / float(10);
                    const float __c4 = float(3) / float(8);
                    float __xn = __x;
                    float __yn = __y;
                    const float __eps = std::numeric_limits<float>::epsilon();
                    const float __errtol = std::pow(__eps / float(30), float(1) / float(6));
                    float __mu;
                    float __sn;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + float(2) * __yn) / float(3);
                        __sn = (__yn + __mu) / __mu - float(2);
                        if (std::abs(__sn) < __errtol)
                            break;
                        const float __lambda = float(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                    }
                    float __s = __sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));
                    return (float(1) + __s) / std::sqrt(__mu);
                }
            }
            template<> long double __ellint_rc<long double>(long double __x, long double __y)             {
                const long double __min = std::numeric_limits<long double>::min();
                const long double __max = std::numeric_limits<long double>::max();
                const long double __lolim = long double(5) * __min;
                const long double __uplim = __max / long double(5);
                if (__x < long double(0) || __y < long double(0) || __x + __y < __lolim)
                    std::__throw_domain_error(("Argument less than zero in __ellint_rc."));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(1) / long double(7);
                    const long double __c2 = long double(9) / long double(22);
                    const long double __c3 = long double(3) / long double(10);
                    const long double __c4 = long double(3) / long double(8);
                    long double __xn = __x;
                    long double __yn = __y;
                    const long double __eps = std::numeric_limits<long double>::epsilon();
                    const long double __errtol = std::pow(__eps / long double(30), long double(1) / long double(6));
                    long double __mu;
                    long double __sn;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + long double(2) * __yn) / long double(3);
                        __sn = (__yn + __mu) / __mu - long double(2);
                        if (std::abs(__sn) < __errtol)
                            break;
                        const long double __lambda = long double(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                    }
                    long double __s = __sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));
                    return (long double(1) + __s) / std::sqrt(__mu);
                }
            }
            template <typename _Tp> _Tp __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)             {
                const _Tp __min = std::numeric_limits<_Tp>::min();
                const _Tp __max = std::numeric_limits<_Tp>::max();
                const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1) / _Tp(3));
                const _Tp __uplim = _Tp(0.300000000000000000011L) * std::pow(_Tp(0.200000000000000000003L) * __max, _Tp(1) / _Tp(3));
                if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rj."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim || __p < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rj"));
                else {
                    const _Tp __c0 = _Tp(1) / _Tp(4);
                    const _Tp __c1 = _Tp(3) / _Tp(14);
                    const _Tp __c2 = _Tp(1) / _Tp(3);
                    const _Tp __c3 = _Tp(3) / _Tp(22);
                    const _Tp __c4 = _Tp(3) / _Tp(26);
                    _Tp __xn = __x;
                    _Tp __yn = __y;
                    _Tp __zn = __z;
                    _Tp __pn = __p;
                    _Tp __sigma = _Tp(0);
                    _Tp __power4 = _Tp(1);
                    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                    const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
                    _Tp __lambda, __mu;
                    _Tp __xndev, __yndev, __zndev, __pndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        __pndev = (__mu - __pn) / __mu;
                        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        __epsilon = std::max(__epsilon, std::abs(__pndev));
                        if (__epsilon < __errtol)
                            break;
                        const _Tp __xnroot = std::sqrt(__xn);
                        const _Tp __ynroot = std::sqrt(__yn);
                        const _Tp __znroot = std::sqrt(__zn);
                        const _Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot) + __xnroot * __ynroot * __znroot;
                        const _Tp __alpha2 = __alpha1 * __alpha1;
                        const _Tp __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
                        __sigma += __power4 * __ellint_rc(__alpha2, __beta);
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                        __pn = __c0 * (__pn + __lambda);
                    }
                    _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
                    _Tp __eb = __xndev * __yndev * __zndev;
                    _Tp __ec = __pndev * __pndev;
                    _Tp __e2 = __ea - _Tp(3) * __ec;
                    _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
                    _Tp __s1 = _Tp(1) + __e2 * (- __c1 + _Tp(3) * __c3 * __e2 / _Tp(4) - _Tp(3) * __c4 * __e3 / _Tp(2));
                    _Tp __s2 = __eb * (__c2 / _Tp(2) + __pndev * (- __c3 - __c3 + __pndev * __c4));
                    _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;
                    return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
                }
            }
            template<> float __ellint_rj<float>(float __x, float __y, float __z, float __p)             {
                const float __min = std::numeric_limits<float>::min();
                const float __max = std::numeric_limits<float>::max();
                const float __lolim = std::pow(float(5) * __min, float(1) / float(3));
                const float __uplim = float(0.300000000000000000011L) * std::pow(float(0.200000000000000000003L) * __max, float(1) / float(3));
                if (__x < float(0) || __y < float(0) || __z < float(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rj."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim || __p < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rj"));
                else {
                    const float __c0 = float(1) / float(4);
                    const float __c1 = float(3) / float(14);
                    const float __c2 = float(1) / float(3);
                    const float __c3 = float(3) / float(22);
                    const float __c4 = float(3) / float(26);
                    float __xn = __x;
                    float __yn = __y;
                    float __zn = __z;
                    float __pn = __p;
                    float __sigma = float(0);
                    float __power4 = float(1);
                    const float __eps = std::numeric_limits<float>::epsilon();
                    const float __errtol = std::pow(__eps / float(8), float(1) / float(6));
                    float __lambda, __mu;
                    float __xndev, __yndev, __zndev, __pndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn + float(2) * __pn) / float(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        __pndev = (__mu - __pn) / __mu;
                        float __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        __epsilon = std::max(__epsilon, std::abs(__pndev));
                        if (__epsilon < __errtol)
                            break;
                        const float __xnroot = std::sqrt(__xn);
                        const float __ynroot = std::sqrt(__yn);
                        const float __znroot = std::sqrt(__zn);
                        const float __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        const float __alpha1 = __pn * (__xnroot + __ynroot + __znroot) + __xnroot * __ynroot * __znroot;
                        const float __alpha2 = __alpha1 * __alpha1;
                        const float __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
                        __sigma += __power4 * __ellint_rc(__alpha2, __beta);
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                        __pn = __c0 * (__pn + __lambda);
                    }
                    float __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
                    float __eb = __xndev * __yndev * __zndev;
                    float __ec = __pndev * __pndev;
                    float __e2 = __ea - float(3) * __ec;
                    float __e3 = __eb + float(2) * __pndev * (__ea - __ec);
                    float __s1 = float(1) + __e2 * (-__c1 + float(3) * __c3 * __e2 / float(4) - float(3) * __c4 * __e3 / float(2));
                    float __s2 = __eb * (__c2 / float(2) + __pndev * (-__c3 - __c3 + __pndev * __c4));
                    float __s3 = __pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;
                    return float(3) * __sigma + __power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
                }
            }
            template<> long double __ellint_rj<long double>(long double __x, long double __y, long double __z, long double __p)             {
                const long double __min = std::numeric_limits<long double>::min();
                const long double __max = std::numeric_limits<long double>::max();
                const long double __lolim = std::pow(long double(5) * __min, long double(1) / long double(3));
                const long double __uplim = long double(0.300000000000000000011L) * std::pow(long double(0.200000000000000000003L) * __max, long double(1) / long double(3));
                if (__x < long double(0) || __y < long double(0) || __z < long double(0))
                    std::__throw_domain_error(("Argument less than zero in __ellint_rj."));
                else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim || __p < __lolim)
                    std::__throw_domain_error(("Argument too small in __ellint_rj"));
                else {
                    const long double __c0 = long double(1) / long double(4);
                    const long double __c1 = long double(3) / long double(14);
                    const long double __c2 = long double(1) / long double(3);
                    const long double __c3 = long double(3) / long double(22);
                    const long double __c4 = long double(3) / long double(26);
                    long double __xn = __x;
                    long double __yn = __y;
                    long double __zn = __z;
                    long double __pn = __p;
                    long double __sigma = long double(0);
                    long double __power4 = long double(1);
                    const long double __eps = std::numeric_limits<long double>::epsilon();
                    const long double __errtol = std::pow(__eps / long double(8), long double(1) / long double(6));
                    long double __lambda, __mu;
                    long double __xndev, __yndev, __zndev, __pndev;
                    const unsigned int __max_iter = 100;
                    for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
                        __mu = (__xn + __yn + __zn + long double(2) * __pn) / long double(5);
                        __xndev = (__mu - __xn) / __mu;
                        __yndev = (__mu - __yn) / __mu;
                        __zndev = (__mu - __zn) / __mu;
                        __pndev = (__mu - __pn) / __mu;
                        long double __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
                        __epsilon = std::max(__epsilon, std::abs(__zndev));
                        __epsilon = std::max(__epsilon, std::abs(__pndev));
                        if (__epsilon < __errtol)
                            break;
                        const long double __xnroot = std::sqrt(__xn);
                        const long double __ynroot = std::sqrt(__yn);
                        const long double __znroot = std::sqrt(__zn);
                        const long double __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
                        const long double __alpha1 = __pn * (__xnroot + __ynroot + __znroot) + __xnroot * __ynroot * __znroot;
                        const long double __alpha2 = __alpha1 * __alpha1;
                        const long double __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
                        __sigma += __power4 * __ellint_rc(__alpha2, __beta);
                        __power4 *= __c0;
                        __xn = __c0 * (__xn + __lambda);
                        __yn = __c0 * (__yn + __lambda);
                        __zn = __c0 * (__zn + __lambda);
                        __pn = __c0 * (__pn + __lambda);
                    }
                    long double __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
                    long double __eb = __xndev * __yndev * __zndev;
                    long double __ec = __pndev * __pndev;
                    long double __e2 = __ea - long double(3) * __ec;
                    long double __e3 = __eb + long double(2) * __pndev * (__ea - __ec);
                    long double __s1 = long double(1) + __e2 * (-__c1 + long double(3) * __c3 * __e2 / long double(4) - long double(3) * __c4 * __e3 / long double(2));
                    long double __s2 = __eb * (__c2 / long double(2) + __pndev * (-__c3 - __c3 + __pndev * __c4));
                    long double __s3 = __pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;
                    return long double(3) * __sigma + __power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
                }
            }
            template <typename _Tp> _Tp __comp_ellint_3(_Tp __k, _Tp __nu)             {
                if (__isnan(__k) || __isnan(__nu))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__nu == _Tp(1))
                    return std::numeric_limits<_Tp>::infinity();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
                else {
                    const _Tp __kk = __k * __k;
                    return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) + __nu * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu) / _Tp(3);
                }
            }
            template<> float __comp_ellint_3<float>(float __k, float __nu)             {
                if (__isnan(__k) || __isnan(__nu))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__nu == float(1))
                    return std::numeric_limits<float>::infinity();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
                else {
                    const float __kk = __k * __k;
                    return __ellint_rf(float(0), float(1) - __kk, float(1)) + __nu * __ellint_rj(float(0), float(1) - __kk, float(1), float(1) - __nu) / float(3);
                }
            }
            template<> long double __comp_ellint_3<long double>(long double __k, long double __nu)             {
                if (__isnan(__k) || __isnan(__nu))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__nu == long double(1))
                    return std::numeric_limits<long double>::infinity();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
                else {
                    const long double __kk = __k * __k;
                    return __ellint_rf(long double(0), long double(1) - __kk, long double(1)) + __nu * __ellint_rj(long double(0), long double(1) - __kk, long double(1), long double(1) - __nu) / long double(3);
                }
            }
            template <typename _Tp> _Tp __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)             {
                if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (std::abs(__k) > _Tp(1))
                    std::__throw_domain_error(("Bad argument in __ellint_3."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
                    const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();
                    const _Tp __kk = __k * __k;
                    const _Tp __s = std::sin(__phi_red);
                    const _Tp __ss = __s * __s;
                    const _Tp __sss = __ss * __s;
                    const _Tp __c = std::cos(__phi_red);
                    const _Tp __cc = __c * __c;
                    const _Tp __Pi = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) + __nu * __sss * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1), _Tp(1) - __nu * __ss) / _Tp(3);
                    if (__n == 0)
                        return __Pi;
                    else
                        return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
                }
            }
            template<> float __ellint_3<float>(float __k, float __nu, float __phi)             {
                if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (std::abs(__k) > float(1))
                    std::__throw_domain_error(("Bad argument in __ellint_3."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<float>::__pi() + float(0.5L));
                    const float __phi_red = __phi - __n * __numeric_constants<float>::__pi();
                    const float __kk = __k * __k;
                    const float __s = std::sin(__phi_red);
                    const float __ss = __s * __s;
                    const float __sss = __ss * __s;
                    const float __c = std::cos(__phi_red);
                    const float __cc = __c * __c;
                    const float __Pi = __s * __ellint_rf(__cc, float(1) - __kk * __ss, float(1)) + __nu * __sss * __ellint_rj(__cc, float(1) - __kk * __ss, float(1), float(1) - __nu * __ss) / float(3);
                    if (__n == 0)
                        return __Pi;
                    else
                        return __Pi + float(2) * __n * __comp_ellint_3(__k, __nu);
                }
            }
            template<> long double __ellint_3<long double>(long double __k, long double __nu, long double __phi)             {
                if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (std::abs(__k) > long double(1))
                    std::__throw_domain_error(("Bad argument in __ellint_3."));
                else {
                    const int __n = std::floor(__phi / __numeric_constants<long double>::__pi() + long double(0.5L));
                    const long double __phi_red = __phi - __n * __numeric_constants<long double>::__pi();
                    const long double __kk = __k * __k;
                    const long double __s = std::sin(__phi_red);
                    const long double __ss = __s * __s;
                    const long double __sss = __ss * __s;
                    const long double __c = std::cos(__phi_red);
                    const long double __cc = __c * __c;
                    const long double __Pi = __s * __ellint_rf(__cc, long double(1) - __kk * __ss, long double(1)) + __nu * __sss * __ellint_rj(__cc, long double(1) - __kk * __ss, long double(1), long double(1) - __nu * __ss) / long double(3);
                    if (__n == 0)
                        return __Pi;
                    else
                        return __Pi + long double(2) * __n * __comp_ellint_3(__k, __nu);
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __expint_E1(_Tp);
            template <typename _Tp> _Tp __expint_E1_series(_Tp __x)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                _Tp __term = _Tp(1);
                _Tp __esum = _Tp(0);
                _Tp __osum = _Tp(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= - __x / __i;
                    if (std::abs(__term) < __eps)
                        break;
                    if (__term >= _Tp(0))
                        __esum += __term / __i;
                    else
                        __osum += __term / __i;
                }
                return - __esum - __osum - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
            }
            template<> float __expint_E1_series<float>(float __x)             {
                const float __eps = std::numeric_limits<float>::epsilon();
                float __term = float(1);
                float __esum = float(0);
                float __osum = float(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= -__x / __i;
                    if (std::abs(__term) < __eps)
                        break;
                    if (__term >= float(0))
                        __esum += __term / __i;
                    else
                        __osum += __term / __i;
                }
                return -__esum - __osum - __numeric_constants<float>::__gamma_e() - std::log(__x);
            }
            template<> long double __expint_E1_series<long double>(long double __x)             {
                const long double __eps = std::numeric_limits<long double>::epsilon();
                long double __term = long double(1);
                long double __esum = long double(0);
                long double __osum = long double(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= -__x / __i;
                    if (std::abs(__term) < __eps)
                        break;
                    if (__term >= long double(0))
                        __esum += __term / __i;
                    else
                        __osum += __term / __i;
                }
                return -__esum - __osum - __numeric_constants<long double>::__gamma_e() - std::log(__x);
            }
            template <typename _Tp> _Tp __expint_E1_asymp(_Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __esum = _Tp(1);
                _Tp __osum = _Tp(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    _Tp __prev = __term;
                    __term *= -__i / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    if (__term >= _Tp(0))
                        __esum += __term;
                    else
                        __osum += __term;
                }
                return std::exp(- __x) * (__esum + __osum) / __x;
            }
            template<> float __expint_E1_asymp<float>(float __x)             {
                float __term = float(1);
                float __esum = float(1);
                float __osum = float(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    float __prev = __term;
                    __term *= -__i / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    if (__term >= float(0))
                        __esum += __term;
                    else
                        __osum += __term;
                }
                return std::exp(-__x) * (__esum + __osum) / __x;
            }
            template<> long double __expint_E1_asymp<long double>(long double __x)             {
                long double __term = long double(1);
                long double __esum = long double(1);
                long double __osum = long double(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    long double __prev = __term;
                    __term *= -__i / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    if (__term >= long double(0))
                        __esum += __term;
                    else
                        __osum += __term;
                }
                return std::exp(-__x) * (__esum + __osum) / __x;
            }
            template <typename _Tp> _Tp __expint_En_series(unsigned int __n, _Tp __x)             {
                const unsigned int __max_iter = 1000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const int __nm1 = __n - 1;
                _Tp __ans = (__nm1 != 0 ? _Tp(1) / __nm1 : - std::log(__x) - __numeric_constants<_Tp>::__gamma_e());
                _Tp __fact = _Tp(1);
                for (int __i = 1; __i <= __max_iter; ++__i) {
                    __fact *= - __x / _Tp(__i);
                    _Tp __del;
                    if (__i != __nm1)
                        __del = - __fact / _Tp(__i - __nm1);
                    else {
                        _Tp __psi = - __numeric_constants<_Tp>::gamma_e();
                        for (int __ii = 1; __ii <= __nm1; ++__ii)
                            __psi += _Tp(1) / _Tp(__ii);
                        __del = __fact * (__psi - std::log(__x));
                    }
                    __ans += __del;
                    if (std::abs(__del) < __eps * std::abs(__ans))
                        return __ans;
                }
                std::__throw_runtime_error(("Series summation failed in __expint_En_series."));
            }
            template <typename _Tp> _Tp __expint_En_cont_frac(unsigned int __n, _Tp __x)             {
                const unsigned int __max_iter = 1000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __fp_min = std::numeric_limits<_Tp>::min();
                const int __nm1 = __n - 1;
                _Tp __b = __x + _Tp(__n);
                _Tp __c = _Tp(1) / __fp_min;
                _Tp __d = _Tp(1) / __b;
                _Tp __h = __d;
                for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
                    _Tp __a = - _Tp(__i * (__nm1 + __i));
                    __b += _Tp(2);
                    __d = _Tp(1) / (__a * __d + __b);
                    __c = __b + __a / __c;
                    const _Tp __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - _Tp(1)) < __eps) {
                        const _Tp __ans = __h * std::exp(- __x);
                        return __ans;
                    }
                }
                std::__throw_runtime_error(("Continued fraction failed in __expint_En_cont_frac."));
            }
            template<> float __expint_En_cont_frac<float>(unsigned int __n, float __x)             {
                const unsigned int __max_iter = 1000;
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __fp_min = std::numeric_limits<float>::min();
                const int __nm1 = __n - 1;
                float __b = __x + float(__n);
                float __c = float(1) / __fp_min;
                float __d = float(1) / __b;
                float __h = __d;
                for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
                    float __a = -float(__i * (__nm1 + __i));
                    __b += float(2);
                    __d = float(1) / (__a * __d + __b);
                    __c = __b + __a / __c;
                    const float __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - float(1)) < __eps) {
                        const float __ans = __h * std::exp(-__x);
                        return __ans;
                    }
                }
                std::__throw_runtime_error(("Continued fraction failed in __expint_En_cont_frac."));
            }
            template<> long double __expint_En_cont_frac<long double>(unsigned int __n, long double __x)             {
                const unsigned int __max_iter = 1000;
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __fp_min = std::numeric_limits<long double>::min();
                const int __nm1 = __n - 1;
                long double __b = __x + long double(__n);
                long double __c = long double(1) / __fp_min;
                long double __d = long double(1) / __b;
                long double __h = __d;
                for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
                    long double __a = -long double(__i * (__nm1 + __i));
                    __b += long double(2);
                    __d = long double(1) / (__a * __d + __b);
                    __c = __b + __a / __c;
                    const long double __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - long double(1)) < __eps) {
                        const long double __ans = __h * std::exp(-__x);
                        return __ans;
                    }
                }
                std::__throw_runtime_error(("Continued fraction failed in __expint_En_cont_frac."));
            }
            template <typename _Tp> _Tp __expint_En_recursion(unsigned int __n, _Tp __x)             {
                _Tp __En;
                _Tp __E1 = __expint_E1(__x);
                if (__x < _Tp(__n)) {
                    __En = __E1;
                    for (unsigned int __j = 2; __j < __n; ++__j)
                        __En = (std::exp(- __x) - __x * __En) / _Tp(__j - 1);
                } else {
                    __En = _Tp(1);
                    const int __N = __n + 20;
                    _Tp __save = _Tp(0);
                    for (int __j = __N; __j > 0; --__j) {
                        __En = (std::exp(- __x) - __j * __En) / __x;
                        if (__j == __n)
                            __save = __En;
                    }
                    _Tp __norm = __En / __E1;
                    __En /= __norm;
                }
                return __En;
            }
            template <typename _Tp> _Tp __expint_Ei_series(_Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __x / __i;
                    __sum += __term / __i;
                    if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
                        break;
                }
                return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
            }
            template<> float __expint_Ei_series<float>(float __x)             {
                float __term = float(1);
                float __sum = float(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __x / __i;
                    __sum += __term / __i;
                    if (__term < std::numeric_limits<float>::epsilon() * __sum)
                        break;
                }
                return __numeric_constants<float>::__gamma_e() + __sum + std::log(__x);
            }
            template<> long double __expint_Ei_series<long double>(long double __x)             {
                long double __term = long double(1);
                long double __sum = long double(0);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    __term *= __x / __i;
                    __sum += __term / __i;
                    if (__term < std::numeric_limits<long double>::epsilon() * __sum)
                        break;
                }
                return __numeric_constants<long double>::__gamma_e() + __sum + std::log(__x);
            }
            template <typename _Tp> _Tp __expint_Ei_asymp(_Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(1);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    _Tp __prev = __term;
                    __term *= __i / __x;
                    if (__term < std::numeric_limits<_Tp>::epsilon())
                        break;
                    if (__term >= __prev)
                        break;
                    __sum += __term;
                }
                return std::exp(__x) * __sum / __x;
            }
            template<> float __expint_Ei_asymp<float>(float __x)             {
                float __term = float(1);
                float __sum = float(1);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    float __prev = __term;
                    __term *= __i / __x;
                    if (__term < std::numeric_limits<float>::epsilon())
                        break;
                    if (__term >= __prev)
                        break;
                    __sum += __term;
                }
                return std::exp(__x) * __sum / __x;
            }
            template<> long double __expint_Ei_asymp<long double>(long double __x)             {
                long double __term = long double(1);
                long double __sum = long double(1);
                const unsigned int __max_iter = 1000;
                for (unsigned int __i = 1; __i < __max_iter; ++__i) {
                    long double __prev = __term;
                    __term *= __i / __x;
                    if (__term < std::numeric_limits<long double>::epsilon())
                        break;
                    if (__term >= __prev)
                        break;
                    __sum += __term;
                }
                return std::exp(__x) * __sum / __x;
            }
            template <typename _Tp> _Tp __expint_Ei(_Tp __x)             {
                if (__x < _Tp(0))
                    return - __expint_E1(- __x);
                else if (__x < - std::log(std::numeric_limits<_Tp>::epsilon()))
                    return __expint_Ei_series(__x);
                else
                    return __expint_Ei_asymp(__x);
            }
            template<> float __expint_Ei<float>(float __x)             {
                if (__x < float(0))
                    return -__expint_E1(-__x);
                else if (__x < -std::log(std::numeric_limits<float>::epsilon()))
                    return __expint_Ei_series(__x);
                else
                    return __expint_Ei_asymp(__x);
            }
            template<> long double __expint_Ei<long double>(long double __x)             {
                if (__x < long double(0))
                    return -__expint_E1(-__x);
                else if (__x < -std::log(std::numeric_limits<long double>::epsilon()))
                    return __expint_Ei_series(__x);
                else
                    return __expint_Ei_asymp(__x);
            }
            template <typename _Tp> _Tp __expint_E1(_Tp __x)             {
                if (__x < _Tp(0))
                    return - __expint_Ei(- __x);
                else if (__x < _Tp(1))
                    return __expint_E1_series(__x);
                else if (__x < _Tp(100))
                    return __expint_En_cont_frac(1, __x);
                else
                    return __expint_E1_asymp(__x);
            }
            template<> float __expint_E1<float>(float __x)             {
                if (__x < float(0))
                    return -__expint_Ei(-__x);
                else if (__x < float(1))
                    return __expint_E1_series(__x);
                else if (__x < float(100))
                    return __expint_En_cont_frac(1, __x);
                else
                    return __expint_E1_asymp(__x);
            }
            template<> long double __expint_E1<long double>(long double __x)             {
                if (__x < long double(0))
                    return -__expint_Ei(-__x);
                else if (__x < long double(1))
                    return __expint_E1_series(__x);
                else if (__x < long double(100))
                    return __expint_En_cont_frac(1, __x);
                else
                    return __expint_E1_asymp(__x);
            }
            template <typename _Tp> _Tp __expint_asymp(unsigned int __n, _Tp __x)             {
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(1);
                for (unsigned int __i = 1; __i <= __n; ++__i) {
                    _Tp __prev = __term;
                    __term *= -(__n - __i + 1) / __x;
                    if (std::abs(__term) > std::abs(__prev))
                        break;
                    __sum += __term;
                }
                return std::exp(- __x) * __sum / __x;
            }
            template <typename _Tp> _Tp __expint_large_n(unsigned int __n, _Tp __x)             {
                const _Tp __xpn = __x + __n;
                const _Tp __xpn2 = __xpn * __xpn;
                _Tp __term = _Tp(1);
                _Tp __sum = _Tp(1);
                for (unsigned int __i = 1; __i <= __n; ++__i) {
                    _Tp __prev = __term;
                    __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
                    if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __sum += __term;
                }
                return std::exp(- __x) * __sum / __xpn;
            }
            template <typename _Tp> _Tp __expint(unsigned int __n, _Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__n <= 1 && __x == _Tp(0))
                    return std::numeric_limits<_Tp>::infinity();
                else {
                    _Tp __E0 = std::exp(__x) / __x;
                    if (__n == 0)
                        return __E0;
                    _Tp __E1 = __expint_E1(__x);
                    if (__n == 1)
                        return __E1;
                    if (__x == _Tp(0))
                        return _Tp(1) / static_cast<_Tp>(__n - 1);
                    _Tp __En = __expint_En_recursion(__n, __x);
                    return __En;
                }
            }
            template <typename _Tp> inline _Tp __expint(_Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __expint_Ei(__x);
            }
            template<> inline float __expint<float>(float __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __expint_Ei(__x);
            }
            template<> inline long double __expint<long double>(long double __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __expint_Ei(__x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                _Tp __term = _Tp(1);
                _Tp __Fac = _Tp(1);
                const unsigned int __max_iter = 100000;
                unsigned int __i;
                for (__i = 0; __i < __max_iter; ++__i) {
                    __term *= (__a + _Tp(__i)) * __x / ((__c + _Tp(__i)) * _Tp(1 + __i));
                    if (std::abs(__term) < __eps) {
                        break;
                    }
                    __Fac += __term;
                }
                if (__i == __max_iter)
                    std::__throw_runtime_error(("Series failed to converge in __conf_hyperg_series."));
                return __Fac;
            }
            template <typename _Tp> _Tp __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)             {
                const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.159999999999999999997L));
                const int __nmax = 20000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __x = - __xin;
                const _Tp __x3 = __x * __x * __x;
                const _Tp __t0 = __a / __c;
                const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
                const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
                _Tp __F = _Tp(1);
                _Tp __prec;
                _Tp __Bnm3 = _Tp(1);
                _Tp __Bnm2 = _Tp(1) + __t1 * __x;
                _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);
                _Tp __Anm3 = _Tp(1);
                _Tp __Anm2 = __Bnm2 - __t0 * __x;
                _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;
                int __n = 3;
                while (1)
                    {
                        _Tp __npam1 = _Tp(__n - 1) + __a;
                        _Tp __npcm1 = _Tp(__n - 1) + __c;
                        _Tp __npam2 = _Tp(__n - 2) + __a;
                        _Tp __npcm2 = _Tp(__n - 2) + __c;
                        _Tp __tnm1 = _Tp(2 * __n - 1);
                        _Tp __tnm3 = _Tp(2 * __n - 3);
                        _Tp __tnm5 = _Tp(2 * __n - 5);
                        _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
                        _Tp __F2 = (_Tp(__n) + __a) * __npam1 / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
                        _Tp __F3 = - __npam2 * __npam1 * (_Tp(__n - 2) - __a) / (_Tp(8) * __tnm3 * __tnm3 * __tnm5 * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
                        _Tp __E = - __npam1 * (_Tp(__n - 1) - __c) / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);
                        _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
                        _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
                        _Tp __r = __An / __Bn;
                        __prec = std::abs((__F - __r) / __F);
                        __F = __r;
                        if (__prec < __eps || __n > __nmax)
                            break;
                        if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
                            __An /= __big;
                            __Bn /= __big;
                            __Anm1 /= __big;
                            __Bnm1 /= __big;
                            __Anm2 /= __big;
                            __Bnm2 /= __big;
                            __Anm3 /= __big;
                            __Bnm3 /= __big;
                        } else if (std::abs(__An) < _Tp(1) / __big || std::abs(__Bn) < _Tp(1) / __big) {
                            __An *= __big;
                            __Bn *= __big;
                            __Anm1 *= __big;
                            __Bnm1 *= __big;
                            __Anm2 *= __big;
                            __Bnm2 *= __big;
                            __Anm3 *= __big;
                            __Bnm3 *= __big;
                        }
                        ++__n;
                        __Bnm3 = __Bnm2;
                        __Bnm2 = __Bnm1;
                        __Bnm1 = __Bn;
                        __Anm3 = __Anm2;
                        __Anm2 = __Anm1;
                        __Anm1 = __An;
                    }
                if (__n >= __nmax)
                    std::__throw_runtime_error(("Iteration failed to converge in __conf_hyperg_luke."));
                return __F;
            }
            template <typename _Tp> _Tp __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)             {
                const _Tp __c_nint = ::std::nearbyint(__c);
                if (__isnan(__a) || __isnan(__c) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__c_nint == __c && __c_nint <= 0)
                    return std::numeric_limits<_Tp>::infinity();
                else if (__a == _Tp(0))
                    return _Tp(1);
                else if (__c == __a)
                    return std::exp(__x);
                else if (__x < _Tp(0))
                    return __conf_hyperg_luke(__a, __c, __x);
                else
                    return __conf_hyperg_series(__a, __c, __x);
            }
            template <typename _Tp> _Tp __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)             {
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                _Tp __term = _Tp(1);
                _Tp __Fabc = _Tp(1);
                const unsigned int __max_iter = 100000;
                unsigned int __i;
                for (__i = 0; __i < __max_iter; ++__i) {
                    __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x / ((__c + _Tp(__i)) * _Tp(1 + __i));
                    if (std::abs(__term) < __eps) {
                        break;
                    }
                    __Fabc += __term;
                }
                if (__i == __max_iter)
                    std::__throw_runtime_error(("Series failed to converge in __hyperg_series."));
                return __Fabc;
            }
            template <typename _Tp> _Tp __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)             {
                const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.159999999999999999997L));
                const int __nmax = 20000;
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __x = - __xin;
                const _Tp __x3 = __x * __x * __x;
                const _Tp __t0 = __a * __b / __c;
                const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
                const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
                _Tp __F = _Tp(1);
                _Tp __Bnm3 = _Tp(1);
                _Tp __Bnm2 = _Tp(1) + __t1 * __x;
                _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);
                _Tp __Anm3 = _Tp(1);
                _Tp __Anm2 = __Bnm2 - __t0 * __x;
                _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;
                int __n = 3;
                while (1)
                    {
                        const _Tp __npam1 = _Tp(__n - 1) + __a;
                        const _Tp __npbm1 = _Tp(__n - 1) + __b;
                        const _Tp __npcm1 = _Tp(__n - 1) + __c;
                        const _Tp __npam2 = _Tp(__n - 2) + __a;
                        const _Tp __npbm2 = _Tp(__n - 2) + __b;
                        const _Tp __npcm2 = _Tp(__n - 2) + __c;
                        const _Tp __tnm1 = _Tp(2 * __n - 1);
                        const _Tp __tnm3 = _Tp(2 * __n - 3);
                        const _Tp __tnm5 = _Tp(2 * __n - 5);
                        const _Tp __n2 = __n * __n;
                        const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n + _Tp(2) - __a * __b - _Tp(2) * (__a + __b)) / (_Tp(2) * __tnm3 * __npcm1);
                        const _Tp __F2 = - (_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n + _Tp(2) - __a * __b) * __npam1 * __npbm1 / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
                        const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1 * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b)) / (_Tp(8) * __tnm3 * __tnm3 * __tnm5 * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
                        const _Tp __E = - __npam1 * __npbm1 * (_Tp(__n - 1) - __c) / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);
                        _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
                        _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
                        const _Tp __r = __An / __Bn;
                        const _Tp __prec = std::abs((__F - __r) / __F);
                        __F = __r;
                        if (__prec < __eps || __n > __nmax)
                            break;
                        if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
                            __An /= __big;
                            __Bn /= __big;
                            __Anm1 /= __big;
                            __Bnm1 /= __big;
                            __Anm2 /= __big;
                            __Bnm2 /= __big;
                            __Anm3 /= __big;
                            __Bnm3 /= __big;
                        } else if (std::abs(__An) < _Tp(1) / __big || std::abs(__Bn) < _Tp(1) / __big) {
                            __An *= __big;
                            __Bn *= __big;
                            __Anm1 *= __big;
                            __Bnm1 *= __big;
                            __Anm2 *= __big;
                            __Bnm2 *= __big;
                            __Anm3 *= __big;
                            __Bnm3 *= __big;
                        }
                        ++__n;
                        __Bnm3 = __Bnm2;
                        __Bnm2 = __Bnm1;
                        __Bnm1 = __Bn;
                        __Anm3 = __Anm2;
                        __Anm2 = __Anm1;
                        __Anm1 = __An;
                    }
                if (__n >= __nmax)
                    std::__throw_runtime_error(("Iteration failed to converge in __hyperg_luke."));
                return __F;
            }
            template <typename _Tp> _Tp __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)             {
                const _Tp __d = __c - __a - __b;
                const int __intd = std::floor(__d + _Tp(0.5L));
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __toler = _Tp(1000) * __eps;
                const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
                const bool __d_integer = (std::abs(__d - __intd) < __toler);
                if (__d_integer) {
                    const _Tp __ln_omx = std::log(_Tp(1) - __x);
                    const _Tp __ad = std::abs(__d);
                    _Tp __F1, __F2;
                    _Tp __d1, __d2;
                    if (__d >= _Tp(0)) {
                        __d1 = __d;
                        __d2 = _Tp(0);
                    } else {
                        __d1 = _Tp(0);
                        __d2 = __d;
                    }
                    const _Tp __lng_c = __log_gamma(__c);
                    if (__ad < __eps) {
                        __F1 = _Tp(0);
                    } else {
                        bool __ok_d1 = true;
                        _Tp __lng_ad, __lng_ad1, __lng_bd1;
                        try {
                            __lng_ad = __log_gamma(__ad);
                            __lng_ad1 = __log_gamma(__a + __d1);
                            __lng_bd1 = __log_gamma(__b + __d1);
                        } catch (...) {
                            __ok_d1 = false;
                        }
                        if (__ok_d1) {
                            _Tp __sum1 = _Tp(1);
                            _Tp __term = _Tp(1);
                            _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx - __lng_ad1 - __lng_bd1;
                            for (int __i = 1; __i < __ad; ++__i) {
                                const int __j = __i - 1;
                                __term *= (__a + __d2 + __j) * (__b + __d2 + __j) / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                                __sum1 += __term;
                            }
                            if (__ln_pre1 > __log_max)
                                std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_luke."));
                            else
                                __F1 = std::exp(__ln_pre1) * __sum1;
                        } else {
                            __F1 = _Tp(0);
                        }
                    }
                    bool __ok_d2 = true;
                    _Tp __lng_ad2, __lng_bd2;
                    try {
                        __lng_ad2 = __log_gamma(__a + __d2);
                        __lng_bd2 = __log_gamma(__b + __d2);
                    } catch (...) {
                        __ok_d2 = false;
                    }
                    if (__ok_d2) {
                        const int __maxiter = 2000;
                        const _Tp __psi_1 = - __numeric_constants<_Tp>::__gamma_e();
                        const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
                        const _Tp __psi_apd1 = __psi(__a + __d1);
                        const _Tp __psi_bpd1 = __psi(__b + __d1);
                        _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1 - __psi_bpd1 - __ln_omx;
                        _Tp __fact = _Tp(1);
                        _Tp __sum2 = __psi_term;
                        _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx - __lng_ad2 - __lng_bd2;
                        int __j;
                        for (__j = 1; __j < __maxiter; ++__j) {
                            const _Tp __term1 = _Tp(1) / _Tp(__j) + _Tp(1) / (__ad + __j);
                            const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1)) + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                            __psi_term += __term1 - __term2;
                            __fact *= (__a + __d1 + _Tp(__j - 1)) * (__b + __d1 + _Tp(__j - 1)) / ((__ad + __j) * __j) * (_Tp(1) - __x);
                            const _Tp __delta = __fact * __psi_term;
                            __sum2 += __delta;
                            if (std::abs(__delta) < __eps * std::abs(__sum2))
                                break;
                        }
                        if (__j == __maxiter)
                            std::__throw_runtime_error(("Sum F2 failed to converge in __hyperg_reflect"));
                        if (__sum2 == _Tp(0))
                            __F2 = _Tp(0);
                        else
                            __F2 = std::exp(__ln_pre2) * __sum2;
                    } else {
                        __F2 = _Tp(0);
                    }
                    const _Tp __sgn_2 = (__intd % 2 == 1 ? - _Tp(1) : _Tp(1));
                    const _Tp __F = __F1 + __sgn_2 * __F2;
                    return __F;
                } else {
                    bool __ok1 = true;
                    _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
                    _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
                    try {
                        __sgn_g1ca = __log_gamma_sign(__c - __a);
                        __ln_g1ca = __log_gamma(__c - __a);
                        __sgn_g1cb = __log_gamma_sign(__c - __b);
                        __ln_g1cb = __log_gamma(__c - __b);
                    } catch (...) {
                        __ok1 = false;
                    }
                    bool __ok2 = true;
                    _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
                    _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
                    try {
                        __sgn_g2a = __log_gamma_sign(__a);
                        __ln_g2a = __log_gamma(__a);
                        __sgn_g2b = __log_gamma_sign(__b);
                        __ln_g2b = __log_gamma(__b);
                    } catch (...) {
                        __ok2 = false;
                    }
                    const _Tp __sgn_gc = __log_gamma_sign(__c);
                    const _Tp __ln_gc = __log_gamma(__c);
                    const _Tp __sgn_gd = __log_gamma_sign(__d);
                    const _Tp __ln_gd = __log_gamma(__d);
                    const _Tp __sgn_gmd = __log_gamma_sign(- __d);
                    const _Tp __ln_gmd = __log_gamma(- __d);
                    const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
                    const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;
                    _Tp __pre1, __pre2;
                    if (__ok1 && __ok2) {
                        _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
                        _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b + __d * std::log(_Tp(1) - __x);
                        if (__ln_pre1 < __log_max && __ln_pre2 < __log_max) {
                            __pre1 = std::exp(__ln_pre1);
                            __pre2 = std::exp(__ln_pre2);
                            __pre1 *= __sgn1;
                            __pre2 *= __sgn2;
                        } else {
                            std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_reflect"));
                        }
                    } else if (__ok1 && !__ok2) {
                        _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
                        if (__ln_pre1 < __log_max) {
                            __pre1 = std::exp(__ln_pre1);
                            __pre1 *= __sgn1;
                            __pre2 = _Tp(0);
                        } else {
                            std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_reflect"));
                        }
                    } else if (!__ok1 && __ok2) {
                        _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b + __d * std::log(_Tp(1) - __x);
                        if (__ln_pre2 < __log_max) {
                            __pre1 = _Tp(0);
                            __pre2 = std::exp(__ln_pre2);
                            __pre2 *= __sgn2;
                        } else {
                            std::__throw_runtime_error(("Overflow of gamma functions in __hyperg_reflect"));
                        }
                    } else {
                        __pre1 = _Tp(0);
                        __pre2 = _Tp(0);
                        std::__throw_runtime_error(("Underflow of gamma functions in __hyperg_reflect"));
                    }
                    const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d, _Tp(1) - __x);
                    const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d, _Tp(1) - __x);
                    const _Tp __F = __pre1 * __F1 + __pre2 * __F2;
                    return __F;
                }
            }
            template <typename _Tp> _Tp __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)             {
                const _Tp __a_nint = ::std::nearbyint(__a);
                const _Tp __b_nint = ::std::nearbyint(__b);
                const _Tp __c_nint = ::std::nearbyint(__c);
                const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
                if (std::abs(__x) >= _Tp(1))
                    std::__throw_domain_error(("Argument outside unit circle in __hyperg."));
                else if (__isnan(__a) || __isnan(__b) || __isnan(__c) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__c_nint == __c && __c_nint <= _Tp(0))
                    return std::numeric_limits<_Tp>::infinity();
                else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
                    return std::pow(_Tp(1) - __x, __c - __a - __b);
                else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0) && __x >= _Tp(0) && __x < _Tp(0.995000000000000000004L))
                    return __hyperg_series(__a, __b, __c, __x);
                else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10)) {
                    if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
                        return __hyperg_series(__a_nint, __b, __c, __x);
                    else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
                        return __hyperg_series(__a, __b_nint, __c, __x);
                    else if (__x < - _Tp(0.25L))
                        return __hyperg_luke(__a, __b, __c, __x);
                    else if (__x < _Tp(0.5L))
                        return __hyperg_series(__a, __b, __c, __x);
                    else if (std::abs(__c) > _Tp(10))
                        return __hyperg_series(__a, __b, __c, __x);
                    else
                        return __hyperg_reflect(__a, __b, __c, __x);
                } else
                    return __hyperg_luke(__a, __b, __c, __x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __poly_legendre_p(unsigned int __l, _Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x == + _Tp(1))
                    return + _Tp(1);
                else if (__x == - _Tp(1))
                    return (__l % 2 == 1 ? - _Tp(1) : + _Tp(1));
                else {
                    _Tp __p_lm2 = _Tp(1);
                    if (__l == 0)
                        return __p_lm2;
                    _Tp __p_lm1 = __x;
                    if (__l == 1)
                        return __p_lm1;
                    _Tp __p_l = 0;
                    for (unsigned int __ll = 2; __ll <= __l; ++__ll) {
                        __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2 - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
                        __p_lm2 = __p_lm1;
                        __p_lm1 = __p_l;
                    }
                    return __p_l;
                }
            }
            template<> float __poly_legendre_p<float>(unsigned int __l, float __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x == +float(1))
                    return +float(1);
                else if (__x == -float(1))
                    return (__l % 2 == 1 ? -float(1) : +float(1));
                else {
                    float __p_lm2 = float(1);
                    if (__l == 0)
                        return __p_lm2;
                    float __p_lm1 = __x;
                    if (__l == 1)
                        return __p_lm1;
                    float __p_l = 0;
                    for (unsigned int __ll = 2; __ll <= __l; ++__ll) {
                        __p_l = float(2) * __x * __p_lm1 - __p_lm2 - (__x * __p_lm1 - __p_lm2) / float(__ll);
                        __p_lm2 = __p_lm1;
                        __p_lm1 = __p_l;
                    }
                    return __p_l;
                }
            }
            template<> long double __poly_legendre_p<long double>(unsigned int __l, long double __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x == +long double(1))
                    return +long double(1);
                else if (__x == -long double(1))
                    return (__l % 2 == 1 ? -long double(1) : +long double(1));
                else {
                    long double __p_lm2 = long double(1);
                    if (__l == 0)
                        return __p_lm2;
                    long double __p_lm1 = __x;
                    if (__l == 1)
                        return __p_lm1;
                    long double __p_l = 0;
                    for (unsigned int __ll = 2; __ll <= __l; ++__ll) {
                        __p_l = long double(2) * __x * __p_lm1 - __p_lm2 - (__x * __p_lm1 - __p_lm2) / long double(__ll);
                        __p_lm2 = __p_lm1;
                        __p_lm1 = __p_l;
                    }
                    return __p_l;
                }
            }
            template <typename _Tp> _Tp __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x, _Tp __phase = _Tp(+1))             {
                if (__m > __l)
                    return _Tp(0);
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__m == 0)
                    return __poly_legendre_p(__l, __x);
                else {
                    _Tp __p_mm = _Tp(1);
                    if (__m > 0) {
                        _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
                        _Tp __fact = _Tp(1);
                        for (unsigned int __i = 1; __i <= __m; ++__i) {
                            __p_mm *= __phase * __fact * __root;
                            __fact += _Tp(2);
                        }
                    }
                    if (__l == __m)
                        return __p_mm;
                    _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
                    if (__l == __m + 1)
                        return __p_mp1m;
                    _Tp __p_lm2m = __p_mm;
                    _Tp __P_lm1m = __p_mp1m;
                    _Tp __p_lm = _Tp(0);
                    for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
                        __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
                        __p_lm2m = __P_lm1m;
                        __P_lm1m = __p_lm;
                    }
                    return __p_lm;
                }
            }
            template<> float __assoc_legendre_p<float>(unsigned int __l, unsigned int __m, float __x, float __phase = float(+1))             {
                if (__m > __l)
                    return float(0);
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__m == 0)
                    return __poly_legendre_p(__l, __x);
                else {
                    float __p_mm = float(1);
                    if (__m > 0) {
                        float __root = std::sqrt(float(1) - __x) * std::sqrt(float(1) + __x);
                        float __fact = float(1);
                        for (unsigned int __i = 1; __i <= __m; ++__i) {
                            __p_mm *= __phase * __fact * __root;
                            __fact += float(2);
                        }
                    }
                    if (__l == __m)
                        return __p_mm;
                    float __p_mp1m = float(2 * __m + 1) * __x * __p_mm;
                    if (__l == __m + 1)
                        return __p_mp1m;
                    float __p_lm2m = __p_mm;
                    float __P_lm1m = __p_mp1m;
                    float __p_lm = float(0);
                    for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
                        __p_lm = (float(2 * __j - 1) * __x * __P_lm1m - float(__j + __m - 1) * __p_lm2m) / float(__j - __m);
                        __p_lm2m = __P_lm1m;
                        __P_lm1m = __p_lm;
                    }
                    return __p_lm;
                }
            }
            template<> long double __assoc_legendre_p<long double>(unsigned int __l, unsigned int __m, long double __x, long double __phase = long double(+1))             {
                if (__m > __l)
                    return long double(0);
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__m == 0)
                    return __poly_legendre_p(__l, __x);
                else {
                    long double __p_mm = long double(1);
                    if (__m > 0) {
                        long double __root = std::sqrt(long double(1) - __x) * std::sqrt(long double(1) + __x);
                        long double __fact = long double(1);
                        for (unsigned int __i = 1; __i <= __m; ++__i) {
                            __p_mm *= __phase * __fact * __root;
                            __fact += long double(2);
                        }
                    }
                    if (__l == __m)
                        return __p_mm;
                    long double __p_mp1m = long double(2 * __m + 1) * __x * __p_mm;
                    if (__l == __m + 1)
                        return __p_mp1m;
                    long double __p_lm2m = __p_mm;
                    long double __P_lm1m = __p_mp1m;
                    long double __p_lm = long double(0);
                    for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
                        __p_lm = (long double(2 * __j - 1) * __x * __P_lm1m - long double(__j + __m - 1) * __p_lm2m) / long double(__j - __m);
                        __p_lm2m = __P_lm1m;
                        __P_lm1m = __p_lm;
                    }
                    return __p_lm;
                }
            }
            template <typename _Tp> _Tp __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)             {
                if (__isnan(__theta))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                const _Tp __x = std::cos(__theta);
                if (__m > __l)
                    return _Tp(0);
                else if (__m == 0) {
                    _Tp __P = __poly_legendre_p(__l, __x);
                    _Tp __fact = std::sqrt(_Tp(2 * __l + 1) / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
                    __P *= __fact;
                    return __P;
                } else if (__x == _Tp(1) || __x == - _Tp(1)) {
                    return _Tp(0);
                } else {
                    const _Tp __sgn = (__m % 2 == 1 ? - _Tp(1) : _Tp(1));
                    const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));
                    const _Tp __lncirc = ::std::log1p(- __x * __x);
                    const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L))) - ::std::lgamma(_Tp(__m));
                    const _Tp __lnpre_val = - _Tp(0.25L) * __numeric_constants<_Tp>::__lnpi() + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
                    const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m) / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
                    _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
                    _Tp __y_mp1m = __y_mp1m_factor * __y_mm;
                    if (__l == __m)
                        return __y_mm;
                    else if (__l == __m + 1)
                        return __y_mp1m;
                    else {
                        _Tp __y_lm = _Tp(0);
                        for (int __ll = __m + 2; __ll <= __l; ++__ll) {
                            const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                            const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                            const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1) * _Tp(2 * __ll - 1));
                            const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1) / _Tp(2 * __ll - 3));
                            __y_lm = (__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                            __y_mm = __y_mp1m;
                            __y_mp1m = __y_lm;
                        }
                        return __y_lm;
                    }
                }
            }
            template<> float __sph_legendre<float>(unsigned int __l, unsigned int __m, float __theta)             {
                if (__isnan(__theta))
                    return std::numeric_limits<float>::quiet_NaN();
                const float __x = std::cos(__theta);
                if (__m > __l)
                    return float(0);
                else if (__m == 0) {
                    float __P = __poly_legendre_p(__l, __x);
                    float __fact = std::sqrt(float(2 * __l + 1) / (float(4) * __numeric_constants<float>::__pi()));
                    __P *= __fact;
                    return __P;
                } else if (__x == float(1) || __x == -float(1)) {
                    return float(0);
                } else {
                    const float __sgn = (__m % 2 == 1 ? -float(1) : float(1));
                    const float __y_mp1m_factor = __x * std::sqrt(float(2 * __m + 3));
                    const float __lncirc = ::std::log1p(-__x * __x);
                    const float __lnpoch = ::std::lgamma(float(__m + float(0.5L))) - ::std::lgamma(float(__m));
                    const float __lnpre_val = -float(0.25L) * __numeric_constants<float>::__lnpi() + float(0.5L) * (__lnpoch + __m * __lncirc);
                    const float __sr = std::sqrt((float(2) + float(1) / __m) / (float(4) * __numeric_constants<float>::__pi()));
                    float __y_mm = __sgn * __sr * std::exp(__lnpre_val);
                    float __y_mp1m = __y_mp1m_factor * __y_mm;
                    if (__l == __m)
                        return __y_mm;
                    else if (__l == __m + 1)
                        return __y_mp1m;
                    else {
                        float __y_lm = float(0);
                        for (int __ll = __m + 2; __ll <= __l; ++__ll) {
                            const float __rat1 = float(__ll - __m) / float(__ll + __m);
                            const float __rat2 = float(__ll - __m - 1) / float(__ll + __m - 1);
                            const float __fact1 = std::sqrt(__rat1 * float(2 * __ll + 1) * float(2 * __ll - 1));
                            const float __fact2 = std::sqrt(__rat1 * __rat2 * float(2 * __ll + 1) / float(2 * __ll - 3));
                            __y_lm = (__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) / float(__ll - __m);
                            __y_mm = __y_mp1m;
                            __y_mp1m = __y_lm;
                        }
                        return __y_lm;
                    }
                }
            }
            template<> long double __sph_legendre<long double>(unsigned int __l, unsigned int __m, long double __theta)             {
                if (__isnan(__theta))
                    return std::numeric_limits<long double>::quiet_NaN();
                const long double __x = std::cos(__theta);
                if (__m > __l)
                    return long double(0);
                else if (__m == 0) {
                    long double __P = __poly_legendre_p(__l, __x);
                    long double __fact = std::sqrt(long double(2 * __l + 1) / (long double(4) * __numeric_constants<long double>::__pi()));
                    __P *= __fact;
                    return __P;
                } else if (__x == long double(1) || __x == -long double(1)) {
                    return long double(0);
                } else {
                    const long double __sgn = (__m % 2 == 1 ? -long double(1) : long double(1));
                    const long double __y_mp1m_factor = __x * std::sqrt(long double(2 * __m + 3));
                    const long double __lncirc = ::std::log1p(-__x * __x);
                    const long double __lnpoch = ::std::lgamma(long double(__m + long double(0.5L))) - ::std::lgamma(long double(__m));
                    const long double __lnpre_val = -long double(0.25L) * __numeric_constants<long double>::__lnpi() + long double(0.5L) * (__lnpoch + __m * __lncirc);
                    const long double __sr = std::sqrt((long double(2) + long double(1) / __m) / (long double(4) * __numeric_constants<long double>::__pi()));
                    long double __y_mm = __sgn * __sr * std::exp(__lnpre_val);
                    long double __y_mp1m = __y_mp1m_factor * __y_mm;
                    if (__l == __m)
                        return __y_mm;
                    else if (__l == __m + 1)
                        return __y_mp1m;
                    else {
                        long double __y_lm = long double(0);
                        for (int __ll = __m + 2; __ll <= __l; ++__ll) {
                            const long double __rat1 = long double(__ll - __m) / long double(__ll + __m);
                            const long double __rat2 = long double(__ll - __m - 1) / long double(__ll + __m - 1);
                            const long double __fact1 = std::sqrt(__rat1 * long double(2 * __ll + 1) * long double(2 * __ll - 1));
                            const long double __fact2 = std::sqrt(__rat1 * __rat2 * long double(2 * __ll + 1) / long double(2 * __ll - 3));
                            __y_lm = (__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) / long double(__ll - __m);
                            __y_mm = __y_mp1m;
                            __y_mp1m = __y_lm;
                        }
                        return __y_lm;
                    }
                }
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> void __bessel_ik(_Tp __nu, _Tp __x, _Tp &__Inu, _Tp &__Knu, _Tp &__Ipnu, _Tp &__Kpnu)             {
                if (__x == _Tp(0)) {
                    if (__nu == _Tp(0)) {
                        __Inu = _Tp(1);
                        __Ipnu = _Tp(0);
                    } else if (__nu == _Tp(1)) {
                        __Inu = _Tp(0);
                        __Ipnu = _Tp(0.5L);
                    } else {
                        __Inu = _Tp(0);
                        __Ipnu = _Tp(0);
                    }
                    __Knu = std::numeric_limits<_Tp>::infinity();
                    __Kpnu = - std::numeric_limits<_Tp>::infinity();
                    return;
                }
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
                const int __max_iter = 15000;
                const _Tp __x_min = _Tp(2);
                const int __nl = static_cast<int>(__nu + _Tp(0.5L));
                const _Tp __mu = __nu - __nl;
                const _Tp __mu2 = __mu * __mu;
                const _Tp __xi = _Tp(1) / __x;
                const _Tp __xi2 = _Tp(2) * __xi;
                _Tp __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                _Tp __b = __xi2 * __nu;
                _Tp __d = _Tp(0);
                _Tp __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = _Tp(1) / (__b + __d);
                    __c = __b + _Tp(1) / __c;
                    const _Tp __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - _Tp(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_ik; try asymptotic expansion."));
                _Tp __Inul = __fp_min;
                _Tp __Ipnul = __h * __Inul;
                _Tp __Inul1 = __Inul;
                _Tp __Ipnu1 = __Ipnul;
                _Tp __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const _Tp __Inutemp = __fact * __Inul + __Ipnul;
                    __fact -= __xi;
                    __Ipnul = __fact * __Inutemp + __Inul;
                    __Inul = __Inutemp;
                }
                _Tp __f = __Ipnul / __Inul;
                _Tp __Kmu, __Knu1;
                if (__x < __x_min) {
                    const _Tp __x2 = __x / _Tp(2);
                    const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
                    const _Tp __fact = (std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
                    _Tp __d = - std::log(__x2);
                    _Tp __e = __mu * __d;
                    const _Tp __fact2 = (std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
                    _Tp __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    _Tp __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    _Tp __sum = __ff;
                    __e = std::exp(__e);
                    _Tp __p = __e / (_Tp(2) * __gampl);
                    _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
                    _Tp __c = _Tp(1);
                    __d = __x2 * __x2;
                    _Tp __sum1 = __p;
                    int __i;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / __i;
                        __p /= __i - __mu;
                        __q /= __i + __mu;
                        const _Tp __del = __c * __ff;
                        __sum += __del;
                        const _Tp __del1 = __c * (__p - __i * __ff);
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * std::abs(__sum))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel k series failed to converge in __bessel_ik."));
                    __Kmu = __sum;
                    __Knu1 = __sum1 * __xi2;
                } else {
                    _Tp __b = _Tp(2) * (_Tp(1) + __x);
                    _Tp __d = _Tp(1) / __b;
                    _Tp __delh = __d;
                    _Tp __h = __delh;
                    _Tp __q1 = _Tp(0);
                    _Tp __q2 = _Tp(1);
                    _Tp __a1 = _Tp(0.25L) - __mu2;
                    _Tp __q = __c = __a1;
                    _Tp __a = - __a1;
                    _Tp __s = _Tp(1) + __q * __delh;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a -= 2 * (__i - 1);
                        __c = - __a * __c / __i;
                        const _Tp __qnew = (__q1 - __b * __q2) / __a;
                        __q1 = __q2;
                        __q2 = __qnew;
                        __q += __c * __qnew;
                        __b += _Tp(2);
                        __d = _Tp(1) / (__b + __a * __d);
                        __delh = (__b * __d - _Tp(1)) * __delh;
                        __h += __delh;
                        const _Tp __dels = __q * __delh;
                        __s += __dels;
                        if (std::abs(__dels / __s) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Steed's method failed in __bessel_ik."));
                    __h = __a1 * __h;
                    __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x)) * std::exp(- __x) / __s;
                    __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
                }
                _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
                _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
                __Inu = __Inumu * __Inul1 / __Inul;
                __Ipnu = __Inumu * __Ipnu1 / __Inul;
                for (__i = 1; __i <= __nl; ++__i) {
                    const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
                    __Kmu = __Knu1;
                    __Knu1 = __Knutemp;
                }
                __Knu = __Kmu;
                __Kpnu = __nu * __xi * __Kmu - __Knu1;
                return;
            }
            template<> void __bessel_ik<float>(float __nu, float __x, float &__Inu, float &__Knu, float &__Ipnu, float &__Kpnu)             {
                if (__x == float(0)) {
                    if (__nu == float(0)) {
                        __Inu = float(1);
                        __Ipnu = float(0);
                    } else if (__nu == float(1)) {
                        __Inu = float(0);
                        __Ipnu = float(0.5L);
                    } else {
                        __Inu = float(0);
                        __Ipnu = float(0);
                    }
                    __Knu = std::numeric_limits<float>::infinity();
                    __Kpnu = -std::numeric_limits<float>::infinity();
                    return;
                }
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __fp_min = float(10) * std::numeric_limits<float>::epsilon();
                const int __max_iter = 15000;
                const float __x_min = float(2);
                const int __nl = static_cast<int>(__nu + float(0.5L));
                const float __mu = __nu - __nl;
                const float __mu2 = __mu * __mu;
                const float __xi = float(1) / __x;
                const float __xi2 = float(2) * __xi;
                float __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                float __b = __xi2 * __nu;
                float __d = float(0);
                float __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = float(1) / (__b + __d);
                    __c = __b + float(1) / __c;
                    const float __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - float(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_ik; try asymptotic expansion."));
                float __Inul = __fp_min;
                float __Ipnul = __h * __Inul;
                float __Inul1 = __Inul;
                float __Ipnu1 = __Ipnul;
                float __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const float __Inutemp = __fact * __Inul + __Ipnul;
                    __fact -= __xi;
                    __Ipnul = __fact * __Inutemp + __Inul;
                    __Inul = __Inutemp;
                }
                float __f = __Ipnul / __Inul;
                float __Kmu, __Knu1;
                if (__x < __x_min) {
                    const float __x2 = __x / float(2);
                    const float __pimu = __numeric_constants<float>::__pi() * __mu;
                    const float __fact = (std::abs(__pimu) < __eps ? float(1) : __pimu / std::sin(__pimu));
                    float __d = -std::log(__x2);
                    float __e = __mu * __d;
                    const float __fact2 = (std::abs(__e) < __eps ? float(1) : std::sinh(__e) / __e);
                    float __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    float __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    float __sum = __ff;
                    __e = std::exp(__e);
                    float __p = __e / (float(2) * __gampl);
                    float __q = float(1) / (float(2) * __e * __gammi);
                    float __c = float(1);
                    __d = __x2 * __x2;
                    float __sum1 = __p;
                    int __i;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / __i;
                        __p /= __i - __mu;
                        __q /= __i + __mu;
                        const float __del = __c * __ff;
                        __sum += __del;
                        const float __del1 = __c * (__p - __i * __ff);
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * std::abs(__sum))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel k series failed to converge in __bessel_ik."));
                    __Kmu = __sum;
                    __Knu1 = __sum1 * __xi2;
                } else {
                    float __b = float(2) * (float(1) + __x);
                    float __d = float(1) / __b;
                    float __delh = __d;
                    float __h = __delh;
                    float __q1 = float(0);
                    float __q2 = float(1);
                    float __a1 = float(0.25L) - __mu2;
                    float __q = __c = __a1;
                    float __a = -__a1;
                    float __s = float(1) + __q * __delh;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a -= 2 * (__i - 1);
                        __c = -__a * __c / __i;
                        const float __qnew = (__q1 - __b * __q2) / __a;
                        __q1 = __q2;
                        __q2 = __qnew;
                        __q += __c * __qnew;
                        __b += float(2);
                        __d = float(1) / (__b + __a * __d);
                        __delh = (__b * __d - float(1)) * __delh;
                        __h += __delh;
                        const float __dels = __q * __delh;
                        __s += __dels;
                        if (std::abs(__dels / __s) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Steed's method failed in __bessel_ik."));
                    __h = __a1 * __h;
                    __Kmu = std::sqrt(__numeric_constants<float>::__pi() / (float(2) * __x)) * std::exp(-__x) / __s;
                    __Knu1 = __Kmu * (__mu + __x + float(0.5L) - __h) * __xi;
                }
                float __Kpmu = __mu * __xi * __Kmu - __Knu1;
                float __Inumu = __xi / (__f * __Kmu - __Kpmu);
                __Inu = __Inumu * __Inul1 / __Inul;
                __Ipnu = __Inumu * __Ipnu1 / __Inul;
                for (__i = 1; __i <= __nl; ++__i) {
                    const float __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
                    __Kmu = __Knu1;
                    __Knu1 = __Knutemp;
                }
                __Knu = __Kmu;
                __Kpnu = __nu * __xi * __Kmu - __Knu1;
                return;
            }
            template<> void __bessel_ik<long double>(long double __nu, long double __x, long double &__Inu, long double &__Knu, long double &__Ipnu, long double &__Kpnu)             {
                if (__x == long double(0)) {
                    if (__nu == long double(0)) {
                        __Inu = long double(1);
                        __Ipnu = long double(0);
                    } else if (__nu == long double(1)) {
                        __Inu = long double(0);
                        __Ipnu = long double(0.5L);
                    } else {
                        __Inu = long double(0);
                        __Ipnu = long double(0);
                    }
                    __Knu = std::numeric_limits<long double>::infinity();
                    __Kpnu = -std::numeric_limits<long double>::infinity();
                    return;
                }
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __fp_min = long double(10) * std::numeric_limits<long double>::epsilon();
                const int __max_iter = 15000;
                const long double __x_min = long double(2);
                const int __nl = static_cast<int>(__nu + long double(0.5L));
                const long double __mu = __nu - __nl;
                const long double __mu2 = __mu * __mu;
                const long double __xi = long double(1) / __x;
                const long double __xi2 = long double(2) * __xi;
                long double __h = __nu * __xi;
                if (__h < __fp_min)
                    __h = __fp_min;
                long double __b = __xi2 * __nu;
                long double __d = long double(0);
                long double __c = __h;
                int __i;
                for (__i = 1; __i <= __max_iter; ++__i) {
                    __b += __xi2;
                    __d = long double(1) / (__b + __d);
                    __c = __b + long double(1) / __c;
                    const long double __del = __c * __d;
                    __h *= __del;
                    if (std::abs(__del - long double(1)) < __eps)
                        break;
                }
                if (__i > __max_iter)
                    std::__throw_runtime_error(("Argument x too large in __bessel_ik; try asymptotic expansion."));
                long double __Inul = __fp_min;
                long double __Ipnul = __h * __Inul;
                long double __Inul1 = __Inul;
                long double __Ipnu1 = __Ipnul;
                long double __fact = __nu * __xi;
                for (int __l = __nl; __l >= 1; --__l) {
                    const long double __Inutemp = __fact * __Inul + __Ipnul;
                    __fact -= __xi;
                    __Ipnul = __fact * __Inutemp + __Inul;
                    __Inul = __Inutemp;
                }
                long double __f = __Ipnul / __Inul;
                long double __Kmu, __Knu1;
                if (__x < __x_min) {
                    const long double __x2 = __x / long double(2);
                    const long double __pimu = __numeric_constants<long double>::__pi() * __mu;
                    const long double __fact = (std::abs(__pimu) < __eps ? long double(1) : __pimu / std::sin(__pimu));
                    long double __d = -std::log(__x2);
                    long double __e = __mu * __d;
                    const long double __fact2 = (std::abs(__e) < __eps ? long double(1) : std::sinh(__e) / __e);
                    long double __gam1, __gam2, __gampl, __gammi;
                    __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
                    long double __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
                    long double __sum = __ff;
                    __e = std::exp(__e);
                    long double __p = __e / (long double(2) * __gampl);
                    long double __q = long double(1) / (long double(2) * __e * __gammi);
                    long double __c = long double(1);
                    __d = __x2 * __x2;
                    long double __sum1 = __p;
                    int __i;
                    for (__i = 1; __i <= __max_iter; ++__i) {
                        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
                        __c *= __d / __i;
                        __p /= __i - __mu;
                        __q /= __i + __mu;
                        const long double __del = __c * __ff;
                        __sum += __del;
                        const long double __del1 = __c * (__p - __i * __ff);
                        __sum1 += __del1;
                        if (std::abs(__del) < __eps * std::abs(__sum))
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Bessel k series failed to converge in __bessel_ik."));
                    __Kmu = __sum;
                    __Knu1 = __sum1 * __xi2;
                } else {
                    long double __b = long double(2) * (long double(1) + __x);
                    long double __d = long double(1) / __b;
                    long double __delh = __d;
                    long double __h = __delh;
                    long double __q1 = long double(0);
                    long double __q2 = long double(1);
                    long double __a1 = long double(0.25L) - __mu2;
                    long double __q = __c = __a1;
                    long double __a = -__a1;
                    long double __s = long double(1) + __q * __delh;
                    int __i;
                    for (__i = 2; __i <= __max_iter; ++__i) {
                        __a -= 2 * (__i - 1);
                        __c = -__a * __c / __i;
                        const long double __qnew = (__q1 - __b * __q2) / __a;
                        __q1 = __q2;
                        __q2 = __qnew;
                        __q += __c * __qnew;
                        __b += long double(2);
                        __d = long double(1) / (__b + __a * __d);
                        __delh = (__b * __d - long double(1)) * __delh;
                        __h += __delh;
                        const long double __dels = __q * __delh;
                        __s += __dels;
                        if (std::abs(__dels / __s) < __eps)
                            break;
                    }
                    if (__i > __max_iter)
                        std::__throw_runtime_error(("Steed's method failed in __bessel_ik."));
                    __h = __a1 * __h;
                    __Kmu = std::sqrt(__numeric_constants<long double>::__pi() / (long double(2) * __x)) * std::exp(-__x) / __s;
                    __Knu1 = __Kmu * (__mu + __x + long double(0.5L) - __h) * __xi;
                }
                long double __Kpmu = __mu * __xi * __Kmu - __Knu1;
                long double __Inumu = __xi / (__f * __Kmu - __Kpmu);
                __Inu = __Inumu * __Inul1 / __Inul;
                __Ipnu = __Inumu * __Ipnu1 / __Inul;
                for (__i = 1; __i <= __nl; ++__i) {
                    const long double __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
                    __Kmu = __Knu1;
                    __Knu1 = __Knutemp;
                }
                __Knu = __Kmu;
                __Kpnu = __nu * __xi * __Kmu - __Knu1;
                return;
            }
            template <typename _Tp> _Tp __cyl_bessel_i(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_i."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
                    return __cyl_bessel_ij_series(__nu, __x, + _Tp(1), 200);
                else {
                    _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __I_nu;
                }
            }
            template<> float __cyl_bessel_i<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_i."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__x * __x < float(10) * (__nu + float(1)))
                    return __cyl_bessel_ij_series(__nu, __x, +float(1), 200);
                else {
                    float __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __I_nu;
                }
            }
            template<> long double __cyl_bessel_i<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_i."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__x * __x < long double(10) * (__nu + long double(1)))
                    return __cyl_bessel_ij_series(__nu, __x, +long double(1), 200);
                else {
                    long double __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __I_nu;
                }
            }
            template <typename _Tp> _Tp __cyl_bessel_k(_Tp __nu, _Tp __x)             {
                if (__nu < _Tp(0) || __x < _Tp(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_k."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else {
                    _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __K_nu;
                }
            }
            template<> float __cyl_bessel_k<float>(float __nu, float __x)             {
                if (__nu < float(0) || __x < float(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_k."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else {
                    float __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __K_nu;
                }
            }
            template<> long double __cyl_bessel_k<long double>(long double __nu, long double __x)             {
                if (__nu < long double(0) || __x < long double(0))
                    std::__throw_domain_error(("Bad argument in __cyl_bessel_k."));
                else if (__isnan(__nu) || __isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else {
                    long double __I_nu, __K_nu, __Ip_nu, __Kp_nu;
                    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    return __K_nu;
                }
            }
            template <typename _Tp> void __sph_bessel_ik(unsigned int __n, _Tp __x, _Tp &__i_n, _Tp &__k_n, _Tp &__ip_n, _Tp &__kp_n)             {
                const _Tp __nu = _Tp(__n) + _Tp(0.5L);
                _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
                __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);
                __i_n = __factor * __I_nu;
                __k_n = __factor * __K_nu;
                __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
                __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);
                return;
            }
            template <typename _Tp> void __airy(_Tp __x, _Tp &__Ai, _Tp &__Bi, _Tp &__Aip, _Tp &__Bip)             {
                const _Tp __absx = std::abs(__x);
                const _Tp __rootx = std::sqrt(__absx);
                const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
                const _Tp _S_NaN = std::numeric_limits<_Tp>::quiet_NaN();
                const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();
                if (__isnan(__x))
                    __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
                else if (__z == _S_inf) {
                    __Aip = __Ai = _Tp(0);
                    __Bip = __Bi = _S_inf;
                } else if (__z == - _S_inf)
                    __Bip = __Aip = __Bi = __Ai = _Tp(0);
                else if (__x > _Tp(0)) {
                    _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
                    __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    __Ai = __rootx * __K_nu / (__numeric_constants<_Tp>::__sqrt3() * __numeric_constants<_Tp>::__pi());
                    __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi() + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());
                    __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
                    __Aip = - __x * __K_nu / (__numeric_constants<_Tp>::__sqrt3() * __numeric_constants<_Tp>::__pi());
                    __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi() + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());
                } else if (__x < _Tp(0)) {
                    _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;
                    __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    __Ai = __rootx * (__J_nu - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
                    __Bi = - __rootx * (__N_nu + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
                    __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
                    __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3() + __J_nu) / _Tp(2);
                    __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3() - __N_nu) / _Tp(2);
                } else {
                    __Ai = _Tp(0.355028053887817239255L);
                    __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();
                    __Aip = - _Tp(0.258819403792806798393L);
                    __Bip = - __Aip * __numeric_constants<_Tp>::__sqrt3();
                }
                return;
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __poly_hermite_recursion(unsigned int __n, _Tp __x)             {
                _Tp __H_0 = 1;
                if (__n == 0)
                    return __H_0;
                _Tp __H_1 = 2 * __x;
                if (__n == 1)
                    return __H_1;
                _Tp __H_n, __H_nm1, __H_nm2;
                unsigned int __i;
                for (__H_nm2 = __H_0 , __H_nm1 = __H_1 , __i = 2; __i <= __n; ++__i) {
                    __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
                    __H_nm2 = __H_nm1;
                    __H_nm1 = __H_n;
                }
                return __H_n;
            }
            template<> float __poly_hermite_recursion<float>(unsigned int __n, float __x)             {
                float __H_0 = 1;
                if (__n == 0)
                    return __H_0;
                float __H_1 = 2 * __x;
                if (__n == 1)
                    return __H_1;
                float __H_n, __H_nm1, __H_nm2;
                unsigned int __i;
                for (__H_nm2 = __H_0 , __H_nm1 = __H_1 , __i = 2; __i <= __n; ++__i) {
                    __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
                    __H_nm2 = __H_nm1;
                    __H_nm1 = __H_n;
                }
                return __H_n;
            }
            template<> long double __poly_hermite_recursion<long double>(unsigned int __n, long double __x)             {
                long double __H_0 = 1;
                if (__n == 0)
                    return __H_0;
                long double __H_1 = 2 * __x;
                if (__n == 1)
                    return __H_1;
                long double __H_n, __H_nm1, __H_nm2;
                unsigned int __i;
                for (__H_nm2 = __H_0 , __H_nm1 = __H_1 , __i = 2; __i <= __n; ++__i) {
                    __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
                    __H_nm2 = __H_nm1;
                    __H_nm1 = __H_n;
                }
                return __H_n;
            }
            template <typename _Tp> inline _Tp __poly_hermite(unsigned int __n, _Tp __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else
                    return __poly_hermite_recursion(__n, __x);
            }
            template<> inline float __poly_hermite<float>(unsigned int __n, float __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else
                    return __poly_hermite_recursion(__n, __x);
            }
            template<> inline long double __poly_hermite<long double>(unsigned int __n, long double __x)             {
                if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else
                    return __poly_hermite_recursion(__n, __x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre_large_n(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                const _Tp __a = - _Tp(__n);
                const _Tp __b = _Tp(__alpha1) + _Tp(1);
                const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
                const _Tp __cos2th = __x / __eta;
                const _Tp __sin2th = _Tp(1) - __cos2th;
                const _Tp __th = std::acos(std::sqrt(__cos2th));
                const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2() * __numeric_constants<_Tp>::__pi_2() * __eta * __eta * __cos2th * __sin2th;
                const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
                const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));
                _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b) * std::log(_Tp(0.25L) * __x * __eta);
                _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
                _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x + __pre_term1 - __pre_term2;
                _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
                _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta * (_Tp(2) * __th - std::sin(_Tp(2) * __th)) + __numeric_constants<_Tp>::__pi_4());
                _Tp __ser = __ser_term1 + __ser_term2;
                return std::exp(__lnpre) * __ser;
            }
            template<> float __poly_laguerre_large_n<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                const float __a = -float(__n);
                const float __b = float(__alpha1) + float(1);
                const float __eta = float(2) * __b - float(4) * __a;
                const float __cos2th = __x / __eta;
                const float __sin2th = float(1) - __cos2th;
                const float __th = std::acos(std::sqrt(__cos2th));
                const float __pre_h = __numeric_constants<float>::__pi_2() * __numeric_constants<float>::__pi_2() * __eta * __eta * __cos2th * __sin2th;
                const float __lg_b = ::std::lgamma(float(__n) + __b);
                const float __lnfact = ::std::lgamma(float(__n + 1));
                float __pre_term1 = float(0.5L) * (float(1) - __b) * std::log(float(0.25L) * __x * __eta);
                float __pre_term2 = float(0.25L) * std::log(__pre_h);
                float __lnpre = __lg_b - __lnfact + float(0.5L) * __x + __pre_term1 - __pre_term2;
                float __ser_term1 = std::sin(__a * __numeric_constants<float>::__pi());
                float __ser_term2 = std::sin(float(0.25L) * __eta * (float(2) * __th - std::sin(float(2) * __th)) + __numeric_constants<float>::__pi_4());
                float __ser = __ser_term1 + __ser_term2;
                return std::exp(__lnpre) * __ser;
            }
            template<> long double __poly_laguerre_large_n<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                const long double __a = -long double(__n);
                const long double __b = long double(__alpha1) + long double(1);
                const long double __eta = long double(2) * __b - long double(4) * __a;
                const long double __cos2th = __x / __eta;
                const long double __sin2th = long double(1) - __cos2th;
                const long double __th = std::acos(std::sqrt(__cos2th));
                const long double __pre_h = __numeric_constants<long double>::__pi_2() * __numeric_constants<long double>::__pi_2() * __eta * __eta * __cos2th * __sin2th;
                const long double __lg_b = ::std::lgamma(long double(__n) + __b);
                const long double __lnfact = ::std::lgamma(long double(__n + 1));
                long double __pre_term1 = long double(0.5L) * (long double(1) - __b) * std::log(long double(0.25L) * __x * __eta);
                long double __pre_term2 = long double(0.25L) * std::log(__pre_h);
                long double __lnpre = __lg_b - __lnfact + long double(0.5L) * __x + __pre_term1 - __pre_term2;
                long double __ser_term1 = std::sin(__a * __numeric_constants<long double>::__pi());
                long double __ser_term2 = std::sin(long double(0.25L) * __eta * (long double(2) * __th - std::sin(long double(2) * __th)) + __numeric_constants<long double>::__pi_4());
                long double __ser = __ser_term1 + __ser_term2;
                return std::exp(__lnpre) * __ser;
            }
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                const _Tp __b = _Tp(__alpha1) + _Tp(1);
                const _Tp __mx = - __x;
                const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1) : ((__n % 2 == 1) ? - _Tp(1) : _Tp(1)));
                _Tp __tc = _Tp(1);
                const _Tp __ax = std::abs(__x);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __tc *= (__ax / __k);
                _Tp __term = __tc * __tc_sgn;
                _Tp __sum = __term;
                for (int __k = int(__n) - 1; __k >= 0; --__k) {
                    __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k)) * _Tp(__k + 1) / __mx;
                    __sum += __term;
                }
                return __sum;
            }
            template<> float __poly_laguerre_hyperg<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                const float __b = float(__alpha1) + float(1);
                const float __mx = -__x;
                const float __tc_sgn = (__x < float(0) ? float(1) : ((__n % 2 == 1) ? -float(1) : float(1)));
                float __tc = float(1);
                const float __ax = std::abs(__x);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __tc *= (__ax / __k);
                float __term = __tc * __tc_sgn;
                float __sum = __term;
                for (int __k = int(__n) - 1; __k >= 0; --__k) {
                    __term *= ((__b + float(__k)) / float(int(__n) - __k)) * float(__k + 1) / __mx;
                    __sum += __term;
                }
                return __sum;
            }
            template<> long double __poly_laguerre_hyperg<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                const long double __b = long double(__alpha1) + long double(1);
                const long double __mx = -__x;
                const long double __tc_sgn = (__x < long double(0) ? long double(1) : ((__n % 2 == 1) ? -long double(1) : long double(1)));
                long double __tc = long double(1);
                const long double __ax = std::abs(__x);
                for (unsigned int __k = 1; __k <= __n; ++__k)
                    __tc *= (__ax / __k);
                long double __term = __tc * __tc_sgn;
                long double __sum = __term;
                for (int __k = int(__n) - 1; __k >= 0; --__k) {
                    __term *= ((__b + long double(__k)) / long double(int(__n) - __k)) * long double(__k + 1) / __mx;
                    __sum += __term;
                }
                return __sum;
            }
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                _Tp __l_0 = _Tp(1);
                if (__n == 0)
                    return __l_0;
                _Tp __l_1 = - __x + _Tp(1) + _Tp(__alpha1);
                if (__n == 1)
                    return __l_1;
                _Tp __l_n2 = __l_0;
                _Tp __l_n1 = __l_1;
                _Tp __l_n = _Tp(0);
                for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
                    __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x) * __l_n1 / _Tp(__nn) - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
                    __l_n2 = __l_n1;
                    __l_n1 = __l_n;
                }
                return __l_n;
            }
            template<> float __poly_laguerre_recursion<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                float __l_0 = float(1);
                if (__n == 0)
                    return __l_0;
                float __l_1 = -__x + float(1) + float(__alpha1);
                if (__n == 1)
                    return __l_1;
                float __l_n2 = __l_0;
                float __l_n1 = __l_1;
                float __l_n = float(0);
                for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
                    __l_n = (float(2 * __nn - 1) + float(__alpha1) - __x) * __l_n1 / float(__nn) - (float(__nn - 1) + float(__alpha1)) * __l_n2 / float(__nn);
                    __l_n2 = __l_n1;
                    __l_n1 = __l_n;
                }
                return __l_n;
            }
            template<> long double __poly_laguerre_recursion<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                long double __l_0 = long double(1);
                if (__n == 0)
                    return __l_0;
                long double __l_1 = -__x + long double(1) + long double(__alpha1);
                if (__n == 1)
                    return __l_1;
                long double __l_n2 = __l_0;
                long double __l_n1 = __l_1;
                long double __l_n = long double(0);
                for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
                    __l_n = (long double(2 * __nn - 1) + long double(__alpha1) - __x) * __l_n1 / long double(__nn) - (long double(__nn - 1) + long double(__alpha1)) * __l_n2 / long double(__nn);
                    __l_n2 = __l_n1;
                    __l_n1 = __l_n;
                }
                return __l_n;
            }
            template <typename _Tpa, typename _Tp> _Tp __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)             {
                if (__x < _Tp(0))
                    std::__throw_domain_error(("Negative argument in __poly_laguerre."));
                else if (__isnan(__x))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__n == 0)
                    return _Tp(1);
                else if (__n == 1)
                    return _Tp(1) + _Tp(__alpha1) - __x;
                else if (__x == _Tp(0)) {
                    _Tp __prod = _Tp(__alpha1) + _Tp(1);
                    for (unsigned int __k = 2; __k <= __n; ++__k)
                        __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
                    return __prod;
                } else if (__n > 10000000 && _Tp(__alpha1) > - _Tp(1) && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
                    return __poly_laguerre_large_n(__n, __alpha1, __x);
                else if (_Tp(__alpha1) >= _Tp(0) || (__x > _Tp(0) && _Tp(__alpha1) < - _Tp(__n + 1)))
                    return __poly_laguerre_recursion(__n, __alpha1, __x);
                else
                    return __poly_laguerre_hyperg(__n, __alpha1, __x);
            }
            template<> float __poly_laguerre<unsigned int, float>(unsigned int __n, unsigned int __alpha1, float __x)             {
                if (__x < float(0))
                    std::__throw_domain_error(("Negative argument in __poly_laguerre."));
                else if (__isnan(__x))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__n == 0)
                    return float(1);
                else if (__n == 1)
                    return float(1) + float(__alpha1) - __x;
                else if (__x == float(0)) {
                    float __prod = float(__alpha1) + float(1);
                    for (unsigned int __k = 2; __k <= __n; ++__k)
                        __prod *= (float(__alpha1) + float(__k)) / float(__k);
                    return __prod;
                } else if (__n > 10000000 && float(__alpha1) > -float(1) && __x < float(2) * (float(__alpha1) + float(1)) + float(4 * __n))
                    return __poly_laguerre_large_n(__n, __alpha1, __x);
                else if (float(__alpha1) >= float(0) || (__x > float(0) && float(__alpha1) < -float(__n + 1)))
                    return __poly_laguerre_recursion(__n, __alpha1, __x);
                else
                    return __poly_laguerre_hyperg(__n, __alpha1, __x);
            }
            template<> long double __poly_laguerre<unsigned int, long double>(unsigned int __n, unsigned int __alpha1, long double __x)             {
                if (__x < long double(0))
                    std::__throw_domain_error(("Negative argument in __poly_laguerre."));
                else if (__isnan(__x))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__n == 0)
                    return long double(1);
                else if (__n == 1)
                    return long double(1) + long double(__alpha1) - __x;
                else if (__x == long double(0)) {
                    long double __prod = long double(__alpha1) + long double(1);
                    for (unsigned int __k = 2; __k <= __n; ++__k)
                        __prod *= (long double(__alpha1) + long double(__k)) / long double(__k);
                    return __prod;
                } else if (__n > 10000000 && long double(__alpha1) > -long double(1) && __x < long double(2) * (long double(__alpha1) + long double(1)) + long double(4 * __n))
                    return __poly_laguerre_large_n(__n, __alpha1, __x);
                else if (long double(__alpha1) >= long double(0) || (__x > long double(0) && long double(__alpha1) < -long double(__n + 1)))
                    return __poly_laguerre_recursion(__n, __alpha1, __x);
                else
                    return __poly_laguerre_hyperg(__n, __alpha1, __x);
            }
            template <typename _Tp> inline _Tp __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)             {
                return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x);
            }
            template<> inline float __assoc_laguerre<float>(unsigned int __n, unsigned int __m, float __x)             {
                return __poly_laguerre<unsigned int, float>(__n, __m, __x);
            }
            template<> inline long double __assoc_laguerre<long double>(unsigned int __n, unsigned int __m, long double __x)             {
                return __poly_laguerre<unsigned int, long double>(__n, __m, __x);
            }
            template <typename _Tp> inline _Tp __laguerre(unsigned int __n, _Tp __x)             {
                return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x);
            }
            template<> inline float __laguerre<float>(unsigned int __n, float __x)             {
                return __poly_laguerre<unsigned int, float>(__n, 0, __x);
            }
            template<> inline long double __laguerre<long double>(unsigned int __n, long double __x)             {
                return __poly_laguerre<unsigned int, long double>(__n, 0, __x);
            }
        }
    }
    namespace std {
        namespace __detail {
            template <typename _Tp> _Tp __riemann_zeta_sum(_Tp __s)             {
                if (__s < _Tp(1))
                    std::__throw_domain_error(("Bad argument in zeta sum."));
                const unsigned int max_iter = 10000;
                _Tp __zeta = _Tp(0);
                for (unsigned int __k = 1; __k < max_iter; ++__k) {
                    _Tp __term = std::pow(static_cast<_Tp>(__k), - __s);
                    if (__term < std::numeric_limits<_Tp>::epsilon()) {
                        break;
                    }
                    __zeta += __term;
                }
                return __zeta;
            }
            template<> float __riemann_zeta_sum<float>(float __s)             {
                if (__s < float(1))
                    std::__throw_domain_error(("Bad argument in zeta sum."));
                const unsigned int max_iter = 10000;
                float __zeta = float(0);
                for (unsigned int __k = 1; __k < max_iter; ++__k) {
                    float __term = std::pow(static_cast<float>(__k), -__s);
                    if (__term < std::numeric_limits<float>::epsilon()) {
                        break;
                    }
                    __zeta += __term;
                }
                return __zeta;
            }
            template<> long double __riemann_zeta_sum<long double>(long double __s)             {
                if (__s < long double(1))
                    std::__throw_domain_error(("Bad argument in zeta sum."));
                const unsigned int max_iter = 10000;
                long double __zeta = long double(0);
                for (unsigned int __k = 1; __k < max_iter; ++__k) {
                    long double __term = std::pow(static_cast<long double>(__k), -__s);
                    if (__term < std::numeric_limits<long double>::epsilon()) {
                        break;
                    }
                    __zeta += __term;
                }
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta_alt(_Tp __s)             {
                _Tp __sgn = _Tp(1);
                _Tp __zeta = _Tp(0);
                for (unsigned int __i = 1; __i < 10000000; ++__i) {
                    _Tp __term = __sgn / std::pow(__i, __s);
                    if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
                        break;
                    __zeta += __term;
                    __sgn *= _Tp(-1);
                }
                __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta_glob(_Tp __s)             {
                _Tp __zeta = _Tp(0);
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                if (__s < _Tp(0)) {
                    if (::std::fmod(__s, _Tp(2)) == _Tp(0))
                        return _Tp(0);
                    else {
                        _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
                        __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) * std::sin(__numeric_constants<_Tp>::__pi_2() * __s) * std::exp(::std::lgamma(_Tp(1) - __s)) / __numeric_constants<_Tp>::__pi();
                        return __zeta;
                    }
                }
                _Tp __num = _Tp(0.5L);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    _Tp __sgn = _Tp(1);
                    _Tp __term = _Tp(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) - ::std::lgamma(_Tp(1 + __j)) - ::std::lgamma(_Tp(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), - __s);
                        __sgn *= _Tp(-1);
                    }
                    if (__punt)
                        break;
                    __term *= __num;
                    __zeta += __term;
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __num *= _Tp(0.5L);
                }
                __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);
                return __zeta;
            }
            template<> float __riemann_zeta_glob<float>(float __s)             {
                float __zeta = float(0);
                const float __eps = std::numeric_limits<float>::epsilon();
                const float __max_bincoeff = std::numeric_limits<float>::max_exponent10 * std::log(float(10)) - float(1);
                if (__s < float(0)) {
                    if (::std::fmod(__s, float(2)) == float(0))
                        return float(0);
                    else {
                        float __zeta = __riemann_zeta_glob(float(1) - __s);
                        __zeta *= std::pow(float(2) * __numeric_constants<float>::__pi(), __s) * std::sin(__numeric_constants<float>::__pi_2() * __s) * std::exp(::std::lgamma(float(1) - __s)) / __numeric_constants<float>::__pi();
                        return __zeta;
                    }
                }
                float __num = float(0.5L);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    float __sgn = float(1);
                    float __term = float(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        float __bincoeff = ::std::lgamma(float(1 + __i)) - ::std::lgamma(float(1 + __j)) - ::std::lgamma(float(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(float(1 + __j), -__s);
                        __sgn *= float(-1);
                    }
                    if (__punt)
                        break;
                    __term *= __num;
                    __zeta += __term;
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __num *= float(0.5L);
                }
                __zeta /= float(1) - std::pow(float(2), float(1) - __s);
                return __zeta;
            }
            template<> long double __riemann_zeta_glob<long double>(long double __s)             {
                long double __zeta = long double(0);
                const long double __eps = std::numeric_limits<long double>::epsilon();
                const long double __max_bincoeff = std::numeric_limits<long double>::max_exponent10 * std::log(long double(10)) - long double(1);
                if (__s < long double(0)) {
                    if (::std::fmod(__s, long double(2)) == long double(0))
                        return long double(0);
                    else {
                        long double __zeta = __riemann_zeta_glob(long double(1) - __s);
                        __zeta *= std::pow(long double(2) * __numeric_constants<long double>::__pi(), __s) * std::sin(__numeric_constants<long double>::__pi_2() * __s) * std::exp(::std::lgamma(long double(1) - __s)) / __numeric_constants<long double>::__pi();
                        return __zeta;
                    }
                }
                long double __num = long double(0.5L);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    long double __sgn = long double(1);
                    long double __term = long double(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        long double __bincoeff = ::std::lgamma(long double(1 + __i)) - ::std::lgamma(long double(1 + __j)) - ::std::lgamma(long double(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(long double(1 + __j), -__s);
                        __sgn *= long double(-1);
                    }
                    if (__punt)
                        break;
                    __term *= __num;
                    __zeta += __term;
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __num *= long double(0.5L);
                }
                __zeta /= long double(1) - std::pow(long double(2), long double(1) - __s);
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta_product(_Tp __s)             {
                static const _Tp __prime[] = {_Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19), _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47), _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79), _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)};
                static const unsigned int __num_primes = sizeof (__prime) / sizeof(_Tp);
                _Tp __zeta = _Tp(1);
                for (unsigned int __i = 0; __i < __num_primes; ++__i) {
                    const _Tp __fact = _Tp(1) - std::pow(__prime[__i], - __s);
                    __zeta *= __fact;
                    if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
                        break;
                }
                __zeta = _Tp(1) / __zeta;
                return __zeta;
            }
            template<> float __riemann_zeta_product<float>(float __s)             {
                static const float __prime[] = {float(2), float(3), float(5), float(7), float(11), float(13), float(17), float(19), float(23), float(29), float(31), float(37), float(41), float(43), float(47), float(53), float(59), float(61), float(67), float(71), float(73), float(79), float(83), float(89), float(97), float(101), float(103), float(107), float(109)};
                static const unsigned int __num_primes = sizeof (__prime) / sizeof(float);
                float __zeta = float(1);
                for (unsigned int __i = 0; __i < __num_primes; ++__i) {
                    const float __fact = float(1) - std::pow(__prime[__i], -__s);
                    __zeta *= __fact;
                    if (float(1) - __fact < std::numeric_limits<float>::epsilon())
                        break;
                }
                __zeta = float(1) / __zeta;
                return __zeta;
            }
            template<> long double __riemann_zeta_product<long double>(long double __s)             {
                static const long double __prime[] = {long double(2), long double(3), long double(5), long double(7), long double(11), long double(13), long double(17), long double(19), long double(23), long double(29), long double(31), long double(37), long double(41), long double(43), long double(47), long double(53), long double(59), long double(61), long double(67), long double(71), long double(73), long double(79), long double(83), long double(89), long double(97), long double(101), long double(103), long double(107), long double(109)};
                static const unsigned int __num_primes = sizeof (__prime) / sizeof(long double);
                long double __zeta = long double(1);
                for (unsigned int __i = 0; __i < __num_primes; ++__i) {
                    const long double __fact = long double(1) - std::pow(__prime[__i], -__s);
                    __zeta *= __fact;
                    if (long double(1) - __fact < std::numeric_limits<long double>::epsilon())
                        break;
                }
                __zeta = long double(1) / __zeta;
                return __zeta;
            }
            template <typename _Tp> _Tp __riemann_zeta(_Tp __s)             {
                if (__isnan(__s))
                    return std::numeric_limits<_Tp>::quiet_NaN();
                else if (__s == _Tp(1))
                    return std::numeric_limits<_Tp>::infinity();
                else if (__s < - _Tp(19)) {
                    _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
                    __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) * std::sin(__numeric_constants<_Tp>::__pi_2() * __s) * std::exp(::std::lgamma(_Tp(1) - __s)) / __numeric_constants<_Tp>::__pi();
                    return __zeta;
                } else if (__s < _Tp(20)) {
                    bool __glob = true;
                    if (__glob)
                        return __riemann_zeta_glob(__s);
                    else {
                        if (__s > _Tp(1))
                            return __riemann_zeta_sum(__s);
                        else {
                            _Tp __zeta = std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) * std::sin(__numeric_constants<_Tp>::__pi_2() * __s) * ::std::tgamma(_Tp(1) - __s) * __riemann_zeta_sum(_Tp(1) - __s);
                            return __zeta;
                        }
                    }
                } else
                    return __riemann_zeta_product(__s);
            }
            template<> float __riemann_zeta<float>(float __s)             {
                if (__isnan(__s))
                    return std::numeric_limits<float>::quiet_NaN();
                else if (__s == float(1))
                    return std::numeric_limits<float>::infinity();
                else if (__s < -float(19)) {
                    float __zeta = __riemann_zeta_product(float(1) - __s);
                    __zeta *= std::pow(float(2) * __numeric_constants<float>::__pi(), __s) * std::sin(__numeric_constants<float>::__pi_2() * __s) * std::exp(::std::lgamma(float(1) - __s)) / __numeric_constants<float>::__pi();
                    return __zeta;
                } else if (__s < float(20)) {
                    bool __glob = true;
                    if (__glob)
                        return __riemann_zeta_glob(__s);
                    else {
                        if (__s > float(1))
                            return __riemann_zeta_sum(__s);
                        else {
                            float __zeta = std::pow(float(2) * __numeric_constants<float>::__pi(), __s) * std::sin(__numeric_constants<float>::__pi_2() * __s) * ::std::tgamma(float(1) - __s) * __riemann_zeta_sum(float(1) - __s);
                            return __zeta;
                        }
                    }
                } else
                    return __riemann_zeta_product(__s);
            }
            template<> long double __riemann_zeta<long double>(long double __s)             {
                if (__isnan(__s))
                    return std::numeric_limits<long double>::quiet_NaN();
                else if (__s == long double(1))
                    return std::numeric_limits<long double>::infinity();
                else if (__s < -long double(19)) {
                    long double __zeta = __riemann_zeta_product(long double(1) - __s);
                    __zeta *= std::pow(long double(2) * __numeric_constants<long double>::__pi(), __s) * std::sin(__numeric_constants<long double>::__pi_2() * __s) * std::exp(::std::lgamma(long double(1) - __s)) / __numeric_constants<long double>::__pi();
                    return __zeta;
                } else if (__s < long double(20)) {
                    bool __glob = true;
                    if (__glob)
                        return __riemann_zeta_glob(__s);
                    else {
                        if (__s > long double(1))
                            return __riemann_zeta_sum(__s);
                        else {
                            long double __zeta = std::pow(long double(2) * __numeric_constants<long double>::__pi(), __s) * std::sin(__numeric_constants<long double>::__pi_2() * __s) * ::std::tgamma(long double(1) - __s) * __riemann_zeta_sum(long double(1) - __s);
                            return __zeta;
                        }
                    }
                } else
                    return __riemann_zeta_product(__s);
            }
            template <typename _Tp> _Tp __hurwitz_zeta_glob(_Tp __a, _Tp __s)             {
                _Tp __zeta = _Tp(0);
                const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
                const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);
                const unsigned int __maxit = 10000;
                for (unsigned int __i = 0; __i < __maxit; ++__i) {
                    bool __punt = false;
                    _Tp __sgn = _Tp(1);
                    _Tp __term = _Tp(0);
                    for (unsigned int __j = 0; __j <= __i; ++__j) {
                        _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) - ::std::lgamma(_Tp(1 + __j)) - ::std::lgamma(_Tp(1 + __i - __j));
                        if (__bincoeff > __max_bincoeff) {
                            __punt = true;
                            break;
                        }
                        __bincoeff = std::exp(__bincoeff);
                        __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), - __s);
                        __sgn *= _Tp(-1);
                    }
                    if (__punt)
                        break;
                    __term /= _Tp(__i + 1);
                    if (std::abs(__term / __zeta) < __eps)
                        break;
                    __zeta += __term;
                }
                __zeta /= __s - _Tp(1);
                return __zeta;
            }
            template <typename _Tp> inline _Tp __hurwitz_zeta(_Tp __a, _Tp __s)             {
                return __hurwitz_zeta_glob(__a, __s);
            }
        }
    }
    namespace std {
        inline float assoc_laguerref(unsigned int __n, unsigned int __m, float __x)         {
            return __detail::__assoc_laguerre<float>(__n, __m, __x);
        }
        inline long double assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)         {
            return __detail::__assoc_laguerre<long double>(__n, __m, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__assoc_laguerre<__type>(__n, __m, __x);
        }
        inline float assoc_legendref(unsigned int __l, unsigned int __m, float __x)         {
            return __detail::__assoc_legendre_p<float>(__l, __m, __x);
        }
        inline long double assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)         {
            return __detail::__assoc_legendre_p<long double>(__l, __m, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
        }
        inline float betaf(float __a, float __b)         {
            return __detail::__beta<float>(__a, __b);
        }
        inline long double betal(long double __a, long double __b)         {
            return __detail::__beta<long double>(__a, __b);
        }
        template <typename _Tpa, typename _Tpb> inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type beta(_Tpa __a, _Tpb __b)         {
            typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
            return __detail::__beta<__type>(__a, __b);
        }
        inline float comp_ellint_1f(float __k)         {
            return __detail::__comp_ellint_1<float>(__k);
        }
        inline long double comp_ellint_1l(long double __k)         {
            return __detail::__comp_ellint_1<long double>(__k);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_1(_Tp __k)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__comp_ellint_1<__type>(__k);
        }
        inline float comp_ellint_2f(float __k)         {
            return __detail::__comp_ellint_2<float>(__k);
        }
        inline long double comp_ellint_2l(long double __k)         {
            return __detail::__comp_ellint_2<long double>(__k);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_2(_Tp __k)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__comp_ellint_2<__type>(__k);
        }
        inline float comp_ellint_3f(float __k, float __nu)         {
            return __detail::__comp_ellint_3<float>(__k, __nu);
        }
        inline long double comp_ellint_3l(long double __k, long double __nu)         {
            return __detail::__comp_ellint_3<long double>(__k, __nu);
        }
        template <typename _Tp, typename _Tpn> inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type comp_ellint_3(_Tp __k, _Tpn __nu)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
            return __detail::__comp_ellint_3<__type>(__k, __nu);
        }
        inline float cyl_bessel_if(float __nu, float __x)         {
            return __detail::__cyl_bessel_i<float>(__nu, __x);
        }
        inline long double cyl_bessel_il(long double __nu, long double __x)         {
            return __detail::__cyl_bessel_i<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_i(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_bessel_i<__type>(__nu, __x);
        }
        inline float cyl_bessel_jf(float __nu, float __x)         {
            return __detail::__cyl_bessel_j<float>(__nu, __x);
        }
        inline long double cyl_bessel_jl(long double __nu, long double __x)         {
            return __detail::__cyl_bessel_j<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_j(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_bessel_j<__type>(__nu, __x);
        }
        inline float cyl_bessel_kf(float __nu, float __x)         {
            return __detail::__cyl_bessel_k<float>(__nu, __x);
        }
        inline long double cyl_bessel_kl(long double __nu, long double __x)         {
            return __detail::__cyl_bessel_k<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_k(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_bessel_k<__type>(__nu, __x);
        }
        inline float cyl_neumannf(float __nu, float __x)         {
            return __detail::__cyl_neumann_n<float>(__nu, __x);
        }
        inline long double cyl_neumannl(long double __nu, long double __x)         {
            return __detail::__cyl_neumann_n<long double>(__nu, __x);
        }
        template <typename _Tpnu, typename _Tp> inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_neumann(_Tpnu __nu, _Tp __x)         {
            typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
            return __detail::__cyl_neumann_n<__type>(__nu, __x);
        }
        inline float ellint_1f(float __k, float __phi)         {
            return __detail::__ellint_1<float>(__k, __phi);
        }
        inline long double ellint_1l(long double __k, long double __phi)         {
            return __detail::__ellint_1<long double>(__k, __phi);
        }
        template <typename _Tp, typename _Tpp> inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_1(_Tp __k, _Tpp __phi)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
            return __detail::__ellint_1<__type>(__k, __phi);
        }
        inline float ellint_2f(float __k, float __phi)         {
            return __detail::__ellint_2<float>(__k, __phi);
        }
        inline long double ellint_2l(long double __k, long double __phi)         {
            return __detail::__ellint_2<long double>(__k, __phi);
        }
        template <typename _Tp, typename _Tpp> inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_2(_Tp __k, _Tpp __phi)         {
            typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
            return __detail::__ellint_2<__type>(__k, __phi);
        }
        inline float ellint_3f(float __k, float __nu, float __phi)         {
            return __detail::__ellint_3<float>(__k, __nu, __phi);
        }
        inline long double ellint_3l(long double __k, long double __nu, long double __phi)         {
            return __detail::__ellint_3<long double>(__k, __nu, __phi);
        }
        template <typename _Tp, typename _Tpn, typename _Tpp> inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)         {
            typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
            return __detail::__ellint_3<__type>(__k, __nu, __phi);
        }
        inline float expintf(float __x)         {
            return __detail::__expint<float>(__x);
        }
        inline long double expintl(long double __x)         {
            return __detail::__expint<long double>(__x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type expint(_Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__expint<__type>(__x);
        }
        inline float hermitef(unsigned int __n, float __x)         {
            return __detail::__poly_hermite<float>(__n, __x);
        }
        inline long double hermitel(unsigned int __n, long double __x)         {
            return __detail::__poly_hermite<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type hermite(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__poly_hermite<__type>(__n, __x);
        }
        inline float laguerref(unsigned int __n, float __x)         {
            return __detail::__laguerre<float>(__n, __x);
        }
        inline long double laguerrel(unsigned int __n, long double __x)         {
            return __detail::__laguerre<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type laguerre(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__laguerre<__type>(__n, __x);
        }
        inline float legendref(unsigned int __l, float __x)         {
            return __detail::__poly_legendre_p<float>(__l, __x);
        }
        inline long double legendrel(unsigned int __l, long double __x)         {
            return __detail::__poly_legendre_p<long double>(__l, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type legendre(unsigned int __l, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__poly_legendre_p<__type>(__l, __x);
        }
        inline float riemann_zetaf(float __s)         {
            return __detail::__riemann_zeta<float>(__s);
        }
        inline long double riemann_zetal(long double __s)         {
            return __detail::__riemann_zeta<long double>(__s);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type riemann_zeta(_Tp __s)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__riemann_zeta<__type>(__s);
        }
        inline float sph_besself(unsigned int __n, float __x)         {
            return __detail::__sph_bessel<float>(__n, __x);
        }
        inline long double sph_bessell(unsigned int __n, long double __x)         {
            return __detail::__sph_bessel<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type sph_bessel(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__sph_bessel<__type>(__n, __x);
        }
        inline float sph_legendref(unsigned int __l, unsigned int __m, float __theta)         {
            return __detail::__sph_legendre<float>(__l, __m, __theta);
        }
        inline long double sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)         {
            return __detail::__sph_legendre<long double>(__l, __m, __theta);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__sph_legendre<__type>(__l, __m, __theta);
        }
        inline float sph_neumannf(unsigned int __n, float __x)         {
            return __detail::__sph_neumann<float>(__n, __x);
        }
        inline long double sph_neumannl(unsigned int __n, long double __x)         {
            return __detail::__sph_neumann<long double>(__n, __x);
        }
        template <typename _Tp> inline typename __gnu_cxx::__promote<_Tp>::__type sph_neumann(unsigned int __n, _Tp __x)         {
            typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
            return __detail::__sph_neumann<__type>(__n, __x);
        }
    }
}
constexpr int _pow(int base, int exp, int result = 1) {
    return exp < 1 ? result : _pow(base * base, exp / 2, (exp % 2) ? result * base : result);
}
constexpr int _log(int b, int n) {
    return n < b ? 0 : _log(b, n / b) + 1;
}
template <typename A, typename B> constexpr bool is_same_type = std::is_same<A, B>::value;
template <typename Lambda, size_t Index, size_t end_of_list> constexpr auto tokenize_list(Lambda str_lambda) {
    using curr = decltype(tokenize<Lambda, Index + 1>(str_lambda));
    return make_list(curr({}));
}
template<> constexpr list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> tokenize_list<(lambda at main.cpp:161:11), 0, 16>((lambda at main.cpp:161:11) str_lambda) {
    using curr = decltype(tokenize<(lambda at main.cpp:161:11), 0UL + 1>(str_lambda));
    return make_list(curr{});
}
template<> constexpr list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> tokenize_list<(lambda at main.cpp:161:11), 5, 16>((lambda at main.cpp:161:11) str_lambda) {
    using curr = decltype(tokenize<(lambda at main.cpp:161:11), 5UL + 1>(str_lambda));
    return make_list(curr{});
}
template<> constexpr list<token_list<plus, integer<2>, integer<2>>> tokenize_list<(lambda at main.cpp:161:11), 10, 16>((lambda at main.cpp:161:11) str_lambda) {
    using curr = decltype(tokenize<(lambda at main.cpp:161:11), 10UL + 1>(str_lambda));
    return make_list(curr{});
}
template <typename ...Types> struct token_list {
    static constexpr auto append(token_list<>) -> token_list<Types...>;
    template <typename A> static constexpr auto append(A) -> token_list<Types..., A>;
    template <typename A> static constexpr auto append(token_list<A>)     {
        return decltype(append(A({})))({});
    }
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>)     {
        using curr = decltype(token_list<Types...>::append(A({})));
        return decltype(curr::append(token_list<B, Args...>({})))({});
    }
};
template<> struct token_list<<>> {
    static constexpr auto append(token_list<>) -> token_list<>;
    template <typename A> static constexpr auto append(A) -> token_list<A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<2>, A>;
    template<> static constexpr auto append<token_list<token_list<>>>(token_list<token_list<>>) -> token_list<integer<2>, token_list<token_list<>>>;
    template<> static constexpr auto append<token_list<>>(token_list<>) -> token_list<integer<2>, token_list<>>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<integer<2>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<integer<2>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<2>> append<token_list<>>(token_list<token_list<>>)     {
        return decltype(append(token_list<>{})){};
    }
;
    template<> static constexpr token_list<integer<2>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<integer<2>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<2>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<2>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus>> {
    static constexpr auto append(token_list<>) -> token_list<plus>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>, integer<2>>>>(token_list<token_list<integer<2>, integer<2>>>) -> token_list<plus, token_list<token_list<integer<2>, integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>, integer<2>>>(token_list<integer<2>, integer<2>>) -> token_list<plus, token_list<integer<2>, integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<plus, integer<2>>;
    template<> static constexpr auto append<token_list<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(token_list<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>) -> token_list<plus, token_list<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> token_list<plus, token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<integer<3>>(integer<3>) -> token_list<plus, integer<3>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<plus, integer<2>, integer<2>> append<token_list<integer<2>, integer<2>>>(token_list<token_list<integer<2>, integer<2>>>)     {
        return decltype(append(token_list<integer<2>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<integer<2>>(token_list<integer<2>>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<integer<3>>(token_list<integer<3>>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<plus, integer<2>, integer<2>> append<integer<2>, integer<2>, <>>(token_list<integer<2>, integer<2>>)     {
        using curr = decltype(token_list<plus>::append(integer<2>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, <integer<2>>>(token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<plus>::append(integer<3>{}));
        return decltype(curr::append(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>{})){};
    }
;
};
template<> struct token_list<<token_list<integer<2>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<2>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<2>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<2>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<plus, integer<2>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<plus, integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<plus, integer<2>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<2>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<2>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<2>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<2>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, A>;
    template<> static constexpr auto append<token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<integer<3>, token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> token_list<integer<3>, token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(list<token_list<plus, integer<2>, integer<2>>>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template<> static constexpr auto append<token_list<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(token_list<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>) -> token_list<integer<3>, token_list<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> token_list<integer<3>, token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>>);
    template<> static constexpr token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<list<token_list<plus, integer<2>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<integer<3>>::append(list<token_list<plus, integer<2>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<integer<3>>::append(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
};
template<> struct token_list<<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<plus, integer<2>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<mul>> {
    static constexpr auto append(token_list<>) -> token_list<mul>;
    template <typename A> static constexpr auto append(A) -> token_list<mul, A>;
    template<> static constexpr auto append<token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<mul, token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> token_list<mul, token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<integer<3>>(integer<3>) -> token_list<mul, integer<3>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>)     {
        return decltype(append(token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>{})){};
    }
;
    template<> static constexpr auto append<integer<3>>(token_list<integer<3>>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, <integer<2>>>(token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<mul>::append(integer<3>{}));
        return decltype(curr::append(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>{})){};
    }
;
};
template<> struct token_list<<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<mul, integer<3>>> {
    static constexpr auto append(token_list<>) -> token_list<mul, integer<3>>;
    template <typename A> static constexpr auto append(A) -> token_list<mul, integer<3>, A>;
    template<> static constexpr auto append<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> token_list<mul, integer<3>, token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(list<token_list<plus, integer<2>, integer<2>>>) -> token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr auto append<list<token_list<plus, integer<2>, integer<2>>>>(token_list<list<token_list<plus, integer<2>, integer<2>>>>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<list<token_list<plus, integer<2>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<mul, integer<3>>::append(list<token_list<plus, integer<2>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
};
template<> struct token_list<<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(token_list<>) -> token_list<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> token_list<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<3>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, A>;
    template<> static constexpr auto append<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> token_list<plus, integer<3>, token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template<> static constexpr auto append<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) -> token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr auto append<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, <>>(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>)     {
        using curr = decltype(token_list<plus, integer<3>>::append(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
        return decltype(curr::append(token_list<integer<2>>{})){};
    }
;
};
template<> struct token_list<<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, A>;
    template<> static constexpr auto append<token_list<token_list<integer<2>>>>(token_list<token_list<integer<2>>>) -> token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, token_list<token_list<integer<2>>>>;
    template<> static constexpr auto append<token_list<integer<2>>>(token_list<integer<2>>) -> token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, token_list<integer<2>>>;
    template<> static constexpr auto append<integer<2>>(integer<2>) -> token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(token_list<A>);
    template<> static constexpr token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>> append<token_list<integer<2>>>(token_list<token_list<integer<2>>>)     {
        return decltype(append(token_list<integer<2>>{})){};
    }
;
    template<> static constexpr token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>> append<integer<2>>(token_list<integer<2>>)     {
        return decltype(append(integer<2>{})){};
    }
;
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template<> struct token_list<<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>> {
    static constexpr auto append(token_list<>) -> token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>;
    template <typename A> static constexpr auto append(A) -> token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>, A>;
    template <typename A> static constexpr auto append(token_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(token_list<A, B, Args...>);
};
template <typename T, typename ...Rest> constexpr auto make_token_list(T, Rest ...) -> decltype(token_list<T>::append(token_list<Rest...>({})));
template<> constexpr auto make_token_list<integer<2>, <token_list<>>>(integer<2>, token_list<>) -> decltype(token_list<integer<2>>::append(token_list<token_list<>>{}));
template<> constexpr auto make_token_list<integer<2>, <token_list<integer<2>>>>(integer<2>, token_list<integer<2>>) -> decltype(token_list<integer<2>>::append(token_list<token_list<integer<2>>>{}));
template<> constexpr auto make_token_list<plus, <token_list<integer<2>, integer<2>>>>(plus, token_list<integer<2>, integer<2>>) -> decltype(token_list<plus>::append(token_list<token_list<integer<2>, integer<2>>>{}));
template<> constexpr auto make_token_list<list<token_list<plus, integer<2>, integer<2>>>, <token_list<integer<2>>>>(list<token_list<plus, integer<2>, integer<2>>>, token_list<integer<2>>) -> decltype(token_list<list<token_list<plus, integer<2>, integer<2>>>>::append(token_list<token_list<integer<2>>>{}));
template<> constexpr auto make_token_list<integer<3>, <token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(integer<3>, token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> decltype(token_list<integer<3>>::append(token_list<token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<mul, <token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>(mul, token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> decltype(token_list<mul>::append(token_list<token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, <token_list<integer<2>>>>(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, token_list<integer<2>>) -> decltype(token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>>::append(token_list<token_list<integer<2>>>{}));
template<> constexpr auto make_token_list<integer<3>, <token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(integer<3>, token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> decltype(token_list<integer<3>>::append(token_list<token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<plus, <token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>(plus, token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> decltype(token_list<plus>::append(token_list<token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>{}));
template<> constexpr auto make_token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, <token_list<integer<2>>>>(list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, token_list<integer<2>>) -> decltype(token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>>::append(token_list<token_list<integer<2>>>{}));
constexpr auto make_token_list() -> token_list<>;
template <typename ...Types> using make_token_list_t = decltype(make_token_list(Types({})...));
template <typename ...Types> using token_list_t = decltype(make_token_list());
template <typename ...Types> struct c_list {
    static constexpr auto append(c_list<>) -> c_list<Types...>;
    template <typename A> static constexpr auto append(A) -> c_list<Types..., A>;
    template <typename A> static constexpr auto append(c_list<A>)     {
        return decltype(append(A({})))({});
    }
    template <typename A, typename B, typename ...Args> static constexpr auto append(c_list<A, B, Args...>)     {
        using curr = decltype(c_list<Types...>::append(A({})));
        return decltype(curr::append(c_list<B, Args...>({})))({});
    }
};
template<> struct c_list<<>> {
    static constexpr auto append(c_list<>) -> c_list<>;
    template <typename A> static constexpr auto append(A) -> c_list<A>;
    template <typename A> static constexpr auto append(c_list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(c_list<A, B, Args...>);
};
template <typename T, typename ...Rest> constexpr auto make_c_list(T, Rest ...) -> decltype(c_list<T>::append(c_list<Rest...>({})));
constexpr auto make_c_list() -> c_list<>;
template <typename ...Types> struct list {
    static constexpr auto append(list<>) -> list<Types...>;
    template <typename A> static constexpr auto append(A) -> list<Types..., A>;
    template <typename A> static constexpr auto append(list<A>)     {
        return decltype(append(A({})))({});
    }
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>)     {
        using curr = decltype(list<Types...>::append(A({})));
        return decltype(curr::append(list<B, Args...>({})))({});
    }
};
template<> struct list<<>> {
    static constexpr auto append(list<>) -> list<>;
    template <typename A> static constexpr auto append(A) -> list<A>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template<> struct list<<token_list<plus, integer<2>, integer<2>>>> {
    static constexpr auto append(list<>) -> list<token_list<plus, integer<2>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> list<token_list<plus, integer<2>, integer<2>>, A>;
    template<> static constexpr auto append<list<>>(list<>) -> list<token_list<plus, integer<2>, integer<2>>, list<>>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template<> struct list<<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(list<>) -> list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, A>;
    template<> static constexpr auto append<list<>>(list<>) -> list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, list<>>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template<> struct list<<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>> {
    static constexpr auto append(list<>) -> list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>;
    template <typename A> static constexpr auto append(A) -> list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, A>;
    template<> static constexpr auto append<list<>>(list<>) -> list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, list<>>;
    template <typename A> static constexpr auto append(list<A>);
    template <typename A, typename B, typename ...Args> static constexpr auto append(list<A, B, Args...>);
};
template <typename T, typename ...Rest> constexpr auto make_list(T, Rest ...) -> decltype(list<T>::append(list<Rest...>({})));
template<> constexpr auto make_list<token_list<plus, integer<2>, integer<2>>, <>>(token_list<plus, integer<2>, integer<2>>) -> decltype(list<token_list<plus, integer<2>, integer<2>>>::append(list<>{}));
template<> constexpr auto make_list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>, <>>(token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>) -> decltype(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>::append(list<>{}));
template<> constexpr auto make_list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>, <>>(token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>) -> decltype(list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>::append(list<>{}));
constexpr auto make_list() -> list<>;
struct list_start {
};
struct list_end {
};
struct double_quote {
};
struct quote {
};
struct plus {
};
struct minus {
};
struct mul {
};
struct div_ {
};
struct term {
};
struct whitespace {
};
struct non_integer {
};
struct non_character {
};
template <auto Value> struct c {
};
template <int Value> struct special_character {
};
template <int Value> struct integer {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((Value * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<Value>;
};
template<> struct integer<3> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((3 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<3>;
};
template<> struct integer<2> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((2 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<2>;
};
template<> struct integer<4> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((4 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<4>;
};
template<> struct integer<24> {
    template <int A> static constexpr auto merge(integer<A>) -> integer<_pow((24 * 10), (_log(10, A) + 1)) + A>;
    static constexpr auto merge(non_integer) -> integer<24>;
};
template <int C> constexpr auto deduce_token_type() {
    if (C == '(') {
        return list_start{};
    } else if (C >= '0' && C <= '9') {
        return integer<C - '0'>({});
    } else if (C == ')') {
        return list_end{};
    } else if (C >= 'a' && C <= 'z') {
        return c<C>({});
    } else if (C >= 'A' && C <= 'Z') {
        return c<C>({});
    } else if (C == '"') {
        return double_quote{};
    } else if (C == '\'') {
        return quote{};
    } else if (C == '+') {
        return plus{};
    } else if (C == '-') {
        return minus{};
    } else if (C == '*') {
        return mul{};
    } else if (C == '/') {
        return div_{};
    } else if (C == ' ') {
        return whitespace{};
    }
}
template<> constexpr list_start deduce_token_type<40>() {
    if (40 == '(') {
        return list_start{};
    }
}
template<> constexpr plus deduce_token_type<43>() {
    if (43 == '(')
        ;
    else if (43 >= '0' && 43 <= '9')
        ;
    else if (43 == ')')
        ;
    else if (43 >= 'a' && 43 <= 'z')
        ;
    else if (43 >= 'A' && 43 <= 'Z')
        ;
    else if (43 == '"')
        ;
    else if (43 == '\'')
        ;
    else if (43 == '+') {
        return plus{};
    }
}
template<> constexpr whitespace deduce_token_type<32>() {
    if (32 == '(')
        ;
    else if (32 >= '0' && 32 <= '9')
        ;
    else if (32 == ')')
        ;
    else if (32 >= 'a' && 32 <= 'z')
        ;
    else if (32 >= 'A' && 32 <= 'Z')
        ;
    else if (32 == '"')
        ;
    else if (32 == '\'')
        ;
    else if (32 == '+')
        ;
    else if (32 == '-')
        ;
    else if (32 == '*')
        ;
    else if (32 == '/')
        ;
    else if (32 == ' ') {
        return whitespace{};
    }
}
template<> constexpr integer<3> deduce_token_type<51>() {
    if (51 == '(')
        ;
    else if (51 >= '0' && 51 <= '9') {
        return integer<51 - '0'>{};
    }
}
template<> constexpr mul deduce_token_type<42>() {
    if (42 == '(')
        ;
    else if (42 >= '0' && 42 <= '9')
        ;
    else if (42 == ')')
        ;
    else if (42 >= 'a' && 42 <= 'z')
        ;
    else if (42 >= 'A' && 42 <= 'Z')
        ;
    else if (42 == '"')
        ;
    else if (42 == '\'')
        ;
    else if (42 == '+')
        ;
    else if (42 == '-')
        ;
    else if (42 == '*') {
        return mul{};
    }
}
template<> constexpr integer<2> deduce_token_type<50>() {
    if (50 == '(')
        ;
    else if (50 >= '0' && 50 <= '9') {
        return integer<50 - '0'>{};
    }
}
template<> constexpr list_end deduce_token_type<41>() {
    if (41 == '(')
        ;
    else if (41 >= '0' && 41 <= '9')
        ;
    else if (41 == ')') {
        return list_end{};
    }
}
template <typename Test, template <int ...> class Type> struct is_templated_int_collection : std::false_type {
};
template<> struct is_templated_int_collection<plus, integer> : std::false_type {
};
template<> struct is_templated_int_collection<plus, c> : std::false_type {
};
template<> struct is_templated_int_collection<whitespace, integer> : std::false_type {
};
template<> struct is_templated_int_collection<whitespace, c> : std::false_type {
};
template<> struct is_templated_int_collection<integer<3>, integer> : std::true_type {
};
template<> struct is_templated_int_collection<mul, integer> : std::false_type {
};
template<> struct is_templated_int_collection<mul, c> : std::false_type {
};
template<> struct is_templated_int_collection<integer<2>, integer> : std::true_type {
};
template<> struct is_templated_int_collection<list_end, integer> : std::false_type {
};
template <template <int ...> class Type, int ...Args> struct is_templated_int_collection<Type<Args...>, Type> : std::true_type {
};
template <typename T> constexpr bool is_integer_v = is_templated_int_collection<T, integer>::value;
template <typename T> constexpr bool is_char_v = is_templated_int_collection<T, c>::value;
template <int Index, typename Lambda> constexpr auto find_first_non_integer(Lambda lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[Index]>());
    if (!is_integer_v<type>) {
        return Index;
    } else {
        return find_first_non_integer<Index + 1>(lambda);
    }
}
template<> constexpr int find_first_non_integer<4, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[4]>());
    if (!is_integer_v<type>) {
        return 4;
    }
}
template<> constexpr int find_first_non_integer<9, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[9]>());
    if (!is_integer_v<type>) {
        return 9;
    }
}
template<> constexpr int find_first_non_integer<14, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[14]>());
    if (!is_integer_v<type>) {
        return 14;
    }
}
template<> constexpr int find_first_non_integer<16, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[16]>());
    if (!is_integer_v<type>) {
        return 16;
    }
}
template<> constexpr int find_first_non_integer<19, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[19]>());
    if (!is_integer_v<type>) {
        return 19;
    }
}
template <int Start, int End, typename Lambda> constexpr auto make_integer(Lambda str_lambda) {
    constexpr auto str = str_lambda();
    if (Start < End) {
        constexpr auto value = str[Start] - '0';
        return integer<value>::merge(make_integer<Start + 1, End>(str_lambda));
    } else {
        return non_integer{};
    }
}
template<> constexpr integer<3> make_integer<3, 4, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (3 < 4) {
        constexpr auto value = str[3] - '0';
        return integer<value>::merge(make_integer<3 + 1, 4>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<4, 4, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (4 < 4)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<3> make_integer<8, 9, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (8 < 9) {
        constexpr auto value = str[8] - '0';
        return integer<value>::merge(make_integer<8 + 1, 9>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<9, 9, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (9 < 9)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<2> make_integer<13, 14, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (13 < 14) {
        constexpr auto value = str[13] - '0';
        return integer<value>::merge(make_integer<13 + 1, 14>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<14, 14, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (14 < 14)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<2> make_integer<15, 16, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (15 < 16) {
        constexpr auto value = str[15] - '0';
        return integer<value>::merge(make_integer<15 + 1, 16>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<16, 16, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (16 < 16)
        ;
    else {
        return non_integer{};
    }
}
template<> constexpr integer<2> make_integer<18, 19, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (18 < 19) {
        constexpr auto value = str[18] - '0';
        return integer<value>::merge(make_integer<18 + 1, 19>(str_lambda));
    }
}
template<> constexpr non_integer make_integer<19, 19, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (19 < 19)
        ;
    else {
        return non_integer{};
    }
}
template <typename Lambda, size_t Index = 0, size_t end_of_char_list> constexpr auto tokenize_char_list(Lambda str_lambda) {
    constexpr auto str = str_lambda();
    if (Index < end_of_char_list) {
        using curr = decltype(deduce_token_type<str[Index]>());
        using second = decltype(tokenize_char_list<Lambda, Index + 1, end_of_char_list>(str_lambda));
        return make_c_list(curr({}), second({}));
    } else {
        return make_c_list();
    }
}
template <int Index, typename Lambda> constexpr auto find_end_of_list(Lambda lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[Index]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<Index + 1>(lambda);
    } else {
        return Index;
    }
}
template<> constexpr int find_end_of_list<0, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[0]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<0 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<1, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[1]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<1 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<2, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[2]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<2 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<3, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[3]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<3 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<4, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[4]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<4 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<5, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[5]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<5 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<6, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[6]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<6 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<7, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[7]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<7 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<8, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[8]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<8 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<9, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[9]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<9 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<10, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[10]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<10 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<11, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[11]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<11 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<12, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[12]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<12 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<13, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[13]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<13 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<14, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[14]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<14 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<15, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[15]>());
    if (!is_same_type<type, list_end>) {
        return find_end_of_list<15 + 1>(lambda);
    }
}
template<> constexpr int find_end_of_list<16, (lambda at main.cpp:161:11)>((lambda at main.cpp:161:11) lambda) {
    constexpr auto str = lambda();
    using type = decltype(deduce_token_type<str[16]>());
    if (!is_same_type<type, list_end>)
        ;
    else {
        return 16;
    }
}
template <typename Lambda, int Index = 0> constexpr auto define_atom(Lambda lambda) {
    constexpr auto str = lambda();
    if (Index < str.size()) {
        using curr = decltype(deduce_token_type<str[Index]>());
        using second = decltype(define_atom<Lambda, Index + 1>(lambda));
        return make_c_list(curr({}), second({}));
    } else {
        return make_c_list();
    }
}
template <typename Lambda, size_t Index = 0> constexpr auto tokenize(Lambda str_lambda) {
    constexpr auto str = str_lambda();
    if (Index < str.size()) {
        using curr = decltype(deduce_token_type<str[Index]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<Index>(str_lambda);
            using list = decltype(tokenize_list<Lambda, Index, end_of_list>(str_lambda));
            using second = decltype(tokenize<Lambda, end_of_list + 1>(str_lambda));
            return make_token_list(list({}), second({}));
        } else if (is_same_type<curr, list_end>) {
            return make_token_list();
        } else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<Index + 1>(str_lambda);
            using integer_type = decltype(make_integer<Index, first_non_integer>(str_lambda));
            using second = decltype(tokenize<Lambda, first_non_integer>(str_lambda));
            return make_token_list(integer_type({}), second({}));
        } else if (is_char_v<curr>) {
            constexpr auto end_of_char_list = find_end_of_char_list<Index>(str_lambda);
            if (end_of_char_list > 0) {
                using char_list = decltype(tokenize_char_list<Lambda, Index, end_of_char_list>(str_lambda));
                using second = decltype(tokenize<Lambda, end_of_char_list>(str_lambda));
                return make_token_list(char_list({}), second({}));
            } else {
                using second = decltype(tokenize<Lambda, Index + 1>(str_lambda));
                return make_token_list(curr({}), second({}));
            }
        } else if (is_same_type<curr, whitespace>) {
            return tokenize<Lambda, Index + 1>(str_lambda);
        } else {
            using next = decltype(tokenize<Lambda, Index + 1>(str_lambda));
            return make_token_list(curr({}), next({}));
        }
    } else {
        return make_token_list();
    }
}
template<> constexpr token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 0>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (0UL < str.size()) {
        using curr = decltype(deduce_token_type<str[0UL]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<0UL>(str_lambda);
            using list = decltype(tokenize_list<(lambda at main.cpp:161:11), 0UL, end_of_list>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), end_of_list + 1>(str_lambda));
            return make_token_list(list{}, second{});
        }
    }
}
template<> constexpr token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 1>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (1UL < str.size()) {
        using curr = decltype(deduce_token_type<str[1UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>)
            ;
        else {
            using next = decltype(tokenize<(lambda at main.cpp:161:11), 1UL + 1>(str_lambda));
            return make_token_list(curr{}, next{});
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 2>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (2UL < str.size()) {
        using curr = decltype(deduce_token_type<str[2UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:161:11), 2UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 3>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (3UL < str.size()) {
        using curr = decltype(deduce_token_type<str[3UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<3UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<3UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 4>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (4UL < str.size()) {
        using curr = decltype(deduce_token_type<str[4UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:161:11), 4UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 5>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (5UL < str.size()) {
        using curr = decltype(deduce_token_type<str[5UL]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<5UL>(str_lambda);
            using list = decltype(tokenize_list<(lambda at main.cpp:161:11), 5UL, end_of_list>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), end_of_list + 1>(str_lambda));
            return make_token_list(list{}, second{});
        }
    }
}
template<> constexpr token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 6>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (6UL < str.size()) {
        using curr = decltype(deduce_token_type<str[6UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>)
            ;
        else {
            using next = decltype(tokenize<(lambda at main.cpp:161:11), 6UL + 1>(str_lambda));
            return make_token_list(curr{}, next{});
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 7>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (7UL < str.size()) {
        using curr = decltype(deduce_token_type<str[7UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:161:11), 7UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 8>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (8UL < str.size()) {
        using curr = decltype(deduce_token_type<str[8UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<8UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<8UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 9>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (9UL < str.size()) {
        using curr = decltype(deduce_token_type<str[9UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:161:11), 9UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<list<token_list<plus, integer<2>, integer<2>>>, integer<2>> tokenize<(lambda at main.cpp:161:11), 10>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (10UL < str.size()) {
        using curr = decltype(deduce_token_type<str[10UL]>());
        if (is_same_type<curr, list_start>) {
            constexpr auto end_of_list = find_end_of_list<10UL>(str_lambda);
            using list = decltype(tokenize_list<(lambda at main.cpp:161:11), 10UL, end_of_list>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), end_of_list + 1>(str_lambda));
            return make_token_list(list{}, second{});
        }
    }
}
template<> constexpr token_list<plus, integer<2>, integer<2>> tokenize<(lambda at main.cpp:161:11), 11>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (11UL < str.size()) {
        using curr = decltype(deduce_token_type<str[11UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>)
            ;
        else {
            using next = decltype(tokenize<(lambda at main.cpp:161:11), 11UL + 1>(str_lambda));
            return make_token_list(curr{}, next{});
        }
    }
}
template<> constexpr token_list<integer<2>, integer<2>> tokenize<(lambda at main.cpp:161:11), 12>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (12UL < str.size()) {
        using curr = decltype(deduce_token_type<str[12UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:161:11), 12UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<2>, integer<2>> tokenize<(lambda at main.cpp:161:11), 13>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (13UL < str.size()) {
        using curr = decltype(deduce_token_type<str[13UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<13UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<13UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:161:11), 14>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (14UL < str.size()) {
        using curr = decltype(deduce_token_type<str[14UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:161:11), 14UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:161:11), 15>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (15UL < str.size()) {
        using curr = decltype(deduce_token_type<str[15UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<15UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<15UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<> tokenize<(lambda at main.cpp:161:11), 16>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (16UL < str.size()) {
        using curr = decltype(deduce_token_type<str[16UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>) {
            return make_token_list();
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:161:11), 17>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (17UL < str.size()) {
        using curr = decltype(deduce_token_type<str[17UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>)
            ;
        else if (is_char_v<curr>)
            ;
        else if (is_same_type<curr, whitespace>) {
            return tokenize<(lambda at main.cpp:161:11), 17UL + 1>(str_lambda);
        }
    }
}
template<> constexpr token_list<integer<2>> tokenize<(lambda at main.cpp:161:11), 18>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (18UL < str.size()) {
        using curr = decltype(deduce_token_type<str[18UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>)
            ;
        else if (is_integer_v<curr>) {
            constexpr auto first_non_integer = find_first_non_integer<18UL + 1>(str_lambda);
            using integer_type = decltype(make_integer<18UL, first_non_integer>(str_lambda));
            using second = decltype(tokenize<(lambda at main.cpp:161:11), first_non_integer>(str_lambda));
            return make_token_list(integer_type{}, second{});
        }
    }
}
template<> constexpr token_list<> tokenize<(lambda at main.cpp:161:11), 19>((lambda at main.cpp:161:11) str_lambda) {
    constexpr auto str = str_lambda();
    if (19UL < str.size()) {
        using curr = decltype(deduce_token_type<str[19UL]>());
        if (is_same_type<curr, list_start>)
            ;
        else if (is_same_type<curr, list_end>) {
            return make_token_list();
        }
    }
}
template <int A, typename ...Rest> constexpr auto e_add(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A + e_add(r...);
    else
        return A;
}
template<> constexpr int e_add<3, <list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> r, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 3 + e_add(r, r);
}
template<> constexpr int e_add<2, <integer<2>>>(integer<2>, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 2 + e_add(r);
}
template<> constexpr int e_add<2, <>>(integer<2>) {
    if (sizeof...(Rest) > 0)
        ;
    else
        return 2;
}
template<> constexpr int e_add<24, <integer<2>>>(integer<24>, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 24 + e_add(r);
}
template <typename ...Args, typename ...Rest> constexpr auto e_add(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_add(integer<x>({}), Rest({})...);
}
template<> constexpr int e_add<<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, <integer<2>>>(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>> l, integer<2>) {
    constexpr auto x = handle_prefix(l);
    return e_add(integer<x>{}, integer<2>{});
}
template <int A, typename ...Rest> constexpr auto e_sub(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A - e_sub(r...);
    else
        return A;
}
template <typename ...Args, typename ...Rest> constexpr auto e_sub(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_sub(integer<x>({}), Rest({})...);
}
template <int A, typename ...Rest> constexpr auto e_mul(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A * e_mul(r...);
    else
        return A;
}
template<> constexpr int e_mul<3, <list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(integer<3>, list<token_list<plus, integer<2>, integer<2>>> r, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 3 * e_mul(r, r);
}
template<> constexpr int e_mul<4, <integer<2>>>(integer<4>, integer<2> r) {
    if (sizeof...(Rest) > 0)
        return 4 * e_mul(r);
}
template<> constexpr int e_mul<2, <>>(integer<2>) {
    if (sizeof...(Rest) > 0)
        ;
    else
        return 2;
}
template <typename ...Args, typename ...Rest> constexpr auto e_mul(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_mul(integer<x>({}), Rest({})...);
}
template<> constexpr int e_mul<<token_list<plus, integer<2>, integer<2>>>, <integer<2>>>(list<token_list<plus, integer<2>, integer<2>>> l, integer<2>) {
    constexpr auto x = handle_prefix(l);
    return e_mul(integer<x>{}, integer<2>{});
}
template <int A, typename ...Rest> constexpr auto e_div(integer<A>, Rest ...r) {
    if (sizeof...(Rest) > 0)
        return A / e_div(r...);
    else
        return A;
}
template <typename ...Args, typename ...Rest> constexpr auto e_div(list<Args...> l, Rest ...) {
    constexpr auto x = handle_prefix(l);
    return e_div(integer<x>({}), Rest({})...);
}
template <typename A, typename ...Rest> constexpr auto handle_prefix(list<token_list<A, Rest...>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<A, plus>) {
            return e_add(Rest({})...);
        } else if (is_same_type<A, minus>) {
            return e_sub(Rest({})...);
        } else if (is_same_type<A, mul>) {
            return e_mul(Rest({})...);
        } else if (is_same_type<A, div_>) {
            return e_div(Rest({})...);
        }
    }
}
template<> constexpr int handle_prefix<plus, <integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>(list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<plus, plus>) {
            return e_add(integer<3>{}, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>{}, integer<2>{});
        }
    }
}
template<> constexpr int handle_prefix<mul, <integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>(list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<mul, plus>)
            ;
        else if (is_same_type<mul, minus>)
            ;
        else if (is_same_type<mul, mul>) {
            return e_mul(integer<3>{}, list<token_list<plus, integer<2>, integer<2>>>{}, integer<2>{});
        }
    }
}
template<> constexpr int handle_prefix<plus, <integer<2>, integer<2>>>(list<token_list<plus, integer<2>, integer<2>>>) {
    if (sizeof...(Rest) > 0) {
        if (is_same_type<plus, plus>) {
            return e_add(integer<2>{}, integer<2>{});
        }
    }
}
;
template <typename A, typename ...Rest> constexpr auto parse(token_list<A, Rest...>) {
    if (sizeof...(Rest) >= 0) {
        return handle_prefix(A({}));
    } else {
        return 0;
    }
}
template<> constexpr int parse<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, <integer<2>>>(token_list<list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>, integer<2>>) {
    if (sizeof...(Rest) >= 0) {
        return handle_prefix(list<token_list<plus, integer<3>, list<token_list<mul, integer<3>, list<token_list<plus, integer<2>, integer<2>>>, integer<2>>>, integer<2>>>{});
    }
}
int main() {
    auto x = ([]() -> std::string_view {
        return "(+ 3 (* 3 (+ 2 2) 2))";
    });
    using tokens = decltype(tokenize(x));
    constexpr auto res = parse(tokens{});
}
constexpr bool is_same_type = std::is_same<list_start, list_start>::value;
constexpr bool is_same_type = std::is_same<list_start, list_end>::value;
constexpr bool is_same_type = std::is_same<plus, list_end>::value;
constexpr bool is_same_type = std::is_same<whitespace, list_end>::value;
constexpr bool is_same_type = std::is_same<integer<3>, list_end>::value;
constexpr bool is_same_type = std::is_same<mul, list_end>::value;
constexpr bool is_same_type = std::is_same<integer<2>, list_end>::value;
constexpr bool is_same_type = std::is_same<list_end, list_end>::value;
constexpr bool is_same_type = std::is_same<plus, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<plus, integer>::value;
constexpr bool is_char_v = is_templated_int_collection<plus, c>::value;
constexpr bool is_same_type = std::is_same<plus, whitespace>::value;
constexpr bool is_same_type = std::is_same<whitespace, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<whitespace, integer>::value;
constexpr bool is_char_v = is_templated_int_collection<whitespace, c>::value;
constexpr bool is_same_type = std::is_same<whitespace, whitespace>::value;
constexpr bool is_same_type = std::is_same<integer<3>, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<integer<3>, integer>::value;
constexpr bool is_same_type = std::is_same<mul, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<mul, integer>::value;
constexpr bool is_char_v = is_templated_int_collection<mul, c>::value;
constexpr bool is_same_type = std::is_same<mul, whitespace>::value;
constexpr bool is_same_type = std::is_same<integer<2>, list_start>::value;
constexpr bool is_integer_v = is_templated_int_collection<integer<2>, integer>::value;
constexpr bool is_integer_v = is_templated_int_collection<list_end, integer>::value;
constexpr bool is_same_type = std::is_same<list_end, list_start>::value;
constexpr bool is_same_type = std::is_same<plus, plus>::value;
constexpr bool is_same_type = std::is_same<mul, plus>::value;
constexpr bool is_same_type = std::is_same<mul, minus>::value;
constexpr bool is_same_type = std::is_same<mul, mul>::value;
